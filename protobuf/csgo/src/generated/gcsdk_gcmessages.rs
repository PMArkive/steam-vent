// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `gcsdk_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgSOIDOwner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOIDOwner {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOIDOwner.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSOIDOwner.id)
    pub id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOIDOwner.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOIDOwner {
    fn default() -> &'a CMsgSOIDOwner {
        <CMsgSOIDOwner as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOIDOwner {
    pub fn new() -> CMsgSOIDOwner {
        ::std::default::Default::default()
    }

    // optional uint32 type = 1;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint64 id = 2;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOIDOwner {
    const NAME: &'static str = "CMsgSOIDOwner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOIDOwner {
        CMsgSOIDOwner::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOIDOwner {
        static instance: CMsgSOIDOwner = CMsgSOIDOwner {
            type_: ::std::option::Option::None,
            id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOSingleObject)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOSingleObject {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOSingleObject.type_id)
    pub type_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.object_data)
    pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOSingleObject.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOSingleObject.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOSingleObject {
    fn default() -> &'a CMsgSOSingleObject {
        <CMsgSOSingleObject as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOSingleObject {
    pub fn new() -> CMsgSOSingleObject {
        ::std::default::Default::default()
    }

    // optional int32 type_id = 2;

    pub fn type_id(&self) -> i32 {
        self.type_id.unwrap_or(0)
    }

    pub fn clear_type_id(&mut self) {
        self.type_id = ::std::option::Option::None;
    }

    pub fn has_type_id(&self) -> bool {
        self.type_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_id(&mut self, v: i32) {
        self.type_id = ::std::option::Option::Some(v);
    }

    // optional bytes object_data = 3;

    pub fn object_data(&self) -> &[u8] {
        match self.object_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_object_data(&mut self) {
        self.object_data = ::std::option::Option::None;
    }

    pub fn has_object_data(&self) -> bool {
        self.object_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.object_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.object_data.is_none() {
            self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.object_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
        self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional fixed64 version = 4;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOSingleObject {
    const NAME: &'static str = "CMsgSOSingleObject";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.type_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                33 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.object_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.object_data.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOSingleObject {
        CMsgSOSingleObject::new()
    }

    fn clear(&mut self) {
        self.type_id = ::std::option::Option::None;
        self.object_data = ::std::option::Option::None;
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOSingleObject {
        static instance: CMsgSOSingleObject = CMsgSOSingleObject {
            type_id: ::std::option::Option::None,
            object_data: ::std::option::Option::None,
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOMultipleObjects)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOMultipleObjects {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.objects_modified)
    pub objects_modified: ::std::vec::Vec<cmsg_somultiple_objects::SingleObject>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOMultipleObjects.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOMultipleObjects {
    fn default() -> &'a CMsgSOMultipleObjects {
        <CMsgSOMultipleObjects as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOMultipleObjects {
    pub fn new() -> CMsgSOMultipleObjects {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOMultipleObjects {
    const NAME: &'static str = "CMsgSOMultipleObjects";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects_modified.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects_modified {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.objects_modified {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOMultipleObjects {
        CMsgSOMultipleObjects::new()
    }

    fn clear(&mut self) {
        self.objects_modified.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOMultipleObjects {
        static instance: CMsgSOMultipleObjects = CMsgSOMultipleObjects {
            objects_modified: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSOMultipleObjects`
pub mod cmsg_somultiple_objects {
    // @@protoc_insertion_point(message:CMsgSOMultipleObjects.SingleObject)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleObject {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOMultipleObjects.SingleObject.object_data)
        pub object_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOMultipleObjects.SingleObject.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleObject {
        fn default() -> &'a SingleObject {
            <SingleObject as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleObject {
        pub fn new() -> SingleObject {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }

        // optional bytes object_data = 2;

        pub fn object_data(&self) -> &[u8] {
            match self.object_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_object_data(&mut self) {
            self.object_data = ::std::option::Option::None;
        }

        pub fn has_object_data(&self) -> bool {
            self.object_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_object_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.object_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_object_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.object_data.is_none() {
                self.object_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.object_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_object_data(&mut self) -> ::std::vec::Vec<u8> {
            self.object_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleObject {
        const NAME: &'static str = "SingleObject";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.object_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.object_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleObject {
            SingleObject::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleObject {
            static instance: SingleObject = SingleObject {
                type_id: ::std::option::Option::None,
                object_data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.objects)
    pub objects: ::std::vec::Vec<cmsg_socache_subscribed::SubscribedType>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscribed {
    fn default() -> &'a CMsgSOCacheSubscribed {
        <CMsgSOCacheSubscribed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscribed {
    pub fn new() -> CMsgSOCacheSubscribed {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 3;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscribed {
    const NAME: &'static str = "CMsgSOCacheSubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.objects.push(is.read_message()?);
                },
                25 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.objects {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.objects {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.version {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscribed {
        CMsgSOCacheSubscribed::new()
    }

    fn clear(&mut self) {
        self.objects.clear();
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscribed {
        static instance: CMsgSOCacheSubscribed = CMsgSOCacheSubscribed {
            objects: ::std::vec::Vec::new(),
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSOCacheSubscribed`
pub mod cmsg_socache_subscribed {
    // @@protoc_insertion_point(message:CMsgSOCacheSubscribed.SubscribedType)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SubscribedType {
        // message fields
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.type_id)
        pub type_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSOCacheSubscribed.SubscribedType.object_data)
        pub object_data: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSOCacheSubscribed.SubscribedType.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SubscribedType {
        fn default() -> &'a SubscribedType {
            <SubscribedType as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SubscribedType {
        pub fn new() -> SubscribedType {
            ::std::default::Default::default()
        }

        // optional int32 type_id = 1;

        pub fn type_id(&self) -> i32 {
            self.type_id.unwrap_or(0)
        }

        pub fn clear_type_id(&mut self) {
            self.type_id = ::std::option::Option::None;
        }

        pub fn has_type_id(&self) -> bool {
            self.type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type_id(&mut self, v: i32) {
            self.type_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SubscribedType {
        const NAME: &'static str = "SubscribedType";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.object_data.push(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            for value in &self.object_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_id {
                os.write_int32(1, v)?;
            }
            for v in &self.object_data {
                os.write_bytes(2, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SubscribedType {
            SubscribedType::new()
        }

        fn clear(&mut self) {
            self.type_id = ::std::option::Option::None;
            self.object_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SubscribedType {
            static instance: SubscribedType = SubscribedType {
                type_id: ::std::option::Option::None,
                object_data: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheUnsubscribed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheUnsubscribed {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheUnsubscribed.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheUnsubscribed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheUnsubscribed {
    fn default() -> &'a CMsgSOCacheUnsubscribed {
        <CMsgSOCacheUnsubscribed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheUnsubscribed {
    pub fn new() -> CMsgSOCacheUnsubscribed {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheUnsubscribed {
    const NAME: &'static str = "CMsgSOCacheUnsubscribed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheUnsubscribed {
        CMsgSOCacheUnsubscribed::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheUnsubscribed {
        static instance: CMsgSOCacheUnsubscribed = CMsgSOCacheUnsubscribed {
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionCheck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionCheck {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.version)
    pub version: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionCheck.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionCheck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionCheck {
    fn default() -> &'a CMsgSOCacheSubscriptionCheck {
        <CMsgSOCacheSubscriptionCheck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionCheck {
    pub fn new() -> CMsgSOCacheSubscriptionCheck {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscriptionCheck {
    const NAME: &'static str = "CMsgSOCacheSubscriptionCheck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionCheck {
        CMsgSOCacheSubscriptionCheck::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionCheck {
        static instance: CMsgSOCacheSubscriptionCheck = CMsgSOCacheSubscriptionCheck {
            version: ::std::option::Option::None,
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheSubscriptionRefresh)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheSubscriptionRefresh {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheSubscriptionRefresh.owner_soid)
    pub owner_soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheSubscriptionRefresh.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheSubscriptionRefresh {
    fn default() -> &'a CMsgSOCacheSubscriptionRefresh {
        <CMsgSOCacheSubscriptionRefresh as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheSubscriptionRefresh {
    pub fn new() -> CMsgSOCacheSubscriptionRefresh {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheSubscriptionRefresh {
    const NAME: &'static str = "CMsgSOCacheSubscriptionRefresh";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.owner_soid)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheSubscriptionRefresh {
        CMsgSOCacheSubscriptionRefresh::new()
    }

    fn clear(&mut self) {
        self.owner_soid.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheSubscriptionRefresh {
        static instance: CMsgSOCacheSubscriptionRefresh = CMsgSOCacheSubscriptionRefresh {
            owner_soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheVersion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheVersion {
    fn default() -> &'a CMsgSOCacheVersion {
        <CMsgSOCacheVersion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheVersion {
    pub fn new() -> CMsgSOCacheVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 1;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheVersion {
    const NAME: &'static str = "CMsgSOCacheVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheVersion {
        CMsgSOCacheVersion::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheVersion {
        static instance: CMsgSOCacheVersion = CMsgSOCacheVersion {
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAccountDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountDetails.valid)
    pub valid: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.account_name)
    pub account_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.public_profile)
    pub public_profile: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.public_inventory)
    pub public_inventory: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.vac_banned)
    pub vac_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.cyber_cafe)
    pub cyber_cafe: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.school_account)
    pub school_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.free_trial_account)
    pub free_trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.subscribed)
    pub subscribed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.low_violence)
    pub low_violence: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.limited)
    pub limited: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.trusted)
    pub trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.package)
    pub package: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.time_cached)
    pub time_cached: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.account_locked)
    pub account_locked: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.community_banned)
    pub community_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.trade_banned)
    pub trade_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgAccountDetails.eligible_for_community_market)
    pub eligible_for_community_market: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountDetails {
    fn default() -> &'a CMsgAccountDetails {
        <CMsgAccountDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountDetails {
    pub fn new() -> CMsgAccountDetails {
        ::std::default::Default::default()
    }

    // optional bool valid = 1;

    pub fn valid(&self) -> bool {
        self.valid.unwrap_or(false)
    }

    pub fn clear_valid(&mut self) {
        self.valid = ::std::option::Option::None;
    }

    pub fn has_valid(&self) -> bool {
        self.valid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valid(&mut self, v: bool) {
        self.valid = ::std::option::Option::Some(v);
    }

    // optional string account_name = 2;

    pub fn account_name(&self) -> &str {
        match self.account_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_account_name(&mut self) {
        self.account_name = ::std::option::Option::None;
    }

    pub fn has_account_name(&self) -> bool {
        self.account_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_name(&mut self, v: ::std::string::String) {
        self.account_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_name(&mut self) -> &mut ::std::string::String {
        if self.account_name.is_none() {
            self.account_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.account_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_account_name(&mut self) -> ::std::string::String {
        self.account_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool public_profile = 4;

    pub fn public_profile(&self) -> bool {
        self.public_profile.unwrap_or(false)
    }

    pub fn clear_public_profile(&mut self) {
        self.public_profile = ::std::option::Option::None;
    }

    pub fn has_public_profile(&self) -> bool {
        self.public_profile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_profile(&mut self, v: bool) {
        self.public_profile = ::std::option::Option::Some(v);
    }

    // optional bool public_inventory = 5;

    pub fn public_inventory(&self) -> bool {
        self.public_inventory.unwrap_or(false)
    }

    pub fn clear_public_inventory(&mut self) {
        self.public_inventory = ::std::option::Option::None;
    }

    pub fn has_public_inventory(&self) -> bool {
        self.public_inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_public_inventory(&mut self, v: bool) {
        self.public_inventory = ::std::option::Option::Some(v);
    }

    // optional bool vac_banned = 6;

    pub fn vac_banned(&self) -> bool {
        self.vac_banned.unwrap_or(false)
    }

    pub fn clear_vac_banned(&mut self) {
        self.vac_banned = ::std::option::Option::None;
    }

    pub fn has_vac_banned(&self) -> bool {
        self.vac_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vac_banned(&mut self, v: bool) {
        self.vac_banned = ::std::option::Option::Some(v);
    }

    // optional bool cyber_cafe = 7;

    pub fn cyber_cafe(&self) -> bool {
        self.cyber_cafe.unwrap_or(false)
    }

    pub fn clear_cyber_cafe(&mut self) {
        self.cyber_cafe = ::std::option::Option::None;
    }

    pub fn has_cyber_cafe(&self) -> bool {
        self.cyber_cafe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cyber_cafe(&mut self, v: bool) {
        self.cyber_cafe = ::std::option::Option::Some(v);
    }

    // optional bool school_account = 8;

    pub fn school_account(&self) -> bool {
        self.school_account.unwrap_or(false)
    }

    pub fn clear_school_account(&mut self) {
        self.school_account = ::std::option::Option::None;
    }

    pub fn has_school_account(&self) -> bool {
        self.school_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_school_account(&mut self, v: bool) {
        self.school_account = ::std::option::Option::Some(v);
    }

    // optional bool free_trial_account = 9;

    pub fn free_trial_account(&self) -> bool {
        self.free_trial_account.unwrap_or(false)
    }

    pub fn clear_free_trial_account(&mut self) {
        self.free_trial_account = ::std::option::Option::None;
    }

    pub fn has_free_trial_account(&self) -> bool {
        self.free_trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_free_trial_account(&mut self, v: bool) {
        self.free_trial_account = ::std::option::Option::Some(v);
    }

    // optional bool subscribed = 10;

    pub fn subscribed(&self) -> bool {
        self.subscribed.unwrap_or(false)
    }

    pub fn clear_subscribed(&mut self) {
        self.subscribed = ::std::option::Option::None;
    }

    pub fn has_subscribed(&self) -> bool {
        self.subscribed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subscribed(&mut self, v: bool) {
        self.subscribed = ::std::option::Option::Some(v);
    }

    // optional bool low_violence = 11;

    pub fn low_violence(&self) -> bool {
        self.low_violence.unwrap_or(false)
    }

    pub fn clear_low_violence(&mut self) {
        self.low_violence = ::std::option::Option::None;
    }

    pub fn has_low_violence(&self) -> bool {
        self.low_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_violence(&mut self, v: bool) {
        self.low_violence = ::std::option::Option::Some(v);
    }

    // optional bool limited = 12;

    pub fn limited(&self) -> bool {
        self.limited.unwrap_or(false)
    }

    pub fn clear_limited(&mut self) {
        self.limited = ::std::option::Option::None;
    }

    pub fn has_limited(&self) -> bool {
        self.limited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limited(&mut self, v: bool) {
        self.limited = ::std::option::Option::Some(v);
    }

    // optional bool trusted = 13;

    pub fn trusted(&self) -> bool {
        self.trusted.unwrap_or(false)
    }

    pub fn clear_trusted(&mut self) {
        self.trusted = ::std::option::Option::None;
    }

    pub fn has_trusted(&self) -> bool {
        self.trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trusted(&mut self, v: bool) {
        self.trusted = ::std::option::Option::Some(v);
    }

    // optional uint32 package = 14;

    pub fn package(&self) -> u32 {
        self.package.unwrap_or(0)
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: u32) {
        self.package = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_cached = 15;

    pub fn time_cached(&self) -> u32 {
        self.time_cached.unwrap_or(0)
    }

    pub fn clear_time_cached(&mut self) {
        self.time_cached = ::std::option::Option::None;
    }

    pub fn has_time_cached(&self) -> bool {
        self.time_cached.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_cached(&mut self, v: u32) {
        self.time_cached = ::std::option::Option::Some(v);
    }

    // optional bool account_locked = 16;

    pub fn account_locked(&self) -> bool {
        self.account_locked.unwrap_or(false)
    }

    pub fn clear_account_locked(&mut self) {
        self.account_locked = ::std::option::Option::None;
    }

    pub fn has_account_locked(&self) -> bool {
        self.account_locked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_locked(&mut self, v: bool) {
        self.account_locked = ::std::option::Option::Some(v);
    }

    // optional bool community_banned = 17;

    pub fn community_banned(&self) -> bool {
        self.community_banned.unwrap_or(false)
    }

    pub fn clear_community_banned(&mut self) {
        self.community_banned = ::std::option::Option::None;
    }

    pub fn has_community_banned(&self) -> bool {
        self.community_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_banned(&mut self, v: bool) {
        self.community_banned = ::std::option::Option::Some(v);
    }

    // optional bool trade_banned = 18;

    pub fn trade_banned(&self) -> bool {
        self.trade_banned.unwrap_or(false)
    }

    pub fn clear_trade_banned(&mut self) {
        self.trade_banned = ::std::option::Option::None;
    }

    pub fn has_trade_banned(&self) -> bool {
        self.trade_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_banned(&mut self, v: bool) {
        self.trade_banned = ::std::option::Option::Some(v);
    }

    // optional bool eligible_for_community_market = 19;

    pub fn eligible_for_community_market(&self) -> bool {
        self.eligible_for_community_market.unwrap_or(false)
    }

    pub fn clear_eligible_for_community_market(&mut self) {
        self.eligible_for_community_market = ::std::option::Option::None;
    }

    pub fn has_eligible_for_community_market(&self) -> bool {
        self.eligible_for_community_market.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eligible_for_community_market(&mut self, v: bool) {
        self.eligible_for_community_market = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAccountDetails {
    const NAME: &'static str = "CMsgAccountDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.valid = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.account_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.public_profile = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.public_inventory = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.vac_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.cyber_cafe = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.school_account = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.free_trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.subscribed = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.low_violence = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.limited = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.package = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.time_cached = ::std::option::Option::Some(is.read_fixed32()?);
                },
                128 => {
                    self.account_locked = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.community_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.trade_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.eligible_for_community_market = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.valid {
            my_size += 1 + 1;
        }
        if let Some(v) = self.account_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.public_profile {
            my_size += 1 + 1;
        }
        if let Some(v) = self.public_inventory {
            my_size += 1 + 1;
        }
        if let Some(v) = self.vac_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cyber_cafe {
            my_size += 1 + 1;
        }
        if let Some(v) = self.school_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.free_trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.subscribed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.low_violence {
            my_size += 1 + 1;
        }
        if let Some(v) = self.limited {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.package {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.time_cached {
            my_size += 1 + 4;
        }
        if let Some(v) = self.account_locked {
            my_size += 2 + 1;
        }
        if let Some(v) = self.community_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.trade_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.eligible_for_community_market {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.valid {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.account_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.public_profile {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.public_inventory {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.vac_banned {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.cyber_cafe {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.school_account {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.free_trial_account {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.subscribed {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.low_violence {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.limited {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.trusted {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.package {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.time_cached {
            os.write_fixed32(15, v)?;
        }
        if let Some(v) = self.account_locked {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.community_banned {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.trade_banned {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.eligible_for_community_market {
            os.write_bool(19, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountDetails {
        CMsgAccountDetails::new()
    }

    fn clear(&mut self) {
        self.valid = ::std::option::Option::None;
        self.account_name = ::std::option::Option::None;
        self.public_profile = ::std::option::Option::None;
        self.public_inventory = ::std::option::Option::None;
        self.vac_banned = ::std::option::Option::None;
        self.cyber_cafe = ::std::option::Option::None;
        self.school_account = ::std::option::Option::None;
        self.free_trial_account = ::std::option::Option::None;
        self.subscribed = ::std::option::Option::None;
        self.low_violence = ::std::option::Option::None;
        self.limited = ::std::option::Option::None;
        self.trusted = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.time_cached = ::std::option::Option::None;
        self.account_locked = ::std::option::Option::None;
        self.community_banned = ::std::option::Option::None;
        self.trade_banned = ::std::option::Option::None;
        self.eligible_for_community_market = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountDetails {
        static instance: CMsgAccountDetails = CMsgAccountDetails {
            valid: ::std::option::Option::None,
            account_name: ::std::option::Option::None,
            public_profile: ::std::option::Option::None,
            public_inventory: ::std::option::Option::None,
            vac_banned: ::std::option::Option::None,
            cyber_cafe: ::std::option::Option::None,
            school_account: ::std::option::Option::None,
            free_trial_account: ::std::option::Option::None,
            subscribed: ::std::option::Option::None,
            low_violence: ::std::option::Option::None,
            limited: ::std::option::Option::None,
            trusted: ::std::option::Option::None,
            package: ::std::option::Option::None,
            time_cached: ::std::option::Option::None,
            account_locked: ::std::option::Option::None,
            community_banned: ::std::option::Option::None,
            trade_banned: ::std::option::Option::None,
            eligible_for_community_market: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.payload)
    pub payload: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.steamids)
    pub steamids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage.replytogc)
    pub replytogc: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage {
    fn default() -> &'a CMsgGCMultiplexMessage {
        <CMsgGCMultiplexMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage {
    pub fn new() -> CMsgGCMultiplexMessage {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }

    // optional bytes payload = 2;

    pub fn payload(&self) -> &[u8] {
        match self.payload.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_payload(&mut self) {
        self.payload = ::std::option::Option::None;
    }

    pub fn has_payload(&self) -> bool {
        self.payload.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payload(&mut self, v: ::std::vec::Vec<u8>) {
        self.payload = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_payload(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.payload.is_none() {
            self.payload = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.payload.as_mut().unwrap()
    }

    // Take field
    pub fn take_payload(&mut self) -> ::std::vec::Vec<u8> {
        self.payload.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bool replytogc = 4;

    pub fn replytogc(&self) -> bool {
        self.replytogc.unwrap_or(false)
    }

    pub fn clear_replytogc(&mut self) {
        self.replytogc = ::std::option::Option::None;
    }

    pub fn has_replytogc(&self) -> bool {
        self.replytogc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replytogc(&mut self, v: bool) {
        self.replytogc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMultiplexMessage {
    const NAME: &'static str = "CMsgGCMultiplexMessage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.payload = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.steamids)?;
                },
                25 => {
                    self.steamids.push(is.read_fixed64()?);
                },
                32 => {
                    self.replytogc = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.payload.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += 9 * self.steamids.len() as u64;
        if let Some(v) = self.replytogc {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.payload.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.steamids {
            os.write_fixed64(3, *v)?;
        };
        if let Some(v) = self.replytogc {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage {
        CMsgGCMultiplexMessage::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.payload = ::std::option::Option::None;
        self.steamids.clear();
        self.replytogc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage {
        static instance: CMsgGCMultiplexMessage = CMsgGCMultiplexMessage {
            msgtype: ::std::option::Option::None,
            payload: ::std::option::Option::None,
            steamids: ::std::vec::Vec::new(),
            replytogc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMultiplexMessage_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMultiplexMessage_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMultiplexMessage_Response.msgtype)
    pub msgtype: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMultiplexMessage_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMultiplexMessage_Response {
    fn default() -> &'a CMsgGCMultiplexMessage_Response {
        <CMsgGCMultiplexMessage_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMultiplexMessage_Response {
    pub fn new() -> CMsgGCMultiplexMessage_Response {
        ::std::default::Default::default()
    }

    // optional uint32 msgtype = 1;

    pub fn msgtype(&self) -> u32 {
        self.msgtype.unwrap_or(0)
    }

    pub fn clear_msgtype(&mut self) {
        self.msgtype = ::std::option::Option::None;
    }

    pub fn has_msgtype(&self) -> bool {
        self.msgtype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msgtype(&mut self, v: u32) {
        self.msgtype = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMultiplexMessage_Response {
    const NAME: &'static str = "CMsgGCMultiplexMessage_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msgtype = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msgtype {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msgtype {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMultiplexMessage_Response {
        CMsgGCMultiplexMessage_Response::new()
    }

    fn clear(&mut self) {
        self.msgtype = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMultiplexMessage_Response {
        static instance: CMsgGCMultiplexMessage_Response = CMsgGCMultiplexMessage_Response {
            msgtype: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.dir_index)
    pub dir_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck.gc_type)
    pub gc_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck {
    fn default() -> &'a CGCToGCMsgMasterAck {
        <CGCToGCMsgMasterAck as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck {
    pub fn new() -> CGCToGCMsgMasterAck {
        ::std::default::Default::default()
    }

    // optional uint32 dir_index = 1;

    pub fn dir_index(&self) -> u32 {
        self.dir_index.unwrap_or(0)
    }

    pub fn clear_dir_index(&mut self) {
        self.dir_index = ::std::option::Option::None;
    }

    pub fn has_dir_index(&self) -> bool {
        self.dir_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dir_index(&mut self, v: u32) {
        self.dir_index = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_type = 2;

    pub fn gc_type(&self) -> u32 {
        self.gc_type.unwrap_or(0)
    }

    pub fn clear_gc_type(&mut self) {
        self.gc_type = ::std::option::Option::None;
    }

    pub fn has_gc_type(&self) -> bool {
        self.gc_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_type(&mut self, v: u32) {
        self.gc_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterAck {
    const NAME: &'static str = "CGCToGCMsgMasterAck";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dir_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gc_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dir_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gc_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dir_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gc_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck {
        CGCToGCMsgMasterAck::new()
    }

    fn clear(&mut self) {
        self.dir_index = ::std::option::Option::None;
        self.gc_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck {
        static instance: CGCToGCMsgMasterAck = CGCToGCMsgMasterAck {
            dir_index: ::std::option::Option::None,
            gc_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterAck_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterAck_Response {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgMasterAck_Response.eresult)
    pub eresult: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterAck_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterAck_Response {
    fn default() -> &'a CGCToGCMsgMasterAck_Response {
        <CGCToGCMsgMasterAck_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterAck_Response {
    pub fn new() -> CGCToGCMsgMasterAck_Response {
        ::std::default::Default::default()
    }

    // optional int32 eresult = 1;

    pub fn eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterAck_Response {
    const NAME: &'static str = "CGCToGCMsgMasterAck_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterAck_Response {
        CGCToGCMsgMasterAck_Response::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterAck_Response {
        static instance: CGCToGCMsgMasterAck_Response = CGCToGCMsgMasterAck_Response {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgMasterStartupComplete)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgMasterStartupComplete {
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgMasterStartupComplete.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgMasterStartupComplete {
    fn default() -> &'a CGCToGCMsgMasterStartupComplete {
        <CGCToGCMsgMasterStartupComplete as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgMasterStartupComplete {
    pub fn new() -> CGCToGCMsgMasterStartupComplete {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgMasterStartupComplete {
    const NAME: &'static str = "CGCToGCMsgMasterStartupComplete";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgMasterStartupComplete {
        CGCToGCMsgMasterStartupComplete::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgMasterStartupComplete {
        static instance: CGCToGCMsgMasterStartupComplete = CGCToGCMsgMasterStartupComplete {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgRouted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRouted {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.sender_id)
    pub sender_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCToGCMsgRouted.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRouted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRouted {
    fn default() -> &'a CGCToGCMsgRouted {
        <CGCToGCMsgRouted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRouted {
    pub fn new() -> CGCToGCMsgRouted {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional fixed64 sender_id = 2;

    pub fn sender_id(&self) -> u64 {
        self.sender_id.unwrap_or(0)
    }

    pub fn clear_sender_id(&mut self) {
        self.sender_id = ::std::option::Option::None;
    }

    pub fn has_sender_id(&self) -> bool {
        self.sender_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sender_id(&mut self, v: u64) {
        self.sender_id = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 3;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 ip = 4;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgRouted {
    const NAME: &'static str = "CGCToGCMsgRouted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                17 => {
                    self.sender_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                32 => {
                    self.ip = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sender_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        if let Some(v) = self.ip {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sender_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(3, v)?;
        }
        if let Some(v) = self.ip {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRouted {
        CGCToGCMsgRouted::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.sender_id = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRouted {
        static instance: CGCToGCMsgRouted = CGCToGCMsgRouted {
            msg_type: ::std::option::Option::None,
            sender_id: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCToGCMsgRoutedReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCToGCMsgRoutedReply {
    // message fields
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.msg_type)
    pub msg_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCToGCMsgRoutedReply.net_message)
    pub net_message: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCToGCMsgRoutedReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCToGCMsgRoutedReply {
    fn default() -> &'a CGCToGCMsgRoutedReply {
        <CGCToGCMsgRoutedReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCToGCMsgRoutedReply {
    pub fn new() -> CGCToGCMsgRoutedReply {
        ::std::default::Default::default()
    }

    // optional uint32 msg_type = 1;

    pub fn msg_type(&self) -> u32 {
        self.msg_type.unwrap_or(0)
    }

    pub fn clear_msg_type(&mut self) {
        self.msg_type = ::std::option::Option::None;
    }

    pub fn has_msg_type(&self) -> bool {
        self.msg_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_type(&mut self, v: u32) {
        self.msg_type = ::std::option::Option::Some(v);
    }

    // optional bytes net_message = 2;

    pub fn net_message(&self) -> &[u8] {
        match self.net_message.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_net_message(&mut self) {
        self.net_message = ::std::option::Option::None;
    }

    pub fn has_net_message(&self) -> bool {
        self.net_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_message(&mut self, v: ::std::vec::Vec<u8>) {
        self.net_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_net_message(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.net_message.is_none() {
            self.net_message = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.net_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_net_message(&mut self) -> ::std::vec::Vec<u8> {
        self.net_message.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCToGCMsgRoutedReply {
    const NAME: &'static str = "CGCToGCMsgRoutedReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.net_message = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.net_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.net_message.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCToGCMsgRoutedReply {
        CGCToGCMsgRoutedReply::new()
    }

    fn clear(&mut self) {
        self.msg_type = ::std::option::Option::None;
        self.net_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCToGCMsgRoutedReply {
        static instance: CGCToGCMsgRoutedReply = CGCToGCMsgRoutedReply {
            msg_type: ::std::option::Option::None,
            net_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCUpdateSessionIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCUpdateSessionIP {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCUpdateSessionIP.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCUpdateSessionIP.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCUpdateSessionIP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCUpdateSessionIP {
    fn default() -> &'a CMsgGCUpdateSessionIP {
        <CMsgGCUpdateSessionIP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCUpdateSessionIP {
    pub fn new() -> CMsgGCUpdateSessionIP {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed32 ip = 2;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCUpdateSessionIP {
    const NAME: &'static str = "CMsgGCUpdateSessionIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                21 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.ip {
            os.write_fixed32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCUpdateSessionIP {
        CMsgGCUpdateSessionIP::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCUpdateSessionIP {
        static instance: CMsgGCUpdateSessionIP = CMsgGCUpdateSessionIP {
            steamid: ::std::option::Option::None,
            ip: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestSessionIP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSessionIP {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSessionIP.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSessionIP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSessionIP {
    fn default() -> &'a CMsgGCRequestSessionIP {
        <CMsgGCRequestSessionIP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSessionIP {
    pub fn new() -> CMsgGCRequestSessionIP {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestSessionIP {
    const NAME: &'static str = "CMsgGCRequestSessionIP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSessionIP {
        CMsgGCRequestSessionIP::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSessionIP {
        static instance: CMsgGCRequestSessionIP = CMsgGCRequestSessionIP {
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestSessionIPResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestSessionIPResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCRequestSessionIPResponse.ip)
    pub ip: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestSessionIPResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestSessionIPResponse {
    fn default() -> &'a CMsgGCRequestSessionIPResponse {
        <CMsgGCRequestSessionIPResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestSessionIPResponse {
    pub fn new() -> CMsgGCRequestSessionIPResponse {
        ::std::default::Default::default()
    }

    // optional fixed32 ip = 1;

    pub fn ip(&self) -> u32 {
        self.ip.unwrap_or(0)
    }

    pub fn clear_ip(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestSessionIPResponse {
    const NAME: &'static str = "CMsgGCRequestSessionIPResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ip {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ip {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestSessionIPResponse {
        CMsgGCRequestSessionIPResponse::new()
    }

    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestSessionIPResponse {
        static instance: CMsgGCRequestSessionIPResponse = CMsgGCRequestSessionIPResponse {
            ip: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSOCacheHaveVersion)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSOCacheHaveVersion {
    // message fields
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.soid)
    pub soid: ::steam_vent_proto_common::protobuf::MessageField<CMsgSOIDOwner>,
    // @@protoc_insertion_point(field:CMsgSOCacheHaveVersion.version)
    pub version: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSOCacheHaveVersion.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSOCacheHaveVersion {
    fn default() -> &'a CMsgSOCacheHaveVersion {
        <CMsgSOCacheHaveVersion as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSOCacheHaveVersion {
    pub fn new() -> CMsgSOCacheHaveVersion {
        ::std::default::Default::default()
    }

    // optional fixed64 version = 2;

    pub fn version(&self) -> u64 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u64) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSOCacheHaveVersion {
    const NAME: &'static str = "CMsgSOCacheHaveVersion";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.soid)?;
                },
                17 => {
                    self.version = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soid.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.version {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soid.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.version {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSOCacheHaveVersion {
        CMsgSOCacheHaveVersion::new()
    }

    fn clear(&mut self) {
        self.soid.clear();
        self.version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSOCacheHaveVersion {
        static instance: CMsgSOCacheHaveVersion = CMsgSOCacheHaveVersion {
            soid: ::steam_vent_proto_common::protobuf::MessageField::none(),
            version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.client_launcher)
    pub client_launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_srcid)
    pub partner_srcid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountid)
    pub partner_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountflags)
    pub partner_accountflags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.partner_accountbalance)
    pub partner_accountbalance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientHello.steam_launcher)
    pub steam_launcher: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientHello.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientHello {
    fn default() -> &'a CMsgClientHello {
        <CMsgClientHello as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientHello {
    pub fn new() -> CMsgClientHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 client_session_need = 3;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 4;

    pub fn client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_srcid = 5;

    pub fn partner_srcid(&self) -> u32 {
        self.partner_srcid.unwrap_or(0)
    }

    pub fn clear_partner_srcid(&mut self) {
        self.partner_srcid = ::std::option::Option::None;
    }

    pub fn has_partner_srcid(&self) -> bool {
        self.partner_srcid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_srcid(&mut self, v: u32) {
        self.partner_srcid = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountid = 6;

    pub fn partner_accountid(&self) -> u32 {
        self.partner_accountid.unwrap_or(0)
    }

    pub fn clear_partner_accountid(&mut self) {
        self.partner_accountid = ::std::option::Option::None;
    }

    pub fn has_partner_accountid(&self) -> bool {
        self.partner_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountid(&mut self, v: u32) {
        self.partner_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountflags = 7;

    pub fn partner_accountflags(&self) -> u32 {
        self.partner_accountflags.unwrap_or(0)
    }

    pub fn clear_partner_accountflags(&mut self) {
        self.partner_accountflags = ::std::option::Option::None;
    }

    pub fn has_partner_accountflags(&self) -> bool {
        self.partner_accountflags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountflags(&mut self, v: u32) {
        self.partner_accountflags = ::std::option::Option::Some(v);
    }

    // optional uint32 partner_accountbalance = 8;

    pub fn partner_accountbalance(&self) -> u32 {
        self.partner_accountbalance.unwrap_or(0)
    }

    pub fn clear_partner_accountbalance(&mut self) {
        self.partner_accountbalance = ::std::option::Option::None;
    }

    pub fn has_partner_accountbalance(&self) -> bool {
        self.partner_accountbalance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partner_accountbalance(&mut self, v: u32) {
        self.partner_accountbalance = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_launcher = 9;

    pub fn steam_launcher(&self) -> u32 {
        self.steam_launcher.unwrap_or(0)
    }

    pub fn clear_steam_launcher(&mut self) {
        self.steam_launcher = ::std::option::Option::None;
    }

    pub fn has_steam_launcher(&self) -> bool {
        self.steam_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_launcher(&mut self, v: u32) {
        self.steam_launcher = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientHello {
    const NAME: &'static str = "CMsgClientHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.partner_srcid = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.partner_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.partner_accountflags = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.partner_accountbalance = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.steam_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.client_session_need {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.partner_srcid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.partner_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.partner_accountflags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.partner_accountbalance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.steam_launcher {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.partner_srcid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.partner_accountid {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.partner_accountflags {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.partner_accountbalance {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.steam_launcher {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientHello {
        CMsgClientHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.partner_srcid = ::std::option::Option::None;
        self.partner_accountid = ::std::option::Option::None;
        self.partner_accountflags = ::std::option::Option::None;
        self.partner_accountbalance = ::std::option::Option::None;
        self.steam_launcher = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientHello {
        static instance: CMsgClientHello = CMsgClientHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            partner_srcid: ::std::option::Option::None,
            partner_accountid: ::std::option::Option::None,
            partner_accountflags: ::std::option::Option::None,
            partner_accountbalance: ::std::option::Option::None,
            steam_launcher: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerHello)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerHello {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerHello.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.socache_have_versions)
    pub socache_have_versions: ::std::vec::Vec<CMsgSOCacheHaveVersion>,
    // @@protoc_insertion_point(field:CMsgServerHello.legacy_client_session_need)
    pub legacy_client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.client_launcher)
    pub client_launcher: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.legacy_steamdatagram_routing)
    pub legacy_steamdatagram_routing: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgServerHello.required_internal_addr)
    pub required_internal_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerHello.steamdatagram_login)
    pub steamdatagram_login: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgServerHello.socache_control)
    pub socache_control: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerHello.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerHello {
    fn default() -> &'a CMsgServerHello {
        <CMsgServerHello as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerHello {
    pub fn new() -> CMsgServerHello {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 legacy_client_session_need = 3;

    pub fn legacy_client_session_need(&self) -> u32 {
        self.legacy_client_session_need.unwrap_or(0)
    }

    pub fn clear_legacy_client_session_need(&mut self) {
        self.legacy_client_session_need = ::std::option::Option::None;
    }

    pub fn has_legacy_client_session_need(&self) -> bool {
        self.legacy_client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_client_session_need(&mut self, v: u32) {
        self.legacy_client_session_need = ::std::option::Option::Some(v);
    }

    // optional uint32 client_launcher = 4;

    pub fn client_launcher(&self) -> u32 {
        self.client_launcher.unwrap_or(0)
    }

    pub fn clear_client_launcher(&mut self) {
        self.client_launcher = ::std::option::Option::None;
    }

    pub fn has_client_launcher(&self) -> bool {
        self.client_launcher.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_launcher(&mut self, v: u32) {
        self.client_launcher = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_steamdatagram_routing = 6;

    pub fn legacy_steamdatagram_routing(&self) -> &[u8] {
        match self.legacy_steamdatagram_routing.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_steamdatagram_routing(&mut self) {
        self.legacy_steamdatagram_routing = ::std::option::Option::None;
    }

    pub fn has_legacy_steamdatagram_routing(&self) -> bool {
        self.legacy_steamdatagram_routing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_steamdatagram_routing(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_steamdatagram_routing = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_steamdatagram_routing(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_steamdatagram_routing.is_none() {
            self.legacy_steamdatagram_routing = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_steamdatagram_routing.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_steamdatagram_routing(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_steamdatagram_routing.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 required_internal_addr = 7;

    pub fn required_internal_addr(&self) -> u32 {
        self.required_internal_addr.unwrap_or(0)
    }

    pub fn clear_required_internal_addr(&mut self) {
        self.required_internal_addr = ::std::option::Option::None;
    }

    pub fn has_required_internal_addr(&self) -> bool {
        self.required_internal_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required_internal_addr(&mut self, v: u32) {
        self.required_internal_addr = ::std::option::Option::Some(v);
    }

    // optional bytes steamdatagram_login = 8;

    pub fn steamdatagram_login(&self) -> &[u8] {
        match self.steamdatagram_login.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_steamdatagram_login(&mut self) {
        self.steamdatagram_login = ::std::option::Option::None;
    }

    pub fn has_steamdatagram_login(&self) -> bool {
        self.steamdatagram_login.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamdatagram_login(&mut self, v: ::std::vec::Vec<u8>) {
        self.steamdatagram_login = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_steamdatagram_login(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.steamdatagram_login.is_none() {
            self.steamdatagram_login = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.steamdatagram_login.as_mut().unwrap()
    }

    // Take field
    pub fn take_steamdatagram_login(&mut self) -> ::std::vec::Vec<u8> {
        self.steamdatagram_login.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 socache_control = 9;

    pub fn socache_control(&self) -> u32 {
        self.socache_control.unwrap_or(0)
    }

    pub fn clear_socache_control(&mut self) {
        self.socache_control = ::std::option::Option::None;
    }

    pub fn has_socache_control(&self) -> bool {
        self.socache_control.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socache_control(&mut self, v: u32) {
        self.socache_control = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerHello {
    const NAME: &'static str = "CMsgServerHello";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.socache_have_versions.push(is.read_message()?);
                },
                24 => {
                    self.legacy_client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_launcher = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.legacy_steamdatagram_routing = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.required_internal_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.steamdatagram_login = ::std::option::Option::Some(is.read_bytes()?);
                },
                72 => {
                    self.socache_control = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.socache_have_versions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.legacy_client_session_need {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_launcher {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.legacy_steamdatagram_routing.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.required_internal_addr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(8, &v);
        }
        if let Some(v) = self.socache_control {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        for v in &self.socache_have_versions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.legacy_client_session_need {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_launcher {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.legacy_steamdatagram_routing.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.required_internal_addr {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.steamdatagram_login.as_ref() {
            os.write_bytes(8, v)?;
        }
        if let Some(v) = self.socache_control {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerHello {
        CMsgServerHello::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.socache_have_versions.clear();
        self.legacy_client_session_need = ::std::option::Option::None;
        self.client_launcher = ::std::option::Option::None;
        self.legacy_steamdatagram_routing = ::std::option::Option::None;
        self.required_internal_addr = ::std::option::Option::None;
        self.steamdatagram_login = ::std::option::Option::None;
        self.socache_control = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerHello {
        static instance: CMsgServerHello = CMsgServerHello {
            version: ::std::option::Option::None,
            socache_have_versions: ::std::vec::Vec::new(),
            legacy_client_session_need: ::std::option::Option::None,
            client_launcher: ::std::option::Option::None,
            legacy_steamdatagram_routing: ::std::option::Option::None,
            required_internal_addr: ::std::option::Option::None,
            steamdatagram_login: ::std::option::Option::None,
            socache_control: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientWelcome.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data)
    pub game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.outofdate_subscribed_caches)
    pub outofdate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscribed>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.uptodate_subscribed_caches)
    pub uptodate_subscribed_caches: ::std::vec::Vec<CMsgSOCacheSubscriptionCheck>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.location)
    pub location: ::steam_vent_proto_common::protobuf::MessageField<cmsg_client_welcome::Location>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.game_data2)
    pub game_data2: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.rtime32_gc_welcome_timestamp)
    pub rtime32_gc_welcome_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance)
    pub balance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.balance_url)
    pub balance_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientWelcome.txn_country_code)
    pub txn_country_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientWelcome.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientWelcome {
    fn default() -> &'a CMsgClientWelcome {
        <CMsgClientWelcome as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientWelcome {
    pub fn new() -> CMsgClientWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes game_data = 2;

    pub fn game_data(&self) -> &[u8] {
        match self.game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data(&mut self) {
        self.game_data = ::std::option::Option::None;
    }

    pub fn has_game_data(&self) -> bool {
        self.game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data.is_none() {
            self.game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional bytes game_data2 = 6;

    pub fn game_data2(&self) -> &[u8] {
        match self.game_data2.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_game_data2(&mut self) {
        self.game_data2 = ::std::option::Option::None;
    }

    pub fn has_game_data2(&self) -> bool {
        self.game_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_data2(&mut self, v: ::std::vec::Vec<u8>) {
        self.game_data2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_data2(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.game_data2.is_none() {
            self.game_data2 = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.game_data2.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_data2(&mut self) -> ::std::vec::Vec<u8> {
        self.game_data2.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 rtime32_gc_welcome_timestamp = 7;

    pub fn rtime32_gc_welcome_timestamp(&self) -> u32 {
        self.rtime32_gc_welcome_timestamp.unwrap_or(0)
    }

    pub fn clear_rtime32_gc_welcome_timestamp(&mut self) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
    }

    pub fn has_rtime32_gc_welcome_timestamp(&self) -> bool {
        self.rtime32_gc_welcome_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_gc_welcome_timestamp(&mut self, v: u32) {
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 8;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional uint32 balance = 9;

    pub fn balance(&self) -> u32 {
        self.balance.unwrap_or(0)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: u32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional string balance_url = 10;

    pub fn balance_url(&self) -> &str {
        match self.balance_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_balance_url(&mut self) {
        self.balance_url = ::std::option::Option::None;
    }

    pub fn has_balance_url(&self) -> bool {
        self.balance_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance_url(&mut self, v: ::std::string::String) {
        self.balance_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance_url(&mut self) -> &mut ::std::string::String {
        if self.balance_url.is_none() {
            self.balance_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.balance_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_balance_url(&mut self) -> ::std::string::String {
        self.balance_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string txn_country_code = 11;

    pub fn txn_country_code(&self) -> &str {
        match self.txn_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_txn_country_code(&mut self) {
        self.txn_country_code = ::std::option::Option::None;
    }

    pub fn has_txn_country_code(&self) -> bool {
        self.txn_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_country_code(&mut self, v: ::std::string::String) {
        self.txn_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txn_country_code(&mut self) -> &mut ::std::string::String {
        if self.txn_country_code.is_none() {
            self.txn_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.txn_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_txn_country_code(&mut self) -> ::std::string::String {
        self.txn_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientWelcome {
    const NAME: &'static str = "CMsgClientWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                26 => {
                    self.outofdate_subscribed_caches.push(is.read_message()?);
                },
                34 => {
                    self.uptodate_subscribed_caches.push(is.read_message()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.location)?;
                },
                50 => {
                    self.game_data2 = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.rtime32_gc_welcome_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.balance = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.balance_url = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.txn_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        for value in &self.outofdate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.uptodate_subscribed_caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.game_data2.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.balance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.balance_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        for v in &self.outofdate_subscribed_caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.uptodate_subscribed_caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.location.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.game_data2.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.rtime32_gc_welcome_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.balance {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.balance_url.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.txn_country_code.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientWelcome {
        CMsgClientWelcome::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.game_data = ::std::option::Option::None;
        self.outofdate_subscribed_caches.clear();
        self.uptodate_subscribed_caches.clear();
        self.location.clear();
        self.game_data2 = ::std::option::Option::None;
        self.rtime32_gc_welcome_timestamp = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.balance_url = ::std::option::Option::None;
        self.txn_country_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientWelcome {
        static instance: CMsgClientWelcome = CMsgClientWelcome {
            version: ::std::option::Option::None,
            game_data: ::std::option::Option::None,
            outofdate_subscribed_caches: ::std::vec::Vec::new(),
            uptodate_subscribed_caches: ::std::vec::Vec::new(),
            location: ::steam_vent_proto_common::protobuf::MessageField::none(),
            game_data2: ::std::option::Option::None,
            rtime32_gc_welcome_timestamp: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            balance_url: ::std::option::Option::None,
            txn_country_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientWelcome`
pub mod cmsg_client_welcome {
    // @@protoc_insertion_point(message:CMsgClientWelcome.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.latitude)
        pub latitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.longitude)
        pub longitude: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgClientWelcome.Location.country)
        pub country: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientWelcome.Location.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float latitude = 1;

        pub fn latitude(&self) -> f32 {
            self.latitude.unwrap_or(0.)
        }

        pub fn clear_latitude(&mut self) {
            self.latitude = ::std::option::Option::None;
        }

        pub fn has_latitude(&self) -> bool {
            self.latitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_latitude(&mut self, v: f32) {
            self.latitude = ::std::option::Option::Some(v);
        }

        // optional float longitude = 2;

        pub fn longitude(&self) -> f32 {
            self.longitude.unwrap_or(0.)
        }

        pub fn clear_longitude(&mut self) {
            self.longitude = ::std::option::Option::None;
        }

        pub fn has_longitude(&self) -> bool {
            self.longitude.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longitude(&mut self, v: f32) {
            self.longitude = ::std::option::Option::Some(v);
        }

        // optional string country = 3;

        pub fn country(&self) -> &str {
            match self.country.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_country(&mut self) {
            self.country = ::std::option::Option::None;
        }

        pub fn has_country(&self) -> bool {
            self.country.is_some()
        }

        // Param is passed by value, moved
        pub fn set_country(&mut self, v: ::std::string::String) {
            self.country = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_country(&mut self) -> &mut ::std::string::String {
            if self.country.is_none() {
                self.country = ::std::option::Option::Some(::std::string::String::new());
            }
            self.country.as_mut().unwrap()
        }

        // Take field
        pub fn take_country(&mut self) -> ::std::string::String {
            self.country.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.latitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.longitude = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.country = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.latitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.longitude {
                my_size += 1 + 4;
            }
            if let Some(v) = self.country.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.latitude {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.longitude {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.country.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.latitude = ::std::option::Option::None;
            self.longitude = ::std::option::Option::None;
            self.country = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                latitude: ::std::option::Option::None,
                longitude: ::std::option::Option::None,
                country: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgConnectionStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectionStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgConnectionStatus.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<GCConnectionStatus>>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.client_session_need)
    pub client_session_need: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_position)
    pub queue_position: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.queue_size)
    pub queue_size: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.wait_seconds)
    pub wait_seconds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectionStatus.estimated_wait_seconds_remaining)
    pub estimated_wait_seconds_remaining: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConnectionStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectionStatus {
    fn default() -> &'a CMsgConnectionStatus {
        <CMsgConnectionStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectionStatus {
    pub fn new() -> CMsgConnectionStatus {
        ::std::default::Default::default()
    }

    // optional .GCConnectionStatus status = 1;

    pub fn status(&self) -> GCConnectionStatus {
        match self.status {
            Some(e) => e.enum_value_or(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            None => GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GCConnectionStatus) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 client_session_need = 2;

    pub fn client_session_need(&self) -> u32 {
        self.client_session_need.unwrap_or(0)
    }

    pub fn clear_client_session_need(&mut self) {
        self.client_session_need = ::std::option::Option::None;
    }

    pub fn has_client_session_need(&self) -> bool {
        self.client_session_need.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_session_need(&mut self, v: u32) {
        self.client_session_need = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }

    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 queue_size = 4;

    pub fn queue_size(&self) -> i32 {
        self.queue_size.unwrap_or(0)
    }

    pub fn clear_queue_size(&mut self) {
        self.queue_size = ::std::option::Option::None;
    }

    pub fn has_queue_size(&self) -> bool {
        self.queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_size(&mut self, v: i32) {
        self.queue_size = ::std::option::Option::Some(v);
    }

    // optional int32 wait_seconds = 5;

    pub fn wait_seconds(&self) -> i32 {
        self.wait_seconds.unwrap_or(0)
    }

    pub fn clear_wait_seconds(&mut self) {
        self.wait_seconds = ::std::option::Option::None;
    }

    pub fn has_wait_seconds(&self) -> bool {
        self.wait_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wait_seconds(&mut self, v: i32) {
        self.wait_seconds = ::std::option::Option::Some(v);
    }

    // optional int32 estimated_wait_seconds_remaining = 6;

    pub fn estimated_wait_seconds_remaining(&self) -> i32 {
        self.estimated_wait_seconds_remaining.unwrap_or(0)
    }

    pub fn clear_estimated_wait_seconds_remaining(&mut self) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
    }

    pub fn has_estimated_wait_seconds_remaining(&self) -> bool {
        self.estimated_wait_seconds_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estimated_wait_seconds_remaining(&mut self, v: i32) {
        self.estimated_wait_seconds_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConnectionStatus {
    const NAME: &'static str = "CMsgConnectionStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.client_session_need = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.queue_position = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.queue_size = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.wait_seconds = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.estimated_wait_seconds_remaining = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.client_session_need {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.queue_position {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.queue_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.wait_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.client_session_need {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.wait_seconds {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.estimated_wait_seconds_remaining {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectionStatus {
        CMsgConnectionStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.client_session_need = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.queue_size = ::std::option::Option::None;
        self.wait_seconds = ::std::option::Option::None;
        self.estimated_wait_seconds_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectionStatus {
        static instance: CMsgConnectionStatus = CMsgConnectionStatus {
            status: ::std::option::Option::None,
            client_session_need: ::std::option::Option::None,
            queue_position: ::std::option::Option::None,
            queue_size: ::std::option::Option::None,
            wait_seconds: ::std::option::Option::None,
            estimated_wait_seconds_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_PopulateItemDescriptions_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.languages)
    pub languages: ::std::vec::Vec<cworkshop_populate_item_descriptions_request::ItemDescriptionsLanguageBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_PopulateItemDescriptions_Request {
    fn default() -> &'a CWorkshop_PopulateItemDescriptions_Request {
        <CWorkshop_PopulateItemDescriptions_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_PopulateItemDescriptions_Request {
    pub fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_PopulateItemDescriptions_Request {
    const NAME: &'static str = "CWorkshop_PopulateItemDescriptions_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_PopulateItemDescriptions_Request {
        CWorkshop_PopulateItemDescriptions_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_PopulateItemDescriptions_Request {
        static instance: CWorkshop_PopulateItemDescriptions_Request = CWorkshop_PopulateItemDescriptions_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_PopulateItemDescriptions_Request`
pub mod cworkshop_populate_item_descriptions_request {
    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleItemDescription {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.gameitemid)
        pub gameitemid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.item_description)
        pub item_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.one_per_account)
        pub one_per_account: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.SingleItemDescription.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleItemDescription {
        fn default() -> &'a SingleItemDescription {
            <SingleItemDescription as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleItemDescription {
        pub fn new() -> SingleItemDescription {
            ::std::default::Default::default()
        }

        // optional uint32 gameitemid = 1;

        pub fn gameitemid(&self) -> u32 {
            self.gameitemid.unwrap_or(0)
        }

        pub fn clear_gameitemid(&mut self) {
            self.gameitemid = ::std::option::Option::None;
        }

        pub fn has_gameitemid(&self) -> bool {
            self.gameitemid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gameitemid(&mut self, v: u32) {
            self.gameitemid = ::std::option::Option::Some(v);
        }

        // optional string item_description = 2;

        pub fn item_description(&self) -> &str {
            match self.item_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_item_description(&mut self) {
            self.item_description = ::std::option::Option::None;
        }

        pub fn has_item_description(&self) -> bool {
            self.item_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_description(&mut self, v: ::std::string::String) {
            self.item_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_description(&mut self) -> &mut ::std::string::String {
            if self.item_description.is_none() {
                self.item_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.item_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_description(&mut self) -> ::std::string::String {
            self.item_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool one_per_account = 3;

        pub fn one_per_account(&self) -> bool {
            self.one_per_account.unwrap_or(false)
        }

        pub fn clear_one_per_account(&mut self) {
            self.one_per_account = ::std::option::Option::None;
        }

        pub fn has_one_per_account(&self) -> bool {
            self.one_per_account.is_some()
        }

        // Param is passed by value, moved
        pub fn set_one_per_account(&mut self, v: bool) {
            self.one_per_account = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleItemDescription {
        const NAME: &'static str = "SingleItemDescription";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.item_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.one_per_account = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.gameitemid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.one_per_account {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.gameitemid {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_description.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.one_per_account {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleItemDescription {
            SingleItemDescription::new()
        }

        fn clear(&mut self) {
            self.gameitemid = ::std::option::Option::None;
            self.item_description = ::std::option::Option::None;
            self.one_per_account = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleItemDescription {
            static instance: SingleItemDescription = SingleItemDescription {
                gameitemid: ::std::option::Option::None,
                item_description: ::std::option::Option::None,
                one_per_account: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDescriptionsLanguageBlock {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.descriptions)
        pub descriptions: ::std::vec::Vec<SingleItemDescription>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_PopulateItemDescriptions_Request.ItemDescriptionsLanguageBlock.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDescriptionsLanguageBlock {
        fn default() -> &'a ItemDescriptionsLanguageBlock {
            <ItemDescriptionsLanguageBlock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemDescriptionsLanguageBlock {
        pub fn new() -> ItemDescriptionsLanguageBlock {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemDescriptionsLanguageBlock {
        const NAME: &'static str = "ItemDescriptionsLanguageBlock";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.descriptions.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.descriptions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.descriptions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDescriptionsLanguageBlock {
            ItemDescriptionsLanguageBlock::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.descriptions.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDescriptionsLanguageBlock {
            static instance: ItemDescriptionsLanguageBlock = ItemDescriptionsLanguageBlock {
                language: ::std::option::Option::None,
                descriptions: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Request {
    fn default() -> &'a CWorkshop_GetContributors_Request {
        <CWorkshop_GetContributors_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Request {
    pub fn new() -> CWorkshop_GetContributors_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Request {
    const NAME: &'static str = "CWorkshop_GetContributors_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Request {
        CWorkshop_GetContributors_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Request {
        static instance: CWorkshop_GetContributors_Request = CWorkshop_GetContributors_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_GetContributors_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_GetContributors_Response {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_GetContributors_Response.contributors)
    pub contributors: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_GetContributors_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_GetContributors_Response {
    fn default() -> &'a CWorkshop_GetContributors_Response {
        <CWorkshop_GetContributors_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_GetContributors_Response {
    pub fn new() -> CWorkshop_GetContributors_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_GetContributors_Response {
    const NAME: &'static str = "CWorkshop_GetContributors_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.contributors)?;
                },
                9 => {
                    self.contributors.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.contributors.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.contributors {
            os.write_fixed64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_GetContributors_Response {
        CWorkshop_GetContributors_Response::new()
    }

    fn clear(&mut self) {
        self.contributors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_GetContributors_Response {
        static instance: CWorkshop_GetContributors_Response = CWorkshop_GetContributors_Response {
            contributors: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_files)
    pub associated_workshop_files: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::WorkshopItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.partner_accounts)
    pub partner_accounts: ::std::vec::Vec<cworkshop_set_item_payment_rules_request::PartnerItemPaymentRule>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.validate_only)
    pub validate_only: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.make_workshop_files_subscribable)
    pub make_workshop_files_subscribable: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.associated_workshop_file_for_direct_payments)
    pub associated_workshop_file_for_direct_payments: ::steam_vent_proto_common::protobuf::MessageField<cworkshop_set_item_payment_rules_request::WorkshopDirectPaymentRule>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Request {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Request {
        <CWorkshop_SetItemPaymentRules_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Request {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional bool validate_only = 5;

    pub fn validate_only(&self) -> bool {
        self.validate_only.unwrap_or(false)
    }

    pub fn clear_validate_only(&mut self) {
        self.validate_only = ::std::option::Option::None;
    }

    pub fn has_validate_only(&self) -> bool {
        self.validate_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validate_only(&mut self, v: bool) {
        self.validate_only = ::std::option::Option::Some(v);
    }

    // optional bool make_workshop_files_subscribable = 6;

    pub fn make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.unwrap_or(false)
    }

    pub fn clear_make_workshop_files_subscribable(&mut self) {
        self.make_workshop_files_subscribable = ::std::option::Option::None;
    }

    pub fn has_make_workshop_files_subscribable(&self) -> bool {
        self.make_workshop_files_subscribable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_make_workshop_files_subscribable(&mut self, v: bool) {
        self.make_workshop_files_subscribable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Request {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.associated_workshop_files.push(is.read_message()?);
                },
                34 => {
                    self.partner_accounts.push(is.read_message()?);
                },
                40 => {
                    self.validate_only = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.make_workshop_files_subscribable = ::std::option::Option::Some(is.read_bool()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.associated_workshop_file_for_direct_payments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.associated_workshop_files {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.partner_accounts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.validate_only {
            my_size += 1 + 1;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            my_size += 1 + 1;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        for v in &self.associated_workshop_files {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.partner_accounts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.validate_only {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.make_workshop_files_subscribable {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.associated_workshop_file_for_direct_payments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Request {
        CWorkshop_SetItemPaymentRules_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.associated_workshop_files.clear();
        self.partner_accounts.clear();
        self.validate_only = ::std::option::Option::None;
        self.make_workshop_files_subscribable = ::std::option::Option::None;
        self.associated_workshop_file_for_direct_payments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Request {
        static instance: CWorkshop_SetItemPaymentRules_Request = CWorkshop_SetItemPaymentRules_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            associated_workshop_files: ::std::vec::Vec::new(),
            partner_accounts: ::std::vec::Vec::new(),
            validate_only: ::std::option::Option::None,
            make_workshop_files_subscribable: ::std::option::Option::None,
            associated_workshop_file_for_direct_payments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CWorkshop_SetItemPaymentRules_Request`
pub mod cworkshop_set_item_payment_rules_request {
    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.rule_type)
        pub rule_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopItemPaymentRule {
        fn default() -> &'a WorkshopItemPaymentRule {
            <WorkshopItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopItemPaymentRule {
        pub fn new() -> WorkshopItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 rule_type = 4;

        pub fn rule_type(&self) -> u32 {
            self.rule_type.unwrap_or(1u32)
        }

        pub fn clear_rule_type(&mut self) {
            self.rule_type = ::std::option::Option::None;
        }

        pub fn has_rule_type(&self) -> bool {
            self.rule_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_type(&mut self, v: u32) {
            self.rule_type = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WorkshopItemPaymentRule {
        const NAME: &'static str = "WorkshopItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.rule_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.rule_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.rule_type {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopItemPaymentRule {
            WorkshopItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.rule_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopItemPaymentRule {
            static instance: WorkshopItemPaymentRule = WorkshopItemPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                rule_type: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WorkshopDirectPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.workshop_file_id)
        pub workshop_file_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.WorkshopDirectPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WorkshopDirectPaymentRule {
        fn default() -> &'a WorkshopDirectPaymentRule {
            <WorkshopDirectPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WorkshopDirectPaymentRule {
        pub fn new() -> WorkshopDirectPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint64 workshop_file_id = 1;

        pub fn workshop_file_id(&self) -> u64 {
            self.workshop_file_id.unwrap_or(0)
        }

        pub fn clear_workshop_file_id(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
        }

        pub fn has_workshop_file_id(&self) -> bool {
            self.workshop_file_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_workshop_file_id(&mut self, v: u64) {
            self.workshop_file_id = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 2;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WorkshopDirectPaymentRule {
        const NAME: &'static str = "WorkshopDirectPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.workshop_file_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.workshop_file_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.workshop_file_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WorkshopDirectPaymentRule {
            WorkshopDirectPaymentRule::new()
        }

        fn clear(&mut self) {
            self.workshop_file_id = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WorkshopDirectPaymentRule {
            static instance: WorkshopDirectPaymentRule = WorkshopDirectPaymentRule {
                workshop_file_id: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartnerItemPaymentRule {
        // message fields
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.revenue_percentage)
        pub revenue_percentage: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.rule_description)
        pub rule_description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Request.PartnerItemPaymentRule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartnerItemPaymentRule {
        fn default() -> &'a PartnerItemPaymentRule {
            <PartnerItemPaymentRule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartnerItemPaymentRule {
        pub fn new() -> PartnerItemPaymentRule {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional float revenue_percentage = 2;

        pub fn revenue_percentage(&self) -> f32 {
            self.revenue_percentage.unwrap_or(0.)
        }

        pub fn clear_revenue_percentage(&mut self) {
            self.revenue_percentage = ::std::option::Option::None;
        }

        pub fn has_revenue_percentage(&self) -> bool {
            self.revenue_percentage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revenue_percentage(&mut self, v: f32) {
            self.revenue_percentage = ::std::option::Option::Some(v);
        }

        // optional string rule_description = 3;

        pub fn rule_description(&self) -> &str {
            match self.rule_description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_rule_description(&mut self) {
            self.rule_description = ::std::option::Option::None;
        }

        pub fn has_rule_description(&self) -> bool {
            self.rule_description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rule_description(&mut self, v: ::std::string::String) {
            self.rule_description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_rule_description(&mut self) -> &mut ::std::string::String {
            if self.rule_description.is_none() {
                self.rule_description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.rule_description.as_mut().unwrap()
        }

        // Take field
        pub fn take_rule_description(&mut self) -> ::std::string::String {
            self.rule_description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartnerItemPaymentRule {
        const NAME: &'static str = "PartnerItemPaymentRule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.revenue_percentage = ::std::option::Option::Some(is.read_float()?);
                    },
                    26 => {
                        self.rule_description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revenue_percentage {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rule_description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revenue_percentage {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.rule_description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartnerItemPaymentRule {
            PartnerItemPaymentRule::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.revenue_percentage = ::std::option::Option::None;
            self.rule_description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartnerItemPaymentRule {
            static instance: PartnerItemPaymentRule = PartnerItemPaymentRule {
                account_id: ::std::option::Option::None,
                revenue_percentage: ::std::option::Option::None,
                rule_description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_SetItemPaymentRules_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_SetItemPaymentRules_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_SetItemPaymentRules_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_SetItemPaymentRules_Response {
    fn default() -> &'a CWorkshop_SetItemPaymentRules_Response {
        <CWorkshop_SetItemPaymentRules_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_SetItemPaymentRules_Response {
    pub fn new() -> CWorkshop_SetItemPaymentRules_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_SetItemPaymentRules_Response {
    const NAME: &'static str = "CWorkshop_SetItemPaymentRules_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_SetItemPaymentRules_Response {
        CWorkshop_SetItemPaymentRules_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_SetItemPaymentRules_Response {
        static instance: CWorkshop_SetItemPaymentRules_Response = CWorkshop_SetItemPaymentRules_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameServers_AggregationQuery_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameServers_AggregationQuery_Request {
    // message fields
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Request.filter)
    pub filter: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Request.group_fields)
    pub group_fields: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameServers_AggregationQuery_Request {
    fn default() -> &'a CGameServers_AggregationQuery_Request {
        <CGameServers_AggregationQuery_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameServers_AggregationQuery_Request {
    pub fn new() -> CGameServers_AggregationQuery_Request {
        ::std::default::Default::default()
    }

    // optional string filter = 1;

    pub fn filter(&self) -> &str {
        match self.filter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filter(&mut self) {
        self.filter = ::std::option::Option::None;
    }

    pub fn has_filter(&self) -> bool {
        self.filter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        if self.filter.is_none() {
            self.filter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filter.as_mut().unwrap()
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        self.filter.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameServers_AggregationQuery_Request {
    const NAME: &'static str = "CGameServers_AggregationQuery_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.filter = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.group_fields.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.filter.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        for value in &self.group_fields {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.filter.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.group_fields {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameServers_AggregationQuery_Request {
        CGameServers_AggregationQuery_Request::new()
    }

    fn clear(&mut self) {
        self.filter = ::std::option::Option::None;
        self.group_fields.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameServers_AggregationQuery_Request {
        static instance: CGameServers_AggregationQuery_Request = CGameServers_AggregationQuery_Request {
            filter: ::std::option::Option::None,
            group_fields: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGameServers_AggregationQuery_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGameServers_AggregationQuery_Response {
    // message fields
    // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.groups)
    pub groups: ::std::vec::Vec<cgame_servers_aggregation_query_response::Group>,
    // special fields
    // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGameServers_AggregationQuery_Response {
    fn default() -> &'a CGameServers_AggregationQuery_Response {
        <CGameServers_AggregationQuery_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGameServers_AggregationQuery_Response {
    pub fn new() -> CGameServers_AggregationQuery_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGameServers_AggregationQuery_Response {
    const NAME: &'static str = "CGameServers_AggregationQuery_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.groups.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.groups {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGameServers_AggregationQuery_Response {
        CGameServers_AggregationQuery_Response::new()
    }

    fn clear(&mut self) {
        self.groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGameServers_AggregationQuery_Response {
        static instance: CGameServers_AggregationQuery_Response = CGameServers_AggregationQuery_Response {
            groups: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGameServers_AggregationQuery_Response`
pub mod cgame_servers_aggregation_query_response {
    // @@protoc_insertion_point(message:CGameServers_AggregationQuery_Response.Group)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Group {
        // message fields
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.group_values)
        pub group_values: ::std::vec::Vec<::std::string::String>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_empty)
        pub servers_empty: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_full)
        pub servers_full: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.servers_total)
        pub servers_total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.players_humans)
        pub players_humans: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.players_bots)
        pub players_bots: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGameServers_AggregationQuery_Response.Group.player_capacity)
        pub player_capacity: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CGameServers_AggregationQuery_Response.Group.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Group {
        fn default() -> &'a Group {
            <Group as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Group {
        pub fn new() -> Group {
            ::std::default::Default::default()
        }

        // optional uint32 servers_empty = 2;

        pub fn servers_empty(&self) -> u32 {
            self.servers_empty.unwrap_or(0)
        }

        pub fn clear_servers_empty(&mut self) {
            self.servers_empty = ::std::option::Option::None;
        }

        pub fn has_servers_empty(&self) -> bool {
            self.servers_empty.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_empty(&mut self, v: u32) {
            self.servers_empty = ::std::option::Option::Some(v);
        }

        // optional uint32 servers_full = 3;

        pub fn servers_full(&self) -> u32 {
            self.servers_full.unwrap_or(0)
        }

        pub fn clear_servers_full(&mut self) {
            self.servers_full = ::std::option::Option::None;
        }

        pub fn has_servers_full(&self) -> bool {
            self.servers_full.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_full(&mut self, v: u32) {
            self.servers_full = ::std::option::Option::Some(v);
        }

        // optional uint32 servers_total = 4;

        pub fn servers_total(&self) -> u32 {
            self.servers_total.unwrap_or(0)
        }

        pub fn clear_servers_total(&mut self) {
            self.servers_total = ::std::option::Option::None;
        }

        pub fn has_servers_total(&self) -> bool {
            self.servers_total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_servers_total(&mut self, v: u32) {
            self.servers_total = ::std::option::Option::Some(v);
        }

        // optional uint32 players_humans = 5;

        pub fn players_humans(&self) -> u32 {
            self.players_humans.unwrap_or(0)
        }

        pub fn clear_players_humans(&mut self) {
            self.players_humans = ::std::option::Option::None;
        }

        pub fn has_players_humans(&self) -> bool {
            self.players_humans.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players_humans(&mut self, v: u32) {
            self.players_humans = ::std::option::Option::Some(v);
        }

        // optional uint32 players_bots = 6;

        pub fn players_bots(&self) -> u32 {
            self.players_bots.unwrap_or(0)
        }

        pub fn clear_players_bots(&mut self) {
            self.players_bots = ::std::option::Option::None;
        }

        pub fn has_players_bots(&self) -> bool {
            self.players_bots.is_some()
        }

        // Param is passed by value, moved
        pub fn set_players_bots(&mut self, v: u32) {
            self.players_bots = ::std::option::Option::Some(v);
        }

        // optional uint32 player_capacity = 7;

        pub fn player_capacity(&self) -> u32 {
            self.player_capacity.unwrap_or(0)
        }

        pub fn clear_player_capacity(&mut self) {
            self.player_capacity = ::std::option::Option::None;
        }

        pub fn has_player_capacity(&self) -> bool {
            self.player_capacity.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_capacity(&mut self, v: u32) {
            self.player_capacity = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Group {
        const NAME: &'static str = "Group";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.group_values.push(is.read_string()?);
                    },
                    16 => {
                        self.servers_empty = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.servers_full = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.servers_total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.players_humans = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.players_bots = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.player_capacity = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.group_values {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &value);
            };
            if let Some(v) = self.servers_empty {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.servers_full {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.servers_total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.players_humans {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.players_bots {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.player_capacity {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.group_values {
                os.write_string(1, &v)?;
            };
            if let Some(v) = self.servers_empty {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.servers_full {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.servers_total {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.players_humans {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.players_bots {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.player_capacity {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Group {
            Group::new()
        }

        fn clear(&mut self) {
            self.group_values.clear();
            self.servers_empty = ::std::option::Option::None;
            self.servers_full = ::std::option::Option::None;
            self.servers_total = ::std::option::Option::None;
            self.players_humans = ::std::option::Option::None;
            self.players_bots = ::std::option::Option::None;
            self.player_capacity = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Group {
            static instance: Group = Group {
                group_values: ::std::vec::Vec::new(),
                servers_empty: ::std::option::Option::None,
                servers_full: ::std::option::Option::None,
                servers_total: ::std::option::Option::None,
                players_humans: ::std::option::Option::None,
                players_bots: ::std::option::Option::None,
                player_capacity: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CWorkshop_AddSpecialPayment_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_AddSpecialPayment_Request {
    // message fields
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.gameitemid)
    pub gameitemid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.date)
    pub date: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.payment_us_usd)
    pub payment_us_usd: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CWorkshop_AddSpecialPayment_Request.payment_row_usd)
    pub payment_row_usd: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_AddSpecialPayment_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_AddSpecialPayment_Request {
    fn default() -> &'a CWorkshop_AddSpecialPayment_Request {
        <CWorkshop_AddSpecialPayment_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_AddSpecialPayment_Request {
    pub fn new() -> CWorkshop_AddSpecialPayment_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 gameitemid = 2;

    pub fn gameitemid(&self) -> u32 {
        self.gameitemid.unwrap_or(0)
    }

    pub fn clear_gameitemid(&mut self) {
        self.gameitemid = ::std::option::Option::None;
    }

    pub fn has_gameitemid(&self) -> bool {
        self.gameitemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameitemid(&mut self, v: u32) {
        self.gameitemid = ::std::option::Option::Some(v);
    }

    // optional string date = 3;

    pub fn date(&self) -> &str {
        match self.date.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: ::std::string::String) {
        self.date = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_date(&mut self) -> &mut ::std::string::String {
        if self.date.is_none() {
            self.date = ::std::option::Option::Some(::std::string::String::new());
        }
        self.date.as_mut().unwrap()
    }

    // Take field
    pub fn take_date(&mut self) -> ::std::string::String {
        self.date.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 payment_us_usd = 4;

    pub fn payment_us_usd(&self) -> u64 {
        self.payment_us_usd.unwrap_or(0)
    }

    pub fn clear_payment_us_usd(&mut self) {
        self.payment_us_usd = ::std::option::Option::None;
    }

    pub fn has_payment_us_usd(&self) -> bool {
        self.payment_us_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_us_usd(&mut self, v: u64) {
        self.payment_us_usd = ::std::option::Option::Some(v);
    }

    // optional uint64 payment_row_usd = 5;

    pub fn payment_row_usd(&self) -> u64 {
        self.payment_row_usd.unwrap_or(0)
    }

    pub fn clear_payment_row_usd(&mut self) {
        self.payment_row_usd = ::std::option::Option::None;
    }

    pub fn has_payment_row_usd(&self) -> bool {
        self.payment_row_usd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_payment_row_usd(&mut self, v: u64) {
        self.payment_row_usd = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_AddSpecialPayment_Request {
    const NAME: &'static str = "CWorkshop_AddSpecialPayment_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gameitemid = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.date = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.payment_us_usd = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.payment_row_usd = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gameitemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.date.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.payment_us_usd {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.payment_row_usd {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gameitemid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.date.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.payment_us_usd {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.payment_row_usd {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_AddSpecialPayment_Request {
        CWorkshop_AddSpecialPayment_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.gameitemid = ::std::option::Option::None;
        self.date = ::std::option::Option::None;
        self.payment_us_usd = ::std::option::Option::None;
        self.payment_row_usd = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_AddSpecialPayment_Request {
        static instance: CWorkshop_AddSpecialPayment_Request = CWorkshop_AddSpecialPayment_Request {
            appid: ::std::option::Option::None,
            gameitemid: ::std::option::Option::None,
            date: ::std::option::Option::None,
            payment_us_usd: ::std::option::Option::None,
            payment_row_usd: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CWorkshop_AddSpecialPayment_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CWorkshop_AddSpecialPayment_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CWorkshop_AddSpecialPayment_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CWorkshop_AddSpecialPayment_Response {
    fn default() -> &'a CWorkshop_AddSpecialPayment_Response {
        <CWorkshop_AddSpecialPayment_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CWorkshop_AddSpecialPayment_Response {
    pub fn new() -> CWorkshop_AddSpecialPayment_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CWorkshop_AddSpecialPayment_Response {
    const NAME: &'static str = "CWorkshop_AddSpecialPayment_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CWorkshop_AddSpecialPayment_Response {
        CWorkshop_AddSpecialPayment_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CWorkshop_AddSpecialPayment_Response {
        static instance: CWorkshop_AddSpecialPayment_Response = CWorkshop_AddSpecialPayment_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProductInfo_SetRichPresenceLocalization_Request {
    // message fields
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.appid)
    pub appid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.languages)
    pub languages: ::std::vec::Vec<cproduct_info_set_rich_presence_localization_request::LanguageSection>,
    // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.steamid)
    pub steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProductInfo_SetRichPresenceLocalization_Request {
    fn default() -> &'a CProductInfo_SetRichPresenceLocalization_Request {
        <CProductInfo_SetRichPresenceLocalization_Request as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProductInfo_SetRichPresenceLocalization_Request {
    pub fn new() -> CProductInfo_SetRichPresenceLocalization_Request {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }

    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint64 steamid = 3;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProductInfo_SetRichPresenceLocalization_Request {
    const NAME: &'static str = "CProductInfo_SetRichPresenceLocalization_Request";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.appid = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.languages.push(is.read_message()?);
                },
                24 => {
                    self.steamid = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.languages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.steamid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        for v in &self.languages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.steamid {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProductInfo_SetRichPresenceLocalization_Request {
        CProductInfo_SetRichPresenceLocalization_Request::new()
    }

    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.languages.clear();
        self.steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProductInfo_SetRichPresenceLocalization_Request {
        static instance: CProductInfo_SetRichPresenceLocalization_Request = CProductInfo_SetRichPresenceLocalization_Request {
            appid: ::std::option::Option::None,
            languages: ::std::vec::Vec::new(),
            steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CProductInfo_SetRichPresenceLocalization_Request`
pub mod cproduct_info_set_rich_presence_localization_request {
    // @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request.Token)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Token {
        // message fields
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.Token.token)
        pub token: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.Token.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.Token.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Token {
        fn default() -> &'a Token {
            <Token as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Token {
        pub fn new() -> Token {
            ::std::default::Default::default()
        }

        // optional string token = 1;

        pub fn token(&self) -> &str {
            match self.token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_token(&mut self) {
            self.token = ::std::option::Option::None;
        }

        pub fn has_token(&self) -> bool {
            self.token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_token(&mut self, v: ::std::string::String) {
            self.token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_token(&mut self) -> &mut ::std::string::String {
            if self.token.is_none() {
                self.token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.token.as_mut().unwrap()
        }

        // Take field
        pub fn take_token(&mut self) -> ::std::string::String {
            self.token.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Token {
        const NAME: &'static str = "Token";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.token = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.token.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.token.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Token {
            Token::new()
        }

        fn clear(&mut self) {
            self.token = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Token {
            static instance: Token = Token {
                token: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LanguageSection {
        // message fields
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.language)
        pub language: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.tokens)
        pub tokens: ::std::vec::Vec<Token>,
        // special fields
        // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Request.LanguageSection.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LanguageSection {
        fn default() -> &'a LanguageSection {
            <LanguageSection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LanguageSection {
        pub fn new() -> LanguageSection {
            ::std::default::Default::default()
        }

        // optional string language = 1;

        pub fn language(&self) -> &str {
            match self.language.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_language(&mut self) {
            self.language = ::std::option::Option::None;
        }

        pub fn has_language(&self) -> bool {
            self.language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_language(&mut self, v: ::std::string::String) {
            self.language = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_language(&mut self) -> &mut ::std::string::String {
            if self.language.is_none() {
                self.language = ::std::option::Option::Some(::std::string::String::new());
            }
            self.language.as_mut().unwrap()
        }

        // Take field
        pub fn take_language(&mut self) -> ::std::string::String {
            self.language.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LanguageSection {
        const NAME: &'static str = "LanguageSection";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.language = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.tokens.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.language.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            for value in &self.tokens {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.language.as_ref() {
                os.write_string(1, v)?;
            }
            for v in &self.tokens {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LanguageSection {
            LanguageSection::new()
        }

        fn clear(&mut self) {
            self.language = ::std::option::Option::None;
            self.tokens.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LanguageSection {
            static instance: LanguageSection = LanguageSection {
                language: ::std::option::Option::None,
                tokens: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CProductInfo_SetRichPresenceLocalization_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CProductInfo_SetRichPresenceLocalization_Response {
    // special fields
    // @@protoc_insertion_point(special_field:CProductInfo_SetRichPresenceLocalization_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CProductInfo_SetRichPresenceLocalization_Response {
    fn default() -> &'a CProductInfo_SetRichPresenceLocalization_Response {
        <CProductInfo_SetRichPresenceLocalization_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CProductInfo_SetRichPresenceLocalization_Response {
    pub fn new() -> CProductInfo_SetRichPresenceLocalization_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CProductInfo_SetRichPresenceLocalization_Response {
    const NAME: &'static str = "CProductInfo_SetRichPresenceLocalization_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CProductInfo_SetRichPresenceLocalization_Response {
        CProductInfo_SetRichPresenceLocalization_Response::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CProductInfo_SetRichPresenceLocalization_Response {
        static instance: CProductInfo_SetRichPresenceLocalization_Response = CProductInfo_SetRichPresenceLocalization_Response {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSerializedSOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSerializedSOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.file_version)
    pub file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.caches)
    pub caches: ::std::vec::Vec<cmsg_serialized_socache::Cache>,
    // @@protoc_insertion_point(field:CMsgSerializedSOCache.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSerializedSOCache {
    fn default() -> &'a CMsgSerializedSOCache {
        <CMsgSerializedSOCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSerializedSOCache {
    pub fn new() -> CMsgSerializedSOCache {
        ::std::default::Default::default()
    }

    // optional uint32 file_version = 1;

    pub fn file_version(&self) -> u32 {
        self.file_version.unwrap_or(0)
    }

    pub fn clear_file_version(&mut self) {
        self.file_version = ::std::option::Option::None;
    }

    pub fn has_file_version(&self) -> bool {
        self.file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_version(&mut self, v: u32) {
        self.file_version = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_socache_file_version = 3;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSerializedSOCache {
    const NAME: &'static str = "CMsgSerializedSOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.caches.push(is.read_message()?);
                },
                24 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.caches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.file_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.caches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSerializedSOCache {
        CMsgSerializedSOCache::new()
    }

    fn clear(&mut self) {
        self.file_version = ::std::option::Option::None;
        self.caches.clear();
        self.gc_socache_file_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSerializedSOCache {
        static instance: CMsgSerializedSOCache = CMsgSerializedSOCache {
            file_version: ::std::option::Option::None,
            caches: ::std::vec::Vec::new(),
            gc_socache_file_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSerializedSOCache`
pub mod cmsg_serialized_socache {
    // @@protoc_insertion_point(message:CMsgSerializedSOCache.TypeCache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TypeCache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.objects)
        pub objects: ::std::vec::Vec<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.TypeCache.service_id)
        pub service_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.TypeCache.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TypeCache {
        fn default() -> &'a TypeCache {
            <TypeCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TypeCache {
        pub fn new() -> TypeCache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint32 service_id = 3;

        pub fn service_id(&self) -> u32 {
            self.service_id.unwrap_or(0)
        }

        pub fn clear_service_id(&mut self) {
            self.service_id = ::std::option::Option::None;
        }

        pub fn has_service_id(&self) -> bool {
            self.service_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_service_id(&mut self, v: u32) {
            self.service_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TypeCache {
        const NAME: &'static str = "TypeCache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.objects.push(is.read_bytes()?);
                    },
                    24 => {
                        self.service_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.objects {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &value);
            };
            if let Some(v) = self.service_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            for v in &self.objects {
                os.write_bytes(2, &v)?;
            };
            if let Some(v) = self.service_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TypeCache {
            TypeCache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.objects.clear();
            self.service_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TypeCache {
            static instance: TypeCache = TypeCache {
                type_: ::std::option::Option::None,
                objects: ::std::vec::Vec::new(),
                service_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Cache {
        // message fields
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type)
        pub type_: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.id)
        pub id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.versions)
        pub versions: ::std::vec::Vec<cache::Version>,
        // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.type_caches)
        pub type_caches: ::std::vec::Vec<TypeCache>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Cache {
        fn default() -> &'a Cache {
            <Cache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Cache {
        pub fn new() -> Cache {
            ::std::default::Default::default()
        }

        // optional uint32 type = 1;

        pub fn type_(&self) -> u32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: u32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional uint64 id = 2;

        pub fn id(&self) -> u64 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u64) {
            self.id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Cache {
        const NAME: &'static str = "Cache";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.versions.push(is.read_message()?);
                    },
                    34 => {
                        self.type_caches.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            for value in &self.versions {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.type_caches {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.id {
                os.write_uint64(2, v)?;
            }
            for v in &self.versions {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.type_caches {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Cache {
            Cache::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.id = ::std::option::Option::None;
            self.versions.clear();
            self.type_caches.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Cache {
            static instance: Cache = Cache {
                type_: ::std::option::Option::None,
                id: ::std::option::Option::None,
                versions: ::std::vec::Vec::new(),
                type_caches: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Cache`
    pub mod cache {
        // @@protoc_insertion_point(message:CMsgSerializedSOCache.Cache.Version)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Version {
            // message fields
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.service)
            pub service: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSerializedSOCache.Cache.Version.version)
            pub version: ::std::option::Option<u64>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSerializedSOCache.Cache.Version.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Version {
            fn default() -> &'a Version {
                <Version as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Version {
            pub fn new() -> Version {
                ::std::default::Default::default()
            }

            // optional uint32 service = 1;

            pub fn service(&self) -> u32 {
                self.service.unwrap_or(0)
            }

            pub fn clear_service(&mut self) {
                self.service = ::std::option::Option::None;
            }

            pub fn has_service(&self) -> bool {
                self.service.is_some()
            }

            // Param is passed by value, moved
            pub fn set_service(&mut self, v: u32) {
                self.service = ::std::option::Option::Some(v);
            }

            // optional uint64 version = 2;

            pub fn version(&self) -> u64 {
                self.version.unwrap_or(0)
            }

            pub fn clear_version(&mut self) {
                self.version = ::std::option::Option::None;
            }

            pub fn has_version(&self) -> bool {
                self.version.is_some()
            }

            // Param is passed by value, moved
            pub fn set_version(&mut self, v: u64) {
                self.version = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Version {
            const NAME: &'static str = "Version";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.service = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.version = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.service {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.version {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.service {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.version {
                    os.write_uint64(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Version {
                Version::new()
            }

            fn clear(&mut self) {
                self.service = ::std::option::Option::None;
                self.version = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Version {
                static instance: Version = Version {
                    service: ::std::option::Option::None,
                    version: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCClientLauncherType)
pub enum GCClientLauncherType {
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_DEFAULT)
    GCClientLauncherType_DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_PERFECTWORLD)
    GCClientLauncherType_PERFECTWORLD = 1,
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_STEAMCHINA)
    GCClientLauncherType_STEAMCHINA = 2,
    // @@protoc_insertion_point(enum_value:GCClientLauncherType.GCClientLauncherType_SOURCE2)
    GCClientLauncherType_SOURCE2 = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for GCClientLauncherType {
    const NAME: &'static str = "GCClientLauncherType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCClientLauncherType> {
        match value {
            0 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_DEFAULT),
            1 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_PERFECTWORLD),
            2 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_STEAMCHINA),
            3 => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_SOURCE2),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCClientLauncherType> {
        match str {
            "GCClientLauncherType_DEFAULT" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_DEFAULT),
            "GCClientLauncherType_PERFECTWORLD" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_PERFECTWORLD),
            "GCClientLauncherType_STEAMCHINA" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_STEAMCHINA),
            "GCClientLauncherType_SOURCE2" => ::std::option::Option::Some(GCClientLauncherType::GCClientLauncherType_SOURCE2),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCClientLauncherType] = &[
        GCClientLauncherType::GCClientLauncherType_DEFAULT,
        GCClientLauncherType::GCClientLauncherType_PERFECTWORLD,
        GCClientLauncherType::GCClientLauncherType_STEAMCHINA,
        GCClientLauncherType::GCClientLauncherType_SOURCE2,
    ];
}

impl ::std::default::Default for GCClientLauncherType {
    fn default() -> Self {
        GCClientLauncherType::GCClientLauncherType_DEFAULT
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:GCConnectionStatus)
pub enum GCConnectionStatus {
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_HAVE_SESSION)
    GCConnectionStatus_HAVE_SESSION = 0,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_GC_GOING_DOWN)
    GCConnectionStatus_GC_GOING_DOWN = 1,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION)
    GCConnectionStatus_NO_SESSION = 2,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE)
    GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE = 3,
    // @@protoc_insertion_point(enum_value:GCConnectionStatus.GCConnectionStatus_NO_STEAM)
    GCConnectionStatus_NO_STEAM = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for GCConnectionStatus {
    const NAME: &'static str = "GCConnectionStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GCConnectionStatus> {
        match value {
            0 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            1 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            2 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            3 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            4 => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<GCConnectionStatus> {
        match str {
            "GCConnectionStatus_HAVE_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_HAVE_SESSION),
            "GCConnectionStatus_GC_GOING_DOWN" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN),
            "GCConnectionStatus_NO_SESSION" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION),
            "GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE),
            "GCConnectionStatus_NO_STEAM" => ::std::option::Option::Some(GCConnectionStatus::GCConnectionStatus_NO_STEAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [GCConnectionStatus] = &[
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION,
        GCConnectionStatus::GCConnectionStatus_GC_GOING_DOWN,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION,
        GCConnectionStatus::GCConnectionStatus_NO_SESSION_IN_LOGON_QUEUE,
        GCConnectionStatus::GCConnectionStatus_NO_STEAM,
    ];
}

impl ::std::default::Default for GCConnectionStatus {
    fn default() -> Self {
        GCConnectionStatus::GCConnectionStatus_HAVE_SESSION
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgSOIDOwner {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOSingleObject {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOMultipleObjects {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscribed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscribed {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscribed;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheUnsubscribed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheUnsubscribed {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheUnsubscribed;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscriptionCheck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscriptionCheck {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscriptionCheck;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheSubscriptionRefresh {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSOCacheSubscriptionRefresh {
    type KindEnum = crate::gcsystemmsgs::ESOMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::ESOMsg::k_ESOMsg_CacheSubscriptionRefresh;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheVersion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAccountDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMultiplexMessage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMultiplexMessage_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterAck {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterAck_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgMasterStartupComplete {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgRouted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCToGCMsgRoutedReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCUpdateSessionIP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCUpdateSessionIP {
    type KindEnum = crate::gcsystemmsgs::EGCToGCMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCToGCMsg::k_EMsgUpdateSessionIP;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestSessionIP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCRequestSessionIP {
    type KindEnum = crate::gcsystemmsgs::EGCToGCMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCToGCMsg::k_EMsgRequestSessionIP;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestSessionIPResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCRequestSessionIPResponse {
    type KindEnum = crate::gcsystemmsgs::EGCToGCMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCToGCMsg::k_EMsgRequestSessionIPResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSOCacheHaveVersion {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientHello {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientHello {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientHello;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerHello {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerHello {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCServerHello;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientWelcome {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientWelcome {
    type KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg;
    const KIND: Self::KindEnum = crate::gcsystemmsgs::EGCBaseClientMsg::k_EMsgGCClientWelcome;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConnectionStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CWorkshop_PopulateItemDescriptions_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_GetContributors_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_SetItemPaymentRules_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameServers_AggregationQuery_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGameServers_AggregationQuery_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_AddSpecialPayment_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CWorkshop_AddSpecialPayment_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CProductInfo_SetRichPresenceLocalization_Request {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CProductInfo_SetRichPresenceLocalization_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSerializedSOCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
