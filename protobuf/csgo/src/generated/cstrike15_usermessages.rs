// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `cstrike15_usermessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CCSUsrMsg_VGUIMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VGUIMenu {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.keys)
    pub keys: ::std::vec::Vec<ccsusr_msg_vguimenu::Keys>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VGUIMenu.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VGUIMenu {
    fn default() -> &'a CCSUsrMsg_VGUIMenu {
        <CCSUsrMsg_VGUIMenu as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VGUIMenu {
    pub fn new() -> CCSUsrMsg_VGUIMenu {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show = 2;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VGUIMenu {
    const NAME: &'static str = "CCSUsrMsg_VGUIMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.keys.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        for value in &self.keys {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.show {
            os.write_bool(2, v)?;
        }
        for v in &self.keys {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VGUIMenu {
        CCSUsrMsg_VGUIMenu::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.show = ::std::option::Option::None;
        self.keys.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VGUIMenu {
        static instance: CCSUsrMsg_VGUIMenu = CCSUsrMsg_VGUIMenu {
            name: ::std::option::Option::None,
            show: ::std::option::Option::None,
            keys: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_VGUIMenu`
pub mod ccsusr_msg_vguimenu {
    // @@protoc_insertion_point(message:CCSUsrMsg_VGUIMenu.Keys)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Keys {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.Keys.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCSUsrMsg_VGUIMenu.Keys.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_VGUIMenu.Keys.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Keys {
        fn default() -> &'a Keys {
            <Keys as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Keys {
        pub fn new() -> Keys {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Keys {
        const NAME: &'static str = "Keys";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Keys {
            Keys::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Keys {
            static instance: Keys = Keys {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Geiger)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Geiger {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Geiger.range)
    pub range: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Geiger.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Geiger {
    fn default() -> &'a CCSUsrMsg_Geiger {
        <CCSUsrMsg_Geiger as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Geiger {
    pub fn new() -> CCSUsrMsg_Geiger {
        ::std::default::Default::default()
    }

    // optional int32 range = 1;

    pub fn range(&self) -> i32 {
        self.range.unwrap_or(0)
    }

    pub fn clear_range(&mut self) {
        self.range = ::std::option::Option::None;
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: i32) {
        self.range = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Geiger {
    const NAME: &'static str = "CCSUsrMsg_Geiger";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.range = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.range {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.range {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Geiger {
        CCSUsrMsg_Geiger::new()
    }

    fn clear(&mut self) {
        self.range = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Geiger {
        static instance: CCSUsrMsg_Geiger = CCSUsrMsg_Geiger {
            range: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Train)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Train {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Train.train)
    pub train: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Train.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Train {
    fn default() -> &'a CCSUsrMsg_Train {
        <CCSUsrMsg_Train as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Train {
    pub fn new() -> CCSUsrMsg_Train {
        ::std::default::Default::default()
    }

    // optional int32 train = 1;

    pub fn train(&self) -> i32 {
        self.train.unwrap_or(0)
    }

    pub fn clear_train(&mut self) {
        self.train = ::std::option::Option::None;
    }

    pub fn has_train(&self) -> bool {
        self.train.is_some()
    }

    // Param is passed by value, moved
    pub fn set_train(&mut self, v: i32) {
        self.train = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Train {
    const NAME: &'static str = "CCSUsrMsg_Train";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.train = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.train {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.train {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Train {
        CCSUsrMsg_Train::new()
    }

    fn clear(&mut self) {
        self.train = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Train {
        static instance: CCSUsrMsg_Train = CCSUsrMsg_Train {
            train: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_HudText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HudText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HudText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HudText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudText {
    fn default() -> &'a CCSUsrMsg_HudText {
        <CCSUsrMsg_HudText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudText {
    pub fn new() -> CCSUsrMsg_HudText {
        ::std::default::Default::default()
    }

    // optional string text = 1;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_HudText {
    const NAME: &'static str = "CCSUsrMsg_HudText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.text.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HudText {
        CCSUsrMsg_HudText::new()
    }

    fn clear(&mut self) {
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HudText {
        static instance: CCSUsrMsg_HudText = CCSUsrMsg_HudText {
            text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_HudMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HudMsg {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.pos)
    pub pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector2D>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.clr1)
    pub clr1: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.clr2)
    pub clr2: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.effect)
    pub effect: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fade_in_time)
    pub fade_in_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fade_out_time)
    pub fade_out_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.hold_time)
    pub hold_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.fx_time)
    pub fx_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_HudMsg.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HudMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HudMsg {
    fn default() -> &'a CCSUsrMsg_HudMsg {
        <CCSUsrMsg_HudMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HudMsg {
    pub fn new() -> CCSUsrMsg_HudMsg {
        ::std::default::Default::default()
    }

    // optional int32 channel = 1;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional int32 effect = 5;

    pub fn effect(&self) -> i32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: i32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional float fade_in_time = 6;

    pub fn fade_in_time(&self) -> f32 {
        self.fade_in_time.unwrap_or(0.)
    }

    pub fn clear_fade_in_time(&mut self) {
        self.fade_in_time = ::std::option::Option::None;
    }

    pub fn has_fade_in_time(&self) -> bool {
        self.fade_in_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_in_time(&mut self, v: f32) {
        self.fade_in_time = ::std::option::Option::Some(v);
    }

    // optional float fade_out_time = 7;

    pub fn fade_out_time(&self) -> f32 {
        self.fade_out_time.unwrap_or(0.)
    }

    pub fn clear_fade_out_time(&mut self) {
        self.fade_out_time = ::std::option::Option::None;
    }

    pub fn has_fade_out_time(&self) -> bool {
        self.fade_out_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fade_out_time(&mut self, v: f32) {
        self.fade_out_time = ::std::option::Option::Some(v);
    }

    // optional float hold_time = 9;

    pub fn hold_time(&self) -> f32 {
        self.hold_time.unwrap_or(0.)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: f32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional float fx_time = 10;

    pub fn fx_time(&self) -> f32 {
        self.fx_time.unwrap_or(0.)
    }

    pub fn clear_fx_time(&mut self) {
        self.fx_time = ::std::option::Option::None;
    }

    pub fn has_fx_time(&self) -> bool {
        self.fx_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fx_time(&mut self, v: f32) {
        self.fx_time = ::std::option::Option::Some(v);
    }

    // optional string text = 11;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_HudMsg {
    const NAME: &'static str = "CCSUsrMsg_HudMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.pos)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.clr1)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.clr2)?;
                },
                40 => {
                    self.effect = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.fade_in_time = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.fade_out_time = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.hold_time = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.fx_time = ::std::option::Option::Some(is.read_float()?);
                },
                90 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clr2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.effect {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.fade_in_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fade_out_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hold_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.fx_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.clr1.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.clr2.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.effect {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.fade_in_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.fade_out_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.fx_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HudMsg {
        CCSUsrMsg_HudMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.pos.clear();
        self.clr1.clear();
        self.clr2.clear();
        self.effect = ::std::option::Option::None;
        self.fade_in_time = ::std::option::Option::None;
        self.fade_out_time = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.fx_time = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HudMsg {
        static instance: CCSUsrMsg_HudMsg = CCSUsrMsg_HudMsg {
            channel: ::std::option::Option::None,
            pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clr1: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clr2: ::steam_vent_proto_common::protobuf::MessageField::none(),
            effect: ::std::option::Option::None,
            fade_in_time: ::std::option::Option::None,
            fade_out_time: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            fx_time: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Shake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Shake {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.command)
    pub command: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.local_amplitude)
    pub local_amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Shake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Shake.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Shake {
    fn default() -> &'a CCSUsrMsg_Shake {
        <CCSUsrMsg_Shake as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Shake {
    pub fn new() -> CCSUsrMsg_Shake {
        ::std::default::Default::default()
    }

    // optional int32 command = 1;

    pub fn command(&self) -> i32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: i32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float local_amplitude = 2;

    pub fn local_amplitude(&self) -> f32 {
        self.local_amplitude.unwrap_or(0.)
    }

    pub fn clear_local_amplitude(&mut self) {
        self.local_amplitude = ::std::option::Option::None;
    }

    pub fn has_local_amplitude(&self) -> bool {
        self.local_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_amplitude(&mut self, v: f32) {
        self.local_amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Shake {
    const NAME: &'static str = "CCSUsrMsg_Shake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.local_amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.local_amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.local_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Shake {
        CCSUsrMsg_Shake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.local_amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Shake {
        static instance: CCSUsrMsg_Shake = CCSUsrMsg_Shake {
            command: ::std::option::Option::None,
            local_amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Fade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Fade {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.hold_time)
    pub hold_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.flags)
    pub flags: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Fade.clr)
    pub clr: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgRGBA>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Fade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Fade {
    fn default() -> &'a CCSUsrMsg_Fade {
        <CCSUsrMsg_Fade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Fade {
    pub fn new() -> CCSUsrMsg_Fade {
        ::std::default::Default::default()
    }

    // optional int32 duration = 1;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hold_time = 2;

    pub fn hold_time(&self) -> i32 {
        self.hold_time.unwrap_or(0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: i32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Fade {
    const NAME: &'static str = "CCSUsrMsg_Fade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.hold_time = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.clr)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.hold_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.clr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.clr.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Fade {
        CCSUsrMsg_Fade::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.clr.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Fade {
        static instance: CCSUsrMsg_Fade = CCSUsrMsg_Fade {
            duration: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            clr: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Rumble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Rumble {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.data)
    pub data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Rumble.flags)
    pub flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Rumble.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Rumble {
    fn default() -> &'a CCSUsrMsg_Rumble {
        <CCSUsrMsg_Rumble as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Rumble {
    pub fn new() -> CCSUsrMsg_Rumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Rumble {
    const NAME: &'static str = "CCSUsrMsg_Rumble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Rumble {
        CCSUsrMsg_Rumble::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Rumble {
        static instance: CCSUsrMsg_Rumble = CCSUsrMsg_Rumble {
            index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_CloseCaption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CloseCaption {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaption.cctoken)
    pub cctoken: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CloseCaption.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaption {
    fn default() -> &'a CCSUsrMsg_CloseCaption {
        <CCSUsrMsg_CloseCaption as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaption {
    pub fn new() -> CCSUsrMsg_CloseCaption {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional string cctoken = 4;

    pub fn cctoken(&self) -> &str {
        match self.cctoken.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_cctoken(&mut self) {
        self.cctoken = ::std::option::Option::None;
    }

    pub fn has_cctoken(&self) -> bool {
        self.cctoken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cctoken(&mut self, v: ::std::string::String) {
        self.cctoken = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cctoken(&mut self) -> &mut ::std::string::String {
        if self.cctoken.is_none() {
            self.cctoken = ::std::option::Option::Some(::std::string::String::new());
        }
        self.cctoken.as_mut().unwrap()
    }

    // Take field
    pub fn take_cctoken(&mut self) -> ::std::string::String {
        self.cctoken.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_CloseCaption {
    const NAME: &'static str = "CCSUsrMsg_CloseCaption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.cctoken = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.cctoken.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.cctoken.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CloseCaption {
        CCSUsrMsg_CloseCaption::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.cctoken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaption {
        static instance: CCSUsrMsg_CloseCaption = CCSUsrMsg_CloseCaption {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            cctoken: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_CloseCaptionDirect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CloseCaptionDirect {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.duration)
    pub duration: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CloseCaptionDirect.from_player)
    pub from_player: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CloseCaptionDirect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CloseCaptionDirect {
    fn default() -> &'a CCSUsrMsg_CloseCaptionDirect {
        <CCSUsrMsg_CloseCaptionDirect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CloseCaptionDirect {
    pub fn new() -> CCSUsrMsg_CloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional uint32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional int32 duration = 2;

    pub fn duration(&self) -> i32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_CloseCaptionDirect {
    const NAME: &'static str = "CCSUsrMsg_CloseCaptionDirect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CloseCaptionDirect {
        CCSUsrMsg_CloseCaptionDirect::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CloseCaptionDirect {
        static instance: CCSUsrMsg_CloseCaptionDirect = CCSUsrMsg_CloseCaptionDirect {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendAudio {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendAudio.radio_sound)
    pub radio_sound: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendAudio.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendAudio {
    fn default() -> &'a CCSUsrMsg_SendAudio {
        <CCSUsrMsg_SendAudio as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendAudio {
    pub fn new() -> CCSUsrMsg_SendAudio {
        ::std::default::Default::default()
    }

    // optional string radio_sound = 1;

    pub fn radio_sound(&self) -> &str {
        match self.radio_sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_radio_sound(&mut self) {
        self.radio_sound = ::std::option::Option::None;
    }

    pub fn has_radio_sound(&self) -> bool {
        self.radio_sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radio_sound(&mut self, v: ::std::string::String) {
        self.radio_sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_radio_sound(&mut self) -> &mut ::std::string::String {
        if self.radio_sound.is_none() {
            self.radio_sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.radio_sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_radio_sound(&mut self) -> ::std::string::String {
        self.radio_sound.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SendAudio {
    const NAME: &'static str = "CCSUsrMsg_SendAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.radio_sound = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radio_sound.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.radio_sound.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendAudio {
        CCSUsrMsg_SendAudio::new()
    }

    fn clear(&mut self) {
        self.radio_sound = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendAudio {
        static instance: CCSUsrMsg_SendAudio = CCSUsrMsg_SendAudio {
            radio_sound: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RawAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RawAudio {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.pitch)
    pub pitch: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RawAudio.voice_filename)
    pub voice_filename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RawAudio.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RawAudio {
    fn default() -> &'a CCSUsrMsg_RawAudio {
        <CCSUsrMsg_RawAudio as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RawAudio {
    pub fn new() -> CCSUsrMsg_RawAudio {
        ::std::default::Default::default()
    }

    // optional int32 pitch = 1;

    pub fn pitch(&self) -> i32 {
        self.pitch.unwrap_or(0)
    }

    pub fn clear_pitch(&mut self) {
        self.pitch = ::std::option::Option::None;
    }

    pub fn has_pitch(&self) -> bool {
        self.pitch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pitch(&mut self, v: i32) {
        self.pitch = ::std::option::Option::Some(v);
    }

    // optional int32 entidx = 2;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional string voice_filename = 4;

    pub fn voice_filename(&self) -> &str {
        match self.voice_filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_voice_filename(&mut self) {
        self.voice_filename = ::std::option::Option::None;
    }

    pub fn has_voice_filename(&self) -> bool {
        self.voice_filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_filename(&mut self, v: ::std::string::String) {
        self.voice_filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voice_filename(&mut self) -> &mut ::std::string::String {
        if self.voice_filename.is_none() {
            self.voice_filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.voice_filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_voice_filename(&mut self) -> ::std::string::String {
        self.voice_filename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_RawAudio {
    const NAME: &'static str = "CCSUsrMsg_RawAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pitch = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                34 => {
                    self.voice_filename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pitch {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pitch {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.entidx {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.voice_filename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RawAudio {
        CCSUsrMsg_RawAudio::new()
    }

    fn clear(&mut self) {
        self.pitch = ::std::option::Option::None;
        self.entidx = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.voice_filename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RawAudio {
        static instance: CCSUsrMsg_RawAudio = CCSUsrMsg_RawAudio {
            pitch: ::std::option::Option::None,
            entidx: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            voice_filename: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoiceMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoiceMask {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.player_masks)
    pub player_masks: ::std::vec::Vec<ccsusr_msg_voice_mask::PlayerMask>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.player_mod_enable)
    pub player_mod_enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoiceMask.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoiceMask {
    fn default() -> &'a CCSUsrMsg_VoiceMask {
        <CCSUsrMsg_VoiceMask as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoiceMask {
    pub fn new() -> CCSUsrMsg_VoiceMask {
        ::std::default::Default::default()
    }

    // optional bool player_mod_enable = 2;

    pub fn player_mod_enable(&self) -> bool {
        self.player_mod_enable.unwrap_or(false)
    }

    pub fn clear_player_mod_enable(&mut self) {
        self.player_mod_enable = ::std::option::Option::None;
    }

    pub fn has_player_mod_enable(&self) -> bool {
        self.player_mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mod_enable(&mut self, v: bool) {
        self.player_mod_enable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VoiceMask {
    const NAME: &'static str = "CCSUsrMsg_VoiceMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_masks.push(is.read_message()?);
                },
                16 => {
                    self.player_mod_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_masks {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.player_mod_enable {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_masks {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.player_mod_enable {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoiceMask {
        CCSUsrMsg_VoiceMask::new()
    }

    fn clear(&mut self) {
        self.player_masks.clear();
        self.player_mod_enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoiceMask {
        static instance: CCSUsrMsg_VoiceMask = CCSUsrMsg_VoiceMask {
            player_masks: ::std::vec::Vec::new(),
            player_mod_enable: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_VoiceMask`
pub mod ccsusr_msg_voice_mask {
    // @@protoc_insertion_point(message:CCSUsrMsg_VoiceMask.PlayerMask)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerMask {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.PlayerMask.game_rules_mask)
        pub game_rules_mask: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_VoiceMask.PlayerMask.ban_masks)
        pub ban_masks: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_VoiceMask.PlayerMask.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerMask {
        fn default() -> &'a PlayerMask {
            <PlayerMask as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerMask {
        pub fn new() -> PlayerMask {
            ::std::default::Default::default()
        }

        // optional int32 game_rules_mask = 1;

        pub fn game_rules_mask(&self) -> i32 {
            self.game_rules_mask.unwrap_or(0)
        }

        pub fn clear_game_rules_mask(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
        }

        pub fn has_game_rules_mask(&self) -> bool {
            self.game_rules_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_rules_mask(&mut self, v: i32) {
            self.game_rules_mask = ::std::option::Option::Some(v);
        }

        // optional int32 ban_masks = 2;

        pub fn ban_masks(&self) -> i32 {
            self.ban_masks.unwrap_or(0)
        }

        pub fn clear_ban_masks(&mut self) {
            self.ban_masks = ::std::option::Option::None;
        }

        pub fn has_ban_masks(&self) -> bool {
            self.ban_masks.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_masks(&mut self, v: i32) {
            self.ban_masks = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerMask {
        const NAME: &'static str = "PlayerMask";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_rules_mask = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.ban_masks = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_rules_mask {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.ban_masks {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_rules_mask {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.ban_masks {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerMask {
            PlayerMask::new()
        }

        fn clear(&mut self) {
            self.game_rules_mask = ::std::option::Option::None;
            self.ban_masks = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerMask {
            static instance: PlayerMask = PlayerMask {
                game_rules_mask: ::std::option::Option::None,
                ban_masks: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_Damage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_Damage {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.inflictor_world_pos)
    pub inflictor_world_pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCSUsrMsg_Damage.victim_entindex)
    pub victim_entindex: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_Damage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_Damage {
    fn default() -> &'a CCSUsrMsg_Damage {
        <CCSUsrMsg_Damage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_Damage {
    pub fn new() -> CCSUsrMsg_Damage {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 victim_entindex = 3;

    pub fn victim_entindex(&self) -> i32 {
        self.victim_entindex.unwrap_or(-1i32)
    }

    pub fn clear_victim_entindex(&mut self) {
        self.victim_entindex = ::std::option::Option::None;
    }

    pub fn has_victim_entindex(&self) -> bool {
        self.victim_entindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_entindex(&mut self, v: i32) {
        self.victim_entindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_Damage {
    const NAME: &'static str = "CCSUsrMsg_Damage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.inflictor_world_pos)?;
                },
                24 => {
                    self.victim_entindex = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.victim_entindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.inflictor_world_pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.victim_entindex {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_Damage {
        CCSUsrMsg_Damage::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.inflictor_world_pos.clear();
        self.victim_entindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_Damage {
        static instance: CCSUsrMsg_Damage = CCSUsrMsg_Damage {
            amount: ::std::option::Option::None,
            inflictor_world_pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            victim_entindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RadioText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RadioText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.msg_dst)
    pub msg_dst: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.client)
    pub client: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.msg_name)
    pub msg_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RadioText.params)
    pub params: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RadioText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RadioText {
    fn default() -> &'a CCSUsrMsg_RadioText {
        <CCSUsrMsg_RadioText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RadioText {
    pub fn new() -> CCSUsrMsg_RadioText {
        ::std::default::Default::default()
    }

    // optional int32 msg_dst = 1;

    pub fn msg_dst(&self) -> i32 {
        self.msg_dst.unwrap_or(0)
    }

    pub fn clear_msg_dst(&mut self) {
        self.msg_dst = ::std::option::Option::None;
    }

    pub fn has_msg_dst(&self) -> bool {
        self.msg_dst.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_dst(&mut self, v: i32) {
        self.msg_dst = ::std::option::Option::Some(v);
    }

    // optional int32 client = 2;

    pub fn client(&self) -> i32 {
        self.client.unwrap_or(-1i32)
    }

    pub fn clear_client(&mut self) {
        self.client = ::std::option::Option::None;
    }

    pub fn has_client(&self) -> bool {
        self.client.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client(&mut self, v: i32) {
        self.client = ::std::option::Option::Some(v);
    }

    // optional string msg_name = 3;

    pub fn msg_name(&self) -> &str {
        match self.msg_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg_name(&mut self) {
        self.msg_name = ::std::option::Option::None;
    }

    pub fn has_msg_name(&self) -> bool {
        self.msg_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg_name(&mut self, v: ::std::string::String) {
        self.msg_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg_name(&mut self) -> &mut ::std::string::String {
        if self.msg_name.is_none() {
            self.msg_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg_name(&mut self) -> ::std::string::String {
        self.msg_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_RadioText {
    const NAME: &'static str = "CCSUsrMsg_RadioText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.msg_dst = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.client = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.msg_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.params.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg_dst {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.client {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.msg_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        for value in &self.params {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg_dst {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.client {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.msg_name.as_ref() {
            os.write_string(3, v)?;
        }
        for v in &self.params {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RadioText {
        CCSUsrMsg_RadioText::new()
    }

    fn clear(&mut self) {
        self.msg_dst = ::std::option::Option::None;
        self.client = ::std::option::Option::None;
        self.msg_name = ::std::option::Option::None;
        self.params.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RadioText {
        static instance: CCSUsrMsg_RadioText = CCSUsrMsg_RadioText {
            msg_dst: ::std::option::Option::None,
            client: ::std::option::Option::None,
            msg_name: ::std::option::Option::None,
            params: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_HintText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_HintText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_HintText.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_HintText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_HintText {
    fn default() -> &'a CCSUsrMsg_HintText {
        <CCSUsrMsg_HintText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_HintText {
    pub fn new() -> CCSUsrMsg_HintText {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_HintText {
    const NAME: &'static str = "CCSUsrMsg_HintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_HintText {
        CCSUsrMsg_HintText::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_HintText {
        static instance: CCSUsrMsg_HintText = CCSUsrMsg_HintText {
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_KeyHintText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_KeyHintText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_KeyHintText.messages)
    pub messages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_KeyHintText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KeyHintText {
    fn default() -> &'a CCSUsrMsg_KeyHintText {
        <CCSUsrMsg_KeyHintText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KeyHintText {
    pub fn new() -> CCSUsrMsg_KeyHintText {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_KeyHintText {
    const NAME: &'static str = "CCSUsrMsg_KeyHintText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.messages.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.messages {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.messages {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_KeyHintText {
        CCSUsrMsg_KeyHintText::new()
    }

    fn clear(&mut self) {
        self.messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_KeyHintText {
        static instance: CCSUsrMsg_KeyHintText = CCSUsrMsg_KeyHintText {
            messages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ProcessSpottedEntityUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ProcessSpottedEntityUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.new_update)
    pub new_update: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.entity_updates)
    pub entity_updates: ::std::vec::Vec<ccsusr_msg_process_spotted_entity_update::SpottedEntityUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ProcessSpottedEntityUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn default() -> &'a CCSUsrMsg_ProcessSpottedEntityUpdate {
        <CCSUsrMsg_ProcessSpottedEntityUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ProcessSpottedEntityUpdate {
    pub fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        ::std::default::Default::default()
    }

    // optional bool new_update = 1;

    pub fn new_update(&self) -> bool {
        self.new_update.unwrap_or(false)
    }

    pub fn clear_new_update(&mut self) {
        self.new_update = ::std::option::Option::None;
    }

    pub fn has_new_update(&self) -> bool {
        self.new_update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_update(&mut self, v: bool) {
        self.new_update = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ProcessSpottedEntityUpdate {
    const NAME: &'static str = "CCSUsrMsg_ProcessSpottedEntityUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_update = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_update {
            my_size += 1 + 1;
        }
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.new_update {
            os.write_bool(1, v)?;
        }
        for v in &self.entity_updates {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ProcessSpottedEntityUpdate {
        CCSUsrMsg_ProcessSpottedEntityUpdate::new()
    }

    fn clear(&mut self) {
        self.new_update = ::std::option::Option::None;
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ProcessSpottedEntityUpdate {
        static instance: CCSUsrMsg_ProcessSpottedEntityUpdate = CCSUsrMsg_ProcessSpottedEntityUpdate {
            new_update: ::std::option::Option::None,
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_ProcessSpottedEntityUpdate`
pub mod ccsusr_msg_process_spotted_entity_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpottedEntityUpdate {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.entity_idx)
        pub entity_idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.class_id)
        pub class_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_x)
        pub origin_x: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_y)
        pub origin_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.origin_z)
        pub origin_z: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.angle_y)
        pub angle_y: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.defuser)
        pub defuser: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_defuser)
        pub player_has_defuser: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.player_has_c4)
        pub player_has_c4: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpottedEntityUpdate {
        fn default() -> &'a SpottedEntityUpdate {
            <SpottedEntityUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SpottedEntityUpdate {
        pub fn new() -> SpottedEntityUpdate {
            ::std::default::Default::default()
        }

        // optional int32 entity_idx = 1;

        pub fn entity_idx(&self) -> i32 {
            self.entity_idx.unwrap_or(-1i32)
        }

        pub fn clear_entity_idx(&mut self) {
            self.entity_idx = ::std::option::Option::None;
        }

        pub fn has_entity_idx(&self) -> bool {
            self.entity_idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_idx(&mut self, v: i32) {
            self.entity_idx = ::std::option::Option::Some(v);
        }

        // optional int32 class_id = 2;

        pub fn class_id(&self) -> i32 {
            self.class_id.unwrap_or(0)
        }

        pub fn clear_class_id(&mut self) {
            self.class_id = ::std::option::Option::None;
        }

        pub fn has_class_id(&self) -> bool {
            self.class_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_class_id(&mut self, v: i32) {
            self.class_id = ::std::option::Option::Some(v);
        }

        // optional int32 origin_x = 3;

        pub fn origin_x(&self) -> i32 {
            self.origin_x.unwrap_or(0)
        }

        pub fn clear_origin_x(&mut self) {
            self.origin_x = ::std::option::Option::None;
        }

        pub fn has_origin_x(&self) -> bool {
            self.origin_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_x(&mut self, v: i32) {
            self.origin_x = ::std::option::Option::Some(v);
        }

        // optional int32 origin_y = 4;

        pub fn origin_y(&self) -> i32 {
            self.origin_y.unwrap_or(0)
        }

        pub fn clear_origin_y(&mut self) {
            self.origin_y = ::std::option::Option::None;
        }

        pub fn has_origin_y(&self) -> bool {
            self.origin_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_y(&mut self, v: i32) {
            self.origin_y = ::std::option::Option::Some(v);
        }

        // optional int32 origin_z = 5;

        pub fn origin_z(&self) -> i32 {
            self.origin_z.unwrap_or(0)
        }

        pub fn clear_origin_z(&mut self) {
            self.origin_z = ::std::option::Option::None;
        }

        pub fn has_origin_z(&self) -> bool {
            self.origin_z.is_some()
        }

        // Param is passed by value, moved
        pub fn set_origin_z(&mut self, v: i32) {
            self.origin_z = ::std::option::Option::Some(v);
        }

        // optional int32 angle_y = 6;

        pub fn angle_y(&self) -> i32 {
            self.angle_y.unwrap_or(0)
        }

        pub fn clear_angle_y(&mut self) {
            self.angle_y = ::std::option::Option::None;
        }

        pub fn has_angle_y(&self) -> bool {
            self.angle_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_angle_y(&mut self, v: i32) {
            self.angle_y = ::std::option::Option::Some(v);
        }

        // optional bool defuser = 7;

        pub fn defuser(&self) -> bool {
            self.defuser.unwrap_or(false)
        }

        pub fn clear_defuser(&mut self) {
            self.defuser = ::std::option::Option::None;
        }

        pub fn has_defuser(&self) -> bool {
            self.defuser.is_some()
        }

        // Param is passed by value, moved
        pub fn set_defuser(&mut self, v: bool) {
            self.defuser = ::std::option::Option::Some(v);
        }

        // optional bool player_has_defuser = 8;

        pub fn player_has_defuser(&self) -> bool {
            self.player_has_defuser.unwrap_or(false)
        }

        pub fn clear_player_has_defuser(&mut self) {
            self.player_has_defuser = ::std::option::Option::None;
        }

        pub fn has_player_has_defuser(&self) -> bool {
            self.player_has_defuser.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_defuser(&mut self, v: bool) {
            self.player_has_defuser = ::std::option::Option::Some(v);
        }

        // optional bool player_has_c4 = 9;

        pub fn player_has_c4(&self) -> bool {
            self.player_has_c4.unwrap_or(false)
        }

        pub fn clear_player_has_c4(&mut self) {
            self.player_has_c4 = ::std::option::Option::None;
        }

        pub fn has_player_has_c4(&self) -> bool {
            self.player_has_c4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_has_c4(&mut self, v: bool) {
            self.player_has_c4 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SpottedEntityUpdate {
        const NAME: &'static str = "SpottedEntityUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.class_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.origin_x = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.origin_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.origin_z = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.angle_y = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.defuser = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.player_has_defuser = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.player_has_c4 = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_idx {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.class_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.origin_x {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.origin_y {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.origin_z {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.angle_y {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.defuser {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_defuser {
                my_size += 1 + 1;
            }
            if let Some(v) = self.player_has_c4 {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.entity_idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.class_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.origin_x {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.origin_y {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.origin_z {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.angle_y {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.defuser {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.player_has_defuser {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.player_has_c4 {
                os.write_bool(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpottedEntityUpdate {
            SpottedEntityUpdate::new()
        }

        fn clear(&mut self) {
            self.entity_idx = ::std::option::Option::None;
            self.class_id = ::std::option::Option::None;
            self.origin_x = ::std::option::Option::None;
            self.origin_y = ::std::option::Option::None;
            self.origin_z = ::std::option::Option::None;
            self.angle_y = ::std::option::Option::None;
            self.defuser = ::std::option::Option::None;
            self.player_has_defuser = ::std::option::Option::None;
            self.player_has_c4 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpottedEntityUpdate {
            static instance: SpottedEntityUpdate = SpottedEntityUpdate {
                entity_idx: ::std::option::Option::None,
                class_id: ::std::option::Option::None,
                origin_x: ::std::option::Option::None,
                origin_y: ::std::option::Option::None,
                origin_z: ::std::option::Option::None,
                angle_y: ::std::option::Option::None,
                defuser: ::std::option::Option::None,
                player_has_defuser: ::std::option::Option::None,
                player_has_c4: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendPlayerItemDrops)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendPlayerItemDrops {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemDrops.entity_updates)
    pub entity_updates: ::std::vec::Vec<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendPlayerItemDrops.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemDrops {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemDrops {
        <CCSUsrMsg_SendPlayerItemDrops as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemDrops {
    pub fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SendPlayerItemDrops {
    const NAME: &'static str = "CCSUsrMsg_SendPlayerItemDrops";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_updates.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.entity_updates {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.entity_updates {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendPlayerItemDrops {
        CCSUsrMsg_SendPlayerItemDrops::new()
    }

    fn clear(&mut self) {
        self.entity_updates.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemDrops {
        static instance: CCSUsrMsg_SendPlayerItemDrops = CCSUsrMsg_SendPlayerItemDrops {
            entity_updates: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendPlayerItemFound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendPlayerItemFound {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemFound.iteminfo)
    pub iteminfo: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendPlayerItemFound.playerslot)
    pub playerslot: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendPlayerItemFound.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendPlayerItemFound {
    fn default() -> &'a CCSUsrMsg_SendPlayerItemFound {
        <CCSUsrMsg_SendPlayerItemFound as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendPlayerItemFound {
    pub fn new() -> CCSUsrMsg_SendPlayerItemFound {
        ::std::default::Default::default()
    }

    // optional int32 playerslot = 2;

    pub fn playerslot(&self) -> i32 {
        self.playerslot.unwrap_or(-1i32)
    }

    pub fn clear_playerslot(&mut self) {
        self.playerslot = ::std::option::Option::None;
    }

    pub fn has_playerslot(&self) -> bool {
        self.playerslot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerslot(&mut self, v: i32) {
        self.playerslot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SendPlayerItemFound {
    const NAME: &'static str = "CCSUsrMsg_SendPlayerItemFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                16 => {
                    self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.playerslot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.playerslot {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendPlayerItemFound {
        CCSUsrMsg_SendPlayerItemFound::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.playerslot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendPlayerItemFound {
        static instance: CCSUsrMsg_SendPlayerItemFound = CCSUsrMsg_SendPlayerItemFound {
            iteminfo: ::steam_vent_proto_common::protobuf::MessageField::none(),
            playerslot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ReloadEffect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ReloadEffect {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.actanim)
    pub actanim: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReloadEffect.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ReloadEffect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReloadEffect {
    fn default() -> &'a CCSUsrMsg_ReloadEffect {
        <CCSUsrMsg_ReloadEffect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReloadEffect {
    pub fn new() -> CCSUsrMsg_ReloadEffect {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional int32 actanim = 2;

    pub fn actanim(&self) -> i32 {
        self.actanim.unwrap_or(0)
    }

    pub fn clear_actanim(&mut self) {
        self.actanim = ::std::option::Option::None;
    }

    pub fn has_actanim(&self) -> bool {
        self.actanim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actanim(&mut self, v: i32) {
        self.actanim = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 3;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 4;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 5;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ReloadEffect {
    const NAME: &'static str = "CCSUsrMsg_ReloadEffect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.actanim = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.actanim {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.actanim {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ReloadEffect {
        CCSUsrMsg_ReloadEffect::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.actanim = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ReloadEffect {
        static instance: CCSUsrMsg_ReloadEffect = CCSUsrMsg_ReloadEffect {
            entidx: ::std::option::Option::None,
            actanim: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_WeaponSound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_WeaponSound {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_x)
    pub origin_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_y)
    pub origin_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.origin_z)
    pub origin_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.sound)
    pub sound: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.game_timestamp)
    pub game_timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_WeaponSound.source_soundscapeid)
    pub source_soundscapeid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_WeaponSound.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WeaponSound {
    fn default() -> &'a CCSUsrMsg_WeaponSound {
        <CCSUsrMsg_WeaponSound as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WeaponSound {
    pub fn new() -> CCSUsrMsg_WeaponSound {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float origin_x = 2;

    pub fn origin_x(&self) -> f32 {
        self.origin_x.unwrap_or(0.)
    }

    pub fn clear_origin_x(&mut self) {
        self.origin_x = ::std::option::Option::None;
    }

    pub fn has_origin_x(&self) -> bool {
        self.origin_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_x(&mut self, v: f32) {
        self.origin_x = ::std::option::Option::Some(v);
    }

    // optional float origin_y = 3;

    pub fn origin_y(&self) -> f32 {
        self.origin_y.unwrap_or(0.)
    }

    pub fn clear_origin_y(&mut self) {
        self.origin_y = ::std::option::Option::None;
    }

    pub fn has_origin_y(&self) -> bool {
        self.origin_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_y(&mut self, v: f32) {
        self.origin_y = ::std::option::Option::Some(v);
    }

    // optional float origin_z = 4;

    pub fn origin_z(&self) -> f32 {
        self.origin_z.unwrap_or(0.)
    }

    pub fn clear_origin_z(&mut self) {
        self.origin_z = ::std::option::Option::None;
    }

    pub fn has_origin_z(&self) -> bool {
        self.origin_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin_z(&mut self, v: f32) {
        self.origin_z = ::std::option::Option::Some(v);
    }

    // optional string sound = 5;

    pub fn sound(&self) -> &str {
        match self.sound.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sound(&mut self) {
        self.sound = ::std::option::Option::None;
    }

    pub fn has_sound(&self) -> bool {
        self.sound.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sound(&mut self, v: ::std::string::String) {
        self.sound = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sound(&mut self) -> &mut ::std::string::String {
        if self.sound.is_none() {
            self.sound = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sound.as_mut().unwrap()
    }

    // Take field
    pub fn take_sound(&mut self) -> ::std::string::String {
        self.sound.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float game_timestamp = 6;

    pub fn game_timestamp(&self) -> f32 {
        self.game_timestamp.unwrap_or(0.)
    }

    pub fn clear_game_timestamp(&mut self) {
        self.game_timestamp = ::std::option::Option::None;
    }

    pub fn has_game_timestamp(&self) -> bool {
        self.game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_timestamp(&mut self, v: f32) {
        self.game_timestamp = ::std::option::Option::Some(v);
    }

    // optional fixed32 source_soundscapeid = 7;

    pub fn source_soundscapeid(&self) -> u32 {
        self.source_soundscapeid.unwrap_or(0)
    }

    pub fn clear_source_soundscapeid(&mut self) {
        self.source_soundscapeid = ::std::option::Option::None;
    }

    pub fn has_source_soundscapeid(&self) -> bool {
        self.source_soundscapeid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_soundscapeid(&mut self, v: u32) {
        self.source_soundscapeid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_WeaponSound {
    const NAME: &'static str = "CCSUsrMsg_WeaponSound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.origin_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.origin_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.origin_z = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.sound = ::std::option::Option::Some(is.read_string()?);
                },
                53 => {
                    self.game_timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.source_soundscapeid = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.origin_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.origin_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.sound.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.source_soundscapeid {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.origin_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.origin_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.origin_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.sound.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_timestamp {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.source_soundscapeid {
            os.write_fixed32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_WeaponSound {
        CCSUsrMsg_WeaponSound::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.origin_x = ::std::option::Option::None;
        self.origin_y = ::std::option::Option::None;
        self.origin_z = ::std::option::Option::None;
        self.sound = ::std::option::Option::None;
        self.game_timestamp = ::std::option::Option::None;
        self.source_soundscapeid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_WeaponSound {
        static instance: CCSUsrMsg_WeaponSound = CCSUsrMsg_WeaponSound {
            entidx: ::std::option::Option::None,
            origin_x: ::std::option::Option::None,
            origin_y: ::std::option::Option::None,
            origin_z: ::std::option::Option::None,
            sound: ::std::option::Option::None,
            game_timestamp: ::std::option::Option::None,
            source_soundscapeid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_UpdateScreenHealthBar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_UpdateScreenHealthBar {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.healthratio_old)
    pub healthratio_old: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.healthratio_new)
    pub healthratio_new: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_UpdateScreenHealthBar.style)
    pub style: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_UpdateScreenHealthBar.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_UpdateScreenHealthBar {
    fn default() -> &'a CCSUsrMsg_UpdateScreenHealthBar {
        <CCSUsrMsg_UpdateScreenHealthBar as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_UpdateScreenHealthBar {
    pub fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional float healthratio_old = 2;

    pub fn healthratio_old(&self) -> f32 {
        self.healthratio_old.unwrap_or(0.)
    }

    pub fn clear_healthratio_old(&mut self) {
        self.healthratio_old = ::std::option::Option::None;
    }

    pub fn has_healthratio_old(&self) -> bool {
        self.healthratio_old.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_old(&mut self, v: f32) {
        self.healthratio_old = ::std::option::Option::Some(v);
    }

    // optional float healthratio_new = 3;

    pub fn healthratio_new(&self) -> f32 {
        self.healthratio_new.unwrap_or(0.)
    }

    pub fn clear_healthratio_new(&mut self) {
        self.healthratio_new = ::std::option::Option::None;
    }

    pub fn has_healthratio_new(&self) -> bool {
        self.healthratio_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthratio_new(&mut self, v: f32) {
        self.healthratio_new = ::std::option::Option::Some(v);
    }

    // optional int32 style = 4;

    pub fn style(&self) -> i32 {
        self.style.unwrap_or(0)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: i32) {
        self.style = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_UpdateScreenHealthBar {
    const NAME: &'static str = "CCSUsrMsg_UpdateScreenHealthBar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.healthratio_old = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.healthratio_new = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.style = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.healthratio_old {
            my_size += 1 + 4;
        }
        if let Some(v) = self.healthratio_new {
            my_size += 1 + 4;
        }
        if let Some(v) = self.style {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.healthratio_old {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.healthratio_new {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.style {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_UpdateScreenHealthBar {
        CCSUsrMsg_UpdateScreenHealthBar::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.healthratio_old = ::std::option::Option::None;
        self.healthratio_new = ::std::option::Option::None;
        self.style = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_UpdateScreenHealthBar {
        static instance: CCSUsrMsg_UpdateScreenHealthBar = CCSUsrMsg_UpdateScreenHealthBar {
            entidx: ::std::option::Option::None,
            healthratio_old: ::std::option::Option::None,
            healthratio_new: ::std::option::Option::None,
            style: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_EntityOutlineHighlight)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_EntityOutlineHighlight {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_EntityOutlineHighlight.entidx)
    pub entidx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_EntityOutlineHighlight.removehighlight)
    pub removehighlight: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_EntityOutlineHighlight.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EntityOutlineHighlight {
    fn default() -> &'a CCSUsrMsg_EntityOutlineHighlight {
        <CCSUsrMsg_EntityOutlineHighlight as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EntityOutlineHighlight {
    pub fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }

    // optional bool removehighlight = 2;

    pub fn removehighlight(&self) -> bool {
        self.removehighlight.unwrap_or(false)
    }

    pub fn clear_removehighlight(&mut self) {
        self.removehighlight = ::std::option::Option::None;
    }

    pub fn has_removehighlight(&self) -> bool {
        self.removehighlight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_removehighlight(&mut self, v: bool) {
        self.removehighlight = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_EntityOutlineHighlight {
    const NAME: &'static str = "CCSUsrMsg_EntityOutlineHighlight";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.removehighlight = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.removehighlight {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.removehighlight {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_EntityOutlineHighlight {
        CCSUsrMsg_EntityOutlineHighlight::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.removehighlight = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_EntityOutlineHighlight {
        static instance: CCSUsrMsg_EntityOutlineHighlight = CCSUsrMsg_EntityOutlineHighlight {
            entidx: ::std::option::Option::None,
            removehighlight: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_AdjustMoney)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AdjustMoney {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AdjustMoney.amount)
    pub amount: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AdjustMoney.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AdjustMoney {
    fn default() -> &'a CCSUsrMsg_AdjustMoney {
        <CCSUsrMsg_AdjustMoney as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AdjustMoney {
    pub fn new() -> CCSUsrMsg_AdjustMoney {
        ::std::default::Default::default()
    }

    // optional int32 amount = 1;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_AdjustMoney {
    const NAME: &'static str = "CCSUsrMsg_AdjustMoney";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.amount {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AdjustMoney {
        CCSUsrMsg_AdjustMoney::new()
    }

    fn clear(&mut self) {
        self.amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AdjustMoney {
        static instance: CCSUsrMsg_AdjustMoney = CCSUsrMsg_AdjustMoney {
            amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ReportHit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ReportHit {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.timestamp)
    pub timestamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ReportHit.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ReportHit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ReportHit {
    fn default() -> &'a CCSUsrMsg_ReportHit {
        <CCSUsrMsg_ReportHit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ReportHit {
    pub fn new() -> CCSUsrMsg_ReportHit {
        ::std::default::Default::default()
    }

    // optional float pos_x = 1;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 2;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float timestamp = 4;

    pub fn timestamp(&self) -> f32 {
        self.timestamp.unwrap_or(0.)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: f32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 3;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ReportHit {
    const NAME: &'static str = "CCSUsrMsg_ReportHit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.timestamp = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pos_x {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ReportHit {
        CCSUsrMsg_ReportHit::new()
    }

    fn clear(&mut self) {
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ReportHit {
        static instance: CCSUsrMsg_ReportHit = CCSUsrMsg_ReportHit {
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_KillCam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_KillCam {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.obs_mode)
    pub obs_mode: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.first_target)
    pub first_target: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_KillCam.second_target)
    pub second_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_KillCam.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_KillCam {
    fn default() -> &'a CCSUsrMsg_KillCam {
        <CCSUsrMsg_KillCam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_KillCam {
    pub fn new() -> CCSUsrMsg_KillCam {
        ::std::default::Default::default()
    }

    // optional int32 obs_mode = 1;

    pub fn obs_mode(&self) -> i32 {
        self.obs_mode.unwrap_or(0)
    }

    pub fn clear_obs_mode(&mut self) {
        self.obs_mode = ::std::option::Option::None;
    }

    pub fn has_obs_mode(&self) -> bool {
        self.obs_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_obs_mode(&mut self, v: i32) {
        self.obs_mode = ::std::option::Option::Some(v);
    }

    // optional int32 first_target = 2;

    pub fn first_target(&self) -> i32 {
        self.first_target.unwrap_or(-1i32)
    }

    pub fn clear_first_target(&mut self) {
        self.first_target = ::std::option::Option::None;
    }

    pub fn has_first_target(&self) -> bool {
        self.first_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_target(&mut self, v: i32) {
        self.first_target = ::std::option::Option::Some(v);
    }

    // optional int32 second_target = 3;

    pub fn second_target(&self) -> i32 {
        self.second_target.unwrap_or(-1i32)
    }

    pub fn clear_second_target(&mut self) {
        self.second_target = ::std::option::Option::None;
    }

    pub fn has_second_target(&self) -> bool {
        self.second_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_second_target(&mut self, v: i32) {
        self.second_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_KillCam {
    const NAME: &'static str = "CCSUsrMsg_KillCam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.obs_mode = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.first_target = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.second_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.obs_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.first_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.second_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.obs_mode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.first_target {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.second_target {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_KillCam {
        CCSUsrMsg_KillCam::new()
    }

    fn clear(&mut self) {
        self.obs_mode = ::std::option::Option::None;
        self.first_target = ::std::option::Option::None;
        self.second_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_KillCam {
        static instance: CCSUsrMsg_KillCam = CCSUsrMsg_KillCam {
            obs_mode: ::std::option::Option::None,
            first_target: ::std::option::Option::None,
            second_target: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_DesiredTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DesiredTimescale {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.desired_timescale)
    pub desired_timescale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.duration_realtime_sec)
    pub duration_realtime_sec: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.interpolator_type)
    pub interpolator_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_DesiredTimescale.start_blend_time)
    pub start_blend_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DesiredTimescale.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DesiredTimescale {
    fn default() -> &'a CCSUsrMsg_DesiredTimescale {
        <CCSUsrMsg_DesiredTimescale as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DesiredTimescale {
    pub fn new() -> CCSUsrMsg_DesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired_timescale = 1;

    pub fn desired_timescale(&self) -> f32 {
        self.desired_timescale.unwrap_or(0.)
    }

    pub fn clear_desired_timescale(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
    }

    pub fn has_desired_timescale(&self) -> bool {
        self.desired_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_timescale(&mut self, v: f32) {
        self.desired_timescale = ::std::option::Option::Some(v);
    }

    // optional float duration_realtime_sec = 2;

    pub fn duration_realtime_sec(&self) -> f32 {
        self.duration_realtime_sec.unwrap_or(0.)
    }

    pub fn clear_duration_realtime_sec(&mut self) {
        self.duration_realtime_sec = ::std::option::Option::None;
    }

    pub fn has_duration_realtime_sec(&self) -> bool {
        self.duration_realtime_sec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration_realtime_sec(&mut self, v: f32) {
        self.duration_realtime_sec = ::std::option::Option::Some(v);
    }

    // optional int32 interpolator_type = 3;

    pub fn interpolator_type(&self) -> i32 {
        self.interpolator_type.unwrap_or(0)
    }

    pub fn clear_interpolator_type(&mut self) {
        self.interpolator_type = ::std::option::Option::None;
    }

    pub fn has_interpolator_type(&self) -> bool {
        self.interpolator_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_interpolator_type(&mut self, v: i32) {
        self.interpolator_type = ::std::option::Option::Some(v);
    }

    // optional float start_blend_time = 4;

    pub fn start_blend_time(&self) -> f32 {
        self.start_blend_time.unwrap_or(0.)
    }

    pub fn clear_start_blend_time(&mut self) {
        self.start_blend_time = ::std::option::Option::None;
    }

    pub fn has_start_blend_time(&self) -> bool {
        self.start_blend_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_blend_time(&mut self, v: f32) {
        self.start_blend_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_DesiredTimescale {
    const NAME: &'static str = "CCSUsrMsg_DesiredTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.desired_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.duration_realtime_sec = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.interpolator_type = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.start_blend_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.desired_timescale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration_realtime_sec {
            my_size += 1 + 4;
        }
        if let Some(v) = self.interpolator_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.start_blend_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.desired_timescale {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.duration_realtime_sec {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.interpolator_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_blend_time {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DesiredTimescale {
        CCSUsrMsg_DesiredTimescale::new()
    }

    fn clear(&mut self) {
        self.desired_timescale = ::std::option::Option::None;
        self.duration_realtime_sec = ::std::option::Option::None;
        self.interpolator_type = ::std::option::Option::None;
        self.start_blend_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DesiredTimescale {
        static instance: CCSUsrMsg_DesiredTimescale = CCSUsrMsg_DesiredTimescale {
            desired_timescale: ::std::option::Option::None,
            duration_realtime_sec: ::std::option::Option::None,
            interpolator_type: ::std::option::Option::None,
            start_blend_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_CurrentTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CurrentTimescale {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CurrentTimescale.cur_timescale)
    pub cur_timescale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CurrentTimescale.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentTimescale {
    fn default() -> &'a CCSUsrMsg_CurrentTimescale {
        <CCSUsrMsg_CurrentTimescale as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentTimescale {
    pub fn new() -> CCSUsrMsg_CurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float cur_timescale = 1;

    pub fn cur_timescale(&self) -> f32 {
        self.cur_timescale.unwrap_or(0.)
    }

    pub fn clear_cur_timescale(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
    }

    pub fn has_cur_timescale(&self) -> bool {
        self.cur_timescale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cur_timescale(&mut self, v: f32) {
        self.cur_timescale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_CurrentTimescale {
    const NAME: &'static str = "CCSUsrMsg_CurrentTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.cur_timescale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cur_timescale {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cur_timescale {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CurrentTimescale {
        CCSUsrMsg_CurrentTimescale::new()
    }

    fn clear(&mut self) {
        self.cur_timescale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentTimescale {
        static instance: CCSUsrMsg_CurrentTimescale = CCSUsrMsg_CurrentTimescale {
            cur_timescale: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_AchievementEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AchievementEvent {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.achievement)
    pub achievement: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_AchievementEvent.user_id)
    pub user_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AchievementEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AchievementEvent {
    fn default() -> &'a CCSUsrMsg_AchievementEvent {
        <CCSUsrMsg_AchievementEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AchievementEvent {
    pub fn new() -> CCSUsrMsg_AchievementEvent {
        ::std::default::Default::default()
    }

    // optional int32 achievement = 1;

    pub fn achievement(&self) -> i32 {
        self.achievement.unwrap_or(0)
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: i32) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // optional int32 count = 2;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 user_id = 3;

    pub fn user_id(&self) -> i32 {
        self.user_id.unwrap_or(0)
    }

    pub fn clear_user_id(&mut self) {
        self.user_id = ::std::option::Option::None;
    }

    pub fn has_user_id(&self) -> bool {
        self.user_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_id(&mut self, v: i32) {
        self.user_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_AchievementEvent {
    const NAME: &'static str = "CCSUsrMsg_AchievementEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.achievement = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.user_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.user_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.achievement {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.user_id {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AchievementEvent {
        CCSUsrMsg_AchievementEvent::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.user_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AchievementEvent {
        static instance: CCSUsrMsg_AchievementEvent = CCSUsrMsg_AchievementEvent {
            achievement: ::std::option::Option::None,
            count: ::std::option::Option::None,
            user_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_MatchEndConditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MatchEndConditions {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.fraglimit)
    pub fraglimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_maxrounds)
    pub mp_maxrounds: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_winlimit)
    pub mp_winlimit: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchEndConditions.mp_timelimit)
    pub mp_timelimit: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MatchEndConditions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchEndConditions {
    fn default() -> &'a CCSUsrMsg_MatchEndConditions {
        <CCSUsrMsg_MatchEndConditions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchEndConditions {
    pub fn new() -> CCSUsrMsg_MatchEndConditions {
        ::std::default::Default::default()
    }

    // optional int32 fraglimit = 1;

    pub fn fraglimit(&self) -> i32 {
        self.fraglimit.unwrap_or(0)
    }

    pub fn clear_fraglimit(&mut self) {
        self.fraglimit = ::std::option::Option::None;
    }

    pub fn has_fraglimit(&self) -> bool {
        self.fraglimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fraglimit(&mut self, v: i32) {
        self.fraglimit = ::std::option::Option::Some(v);
    }

    // optional int32 mp_maxrounds = 2;

    pub fn mp_maxrounds(&self) -> i32 {
        self.mp_maxrounds.unwrap_or(0)
    }

    pub fn clear_mp_maxrounds(&mut self) {
        self.mp_maxrounds = ::std::option::Option::None;
    }

    pub fn has_mp_maxrounds(&self) -> bool {
        self.mp_maxrounds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_maxrounds(&mut self, v: i32) {
        self.mp_maxrounds = ::std::option::Option::Some(v);
    }

    // optional int32 mp_winlimit = 3;

    pub fn mp_winlimit(&self) -> i32 {
        self.mp_winlimit.unwrap_or(0)
    }

    pub fn clear_mp_winlimit(&mut self) {
        self.mp_winlimit = ::std::option::Option::None;
    }

    pub fn has_mp_winlimit(&self) -> bool {
        self.mp_winlimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_winlimit(&mut self, v: i32) {
        self.mp_winlimit = ::std::option::Option::Some(v);
    }

    // optional float mp_timelimit = 4;

    pub fn mp_timelimit(&self) -> f32 {
        self.mp_timelimit.unwrap_or(0.)
    }

    pub fn clear_mp_timelimit(&mut self) {
        self.mp_timelimit = ::std::option::Option::None;
    }

    pub fn has_mp_timelimit(&self) -> bool {
        self.mp_timelimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mp_timelimit(&mut self, v: f32) {
        self.mp_timelimit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_MatchEndConditions {
    const NAME: &'static str = "CCSUsrMsg_MatchEndConditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fraglimit = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.mp_maxrounds = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.mp_winlimit = ::std::option::Option::Some(is.read_int32()?);
                },
                37 => {
                    self.mp_timelimit = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fraglimit {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.mp_maxrounds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.mp_winlimit {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.mp_timelimit {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.fraglimit {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.mp_maxrounds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.mp_winlimit {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.mp_timelimit {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MatchEndConditions {
        CCSUsrMsg_MatchEndConditions::new()
    }

    fn clear(&mut self) {
        self.fraglimit = ::std::option::Option::None;
        self.mp_maxrounds = ::std::option::Option::None;
        self.mp_winlimit = ::std::option::Option::None;
        self.mp_timelimit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchEndConditions {
        static instance: CCSUsrMsg_MatchEndConditions = CCSUsrMsg_MatchEndConditions {
            fraglimit: ::std::option::Option::None,
            mp_maxrounds: ::std::option::Option::None,
            mp_winlimit: ::std::option::Option::None,
            mp_timelimit: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_PlayerStatsUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PlayerStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.stats)
    pub stats: ::std::vec::Vec<ccsusr_msg_player_stats_update::Stat>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.ehandle)
    pub ehandle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.crc)
    pub crc: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerStatsUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerStatsUpdate {
    fn default() -> &'a CCSUsrMsg_PlayerStatsUpdate {
        <CCSUsrMsg_PlayerStatsUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerStatsUpdate {
    pub fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional uint32 ehandle = 5;

    pub fn ehandle(&self) -> u32 {
        self.ehandle.unwrap_or(0)
    }

    pub fn clear_ehandle(&mut self) {
        self.ehandle = ::std::option::Option::None;
    }

    pub fn has_ehandle(&self) -> bool {
        self.ehandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ehandle(&mut self, v: u32) {
        self.ehandle = ::std::option::Option::Some(v);
    }

    // optional int32 crc = 6;

    pub fn crc(&self) -> i32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: i32) {
        self.crc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_PlayerStatsUpdate {
    const NAME: &'static str = "CCSUsrMsg_PlayerStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.stats.push(is.read_message()?);
                },
                40 => {
                    self.ehandle = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.crc = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ehandle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.crc {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        for v in &self.stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.ehandle {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.crc {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PlayerStatsUpdate {
        CCSUsrMsg_PlayerStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.stats.clear();
        self.ehandle = ::std::option::Option::None;
        self.crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerStatsUpdate {
        static instance: CCSUsrMsg_PlayerStatsUpdate = CCSUsrMsg_PlayerStatsUpdate {
            version: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            ehandle: ::std::option::Option::None,
            crc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_PlayerStatsUpdate`
pub mod ccsusr_msg_player_stats_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_PlayerStatsUpdate.Stat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Stat {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.Stat.idx)
        pub idx: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_PlayerStatsUpdate.Stat.delta)
        pub delta: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerStatsUpdate.Stat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Stat {
        fn default() -> &'a Stat {
            <Stat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Stat {
        pub fn new() -> Stat {
            ::std::default::Default::default()
        }

        // optional int32 idx = 1;

        pub fn idx(&self) -> i32 {
            self.idx.unwrap_or(0)
        }

        pub fn clear_idx(&mut self) {
            self.idx = ::std::option::Option::None;
        }

        pub fn has_idx(&self) -> bool {
            self.idx.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idx(&mut self, v: i32) {
            self.idx = ::std::option::Option::Some(v);
        }

        // optional int32 delta = 2;

        pub fn delta(&self) -> i32 {
            self.delta.unwrap_or(0)
        }

        pub fn clear_delta(&mut self) {
            self.delta = ::std::option::Option::None;
        }

        pub fn has_delta(&self) -> bool {
            self.delta.is_some()
        }

        // Param is passed by value, moved
        pub fn set_delta(&mut self, v: i32) {
            self.delta = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Stat {
        const NAME: &'static str = "Stat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.idx = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.delta = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.idx {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.delta {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.idx {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.delta {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Stat {
            Stat::new()
        }

        fn clear(&mut self) {
            self.idx = ::std::option::Option::None;
            self.delta = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Stat {
            static instance: Stat = Stat {
                idx: ::std::option::Option::None,
                delta: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_QuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_QuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.normal_points)
    pub normal_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.bonus_points)
    pub bonus_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_QuestProgress.is_event_quest)
    pub is_event_quest: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_QuestProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_QuestProgress {
    fn default() -> &'a CCSUsrMsg_QuestProgress {
        <CCSUsrMsg_QuestProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_QuestProgress {
    pub fn new() -> CCSUsrMsg_QuestProgress {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 normal_points = 2;

    pub fn normal_points(&self) -> u32 {
        self.normal_points.unwrap_or(0)
    }

    pub fn clear_normal_points(&mut self) {
        self.normal_points = ::std::option::Option::None;
    }

    pub fn has_normal_points(&self) -> bool {
        self.normal_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normal_points(&mut self, v: u32) {
        self.normal_points = ::std::option::Option::Some(v);
    }

    // optional uint32 bonus_points = 3;

    pub fn bonus_points(&self) -> u32 {
        self.bonus_points.unwrap_or(0)
    }

    pub fn clear_bonus_points(&mut self) {
        self.bonus_points = ::std::option::Option::None;
    }

    pub fn has_bonus_points(&self) -> bool {
        self.bonus_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bonus_points(&mut self, v: u32) {
        self.bonus_points = ::std::option::Option::Some(v);
    }

    // optional bool is_event_quest = 4;

    pub fn is_event_quest(&self) -> bool {
        self.is_event_quest.unwrap_or(false)
    }

    pub fn clear_is_event_quest(&mut self) {
        self.is_event_quest = ::std::option::Option::None;
    }

    pub fn has_is_event_quest(&self) -> bool {
        self.is_event_quest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_event_quest(&mut self, v: bool) {
        self.is_event_quest = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_QuestProgress {
    const NAME: &'static str = "CCSUsrMsg_QuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.normal_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bonus_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_event_quest = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.normal_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bonus_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_event_quest {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.normal_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bonus_points {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_event_quest {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_QuestProgress {
        CCSUsrMsg_QuestProgress::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.normal_points = ::std::option::Option::None;
        self.bonus_points = ::std::option::Option::None;
        self.is_event_quest = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_QuestProgress {
        static instance: CCSUsrMsg_QuestProgress = CCSUsrMsg_QuestProgress {
            quest_id: ::std::option::Option::None,
            normal_points: ::std::option::Option::None,
            bonus_points: ::std::option::Option::None,
            is_event_quest: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ScoreLeaderboardData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ScoreLeaderboardData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ScoreLeaderboardData.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::ScoreLeaderboardData>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ScoreLeaderboardData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ScoreLeaderboardData {
    fn default() -> &'a CCSUsrMsg_ScoreLeaderboardData {
        <CCSUsrMsg_ScoreLeaderboardData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ScoreLeaderboardData {
    pub fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ScoreLeaderboardData {
    const NAME: &'static str = "CCSUsrMsg_ScoreLeaderboardData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ScoreLeaderboardData {
        CCSUsrMsg_ScoreLeaderboardData::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ScoreLeaderboardData {
        static instance: CCSUsrMsg_ScoreLeaderboardData = CCSUsrMsg_ScoreLeaderboardData {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_PlayerDecalDigitalSignature)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PlayerDecalDigitalSignature {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PlayerDecalDigitalSignature.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::PlayerDecalDigitalSignature>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PlayerDecalDigitalSignature.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PlayerDecalDigitalSignature {
    fn default() -> &'a CCSUsrMsg_PlayerDecalDigitalSignature {
        <CCSUsrMsg_PlayerDecalDigitalSignature as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PlayerDecalDigitalSignature {
    pub fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_PlayerDecalDigitalSignature {
    const NAME: &'static str = "CCSUsrMsg_PlayerDecalDigitalSignature";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PlayerDecalDigitalSignature {
        CCSUsrMsg_PlayerDecalDigitalSignature::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PlayerDecalDigitalSignature {
        static instance: CCSUsrMsg_PlayerDecalDigitalSignature = CCSUsrMsg_PlayerDecalDigitalSignature {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_XRankGet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XRankGet {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankGet.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankGet.controller)
    pub controller: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XRankGet.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankGet {
    fn default() -> &'a CCSUsrMsg_XRankGet {
        <CCSUsrMsg_XRankGet as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankGet {
    pub fn new() -> CCSUsrMsg_XRankGet {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_XRankGet {
    const NAME: &'static str = "CCSUsrMsg_XRankGet";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XRankGet {
        CCSUsrMsg_XRankGet::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankGet {
        static instance: CCSUsrMsg_XRankGet = CCSUsrMsg_XRankGet {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_XRankUpd)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XRankUpd {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.mode_idx)
    pub mode_idx: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.controller)
    pub controller: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_XRankUpd.ranking)
    pub ranking: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XRankUpd.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XRankUpd {
    fn default() -> &'a CCSUsrMsg_XRankUpd {
        <CCSUsrMsg_XRankUpd as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XRankUpd {
    pub fn new() -> CCSUsrMsg_XRankUpd {
        ::std::default::Default::default()
    }

    // optional int32 mode_idx = 1;

    pub fn mode_idx(&self) -> i32 {
        self.mode_idx.unwrap_or(0)
    }

    pub fn clear_mode_idx(&mut self) {
        self.mode_idx = ::std::option::Option::None;
    }

    pub fn has_mode_idx(&self) -> bool {
        self.mode_idx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode_idx(&mut self, v: i32) {
        self.mode_idx = ::std::option::Option::Some(v);
    }

    // optional int32 controller = 2;

    pub fn controller(&self) -> i32 {
        self.controller.unwrap_or(0)
    }

    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: i32) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional int32 ranking = 3;

    pub fn ranking(&self) -> i32 {
        self.ranking.unwrap_or(0)
    }

    pub fn clear_ranking(&mut self) {
        self.ranking = ::std::option::Option::None;
    }

    pub fn has_ranking(&self) -> bool {
        self.ranking.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranking(&mut self, v: i32) {
        self.ranking = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_XRankUpd {
    const NAME: &'static str = "CCSUsrMsg_XRankUpd";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode_idx = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.controller = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.ranking = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mode_idx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.controller {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.ranking {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mode_idx {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.controller {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.ranking {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XRankUpd {
        CCSUsrMsg_XRankUpd::new()
    }

    fn clear(&mut self) {
        self.mode_idx = ::std::option::Option::None;
        self.controller = ::std::option::Option::None;
        self.ranking = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XRankUpd {
        static instance: CCSUsrMsg_XRankUpd = CCSUsrMsg_XRankUpd {
            mode_idx: ::std::option::Option::None,
            controller: ::std::option::Option::None,
            ranking: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_CallVoteFailed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CallVoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CallVoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_CallVoteFailed.time)
    pub time: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CallVoteFailed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CallVoteFailed {
    fn default() -> &'a CCSUsrMsg_CallVoteFailed {
        <CCSUsrMsg_CallVoteFailed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CallVoteFailed {
    pub fn new() -> CCSUsrMsg_CallVoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 reason = 1;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }

    // optional int32 time = 2;

    pub fn time(&self) -> i32 {
        self.time.unwrap_or(0)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: i32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_CallVoteFailed {
    const NAME: &'static str = "CCSUsrMsg_CallVoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.time = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reason {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.time {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CallVoteFailed {
        CCSUsrMsg_CallVoteFailed::new()
    }

    fn clear(&mut self) {
        self.reason = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CallVoteFailed {
        static instance: CCSUsrMsg_CallVoteFailed = CCSUsrMsg_CallVoteFailed {
            reason: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteStart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteStart {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.player_slot)
    pub player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.disp_str)
    pub disp_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.details_str)
    pub details_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.other_team_str)
    pub other_team_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.is_yes_no_vote)
    pub is_yes_no_vote: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteStart.player_slot_target)
    pub player_slot_target: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteStart.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteStart {
    fn default() -> &'a CCSUsrMsg_VoteStart {
        <CCSUsrMsg_VoteStart as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteStart {
    pub fn new() -> CCSUsrMsg_VoteStart {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot = 2;

    pub fn player_slot(&self) -> i32 {
        self.player_slot.unwrap_or(-1i32)
    }

    pub fn clear_player_slot(&mut self) {
        self.player_slot = ::std::option::Option::None;
    }

    pub fn has_player_slot(&self) -> bool {
        self.player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot(&mut self, v: i32) {
        self.player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 3;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 4;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 5;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string other_team_str = 6;

    pub fn other_team_str(&self) -> &str {
        match self.other_team_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_other_team_str(&mut self) {
        self.other_team_str = ::std::option::Option::None;
    }

    pub fn has_other_team_str(&self) -> bool {
        self.other_team_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_team_str(&mut self, v: ::std::string::String) {
        self.other_team_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_other_team_str(&mut self) -> &mut ::std::string::String {
        if self.other_team_str.is_none() {
            self.other_team_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.other_team_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_other_team_str(&mut self) -> ::std::string::String {
        self.other_team_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_yes_no_vote = 7;

    pub fn is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.unwrap_or(false)
    }

    pub fn clear_is_yes_no_vote(&mut self) {
        self.is_yes_no_vote = ::std::option::Option::None;
    }

    pub fn has_is_yes_no_vote(&self) -> bool {
        self.is_yes_no_vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_yes_no_vote(&mut self, v: bool) {
        self.is_yes_no_vote = ::std::option::Option::Some(v);
    }

    // optional int32 player_slot_target = 8;

    pub fn player_slot_target(&self) -> i32 {
        self.player_slot_target.unwrap_or(-1i32)
    }

    pub fn clear_player_slot_target(&mut self) {
        self.player_slot_target = ::std::option::Option::None;
    }

    pub fn has_player_slot_target(&self) -> bool {
        self.player_slot_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_slot_target(&mut self, v: i32) {
        self.player_slot_target = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VoteStart {
    const NAME: &'static str = "CCSUsrMsg_VoteStart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.disp_str = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.details_str = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.other_team_str = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.is_yes_no_vote = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.player_slot_target = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.other_team_str.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.is_yes_no_vote {
            my_size += 1 + 1;
        }
        if let Some(v) = self.player_slot_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.player_slot {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.other_team_str.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.is_yes_no_vote {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.player_slot_target {
            os.write_int32(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteStart {
        CCSUsrMsg_VoteStart::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.player_slot = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.other_team_str = ::std::option::Option::None;
        self.is_yes_no_vote = ::std::option::Option::None;
        self.player_slot_target = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteStart {
        static instance: CCSUsrMsg_VoteStart = CCSUsrMsg_VoteStart {
            team: ::std::option::Option::None,
            player_slot: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            other_team_str: ::std::option::Option::None,
            is_yes_no_vote: ::std::option::Option::None,
            player_slot_target: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_VotePass)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VotePass {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.vote_type)
    pub vote_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.disp_str)
    pub disp_str: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VotePass.details_str)
    pub details_str: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VotePass.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VotePass {
    fn default() -> &'a CCSUsrMsg_VotePass {
        <CCSUsrMsg_VotePass as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VotePass {
    pub fn new() -> CCSUsrMsg_VotePass {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 vote_type = 2;

    pub fn vote_type(&self) -> i32 {
        self.vote_type.unwrap_or(0)
    }

    pub fn clear_vote_type(&mut self) {
        self.vote_type = ::std::option::Option::None;
    }

    pub fn has_vote_type(&self) -> bool {
        self.vote_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote_type(&mut self, v: i32) {
        self.vote_type = ::std::option::Option::Some(v);
    }

    // optional string disp_str = 3;

    pub fn disp_str(&self) -> &str {
        match self.disp_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_disp_str(&mut self) {
        self.disp_str = ::std::option::Option::None;
    }

    pub fn has_disp_str(&self) -> bool {
        self.disp_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disp_str(&mut self, v: ::std::string::String) {
        self.disp_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disp_str(&mut self) -> &mut ::std::string::String {
        if self.disp_str.is_none() {
            self.disp_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.disp_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_disp_str(&mut self) -> ::std::string::String {
        self.disp_str.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string details_str = 4;

    pub fn details_str(&self) -> &str {
        match self.details_str.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_details_str(&mut self) {
        self.details_str = ::std::option::Option::None;
    }

    pub fn has_details_str(&self) -> bool {
        self.details_str.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details_str(&mut self, v: ::std::string::String) {
        self.details_str = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details_str(&mut self) -> &mut ::std::string::String {
        if self.details_str.is_none() {
            self.details_str = ::std::option::Option::Some(::std::string::String::new());
        }
        self.details_str.as_mut().unwrap()
    }

    // Take field
    pub fn take_details_str(&mut self) -> ::std::string::String {
        self.details_str.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VotePass {
    const NAME: &'static str = "CCSUsrMsg_VotePass";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.vote_type = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.disp_str = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.details_str = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.vote_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.disp_str.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.details_str.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.vote_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.disp_str.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.details_str.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VotePass {
        CCSUsrMsg_VotePass::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.vote_type = ::std::option::Option::None;
        self.disp_str = ::std::option::Option::None;
        self.details_str = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VotePass {
        static instance: CCSUsrMsg_VotePass = CCSUsrMsg_VotePass {
            team: ::std::option::Option::None,
            vote_type: ::std::option::Option::None,
            disp_str: ::std::option::Option::None,
            details_str: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteFailed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteFailed {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteFailed.team)
    pub team: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteFailed.reason)
    pub reason: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteFailed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteFailed {
    fn default() -> &'a CCSUsrMsg_VoteFailed {
        <CCSUsrMsg_VoteFailed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteFailed {
    pub fn new() -> CCSUsrMsg_VoteFailed {
        ::std::default::Default::default()
    }

    // optional int32 team = 1;

    pub fn team(&self) -> i32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: i32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional int32 reason = 2;

    pub fn reason(&self) -> i32 {
        self.reason.unwrap_or(0)
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: i32) {
        self.reason = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VoteFailed {
    const NAME: &'static str = "CCSUsrMsg_VoteFailed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteFailed {
        CCSUsrMsg_VoteFailed::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteFailed {
        static instance: CCSUsrMsg_VoteFailed = CCSUsrMsg_VoteFailed {
            team: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_VoteSetup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_VoteSetup {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_VoteSetup.potential_issues)
    pub potential_issues: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_VoteSetup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_VoteSetup {
    fn default() -> &'a CCSUsrMsg_VoteSetup {
        <CCSUsrMsg_VoteSetup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_VoteSetup {
    pub fn new() -> CCSUsrMsg_VoteSetup {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_VoteSetup {
    const NAME: &'static str = "CCSUsrMsg_VoteSetup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.potential_issues.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.potential_issues {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.potential_issues {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_VoteSetup {
        CCSUsrMsg_VoteSetup::new()
    }

    fn clear(&mut self) {
        self.potential_issues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_VoteSetup {
        static instance: CCSUsrMsg_VoteSetup = CCSUsrMsg_VoteSetup {
            potential_issues: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SendLastKillerDamageToClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SendLastKillerDamageToClient {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.num_hits_given)
    pub num_hits_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.damage_given)
    pub damage_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.num_hits_taken)
    pub num_hits_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.damage_taken)
    pub damage_taken: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.actual_damage_given)
    pub actual_damage_given: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SendLastKillerDamageToClient.actual_damage_taken)
    pub actual_damage_taken: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SendLastKillerDamageToClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SendLastKillerDamageToClient {
    fn default() -> &'a CCSUsrMsg_SendLastKillerDamageToClient {
        <CCSUsrMsg_SendLastKillerDamageToClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SendLastKillerDamageToClient {
    pub fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        ::std::default::Default::default()
    }

    // optional int32 num_hits_given = 1;

    pub fn num_hits_given(&self) -> i32 {
        self.num_hits_given.unwrap_or(0)
    }

    pub fn clear_num_hits_given(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
    }

    pub fn has_num_hits_given(&self) -> bool {
        self.num_hits_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_given(&mut self, v: i32) {
        self.num_hits_given = ::std::option::Option::Some(v);
    }

    // optional int32 damage_given = 2;

    pub fn damage_given(&self) -> i32 {
        self.damage_given.unwrap_or(0)
    }

    pub fn clear_damage_given(&mut self) {
        self.damage_given = ::std::option::Option::None;
    }

    pub fn has_damage_given(&self) -> bool {
        self.damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_given(&mut self, v: i32) {
        self.damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 num_hits_taken = 3;

    pub fn num_hits_taken(&self) -> i32 {
        self.num_hits_taken.unwrap_or(0)
    }

    pub fn clear_num_hits_taken(&mut self) {
        self.num_hits_taken = ::std::option::Option::None;
    }

    pub fn has_num_hits_taken(&self) -> bool {
        self.num_hits_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_hits_taken(&mut self, v: i32) {
        self.num_hits_taken = ::std::option::Option::Some(v);
    }

    // optional int32 damage_taken = 4;

    pub fn damage_taken(&self) -> i32 {
        self.damage_taken.unwrap_or(0)
    }

    pub fn clear_damage_taken(&mut self) {
        self.damage_taken = ::std::option::Option::None;
    }

    pub fn has_damage_taken(&self) -> bool {
        self.damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_taken(&mut self, v: i32) {
        self.damage_taken = ::std::option::Option::Some(v);
    }

    // optional int32 actual_damage_given = 5;

    pub fn actual_damage_given(&self) -> i32 {
        self.actual_damage_given.unwrap_or(0)
    }

    pub fn clear_actual_damage_given(&mut self) {
        self.actual_damage_given = ::std::option::Option::None;
    }

    pub fn has_actual_damage_given(&self) -> bool {
        self.actual_damage_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_damage_given(&mut self, v: i32) {
        self.actual_damage_given = ::std::option::Option::Some(v);
    }

    // optional int32 actual_damage_taken = 6;

    pub fn actual_damage_taken(&self) -> i32 {
        self.actual_damage_taken.unwrap_or(0)
    }

    pub fn clear_actual_damage_taken(&mut self) {
        self.actual_damage_taken = ::std::option::Option::None;
    }

    pub fn has_actual_damage_taken(&self) -> bool {
        self.actual_damage_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actual_damage_taken(&mut self, v: i32) {
        self.actual_damage_taken = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SendLastKillerDamageToClient {
    const NAME: &'static str = "CCSUsrMsg_SendLastKillerDamageToClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_hits_given = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.damage_given = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.num_hits_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.damage_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.actual_damage_given = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.actual_damage_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_hits_given {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.damage_given {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.num_hits_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.damage_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.actual_damage_given {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.actual_damage_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.num_hits_given {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.damage_given {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.num_hits_taken {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.damage_taken {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.actual_damage_given {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.actual_damage_taken {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SendLastKillerDamageToClient {
        CCSUsrMsg_SendLastKillerDamageToClient::new()
    }

    fn clear(&mut self) {
        self.num_hits_given = ::std::option::Option::None;
        self.damage_given = ::std::option::Option::None;
        self.num_hits_taken = ::std::option::Option::None;
        self.damage_taken = ::std::option::Option::None;
        self.actual_damage_given = ::std::option::Option::None;
        self.actual_damage_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SendLastKillerDamageToClient {
        static instance: CCSUsrMsg_SendLastKillerDamageToClient = CCSUsrMsg_SendLastKillerDamageToClient {
            num_hits_given: ::std::option::Option::None,
            damage_given: ::std::option::Option::None,
            num_hits_taken: ::std::option::Option::None,
            damage_taken: ::std::option::Option::None,
            actual_damage_given: ::std::option::Option::None,
            actual_damage_taken: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ServerRankUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ServerRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.rank_update)
    pub rank_update: ::std::vec::Vec<ccsusr_msg_server_rank_update::RankUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankUpdate {
    fn default() -> &'a CCSUsrMsg_ServerRankUpdate {
        <CCSUsrMsg_ServerRankUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankUpdate {
    pub fn new() -> CCSUsrMsg_ServerRankUpdate {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ServerRankUpdate {
    const NAME: &'static str = "CCSUsrMsg_ServerRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rank_update.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rank_update {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.rank_update {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ServerRankUpdate {
        CCSUsrMsg_ServerRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rank_update.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankUpdate {
        static instance: CCSUsrMsg_ServerRankUpdate = CCSUsrMsg_ServerRankUpdate {
            rank_update: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_ServerRankUpdate`
pub mod ccsusr_msg_server_rank_update {
    // @@protoc_insertion_point(message:CCSUsrMsg_ServerRankUpdate.RankUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankUpdate {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.account_id)
        pub account_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_old)
        pub rank_old: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_new)
        pub rank_new: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.num_wins)
        pub num_wins: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_change)
        pub rank_change: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankUpdate.RankUpdate.rank_type_id)
        pub rank_type_id: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankUpdate.RankUpdate.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankUpdate {
        fn default() -> &'a RankUpdate {
            <RankUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RankUpdate {
        pub fn new() -> RankUpdate {
            ::std::default::Default::default()
        }

        // optional int32 account_id = 1;

        pub fn account_id(&self) -> i32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: i32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 rank_old = 2;

        pub fn rank_old(&self) -> i32 {
            self.rank_old.unwrap_or(0)
        }

        pub fn clear_rank_old(&mut self) {
            self.rank_old = ::std::option::Option::None;
        }

        pub fn has_rank_old(&self) -> bool {
            self.rank_old.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_old(&mut self, v: i32) {
            self.rank_old = ::std::option::Option::Some(v);
        }

        // optional int32 rank_new = 3;

        pub fn rank_new(&self) -> i32 {
            self.rank_new.unwrap_or(0)
        }

        pub fn clear_rank_new(&mut self) {
            self.rank_new = ::std::option::Option::None;
        }

        pub fn has_rank_new(&self) -> bool {
            self.rank_new.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_new(&mut self, v: i32) {
            self.rank_new = ::std::option::Option::Some(v);
        }

        // optional int32 num_wins = 4;

        pub fn num_wins(&self) -> i32 {
            self.num_wins.unwrap_or(0)
        }

        pub fn clear_num_wins(&mut self) {
            self.num_wins = ::std::option::Option::None;
        }

        pub fn has_num_wins(&self) -> bool {
            self.num_wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_wins(&mut self, v: i32) {
            self.num_wins = ::std::option::Option::Some(v);
        }

        // optional float rank_change = 5;

        pub fn rank_change(&self) -> f32 {
            self.rank_change.unwrap_or(0.)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: f32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional int32 rank_type_id = 6;

        pub fn rank_type_id(&self) -> i32 {
            self.rank_type_id.unwrap_or(0)
        }

        pub fn clear_rank_type_id(&mut self) {
            self.rank_type_id = ::std::option::Option::None;
        }

        pub fn has_rank_type_id(&self) -> bool {
            self.rank_type_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_type_id(&mut self, v: i32) {
            self.rank_type_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RankUpdate {
        const NAME: &'static str = "RankUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.rank_old = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.rank_new = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.num_wins = ::std::option::Option::Some(is.read_int32()?);
                    },
                    45 => {
                        self.rank_change = ::std::option::Option::Some(is.read_float()?);
                    },
                    48 => {
                        self.rank_type_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.rank_old {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.rank_new {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.num_wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.rank_change {
                my_size += 1 + 4;
            }
            if let Some(v) = self.rank_type_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.rank_old {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.rank_new {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.num_wins {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.rank_type_id {
                os.write_int32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankUpdate {
            RankUpdate::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.rank_old = ::std::option::Option::None;
            self.rank_new = ::std::option::Option::None;
            self.num_wins = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.rank_type_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankUpdate {
            static instance: RankUpdate = RankUpdate {
                account_id: ::std::option::Option::None,
                rank_old: ::std::option::Option::None,
                rank_new: ::std::option::Option::None,
                num_wins: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                rank_type_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_XpUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_XpUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_XpUpdate.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_XpUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_XpUpdate {
    fn default() -> &'a CCSUsrMsg_XpUpdate {
        <CCSUsrMsg_XpUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_XpUpdate {
    pub fn new() -> CCSUsrMsg_XpUpdate {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_XpUpdate {
    const NAME: &'static str = "CCSUsrMsg_XpUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_XpUpdate {
        CCSUsrMsg_XpUpdate::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_XpUpdate {
        static instance: CCSUsrMsg_XpUpdate = CCSUsrMsg_XpUpdate {
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ItemPickup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ItemPickup {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemPickup.item)
    pub item: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ItemPickup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemPickup {
    fn default() -> &'a CCSUsrMsg_ItemPickup {
        <CCSUsrMsg_ItemPickup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemPickup {
    pub fn new() -> CCSUsrMsg_ItemPickup {
        ::std::default::Default::default()
    }

    // optional string item = 1;

    pub fn item(&self) -> &str {
        match self.item.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::std::string::String) {
        self.item = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_item(&mut self) -> &mut ::std::string::String {
        if self.item.is_none() {
            self.item = ::std::option::Option::Some(::std::string::String::new());
        }
        self.item.as_mut().unwrap()
    }

    // Take field
    pub fn take_item(&mut self) -> ::std::string::String {
        self.item.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ItemPickup {
    const NAME: &'static str = "CCSUsrMsg_ItemPickup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ItemPickup {
        CCSUsrMsg_ItemPickup::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemPickup {
        static instance: CCSUsrMsg_ItemPickup = CCSUsrMsg_ItemPickup {
            item: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ShowMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ShowMenu {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.bits_valid_slots)
    pub bits_valid_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.display_time)
    pub display_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShowMenu.menu_string)
    pub menu_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ShowMenu.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShowMenu {
    fn default() -> &'a CCSUsrMsg_ShowMenu {
        <CCSUsrMsg_ShowMenu as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShowMenu {
    pub fn new() -> CCSUsrMsg_ShowMenu {
        ::std::default::Default::default()
    }

    // optional int32 bits_valid_slots = 1;

    pub fn bits_valid_slots(&self) -> i32 {
        self.bits_valid_slots.unwrap_or(0)
    }

    pub fn clear_bits_valid_slots(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
    }

    pub fn has_bits_valid_slots(&self) -> bool {
        self.bits_valid_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bits_valid_slots(&mut self, v: i32) {
        self.bits_valid_slots = ::std::option::Option::Some(v);
    }

    // optional int32 display_time = 2;

    pub fn display_time(&self) -> i32 {
        self.display_time.unwrap_or(0)
    }

    pub fn clear_display_time(&mut self) {
        self.display_time = ::std::option::Option::None;
    }

    pub fn has_display_time(&self) -> bool {
        self.display_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_time(&mut self, v: i32) {
        self.display_time = ::std::option::Option::Some(v);
    }

    // optional string menu_string = 3;

    pub fn menu_string(&self) -> &str {
        match self.menu_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_menu_string(&mut self) {
        self.menu_string = ::std::option::Option::None;
    }

    pub fn has_menu_string(&self) -> bool {
        self.menu_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_string(&mut self, v: ::std::string::String) {
        self.menu_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menu_string(&mut self) -> &mut ::std::string::String {
        if self.menu_string.is_none() {
            self.menu_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.menu_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_menu_string(&mut self) -> ::std::string::String {
        self.menu_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ShowMenu {
    const NAME: &'static str = "CCSUsrMsg_ShowMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bits_valid_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.display_time = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.menu_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.bits_valid_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.display_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.menu_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.bits_valid_slots {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.display_time {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.menu_string.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ShowMenu {
        CCSUsrMsg_ShowMenu::new()
    }

    fn clear(&mut self) {
        self.bits_valid_slots = ::std::option::Option::None;
        self.display_time = ::std::option::Option::None;
        self.menu_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ShowMenu {
        static instance: CCSUsrMsg_ShowMenu = CCSUsrMsg_ShowMenu {
            bits_valid_slots: ::std::option::Option::None,
            display_time: ::std::option::Option::None,
            menu_string: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_BarTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_BarTime {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_BarTime.time)
    pub time: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_BarTime.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_BarTime {
    fn default() -> &'a CCSUsrMsg_BarTime {
        <CCSUsrMsg_BarTime as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_BarTime {
    pub fn new() -> CCSUsrMsg_BarTime {
        ::std::default::Default::default()
    }

    // optional string time = 1;

    pub fn time(&self) -> &str {
        match self.time.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: ::std::string::String) {
        self.time = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut ::std::string::String {
        if self.time.is_none() {
            self.time = ::std::option::Option::Some(::std::string::String::new());
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> ::std::string::String {
        self.time.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_BarTime {
    const NAME: &'static str = "CCSUsrMsg_BarTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.time = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.time.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_BarTime {
        CCSUsrMsg_BarTime::new()
    }

    fn clear(&mut self) {
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_BarTime {
        static instance: CCSUsrMsg_BarTime = CCSUsrMsg_BarTime {
            time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_AmmoDenied)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_AmmoDenied {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_AmmoDenied.ammoidx)
    pub ammoidx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_AmmoDenied.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_AmmoDenied {
    fn default() -> &'a CCSUsrMsg_AmmoDenied {
        <CCSUsrMsg_AmmoDenied as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_AmmoDenied {
    pub fn new() -> CCSUsrMsg_AmmoDenied {
        ::std::default::Default::default()
    }

    // optional int32 ammoidx = 1;

    pub fn ammoidx(&self) -> i32 {
        self.ammoidx.unwrap_or(0)
    }

    pub fn clear_ammoidx(&mut self) {
        self.ammoidx = ::std::option::Option::None;
    }

    pub fn has_ammoidx(&self) -> bool {
        self.ammoidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammoidx(&mut self, v: i32) {
        self.ammoidx = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_AmmoDenied {
    const NAME: &'static str = "CCSUsrMsg_AmmoDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ammoidx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ammoidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ammoidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_AmmoDenied {
        CCSUsrMsg_AmmoDenied::new()
    }

    fn clear(&mut self) {
        self.ammoidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_AmmoDenied {
        static instance: CCSUsrMsg_AmmoDenied = CCSUsrMsg_AmmoDenied {
            ammoidx: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_MarkAchievement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MarkAchievement {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MarkAchievement.achievement)
    pub achievement: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MarkAchievement.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MarkAchievement {
    fn default() -> &'a CCSUsrMsg_MarkAchievement {
        <CCSUsrMsg_MarkAchievement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MarkAchievement {
    pub fn new() -> CCSUsrMsg_MarkAchievement {
        ::std::default::Default::default()
    }

    // optional string achievement = 1;

    pub fn achievement(&self) -> &str {
        match self.achievement.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: ::std::string::String) {
        self.achievement = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_achievement(&mut self) -> &mut ::std::string::String {
        if self.achievement.is_none() {
            self.achievement = ::std::option::Option::Some(::std::string::String::new());
        }
        self.achievement.as_mut().unwrap()
    }

    // Take field
    pub fn take_achievement(&mut self) -> ::std::string::String {
        self.achievement.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_MarkAchievement {
    const NAME: &'static str = "CCSUsrMsg_MarkAchievement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.achievement = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.achievement.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MarkAchievement {
        CCSUsrMsg_MarkAchievement::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MarkAchievement {
        static instance: CCSUsrMsg_MarkAchievement = CCSUsrMsg_MarkAchievement {
            achievement: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_MatchStatsUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_MatchStatsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_MatchStatsUpdate.update)
    pub update: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_MatchStatsUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_MatchStatsUpdate {
    fn default() -> &'a CCSUsrMsg_MatchStatsUpdate {
        <CCSUsrMsg_MatchStatsUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_MatchStatsUpdate {
    pub fn new() -> CCSUsrMsg_MatchStatsUpdate {
        ::std::default::Default::default()
    }

    // optional string update = 1;

    pub fn update(&self) -> &str {
        match self.update.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_update(&mut self) {
        self.update = ::std::option::Option::None;
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ::std::string::String) {
        self.update = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ::std::string::String {
        if self.update.is_none() {
            self.update = ::std::option::Option::Some(::std::string::String::new());
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ::std::string::String {
        self.update.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_MatchStatsUpdate {
    const NAME: &'static str = "CCSUsrMsg_MatchStatsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.update = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.update.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_MatchStatsUpdate {
        CCSUsrMsg_MatchStatsUpdate::new()
    }

    fn clear(&mut self) {
        self.update = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_MatchStatsUpdate {
        static instance: CCSUsrMsg_MatchStatsUpdate = CCSUsrMsg_MatchStatsUpdate {
            update: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ItemDrop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ItemDrop {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemDrop.itemid)
    pub itemid: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ItemDrop.death)
    pub death: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ItemDrop.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ItemDrop {
    fn default() -> &'a CCSUsrMsg_ItemDrop {
        <CCSUsrMsg_ItemDrop as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ItemDrop {
    pub fn new() -> CCSUsrMsg_ItemDrop {
        ::std::default::Default::default()
    }

    // optional int64 itemid = 1;

    pub fn itemid(&self) -> i64 {
        self.itemid.unwrap_or(0)
    }

    pub fn clear_itemid(&mut self) {
        self.itemid = ::std::option::Option::None;
    }

    pub fn has_itemid(&self) -> bool {
        self.itemid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemid(&mut self, v: i64) {
        self.itemid = ::std::option::Option::Some(v);
    }

    // optional bool death = 2;

    pub fn death(&self) -> bool {
        self.death.unwrap_or(false)
    }

    pub fn clear_death(&mut self) {
        self.death = ::std::option::Option::None;
    }

    pub fn has_death(&self) -> bool {
        self.death.is_some()
    }

    // Param is passed by value, moved
    pub fn set_death(&mut self, v: bool) {
        self.death = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ItemDrop {
    const NAME: &'static str = "CCSUsrMsg_ItemDrop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.itemid = ::std::option::Option::Some(is.read_int64()?);
                },
                16 => {
                    self.death = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemid {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(1, v);
        }
        if let Some(v) = self.death {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.itemid {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.death {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ItemDrop {
        CCSUsrMsg_ItemDrop::new()
    }

    fn clear(&mut self) {
        self.itemid = ::std::option::Option::None;
        self.death = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ItemDrop {
        static instance: CCSUsrMsg_ItemDrop = CCSUsrMsg_ItemDrop {
            itemid: ::std::option::Option::None,
            death: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_GlowPropTurnOff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_GlowPropTurnOff {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_GlowPropTurnOff.entidx)
    pub entidx: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_GlowPropTurnOff.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GlowPropTurnOff {
    fn default() -> &'a CCSUsrMsg_GlowPropTurnOff {
        <CCSUsrMsg_GlowPropTurnOff as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GlowPropTurnOff {
    pub fn new() -> CCSUsrMsg_GlowPropTurnOff {
        ::std::default::Default::default()
    }

    // optional int32 entidx = 1;

    pub fn entidx(&self) -> i32 {
        self.entidx.unwrap_or(-1i32)
    }

    pub fn clear_entidx(&mut self) {
        self.entidx = ::std::option::Option::None;
    }

    pub fn has_entidx(&self) -> bool {
        self.entidx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entidx(&mut self, v: i32) {
        self.entidx = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_GlowPropTurnOff {
    const NAME: &'static str = "CCSUsrMsg_GlowPropTurnOff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entidx = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entidx {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entidx {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_GlowPropTurnOff {
        CCSUsrMsg_GlowPropTurnOff::new()
    }

    fn clear(&mut self) {
        self.entidx = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_GlowPropTurnOff {
        static instance: CCSUsrMsg_GlowPropTurnOff = CCSUsrMsg_GlowPropTurnOff {
            entidx: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RoundBackupFilenames)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RoundBackupFilenames {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.count)
    pub count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.filename)
    pub filename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundBackupFilenames.nicename)
    pub nicename: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundBackupFilenames.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundBackupFilenames {
    fn default() -> &'a CCSUsrMsg_RoundBackupFilenames {
        <CCSUsrMsg_RoundBackupFilenames as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundBackupFilenames {
    pub fn new() -> CCSUsrMsg_RoundBackupFilenames {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;

    pub fn count(&self) -> i32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional int32 index = 2;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional string filename = 3;

    pub fn filename(&self) -> &str {
        match self.filename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_filename(&mut self) {
        self.filename = ::std::option::Option::None;
    }

    pub fn has_filename(&self) -> bool {
        self.filename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_filename(&mut self, v: ::std::string::String) {
        self.filename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filename(&mut self) -> &mut ::std::string::String {
        if self.filename.is_none() {
            self.filename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.filename.as_mut().unwrap()
    }

    // Take field
    pub fn take_filename(&mut self) -> ::std::string::String {
        self.filename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nicename = 4;

    pub fn nicename(&self) -> &str {
        match self.nicename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_nicename(&mut self) {
        self.nicename = ::std::option::Option::None;
    }

    pub fn has_nicename(&self) -> bool {
        self.nicename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nicename(&mut self, v: ::std::string::String) {
        self.nicename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nicename(&mut self) -> &mut ::std::string::String {
        if self.nicename.is_none() {
            self.nicename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.nicename.as_mut().unwrap()
    }

    // Take field
    pub fn take_nicename(&mut self) -> ::std::string::String {
        self.nicename.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_RoundBackupFilenames {
    const NAME: &'static str = "CCSUsrMsg_RoundBackupFilenames";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.count = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.filename = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.nicename = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.filename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.nicename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.index {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.filename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.nicename.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RoundBackupFilenames {
        CCSUsrMsg_RoundBackupFilenames::new()
    }

    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.filename = ::std::option::Option::None;
        self.nicename = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundBackupFilenames {
        static instance: CCSUsrMsg_RoundBackupFilenames = CCSUsrMsg_RoundBackupFilenames {
            count: ::std::option::Option::None,
            index: ::std::option::Option::None,
            filename: ::std::option::Option::None,
            nicename: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SSUI)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SSUI {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.show)
    pub show: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.start_time)
    pub start_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SSUI.end_time)
    pub end_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SSUI.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SSUI {
    fn default() -> &'a CCSUsrMsg_SSUI {
        <CCSUsrMsg_SSUI as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SSUI {
    pub fn new() -> CCSUsrMsg_SSUI {
        ::std::default::Default::default()
    }

    // optional bool show = 1;

    pub fn show(&self) -> bool {
        self.show.unwrap_or(false)
    }

    pub fn clear_show(&mut self) {
        self.show = ::std::option::Option::None;
    }

    pub fn has_show(&self) -> bool {
        self.show.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show(&mut self, v: bool) {
        self.show = ::std::option::Option::Some(v);
    }

    // optional float start_time = 2;

    pub fn start_time(&self) -> f32 {
        self.start_time.unwrap_or(0.)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: f32) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional float end_time = 3;

    pub fn end_time(&self) -> f32 {
        self.end_time.unwrap_or(0.)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: f32) {
        self.end_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SSUI {
    const NAME: &'static str = "CCSUsrMsg_SSUI";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.show = ::std::option::Option::Some(is.read_bool()?);
                },
                21 => {
                    self.start_time = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.end_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.show {
            my_size += 1 + 1;
        }
        if let Some(v) = self.start_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.end_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.show {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SSUI {
        CCSUsrMsg_SSUI::new()
    }

    fn clear(&mut self) {
        self.show = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SSUI {
        static instance: CCSUsrMsg_SSUI = CCSUsrMsg_SSUI {
            show: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SurvivalStats {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.xuid)
    pub xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.facts)
    pub facts: ::std::vec::Vec<ccsusr_msg_survival_stats::Fact>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.users)
    pub users: ::std::vec::Vec<ccsusr_msg_survival_stats::Placement>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.damages)
    pub damages: ::std::vec::Vec<ccsusr_msg_survival_stats::Damage>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.ticknumber)
    pub ticknumber: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SurvivalStats {
    fn default() -> &'a CCSUsrMsg_SurvivalStats {
        <CCSUsrMsg_SurvivalStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SurvivalStats {
    pub fn new() -> CCSUsrMsg_SurvivalStats {
        ::std::default::Default::default()
    }

    // optional uint64 xuid = 1;

    pub fn xuid(&self) -> u64 {
        self.xuid.unwrap_or(0)
    }

    pub fn clear_xuid(&mut self) {
        self.xuid = ::std::option::Option::None;
    }

    pub fn has_xuid(&self) -> bool {
        self.xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuid(&mut self, v: u64) {
        self.xuid = ::std::option::Option::Some(v);
    }

    // optional int32 ticknumber = 4;

    pub fn ticknumber(&self) -> i32 {
        self.ticknumber.unwrap_or(0)
    }

    pub fn clear_ticknumber(&mut self) {
        self.ticknumber = ::std::option::Option::None;
    }

    pub fn has_ticknumber(&self) -> bool {
        self.ticknumber.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticknumber(&mut self, v: i32) {
        self.ticknumber = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SurvivalStats {
    const NAME: &'static str = "CCSUsrMsg_SurvivalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.facts.push(is.read_message()?);
                },
                26 => {
                    self.users.push(is.read_message()?);
                },
                42 => {
                    self.damages.push(is.read_message()?);
                },
                32 => {
                    self.ticknumber = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.xuid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.facts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.users {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.damages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ticknumber {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.xuid {
            os.write_uint64(1, v)?;
        }
        for v in &self.facts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.users {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.damages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.ticknumber {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SurvivalStats {
        CCSUsrMsg_SurvivalStats::new()
    }

    fn clear(&mut self) {
        self.xuid = ::std::option::Option::None;
        self.facts.clear();
        self.users.clear();
        self.damages.clear();
        self.ticknumber = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SurvivalStats {
        static instance: CCSUsrMsg_SurvivalStats = CCSUsrMsg_SurvivalStats {
            xuid: ::std::option::Option::None,
            facts: ::std::vec::Vec::new(),
            users: ::std::vec::Vec::new(),
            damages: ::std::vec::Vec::new(),
            ticknumber: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_SurvivalStats`
pub mod ccsusr_msg_survival_stats {
    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Fact)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Fact {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.display)
        pub display: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.value)
        pub value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Fact.interestingness)
        pub interestingness: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Fact.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Fact {
        fn default() -> &'a Fact {
            <Fact as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Fact {
        pub fn new() -> Fact {
            ::std::default::Default::default()
        }

        // optional int32 type = 1;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int32 display = 2;

        pub fn display(&self) -> i32 {
            self.display.unwrap_or(0)
        }

        pub fn clear_display(&mut self) {
            self.display = ::std::option::Option::None;
        }

        pub fn has_display(&self) -> bool {
            self.display.is_some()
        }

        // Param is passed by value, moved
        pub fn set_display(&mut self, v: i32) {
            self.display = ::std::option::Option::Some(v);
        }

        // optional int32 value = 3;

        pub fn value(&self) -> i32 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: i32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional float interestingness = 4;

        pub fn interestingness(&self) -> f32 {
            self.interestingness.unwrap_or(0.)
        }

        pub fn clear_interestingness(&mut self) {
            self.interestingness = ::std::option::Option::None;
        }

        pub fn has_interestingness(&self) -> bool {
            self.interestingness.is_some()
        }

        // Param is passed by value, moved
        pub fn set_interestingness(&mut self, v: f32) {
            self.interestingness = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Fact {
        const NAME: &'static str = "Fact";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.display = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    37 => {
                        self.interestingness = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.display {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.interestingness {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.type_ {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.display {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.interestingness {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Fact {
            Fact::new()
        }

        fn clear(&mut self) {
            self.type_ = ::std::option::Option::None;
            self.display = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.interestingness = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Fact {
            static instance: Fact = Fact {
                type_: ::std::option::Option::None,
                display: ::std::option::Option::None,
                value: ::std::option::Option::None,
                interestingness: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Placement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Placement {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Placement.placement)
        pub placement: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Placement.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Placement {
        fn default() -> &'a Placement {
            <Placement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Placement {
        pub fn new() -> Placement {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 teamnumber = 2;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 placement = 3;

        pub fn placement(&self) -> i32 {
            self.placement.unwrap_or(0)
        }

        pub fn clear_placement(&mut self) {
            self.placement = ::std::option::Option::None;
        }

        pub fn has_placement(&self) -> bool {
            self.placement.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placement(&mut self, v: i32) {
            self.placement = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Placement {
        const NAME: &'static str = "Placement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.placement = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.placement {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.placement {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Placement {
            Placement::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.placement = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Placement {
            static instance: Placement = Placement {
                xuid: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                placement: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_SurvivalStats.Damage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Damage {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.to)
        pub to: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.to_hits)
        pub to_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.from)
        pub from: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_SurvivalStats.Damage.from_hits)
        pub from_hits: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_SurvivalStats.Damage.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Damage {
        fn default() -> &'a Damage {
            <Damage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Damage {
        pub fn new() -> Damage {
            ::std::default::Default::default()
        }

        // optional uint64 xuid = 1;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional int32 to = 2;

        pub fn to(&self) -> i32 {
            self.to.unwrap_or(0)
        }

        pub fn clear_to(&mut self) {
            self.to = ::std::option::Option::None;
        }

        pub fn has_to(&self) -> bool {
            self.to.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to(&mut self, v: i32) {
            self.to = ::std::option::Option::Some(v);
        }

        // optional int32 to_hits = 3;

        pub fn to_hits(&self) -> i32 {
            self.to_hits.unwrap_or(0)
        }

        pub fn clear_to_hits(&mut self) {
            self.to_hits = ::std::option::Option::None;
        }

        pub fn has_to_hits(&self) -> bool {
            self.to_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_to_hits(&mut self, v: i32) {
            self.to_hits = ::std::option::Option::Some(v);
        }

        // optional int32 from = 4;

        pub fn from(&self) -> i32 {
            self.from.unwrap_or(0)
        }

        pub fn clear_from(&mut self) {
            self.from = ::std::option::Option::None;
        }

        pub fn has_from(&self) -> bool {
            self.from.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from(&mut self, v: i32) {
            self.from = ::std::option::Option::Some(v);
        }

        // optional int32 from_hits = 5;

        pub fn from_hits(&self) -> i32 {
            self.from_hits.unwrap_or(0)
        }

        pub fn clear_from_hits(&mut self) {
            self.from_hits = ::std::option::Option::None;
        }

        pub fn has_from_hits(&self) -> bool {
            self.from_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_from_hits(&mut self, v: i32) {
            self.from_hits = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Damage {
        const NAME: &'static str = "Damage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.to = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.to_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.from = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.from_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.xuid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.to {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.to_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.from {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.from_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.xuid {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.to {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.to_hits {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.from {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.from_hits {
                os.write_int32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Damage {
            Damage::new()
        }

        fn clear(&mut self) {
            self.xuid = ::std::option::Option::None;
            self.to = ::std::option::Option::None;
            self.to_hits = ::std::option::Option::None;
            self.from = ::std::option::Option::None;
            self.from_hits = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Damage {
            static instance: Damage = Damage {
                xuid: ::std::option::Option::None,
                to: ::std::option::Option::None,
                to_hits: ::std::option::Option::None,
                from: ::std::option::Option::None,
                from_hits: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_EndOfMatchAllPlayersData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.allplayerdata)
    pub allplayerdata: ::std::vec::Vec<ccsusr_msg_end_of_match_all_players_data::PlayerData>,
    // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.scene)
    pub scene: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_EndOfMatchAllPlayersData {
    fn default() -> &'a CCSUsrMsg_EndOfMatchAllPlayersData {
        <CCSUsrMsg_EndOfMatchAllPlayersData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_EndOfMatchAllPlayersData {
    pub fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        ::std::default::Default::default()
    }

    // optional int32 scene = 2;

    pub fn scene(&self) -> i32 {
        self.scene.unwrap_or(0)
    }

    pub fn clear_scene(&mut self) {
        self.scene = ::std::option::Option::None;
    }

    pub fn has_scene(&self) -> bool {
        self.scene.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scene(&mut self, v: i32) {
        self.scene = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_EndOfMatchAllPlayersData {
    const NAME: &'static str = "CCSUsrMsg_EndOfMatchAllPlayersData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.allplayerdata.push(is.read_message()?);
                },
                16 => {
                    self.scene = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.allplayerdata {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.scene {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.allplayerdata {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.scene {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_EndOfMatchAllPlayersData {
        CCSUsrMsg_EndOfMatchAllPlayersData::new()
    }

    fn clear(&mut self) {
        self.allplayerdata.clear();
        self.scene = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_EndOfMatchAllPlayersData {
        static instance: CCSUsrMsg_EndOfMatchAllPlayersData = CCSUsrMsg_EndOfMatchAllPlayersData {
            allplayerdata: ::std::vec::Vec::new(),
            scene: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_EndOfMatchAllPlayersData`
pub mod ccsusr_msg_end_of_match_all_players_data {
    // @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Accolade {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.eaccolade)
        pub eaccolade: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.value)
        pub value: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.position)
        pub position: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.Accolade.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Accolade {
        fn default() -> &'a Accolade {
            <Accolade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Accolade {
        pub fn new() -> Accolade {
            ::std::default::Default::default()
        }

        // optional int32 eaccolade = 1;

        pub fn eaccolade(&self) -> i32 {
            self.eaccolade.unwrap_or(0)
        }

        pub fn clear_eaccolade(&mut self) {
            self.eaccolade = ::std::option::Option::None;
        }

        pub fn has_eaccolade(&self) -> bool {
            self.eaccolade.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eaccolade(&mut self, v: i32) {
            self.eaccolade = ::std::option::Option::Some(v);
        }

        // optional float value = 2;

        pub fn value(&self) -> f32 {
            self.value.unwrap_or(0.)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: f32) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional int32 position = 3;

        pub fn position(&self) -> i32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: i32) {
            self.position = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Accolade {
        const NAME: &'static str = "Accolade";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.eaccolade = ::std::option::Option::Some(is.read_int32()?);
                    },
                    21 => {
                        self.value = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.position = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.eaccolade {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.value {
                my_size += 1 + 4;
            }
            if let Some(v) = self.position {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.eaccolade {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.value {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.position {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Accolade {
            Accolade::new()
        }

        fn clear(&mut self) {
            self.eaccolade = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Accolade {
            static instance: Accolade = Accolade {
                eaccolade: ::std::option::Option::None,
                value: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerData {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.slot)
        pub slot: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.xuid)
        pub xuid: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.teamnumber)
        pub teamnumber: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.nomination)
        pub nomination: ::steam_vent_proto_common::protobuf::MessageField<Accolade>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.items)
        pub items: ::std::vec::Vec<super::super::cstrike15_gcmessages::CEconItemPreviewDataBlock>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.playercolor)
        pub playercolor: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.isbot)
        pub isbot: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_EndOfMatchAllPlayersData.PlayerData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerData {
        fn default() -> &'a PlayerData {
            <PlayerData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerData {
        pub fn new() -> PlayerData {
            ::std::default::Default::default()
        }

        // optional int32 slot = 1;

        pub fn slot(&self) -> i32 {
            self.slot.unwrap_or(-1i32)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: i32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional uint64 xuid = 2;

        pub fn xuid(&self) -> u64 {
            self.xuid.unwrap_or(0)
        }

        pub fn clear_xuid(&mut self) {
            self.xuid = ::std::option::Option::None;
        }

        pub fn has_xuid(&self) -> bool {
            self.xuid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xuid(&mut self, v: u64) {
            self.xuid = ::std::option::Option::Some(v);
        }

        // optional string name = 3;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 teamnumber = 4;

        pub fn teamnumber(&self) -> i32 {
            self.teamnumber.unwrap_or(0)
        }

        pub fn clear_teamnumber(&mut self) {
            self.teamnumber = ::std::option::Option::None;
        }

        pub fn has_teamnumber(&self) -> bool {
            self.teamnumber.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teamnumber(&mut self, v: i32) {
            self.teamnumber = ::std::option::Option::Some(v);
        }

        // optional int32 playercolor = 7;

        pub fn playercolor(&self) -> i32 {
            self.playercolor.unwrap_or(0)
        }

        pub fn clear_playercolor(&mut self) {
            self.playercolor = ::std::option::Option::None;
        }

        pub fn has_playercolor(&self) -> bool {
            self.playercolor.is_some()
        }

        // Param is passed by value, moved
        pub fn set_playercolor(&mut self, v: i32) {
            self.playercolor = ::std::option::Option::Some(v);
        }

        // optional bool isbot = 8;

        pub fn isbot(&self) -> bool {
            self.isbot.unwrap_or(false)
        }

        pub fn clear_isbot(&mut self) {
            self.isbot = ::std::option::Option::None;
        }

        pub fn has_isbot(&self) -> bool {
            self.isbot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_isbot(&mut self, v: bool) {
            self.isbot = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerData {
        const NAME: &'static str = "PlayerData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    26 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    32 => {
                        self.teamnumber = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.nomination)?;
                    },
                    50 => {
                        self.items.push(is.read_message()?);
                    },
                    56 => {
                        self.playercolor = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.isbot = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.xuid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            if let Some(v) = self.teamnumber {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.nomination.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.playercolor {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.isbot {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.xuid {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.teamnumber {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.nomination.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            for v in &self.items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.playercolor {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.isbot {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerData {
            PlayerData::new()
        }

        fn clear(&mut self) {
            self.slot = ::std::option::Option::None;
            self.xuid = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.teamnumber = ::std::option::Option::None;
            self.nomination.clear();
            self.items.clear();
            self.playercolor = ::std::option::Option::None;
            self.isbot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerData {
            static instance: PlayerData = PlayerData {
                slot: ::std::option::Option::None,
                xuid: ::std::option::Option::None,
                name: ::std::option::Option::None,
                teamnumber: ::std::option::Option::None,
                nomination: ::steam_vent_proto_common::protobuf::MessageField::none(),
                items: ::std::vec::Vec::new(),
                playercolor: ::std::option::Option::None,
                isbot: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RoundEndReportData {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.init_conditions)
    pub init_conditions: ::steam_vent_proto_common::protobuf::MessageField<ccsusr_msg_round_end_report_data::InitialConditions>,
    // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.all_rer_event_data)
    pub all_rer_event_data: ::std::vec::Vec<ccsusr_msg_round_end_report_data::RerEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RoundEndReportData {
    fn default() -> &'a CCSUsrMsg_RoundEndReportData {
        <CCSUsrMsg_RoundEndReportData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RoundEndReportData {
    pub fn new() -> CCSUsrMsg_RoundEndReportData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_RoundEndReportData {
    const NAME: &'static str = "CCSUsrMsg_RoundEndReportData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.init_conditions)?;
                },
                18 => {
                    self.all_rer_event_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.init_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.all_rer_event_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.init_conditions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.all_rer_event_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RoundEndReportData {
        CCSUsrMsg_RoundEndReportData::new()
    }

    fn clear(&mut self) {
        self.init_conditions.clear();
        self.all_rer_event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RoundEndReportData {
        static instance: CCSUsrMsg_RoundEndReportData = CCSUsrMsg_RoundEndReportData {
            init_conditions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            all_rer_event_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CCSUsrMsg_RoundEndReportData`
pub mod ccsusr_msg_round_end_report_data {
    // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RerEvent {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.timestamp)
        pub timestamp: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.ct_alive)
        pub ct_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.t_alive)
        pub t_alive: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.victim_data)
        pub victim_data: ::steam_vent_proto_common::protobuf::MessageField<rer_event::Victim>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.objective_data)
        pub objective_data: ::steam_vent_proto_common::protobuf::MessageField<rer_event::Objective>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.all_damage_data)
        pub all_damage_data: ::std::vec::Vec<rer_event::Damage>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RerEvent {
        fn default() -> &'a RerEvent {
            <RerEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RerEvent {
        pub fn new() -> RerEvent {
            ::std::default::Default::default()
        }

        // optional float timestamp = 1;

        pub fn timestamp(&self) -> f32 {
            self.timestamp.unwrap_or(0.)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: f32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 2;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }

        // optional int32 ct_alive = 3;

        pub fn ct_alive(&self) -> i32 {
            self.ct_alive.unwrap_or(0)
        }

        pub fn clear_ct_alive(&mut self) {
            self.ct_alive = ::std::option::Option::None;
        }

        pub fn has_ct_alive(&self) -> bool {
            self.ct_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_alive(&mut self, v: i32) {
            self.ct_alive = ::std::option::Option::Some(v);
        }

        // optional int32 t_alive = 4;

        pub fn t_alive(&self) -> i32 {
            self.t_alive.unwrap_or(0)
        }

        pub fn clear_t_alive(&mut self) {
            self.t_alive = ::std::option::Option::None;
        }

        pub fn has_t_alive(&self) -> bool {
            self.t_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_alive(&mut self, v: i32) {
            self.t_alive = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RerEvent {
        const NAME: &'static str = "RerEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.timestamp = ::std::option::Option::Some(is.read_float()?);
                    },
                    16 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.ct_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.t_alive = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.victim_data)?;
                    },
                    50 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.objective_data)?;
                    },
                    58 => {
                        self.all_damage_data.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += 1 + 4;
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.ct_alive {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.t_alive {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.victim_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.objective_data.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.all_damage_data {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.ct_alive {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.t_alive {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.victim_data.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.objective_data.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            for v in &self.all_damage_data {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RerEvent {
            RerEvent::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.ct_alive = ::std::option::Option::None;
            self.t_alive = ::std::option::Option::None;
            self.victim_data.clear();
            self.objective_data.clear();
            self.all_damage_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RerEvent {
            static instance: RerEvent = RerEvent {
                timestamp: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                ct_alive: ::std::option::Option::None,
                t_alive: ::std::option::Option::None,
                victim_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
                objective_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
                all_damage_data: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `RerEvent`
    pub mod rer_event {
        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Victim)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Victim {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.team_number)
            pub team_number: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.playerslot)
            pub playerslot: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.xuid)
            pub xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.color)
            pub color: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.is_bot)
            pub is_bot: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.is_dead)
            pub is_dead: ::std::option::Option<bool>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Victim.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Victim {
            fn default() -> &'a Victim {
                <Victim as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Victim {
            pub fn new() -> Victim {
                ::std::default::Default::default()
            }

            // optional int32 team_number = 1;

            pub fn team_number(&self) -> i32 {
                self.team_number.unwrap_or(0)
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: i32) {
                self.team_number = ::std::option::Option::Some(v);
            }

            // optional int32 playerslot = 2;

            pub fn playerslot(&self) -> i32 {
                self.playerslot.unwrap_or(-1i32)
            }

            pub fn clear_playerslot(&mut self) {
                self.playerslot = ::std::option::Option::None;
            }

            pub fn has_playerslot(&self) -> bool {
                self.playerslot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_playerslot(&mut self, v: i32) {
                self.playerslot = ::std::option::Option::Some(v);
            }

            // optional uint64 xuid = 3;

            pub fn xuid(&self) -> u64 {
                self.xuid.unwrap_or(0)
            }

            pub fn clear_xuid(&mut self) {
                self.xuid = ::std::option::Option::None;
            }

            pub fn has_xuid(&self) -> bool {
                self.xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xuid(&mut self, v: u64) {
                self.xuid = ::std::option::Option::Some(v);
            }

            // optional int32 color = 4;

            pub fn color(&self) -> i32 {
                self.color.unwrap_or(0)
            }

            pub fn clear_color(&mut self) {
                self.color = ::std::option::Option::None;
            }

            pub fn has_color(&self) -> bool {
                self.color.is_some()
            }

            // Param is passed by value, moved
            pub fn set_color(&mut self, v: i32) {
                self.color = ::std::option::Option::Some(v);
            }

            // optional bool is_bot = 5;

            pub fn is_bot(&self) -> bool {
                self.is_bot.unwrap_or(false)
            }

            pub fn clear_is_bot(&mut self) {
                self.is_bot = ::std::option::Option::None;
            }

            pub fn has_is_bot(&self) -> bool {
                self.is_bot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_bot(&mut self, v: bool) {
                self.is_bot = ::std::option::Option::Some(v);
            }

            // optional bool is_dead = 6;

            pub fn is_dead(&self) -> bool {
                self.is_dead.unwrap_or(false)
            }

            pub fn clear_is_dead(&mut self) {
                self.is_dead = ::std::option::Option::None;
            }

            pub fn has_is_dead(&self) -> bool {
                self.is_dead.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_dead(&mut self, v: bool) {
                self.is_dead = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Victim {
            const NAME: &'static str = "Victim";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.team_number = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.playerslot = ::std::option::Option::Some(is.read_int32()?);
                        },
                        24 => {
                            self.xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        32 => {
                            self.color = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.is_bot = ::std::option::Option::Some(is.read_bool()?);
                        },
                        48 => {
                            self.is_dead = ::std::option::Option::Some(is.read_bool()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.team_number {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.playerslot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
                }
                if let Some(v) = self.xuid {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
                }
                if let Some(v) = self.color {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.is_bot {
                    my_size += 1 + 1;
                }
                if let Some(v) = self.is_dead {
                    my_size += 1 + 1;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.team_number {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.playerslot {
                    os.write_int32(2, v)?;
                }
                if let Some(v) = self.xuid {
                    os.write_uint64(3, v)?;
                }
                if let Some(v) = self.color {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.is_bot {
                    os.write_bool(5, v)?;
                }
                if let Some(v) = self.is_dead {
                    os.write_bool(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Victim {
                Victim::new()
            }

            fn clear(&mut self) {
                self.team_number = ::std::option::Option::None;
                self.playerslot = ::std::option::Option::None;
                self.xuid = ::std::option::Option::None;
                self.color = ::std::option::Option::None;
                self.is_bot = ::std::option::Option::None;
                self.is_dead = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Victim {
                static instance: Victim = Victim {
                    team_number: ::std::option::Option::None,
                    playerslot: ::std::option::Option::None,
                    xuid: ::std::option::Option::None,
                    color: ::std::option::Option::None,
                    is_bot: ::std::option::Option::None,
                    is_dead: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Objective)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Objective {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Objective.type)
            pub type_: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Objective.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Objective {
            fn default() -> &'a Objective {
                <Objective as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Objective {
            pub fn new() -> Objective {
                ::std::default::Default::default()
            }

            // optional int32 type = 1;

            pub fn type_(&self) -> i32 {
                self.type_.unwrap_or(0)
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: i32) {
                self.type_ = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Objective {
            const NAME: &'static str = "Objective";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_ {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.type_ {
                    os.write_int32(1, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Objective {
                Objective::new()
            }

            fn clear(&mut self) {
                self.type_ = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Objective {
                static instance: Objective = Objective {
                    type_: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.RerEvent.Damage)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Damage {
            // message fields
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.other_playerslot)
            pub other_playerslot: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.other_xuid)
            pub other_xuid: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.health_removed)
            pub health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.num_hits)
            pub num_hits: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.return_health_removed)
            pub return_health_removed: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.return_num_hits)
            pub return_num_hits: ::std::option::Option<i32>,
            // special fields
            // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.RerEvent.Damage.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Damage {
            fn default() -> &'a Damage {
                <Damage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Damage {
            pub fn new() -> Damage {
                ::std::default::Default::default()
            }

            // optional int32 other_playerslot = 1;

            pub fn other_playerslot(&self) -> i32 {
                self.other_playerslot.unwrap_or(-1i32)
            }

            pub fn clear_other_playerslot(&mut self) {
                self.other_playerslot = ::std::option::Option::None;
            }

            pub fn has_other_playerslot(&self) -> bool {
                self.other_playerslot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_other_playerslot(&mut self, v: i32) {
                self.other_playerslot = ::std::option::Option::Some(v);
            }

            // optional uint64 other_xuid = 2;

            pub fn other_xuid(&self) -> u64 {
                self.other_xuid.unwrap_or(0)
            }

            pub fn clear_other_xuid(&mut self) {
                self.other_xuid = ::std::option::Option::None;
            }

            pub fn has_other_xuid(&self) -> bool {
                self.other_xuid.is_some()
            }

            // Param is passed by value, moved
            pub fn set_other_xuid(&mut self, v: u64) {
                self.other_xuid = ::std::option::Option::Some(v);
            }

            // optional int32 health_removed = 3;

            pub fn health_removed(&self) -> i32 {
                self.health_removed.unwrap_or(0)
            }

            pub fn clear_health_removed(&mut self) {
                self.health_removed = ::std::option::Option::None;
            }

            pub fn has_health_removed(&self) -> bool {
                self.health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_health_removed(&mut self, v: i32) {
                self.health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 num_hits = 4;

            pub fn num_hits(&self) -> i32 {
                self.num_hits.unwrap_or(0)
            }

            pub fn clear_num_hits(&mut self) {
                self.num_hits = ::std::option::Option::None;
            }

            pub fn has_num_hits(&self) -> bool {
                self.num_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_num_hits(&mut self, v: i32) {
                self.num_hits = ::std::option::Option::Some(v);
            }

            // optional int32 return_health_removed = 5;

            pub fn return_health_removed(&self) -> i32 {
                self.return_health_removed.unwrap_or(0)
            }

            pub fn clear_return_health_removed(&mut self) {
                self.return_health_removed = ::std::option::Option::None;
            }

            pub fn has_return_health_removed(&self) -> bool {
                self.return_health_removed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_return_health_removed(&mut self, v: i32) {
                self.return_health_removed = ::std::option::Option::Some(v);
            }

            // optional int32 return_num_hits = 6;

            pub fn return_num_hits(&self) -> i32 {
                self.return_num_hits.unwrap_or(0)
            }

            pub fn clear_return_num_hits(&mut self) {
                self.return_num_hits = ::std::option::Option::None;
            }

            pub fn has_return_num_hits(&self) -> bool {
                self.return_num_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_return_num_hits(&mut self, v: i32) {
                self.return_num_hits = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Damage {
            const NAME: &'static str = "Damage";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.other_playerslot = ::std::option::Option::Some(is.read_int32()?);
                        },
                        16 => {
                            self.other_xuid = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        24 => {
                            self.health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        32 => {
                            self.num_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.return_health_removed = ::std::option::Option::Some(is.read_int32()?);
                        },
                        48 => {
                            self.return_num_hits = ::std::option::Option::Some(is.read_int32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.other_playerslot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                }
                if let Some(v) = self.other_xuid {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
                }
                if let Some(v) = self.health_removed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
                }
                if let Some(v) = self.num_hits {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.return_health_removed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
                }
                if let Some(v) = self.return_num_hits {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.other_playerslot {
                    os.write_int32(1, v)?;
                }
                if let Some(v) = self.other_xuid {
                    os.write_uint64(2, v)?;
                }
                if let Some(v) = self.health_removed {
                    os.write_int32(3, v)?;
                }
                if let Some(v) = self.num_hits {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.return_health_removed {
                    os.write_int32(5, v)?;
                }
                if let Some(v) = self.return_num_hits {
                    os.write_int32(6, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Damage {
                Damage::new()
            }

            fn clear(&mut self) {
                self.other_playerslot = ::std::option::Option::None;
                self.other_xuid = ::std::option::Option::None;
                self.health_removed = ::std::option::Option::None;
                self.num_hits = ::std::option::Option::None;
                self.return_health_removed = ::std::option::Option::None;
                self.return_num_hits = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Damage {
                static instance: Damage = Damage {
                    other_playerslot: ::std::option::Option::None,
                    other_xuid: ::std::option::Option::None,
                    health_removed: ::std::option::Option::None,
                    num_hits: ::std::option::Option::None,
                    return_health_removed: ::std::option::Option::None,
                    return_num_hits: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CCSUsrMsg_RoundEndReportData.InitialConditions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InitialConditions {
        // message fields
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.ct_equip_value)
        pub ct_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.t_equip_value)
        pub t_equip_value: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CCSUsrMsg_RoundEndReportData.InitialConditions.terrorist_odds)
        pub terrorist_odds: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CCSUsrMsg_RoundEndReportData.InitialConditions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InitialConditions {
        fn default() -> &'a InitialConditions {
            <InitialConditions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl InitialConditions {
        pub fn new() -> InitialConditions {
            ::std::default::Default::default()
        }

        // optional int32 ct_equip_value = 1;

        pub fn ct_equip_value(&self) -> i32 {
            self.ct_equip_value.unwrap_or(0)
        }

        pub fn clear_ct_equip_value(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
        }

        pub fn has_ct_equip_value(&self) -> bool {
            self.ct_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ct_equip_value(&mut self, v: i32) {
            self.ct_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 t_equip_value = 2;

        pub fn t_equip_value(&self) -> i32 {
            self.t_equip_value.unwrap_or(0)
        }

        pub fn clear_t_equip_value(&mut self) {
            self.t_equip_value = ::std::option::Option::None;
        }

        pub fn has_t_equip_value(&self) -> bool {
            self.t_equip_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_t_equip_value(&mut self, v: i32) {
            self.t_equip_value = ::std::option::Option::Some(v);
        }

        // optional int32 terrorist_odds = 3;

        pub fn terrorist_odds(&self) -> i32 {
            self.terrorist_odds.unwrap_or(0)
        }

        pub fn clear_terrorist_odds(&mut self) {
            self.terrorist_odds = ::std::option::Option::None;
        }

        pub fn has_terrorist_odds(&self) -> bool {
            self.terrorist_odds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_terrorist_odds(&mut self, v: i32) {
            self.terrorist_odds = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for InitialConditions {
        const NAME: &'static str = "InitialConditions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.ct_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.t_equip_value = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.terrorist_odds = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.ct_equip_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.t_equip_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.terrorist_odds {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.ct_equip_value {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.t_equip_value {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.terrorist_odds {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InitialConditions {
            InitialConditions::new()
        }

        fn clear(&mut self) {
            self.ct_equip_value = ::std::option::Option::None;
            self.t_equip_value = ::std::option::Option::None;
            self.terrorist_odds = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InitialConditions {
            static instance: InitialConditions = InitialConditions {
                ct_equip_value: ::std::option::Option::None,
                t_equip_value: ::std::option::Option::None,
                terrorist_odds: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_PostRoundDamageReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_PostRoundDamageReport {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.other_xuid)
    pub other_xuid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_kill_type)
    pub given_kill_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_health_removed)
    pub given_health_removed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.given_num_hits)
    pub given_num_hits: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_kill_type)
    pub taken_kill_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_health_removed)
    pub taken_health_removed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_PostRoundDamageReport.taken_num_hits)
    pub taken_num_hits: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_PostRoundDamageReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_PostRoundDamageReport {
    fn default() -> &'a CCSUsrMsg_PostRoundDamageReport {
        <CCSUsrMsg_PostRoundDamageReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_PostRoundDamageReport {
    pub fn new() -> CCSUsrMsg_PostRoundDamageReport {
        ::std::default::Default::default()
    }

    // optional uint64 other_xuid = 1;

    pub fn other_xuid(&self) -> u64 {
        self.other_xuid.unwrap_or(0)
    }

    pub fn clear_other_xuid(&mut self) {
        self.other_xuid = ::std::option::Option::None;
    }

    pub fn has_other_xuid(&self) -> bool {
        self.other_xuid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_xuid(&mut self, v: u64) {
        self.other_xuid = ::std::option::Option::Some(v);
    }

    // optional int32 given_kill_type = 2;

    pub fn given_kill_type(&self) -> i32 {
        self.given_kill_type.unwrap_or(0)
    }

    pub fn clear_given_kill_type(&mut self) {
        self.given_kill_type = ::std::option::Option::None;
    }

    pub fn has_given_kill_type(&self) -> bool {
        self.given_kill_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_kill_type(&mut self, v: i32) {
        self.given_kill_type = ::std::option::Option::Some(v);
    }

    // optional int32 given_health_removed = 3;

    pub fn given_health_removed(&self) -> i32 {
        self.given_health_removed.unwrap_or(0)
    }

    pub fn clear_given_health_removed(&mut self) {
        self.given_health_removed = ::std::option::Option::None;
    }

    pub fn has_given_health_removed(&self) -> bool {
        self.given_health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_health_removed(&mut self, v: i32) {
        self.given_health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 given_num_hits = 4;

    pub fn given_num_hits(&self) -> i32 {
        self.given_num_hits.unwrap_or(0)
    }

    pub fn clear_given_num_hits(&mut self) {
        self.given_num_hits = ::std::option::Option::None;
    }

    pub fn has_given_num_hits(&self) -> bool {
        self.given_num_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_given_num_hits(&mut self, v: i32) {
        self.given_num_hits = ::std::option::Option::Some(v);
    }

    // optional int32 taken_kill_type = 5;

    pub fn taken_kill_type(&self) -> i32 {
        self.taken_kill_type.unwrap_or(0)
    }

    pub fn clear_taken_kill_type(&mut self) {
        self.taken_kill_type = ::std::option::Option::None;
    }

    pub fn has_taken_kill_type(&self) -> bool {
        self.taken_kill_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_kill_type(&mut self, v: i32) {
        self.taken_kill_type = ::std::option::Option::Some(v);
    }

    // optional int32 taken_health_removed = 6;

    pub fn taken_health_removed(&self) -> i32 {
        self.taken_health_removed.unwrap_or(0)
    }

    pub fn clear_taken_health_removed(&mut self) {
        self.taken_health_removed = ::std::option::Option::None;
    }

    pub fn has_taken_health_removed(&self) -> bool {
        self.taken_health_removed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_health_removed(&mut self, v: i32) {
        self.taken_health_removed = ::std::option::Option::Some(v);
    }

    // optional int32 taken_num_hits = 7;

    pub fn taken_num_hits(&self) -> i32 {
        self.taken_num_hits.unwrap_or(0)
    }

    pub fn clear_taken_num_hits(&mut self) {
        self.taken_num_hits = ::std::option::Option::None;
    }

    pub fn has_taken_num_hits(&self) -> bool {
        self.taken_num_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_taken_num_hits(&mut self, v: i32) {
        self.taken_num_hits = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_PostRoundDamageReport {
    const NAME: &'static str = "CCSUsrMsg_PostRoundDamageReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.other_xuid = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.given_kill_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.given_health_removed = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.given_num_hits = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.taken_kill_type = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.taken_health_removed = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.taken_num_hits = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_xuid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.given_kill_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.given_health_removed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.given_num_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.taken_kill_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.taken_health_removed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.taken_num_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.other_xuid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.given_kill_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.given_health_removed {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.given_num_hits {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.taken_kill_type {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.taken_health_removed {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.taken_num_hits {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_PostRoundDamageReport {
        CCSUsrMsg_PostRoundDamageReport::new()
    }

    fn clear(&mut self) {
        self.other_xuid = ::std::option::Option::None;
        self.given_kill_type = ::std::option::Option::None;
        self.given_health_removed = ::std::option::Option::None;
        self.given_num_hits = ::std::option::Option::None;
        self.taken_kill_type = ::std::option::Option::None;
        self.taken_health_removed = ::std::option::Option::None;
        self.taken_num_hits = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_PostRoundDamageReport {
        static instance: CCSUsrMsg_PostRoundDamageReport = CCSUsrMsg_PostRoundDamageReport {
            other_xuid: ::std::option::Option::None,
            given_kill_type: ::std::option::Option::None,
            given_health_removed: ::std::option::Option::None,
            given_num_hits: ::std::option::Option::None,
            taken_kill_type: ::std::option::Option::None,
            taken_health_removed: ::std::option::Option::None,
            taken_num_hits: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_CurrentRoundOdds)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_CurrentRoundOdds {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_CurrentRoundOdds.odds)
    pub odds: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_CurrentRoundOdds.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_CurrentRoundOdds {
    fn default() -> &'a CCSUsrMsg_CurrentRoundOdds {
        <CCSUsrMsg_CurrentRoundOdds as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_CurrentRoundOdds {
    pub fn new() -> CCSUsrMsg_CurrentRoundOdds {
        ::std::default::Default::default()
    }

    // optional int32 odds = 1;

    pub fn odds(&self) -> i32 {
        self.odds.unwrap_or(0)
    }

    pub fn clear_odds(&mut self) {
        self.odds = ::std::option::Option::None;
    }

    pub fn has_odds(&self) -> bool {
        self.odds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_odds(&mut self, v: i32) {
        self.odds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_CurrentRoundOdds {
    const NAME: &'static str = "CCSUsrMsg_CurrentRoundOdds";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.odds = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.odds {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.odds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_CurrentRoundOdds {
        CCSUsrMsg_CurrentRoundOdds::new()
    }

    fn clear(&mut self) {
        self.odds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_CurrentRoundOdds {
        static instance: CCSUsrMsg_CurrentRoundOdds = CCSUsrMsg_CurrentRoundOdds {
            odds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_DeepStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DeepStats {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DeepStats.stats)
    pub stats: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_ClientDeepStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DeepStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DeepStats {
    fn default() -> &'a CCSUsrMsg_DeepStats {
        <CCSUsrMsg_DeepStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DeepStats {
    pub fn new() -> CCSUsrMsg_DeepStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_DeepStats {
    const NAME: &'static str = "CCSUsrMsg_DeepStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DeepStats {
        CCSUsrMsg_DeepStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DeepStats {
        static instance: CCSUsrMsg_DeepStats = CCSUsrMsg_DeepStats {
            stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ShootInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ShootInfo {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.frame_number)
    pub frame_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.hitbox_transforms)
    pub hitbox_transforms: ::std::vec::Vec<super::networkbasetypes::CMsgTransform>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.shoot_pos)
    pub shoot_pos: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ShootInfo.shoot_dir)
    pub shoot_dir: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ShootInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ShootInfo {
    fn default() -> &'a CCSUsrMsg_ShootInfo {
        <CCSUsrMsg_ShootInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ShootInfo {
    pub fn new() -> CCSUsrMsg_ShootInfo {
        ::std::default::Default::default()
    }

    // optional int32 frame_number = 1;

    pub fn frame_number(&self) -> i32 {
        self.frame_number.unwrap_or(0)
    }

    pub fn clear_frame_number(&mut self) {
        self.frame_number = ::std::option::Option::None;
    }

    pub fn has_frame_number(&self) -> bool {
        self.frame_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_number(&mut self, v: i32) {
        self.frame_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ShootInfo {
    const NAME: &'static str = "CCSUsrMsg_ShootInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.frame_number = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.hitbox_transforms.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_pos)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.shoot_dir)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.hitbox_transforms {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.shoot_pos.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.frame_number {
            os.write_int32(1, v)?;
        }
        for v in &self.hitbox_transforms {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.shoot_pos.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.shoot_dir.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ShootInfo {
        CCSUsrMsg_ShootInfo::new()
    }

    fn clear(&mut self) {
        self.frame_number = ::std::option::Option::None;
        self.hitbox_transforms.clear();
        self.shoot_pos.clear();
        self.shoot_dir.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ShootInfo {
        static instance: CCSUsrMsg_ShootInfo = CCSUsrMsg_ShootInfo {
            frame_number: ::std::option::Option::None,
            hitbox_transforms: ::std::vec::Vec::new(),
            shoot_pos: ::steam_vent_proto_common::protobuf::MessageField::none(),
            shoot_dir: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ResetHud)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ResetHud {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ResetHud.reset)
    pub reset: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ResetHud.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ResetHud {
    fn default() -> &'a CCSUsrMsg_ResetHud {
        <CCSUsrMsg_ResetHud as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ResetHud {
    pub fn new() -> CCSUsrMsg_ResetHud {
        ::std::default::Default::default()
    }

    // optional bool reset = 1;

    pub fn reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }

    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ResetHud {
    const NAME: &'static str = "CCSUsrMsg_ResetHud";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reset {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reset {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ResetHud {
        CCSUsrMsg_ResetHud::new()
    }

    fn clear(&mut self) {
        self.reset = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ResetHud {
        static instance: CCSUsrMsg_ResetHud = CCSUsrMsg_ResetHud {
            reset: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_GameTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_GameTitle {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_GameTitle.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_GameTitle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_GameTitle {
    fn default() -> &'a CCSUsrMsg_GameTitle {
        <CCSUsrMsg_GameTitle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_GameTitle {
    pub fn new() -> CCSUsrMsg_GameTitle {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_GameTitle {
    const NAME: &'static str = "CCSUsrMsg_GameTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_GameTitle {
        CCSUsrMsg_GameTitle::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_GameTitle {
        static instance: CCSUsrMsg_GameTitle = CCSUsrMsg_GameTitle {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_RequestState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_RequestState {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_RequestState.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_RequestState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_RequestState {
    fn default() -> &'a CCSUsrMsg_RequestState {
        <CCSUsrMsg_RequestState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_RequestState {
    pub fn new() -> CCSUsrMsg_RequestState {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_RequestState {
    const NAME: &'static str = "CCSUsrMsg_RequestState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_RequestState {
        CCSUsrMsg_RequestState::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_RequestState {
        static instance: CCSUsrMsg_RequestState = CCSUsrMsg_RequestState {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_StopSpectatorMode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_StopSpectatorMode {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_StopSpectatorMode.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_StopSpectatorMode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_StopSpectatorMode {
    fn default() -> &'a CCSUsrMsg_StopSpectatorMode {
        <CCSUsrMsg_StopSpectatorMode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_StopSpectatorMode {
    pub fn new() -> CCSUsrMsg_StopSpectatorMode {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_StopSpectatorMode {
    const NAME: &'static str = "CCSUsrMsg_StopSpectatorMode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_StopSpectatorMode {
        CCSUsrMsg_StopSpectatorMode::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_StopSpectatorMode {
        static instance: CCSUsrMsg_StopSpectatorMode = CCSUsrMsg_StopSpectatorMode {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_DisconnectToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_DisconnectToLobby {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_DisconnectToLobby.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_DisconnectToLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_DisconnectToLobby {
    fn default() -> &'a CCSUsrMsg_DisconnectToLobby {
        <CCSUsrMsg_DisconnectToLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_DisconnectToLobby {
    pub fn new() -> CCSUsrMsg_DisconnectToLobby {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_DisconnectToLobby {
    const NAME: &'static str = "CCSUsrMsg_DisconnectToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_DisconnectToLobby {
        CCSUsrMsg_DisconnectToLobby::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_DisconnectToLobby {
        static instance: CCSUsrMsg_DisconnectToLobby = CCSUsrMsg_DisconnectToLobby {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_WarmupHasEnded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_WarmupHasEnded {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_WarmupHasEnded.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_WarmupHasEnded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_WarmupHasEnded {
    fn default() -> &'a CCSUsrMsg_WarmupHasEnded {
        <CCSUsrMsg_WarmupHasEnded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_WarmupHasEnded {
    pub fn new() -> CCSUsrMsg_WarmupHasEnded {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_WarmupHasEnded {
    const NAME: &'static str = "CCSUsrMsg_WarmupHasEnded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_WarmupHasEnded {
        CCSUsrMsg_WarmupHasEnded::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_WarmupHasEnded {
        static instance: CCSUsrMsg_WarmupHasEnded = CCSUsrMsg_WarmupHasEnded {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ClientInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ClientInfo {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ClientInfo.dummy)
    pub dummy: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ClientInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ClientInfo {
    fn default() -> &'a CCSUsrMsg_ClientInfo {
        <CCSUsrMsg_ClientInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ClientInfo {
    pub fn new() -> CCSUsrMsg_ClientInfo {
        ::std::default::Default::default()
    }

    // optional int32 dummy = 1;

    pub fn dummy(&self) -> i32 {
        self.dummy.unwrap_or(0)
    }

    pub fn clear_dummy(&mut self) {
        self.dummy = ::std::option::Option::None;
    }

    pub fn has_dummy(&self) -> bool {
        self.dummy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dummy(&mut self, v: i32) {
        self.dummy = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ClientInfo {
    const NAME: &'static str = "CCSUsrMsg_ClientInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dummy = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dummy {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dummy {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ClientInfo {
        CCSUsrMsg_ClientInfo::new()
    }

    fn clear(&mut self) {
        self.dummy = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ClientInfo {
        static instance: CCSUsrMsg_ClientInfo = CCSUsrMsg_ClientInfo {
            dummy: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_ServerRankRevealAll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_ServerRankRevealAll {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankRevealAll.seconds_till_shutdown)
    pub seconds_till_shutdown: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_ServerRankRevealAll.reservation)
    pub reservation: ::steam_vent_proto_common::protobuf::MessageField<super::cstrike15_gcmessages::CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_ServerRankRevealAll.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_ServerRankRevealAll {
    fn default() -> &'a CCSUsrMsg_ServerRankRevealAll {
        <CCSUsrMsg_ServerRankRevealAll as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_ServerRankRevealAll {
    pub fn new() -> CCSUsrMsg_ServerRankRevealAll {
        ::std::default::Default::default()
    }

    // optional int32 seconds_till_shutdown = 1;

    pub fn seconds_till_shutdown(&self) -> i32 {
        self.seconds_till_shutdown.unwrap_or(0)
    }

    pub fn clear_seconds_till_shutdown(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
    }

    pub fn has_seconds_till_shutdown(&self) -> bool {
        self.seconds_till_shutdown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_till_shutdown(&mut self, v: i32) {
        self.seconds_till_shutdown = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_ServerRankRevealAll {
    const NAME: &'static str = "CCSUsrMsg_ServerRankRevealAll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds_till_shutdown = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.reservation)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.seconds_till_shutdown {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.reservation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.seconds_till_shutdown {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.reservation.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_ServerRankRevealAll {
        CCSUsrMsg_ServerRankRevealAll::new()
    }

    fn clear(&mut self) {
        self.seconds_till_shutdown = ::std::option::Option::None;
        self.reservation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_ServerRankRevealAll {
        static instance: CCSUsrMsg_ServerRankRevealAll = CCSUsrMsg_ServerRankRevealAll {
            seconds_till_shutdown: ::std::option::Option::None,
            reservation: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsgPreMatchSayText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsgPreMatchSayText {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CCSUsrMsgPreMatchSayText.all_chat)
    pub all_chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsgPreMatchSayText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsgPreMatchSayText {
    fn default() -> &'a CCSUsrMsgPreMatchSayText {
        <CCSUsrMsgPreMatchSayText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsgPreMatchSayText {
    pub fn new() -> CCSUsrMsgPreMatchSayText {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool all_chat = 3;

    pub fn all_chat(&self) -> bool {
        self.all_chat.unwrap_or(false)
    }

    pub fn clear_all_chat(&mut self) {
        self.all_chat = ::std::option::Option::None;
    }

    pub fn has_all_chat(&self) -> bool {
        self.all_chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_all_chat(&mut self, v: bool) {
        self.all_chat = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsgPreMatchSayText {
    const NAME: &'static str = "CCSUsrMsgPreMatchSayText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.all_chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.all_chat {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.all_chat {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsgPreMatchSayText {
        CCSUsrMsgPreMatchSayText::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.all_chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsgPreMatchSayText {
        static instance: CCSUsrMsgPreMatchSayText = CCSUsrMsgPreMatchSayText {
            account_id: ::std::option::Option::None,
            text: ::std::option::Option::None,
            all_chat: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CCSUsrMsg_SnapTapStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CCSUsrMsg_SnapTapStats {
    // message fields
    // @@protoc_insertion_point(field:CCSUsrMsg_SnapTapStats.perfect_bucket)
    pub perfect_bucket: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SnapTapStats.overlap_bucket)
    pub overlap_bucket: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SnapTapStats.underlap_bucket)
    pub underlap_bucket: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CCSUsrMsg_SnapTapStats.max_success_in_20)
    pub max_success_in_20: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CCSUsrMsg_SnapTapStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CCSUsrMsg_SnapTapStats {
    fn default() -> &'a CCSUsrMsg_SnapTapStats {
        <CCSUsrMsg_SnapTapStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CCSUsrMsg_SnapTapStats {
    pub fn new() -> CCSUsrMsg_SnapTapStats {
        ::std::default::Default::default()
    }

    // optional uint32 perfect_bucket = 1;

    pub fn perfect_bucket(&self) -> u32 {
        self.perfect_bucket.unwrap_or(0)
    }

    pub fn clear_perfect_bucket(&mut self) {
        self.perfect_bucket = ::std::option::Option::None;
    }

    pub fn has_perfect_bucket(&self) -> bool {
        self.perfect_bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perfect_bucket(&mut self, v: u32) {
        self.perfect_bucket = ::std::option::Option::Some(v);
    }

    // optional uint32 max_success_in_20 = 4;

    pub fn max_success_in_20(&self) -> u32 {
        self.max_success_in_20.unwrap_or(0)
    }

    pub fn clear_max_success_in_20(&mut self) {
        self.max_success_in_20 = ::std::option::Option::None;
    }

    pub fn has_max_success_in_20(&self) -> bool {
        self.max_success_in_20.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_success_in_20(&mut self, v: u32) {
        self.max_success_in_20 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CCSUsrMsg_SnapTapStats {
    const NAME: &'static str = "CCSUsrMsg_SnapTapStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.perfect_bucket = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.overlap_bucket)?;
                },
                16 => {
                    self.overlap_bucket.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.underlap_bucket)?;
                },
                24 => {
                    self.underlap_bucket.push(is.read_uint32()?);
                },
                32 => {
                    self.max_success_in_20 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.perfect_bucket {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.overlap_bucket {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.underlap_bucket {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.max_success_in_20 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.perfect_bucket {
            os.write_uint32(1, v)?;
        }
        for v in &self.overlap_bucket {
            os.write_uint32(2, *v)?;
        };
        for v in &self.underlap_bucket {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.max_success_in_20 {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CCSUsrMsg_SnapTapStats {
        CCSUsrMsg_SnapTapStats::new()
    }

    fn clear(&mut self) {
        self.perfect_bucket = ::std::option::Option::None;
        self.overlap_bucket.clear();
        self.underlap_bucket.clear();
        self.max_success_in_20 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CCSUsrMsg_SnapTapStats {
        static instance: CCSUsrMsg_SnapTapStats = CCSUsrMsg_SnapTapStats {
            perfect_bucket: ::std::option::Option::None,
            overlap_bucket: ::std::vec::Vec::new(),
            underlap_bucket: ::std::vec::Vec::new(),
            max_success_in_20: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECstrike15UserMessages)
pub enum ECstrike15UserMessages {
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VGUIMenu)
    CS_UM_VGUIMenu = 301,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Geiger)
    CS_UM_Geiger = 302,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Train)
    CS_UM_Train = 303,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HudText)
    CS_UM_HudText = 304,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SayText)
    CS_UM_SayText = 305,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SayText2)
    CS_UM_SayText2 = 306,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_TextMsg)
    CS_UM_TextMsg = 307,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HudMsg)
    CS_UM_HudMsg = 308,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ResetHud)
    CS_UM_ResetHud = 309,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_GameTitle)
    CS_UM_GameTitle = 310,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Shake)
    CS_UM_Shake = 312,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Fade)
    CS_UM_Fade = 313,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Rumble)
    CS_UM_Rumble = 314,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CloseCaption)
    CS_UM_CloseCaption = 315,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CloseCaptionDirect)
    CS_UM_CloseCaptionDirect = 316,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendAudio)
    CS_UM_SendAudio = 317,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RawAudio)
    CS_UM_RawAudio = 318,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoiceMask)
    CS_UM_VoiceMask = 319,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RequestState)
    CS_UM_RequestState = 320,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_Damage)
    CS_UM_Damage = 321,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RadioText)
    CS_UM_RadioText = 322,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_HintText)
    CS_UM_HintText = 323,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_KeyHintText)
    CS_UM_KeyHintText = 324,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ProcessSpottedEntityUpdate)
    CS_UM_ProcessSpottedEntityUpdate = 325,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ReloadEffect)
    CS_UM_ReloadEffect = 326,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AdjustMoney)
    CS_UM_AdjustMoney = 327,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_UpdateTeamMoney)
    CS_UM_UpdateTeamMoney = 328,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_StopSpectatorMode)
    CS_UM_StopSpectatorMode = 329,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_KillCam)
    CS_UM_KillCam = 330,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DesiredTimescale)
    CS_UM_DesiredTimescale = 331,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CurrentTimescale)
    CS_UM_CurrentTimescale = 332,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AchievementEvent)
    CS_UM_AchievementEvent = 333,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MatchEndConditions)
    CS_UM_MatchEndConditions = 334,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DisconnectToLobby)
    CS_UM_DisconnectToLobby = 335,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PlayerStatsUpdate)
    CS_UM_PlayerStatsUpdate = 336,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_WarmupHasEnded)
    CS_UM_WarmupHasEnded = 338,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ClientInfo)
    CS_UM_ClientInfo = 339,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XRankGet)
    CS_UM_XRankGet = 340,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XRankUpd)
    CS_UM_XRankUpd = 341,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CallVoteFailed)
    CS_UM_CallVoteFailed = 345,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteStart)
    CS_UM_VoteStart = 346,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VotePass)
    CS_UM_VotePass = 347,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteFailed)
    CS_UM_VoteFailed = 348,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_VoteSetup)
    CS_UM_VoteSetup = 349,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ServerRankRevealAll)
    CS_UM_ServerRankRevealAll = 350,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendLastKillerDamageToClient)
    CS_UM_SendLastKillerDamageToClient = 351,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ServerRankUpdate)
    CS_UM_ServerRankUpdate = 352,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ItemPickup)
    CS_UM_ItemPickup = 353,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ShowMenu)
    CS_UM_ShowMenu = 354,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_BarTime)
    CS_UM_BarTime = 355,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_AmmoDenied)
    CS_UM_AmmoDenied = 356,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MarkAchievement)
    CS_UM_MarkAchievement = 357,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_MatchStatsUpdate)
    CS_UM_MatchStatsUpdate = 358,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ItemDrop)
    CS_UM_ItemDrop = 359,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_GlowPropTurnOff)
    CS_UM_GlowPropTurnOff = 360,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendPlayerItemDrops)
    CS_UM_SendPlayerItemDrops = 361,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RoundBackupFilenames)
    CS_UM_RoundBackupFilenames = 362,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SendPlayerItemFound)
    CS_UM_SendPlayerItemFound = 363,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ReportHit)
    CS_UM_ReportHit = 364,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_XpUpdate)
    CS_UM_XpUpdate = 365,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_QuestProgress)
    CS_UM_QuestProgress = 366,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ScoreLeaderboardData)
    CS_UM_ScoreLeaderboardData = 367,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PlayerDecalDigitalSignature)
    CS_UM_PlayerDecalDigitalSignature = 368,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_WeaponSound)
    CS_UM_WeaponSound = 369,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_UpdateScreenHealthBar)
    CS_UM_UpdateScreenHealthBar = 370,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_EntityOutlineHighlight)
    CS_UM_EntityOutlineHighlight = 371,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SSUI)
    CS_UM_SSUI = 372,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SurvivalStats)
    CS_UM_SurvivalStats = 373,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DisconnectToLobby2)
    CS_UM_DisconnectToLobby2 = 374,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_EndOfMatchAllPlayersData)
    CS_UM_EndOfMatchAllPlayersData = 375,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_PostRoundDamageReport)
    CS_UM_PostRoundDamageReport = 376,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_RoundEndReportData)
    CS_UM_RoundEndReportData = 379,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_CurrentRoundOdds)
    CS_UM_CurrentRoundOdds = 380,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_DeepStats)
    CS_UM_DeepStats = 381,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_ShootInfo)
    CS_UM_ShootInfo = 383,
    // @@protoc_insertion_point(enum_value:ECstrike15UserMessages.CS_UM_SnapTapStats)
    CS_UM_SnapTapStats = 384,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECstrike15UserMessages {
    const NAME: &'static str = "ECstrike15UserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECstrike15UserMessages> {
        match value {
            301 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            302 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            303 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            304 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            305 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            306 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            307 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            308 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            309 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            310 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            312 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            313 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            314 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            315 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            316 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            317 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            318 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            319 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            320 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            321 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            322 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            323 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            324 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            325 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            326 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            327 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            328 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            329 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            330 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            331 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            332 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            333 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            334 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            335 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            336 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            338 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            339 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            340 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            341 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            345 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            346 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            347 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            348 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            349 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            350 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            351 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            352 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            353 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            354 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            355 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            356 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            357 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            358 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            359 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            360 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            361 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            362 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            363 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            364 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            365 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            366 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            367 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            368 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            369 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            370 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            371 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            372 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            373 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            374 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            375 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData),
            376 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PostRoundDamageReport),
            379 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundEndReportData),
            380 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentRoundOdds),
            381 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DeepStats),
            383 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShootInfo),
            384 => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SnapTapStats),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECstrike15UserMessages> {
        match str {
            "CS_UM_VGUIMenu" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VGUIMenu),
            "CS_UM_Geiger" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Geiger),
            "CS_UM_Train" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Train),
            "CS_UM_HudText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudText),
            "CS_UM_SayText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText),
            "CS_UM_SayText2" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SayText2),
            "CS_UM_TextMsg" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_TextMsg),
            "CS_UM_HudMsg" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HudMsg),
            "CS_UM_ResetHud" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ResetHud),
            "CS_UM_GameTitle" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GameTitle),
            "CS_UM_Shake" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Shake),
            "CS_UM_Fade" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Fade),
            "CS_UM_Rumble" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Rumble),
            "CS_UM_CloseCaption" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaption),
            "CS_UM_CloseCaptionDirect" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CloseCaptionDirect),
            "CS_UM_SendAudio" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendAudio),
            "CS_UM_RawAudio" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RawAudio),
            "CS_UM_VoiceMask" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoiceMask),
            "CS_UM_RequestState" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RequestState),
            "CS_UM_Damage" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_Damage),
            "CS_UM_RadioText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RadioText),
            "CS_UM_HintText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_HintText),
            "CS_UM_KeyHintText" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KeyHintText),
            "CS_UM_ProcessSpottedEntityUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate),
            "CS_UM_ReloadEffect" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReloadEffect),
            "CS_UM_AdjustMoney" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AdjustMoney),
            "CS_UM_UpdateTeamMoney" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateTeamMoney),
            "CS_UM_StopSpectatorMode" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_StopSpectatorMode),
            "CS_UM_KillCam" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_KillCam),
            "CS_UM_DesiredTimescale" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DesiredTimescale),
            "CS_UM_CurrentTimescale" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentTimescale),
            "CS_UM_AchievementEvent" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AchievementEvent),
            "CS_UM_MatchEndConditions" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchEndConditions),
            "CS_UM_DisconnectToLobby" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby),
            "CS_UM_PlayerStatsUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerStatsUpdate),
            "CS_UM_WarmupHasEnded" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WarmupHasEnded),
            "CS_UM_ClientInfo" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ClientInfo),
            "CS_UM_XRankGet" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankGet),
            "CS_UM_XRankUpd" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XRankUpd),
            "CS_UM_CallVoteFailed" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CallVoteFailed),
            "CS_UM_VoteStart" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteStart),
            "CS_UM_VotePass" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VotePass),
            "CS_UM_VoteFailed" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteFailed),
            "CS_UM_VoteSetup" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_VoteSetup),
            "CS_UM_ServerRankRevealAll" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankRevealAll),
            "CS_UM_SendLastKillerDamageToClient" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient),
            "CS_UM_ServerRankUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ServerRankUpdate),
            "CS_UM_ItemPickup" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemPickup),
            "CS_UM_ShowMenu" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShowMenu),
            "CS_UM_BarTime" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_BarTime),
            "CS_UM_AmmoDenied" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_AmmoDenied),
            "CS_UM_MarkAchievement" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MarkAchievement),
            "CS_UM_MatchStatsUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_MatchStatsUpdate),
            "CS_UM_ItemDrop" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ItemDrop),
            "CS_UM_GlowPropTurnOff" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_GlowPropTurnOff),
            "CS_UM_SendPlayerItemDrops" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemDrops),
            "CS_UM_RoundBackupFilenames" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundBackupFilenames),
            "CS_UM_SendPlayerItemFound" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SendPlayerItemFound),
            "CS_UM_ReportHit" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ReportHit),
            "CS_UM_XpUpdate" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_XpUpdate),
            "CS_UM_QuestProgress" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_QuestProgress),
            "CS_UM_ScoreLeaderboardData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ScoreLeaderboardData),
            "CS_UM_PlayerDecalDigitalSignature" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature),
            "CS_UM_WeaponSound" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_WeaponSound),
            "CS_UM_UpdateScreenHealthBar" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar),
            "CS_UM_EntityOutlineHighlight" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EntityOutlineHighlight),
            "CS_UM_SSUI" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SSUI),
            "CS_UM_SurvivalStats" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SurvivalStats),
            "CS_UM_DisconnectToLobby2" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DisconnectToLobby2),
            "CS_UM_EndOfMatchAllPlayersData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData),
            "CS_UM_PostRoundDamageReport" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_PostRoundDamageReport),
            "CS_UM_RoundEndReportData" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_RoundEndReportData),
            "CS_UM_CurrentRoundOdds" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_CurrentRoundOdds),
            "CS_UM_DeepStats" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_DeepStats),
            "CS_UM_ShootInfo" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_ShootInfo),
            "CS_UM_SnapTapStats" => ::std::option::Option::Some(ECstrike15UserMessages::CS_UM_SnapTapStats),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECstrike15UserMessages] = &[
        ECstrike15UserMessages::CS_UM_VGUIMenu,
        ECstrike15UserMessages::CS_UM_Geiger,
        ECstrike15UserMessages::CS_UM_Train,
        ECstrike15UserMessages::CS_UM_HudText,
        ECstrike15UserMessages::CS_UM_SayText,
        ECstrike15UserMessages::CS_UM_SayText2,
        ECstrike15UserMessages::CS_UM_TextMsg,
        ECstrike15UserMessages::CS_UM_HudMsg,
        ECstrike15UserMessages::CS_UM_ResetHud,
        ECstrike15UserMessages::CS_UM_GameTitle,
        ECstrike15UserMessages::CS_UM_Shake,
        ECstrike15UserMessages::CS_UM_Fade,
        ECstrike15UserMessages::CS_UM_Rumble,
        ECstrike15UserMessages::CS_UM_CloseCaption,
        ECstrike15UserMessages::CS_UM_CloseCaptionDirect,
        ECstrike15UserMessages::CS_UM_SendAudio,
        ECstrike15UserMessages::CS_UM_RawAudio,
        ECstrike15UserMessages::CS_UM_VoiceMask,
        ECstrike15UserMessages::CS_UM_RequestState,
        ECstrike15UserMessages::CS_UM_Damage,
        ECstrike15UserMessages::CS_UM_RadioText,
        ECstrike15UserMessages::CS_UM_HintText,
        ECstrike15UserMessages::CS_UM_KeyHintText,
        ECstrike15UserMessages::CS_UM_ProcessSpottedEntityUpdate,
        ECstrike15UserMessages::CS_UM_ReloadEffect,
        ECstrike15UserMessages::CS_UM_AdjustMoney,
        ECstrike15UserMessages::CS_UM_UpdateTeamMoney,
        ECstrike15UserMessages::CS_UM_StopSpectatorMode,
        ECstrike15UserMessages::CS_UM_KillCam,
        ECstrike15UserMessages::CS_UM_DesiredTimescale,
        ECstrike15UserMessages::CS_UM_CurrentTimescale,
        ECstrike15UserMessages::CS_UM_AchievementEvent,
        ECstrike15UserMessages::CS_UM_MatchEndConditions,
        ECstrike15UserMessages::CS_UM_DisconnectToLobby,
        ECstrike15UserMessages::CS_UM_PlayerStatsUpdate,
        ECstrike15UserMessages::CS_UM_WarmupHasEnded,
        ECstrike15UserMessages::CS_UM_ClientInfo,
        ECstrike15UserMessages::CS_UM_XRankGet,
        ECstrike15UserMessages::CS_UM_XRankUpd,
        ECstrike15UserMessages::CS_UM_CallVoteFailed,
        ECstrike15UserMessages::CS_UM_VoteStart,
        ECstrike15UserMessages::CS_UM_VotePass,
        ECstrike15UserMessages::CS_UM_VoteFailed,
        ECstrike15UserMessages::CS_UM_VoteSetup,
        ECstrike15UserMessages::CS_UM_ServerRankRevealAll,
        ECstrike15UserMessages::CS_UM_SendLastKillerDamageToClient,
        ECstrike15UserMessages::CS_UM_ServerRankUpdate,
        ECstrike15UserMessages::CS_UM_ItemPickup,
        ECstrike15UserMessages::CS_UM_ShowMenu,
        ECstrike15UserMessages::CS_UM_BarTime,
        ECstrike15UserMessages::CS_UM_AmmoDenied,
        ECstrike15UserMessages::CS_UM_MarkAchievement,
        ECstrike15UserMessages::CS_UM_MatchStatsUpdate,
        ECstrike15UserMessages::CS_UM_ItemDrop,
        ECstrike15UserMessages::CS_UM_GlowPropTurnOff,
        ECstrike15UserMessages::CS_UM_SendPlayerItemDrops,
        ECstrike15UserMessages::CS_UM_RoundBackupFilenames,
        ECstrike15UserMessages::CS_UM_SendPlayerItemFound,
        ECstrike15UserMessages::CS_UM_ReportHit,
        ECstrike15UserMessages::CS_UM_XpUpdate,
        ECstrike15UserMessages::CS_UM_QuestProgress,
        ECstrike15UserMessages::CS_UM_ScoreLeaderboardData,
        ECstrike15UserMessages::CS_UM_PlayerDecalDigitalSignature,
        ECstrike15UserMessages::CS_UM_WeaponSound,
        ECstrike15UserMessages::CS_UM_UpdateScreenHealthBar,
        ECstrike15UserMessages::CS_UM_EntityOutlineHighlight,
        ECstrike15UserMessages::CS_UM_SSUI,
        ECstrike15UserMessages::CS_UM_SurvivalStats,
        ECstrike15UserMessages::CS_UM_DisconnectToLobby2,
        ECstrike15UserMessages::CS_UM_EndOfMatchAllPlayersData,
        ECstrike15UserMessages::CS_UM_PostRoundDamageReport,
        ECstrike15UserMessages::CS_UM_RoundEndReportData,
        ECstrike15UserMessages::CS_UM_CurrentRoundOdds,
        ECstrike15UserMessages::CS_UM_DeepStats,
        ECstrike15UserMessages::CS_UM_ShootInfo,
        ECstrike15UserMessages::CS_UM_SnapTapStats,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ECstrike15UserMessages {
    fn default() -> Self {
        ECstrike15UserMessages::CS_UM_VGUIMenu
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECSUsrMsg_DisconnectToLobby_Action)
pub enum ECSUsrMsg_DisconnectToLobby_Action {
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_Default)
    k_ECSUsrMsg_DisconnectToLobby_Action_Default = 0,
    // @@protoc_insertion_point(enum_value:ECSUsrMsg_DisconnectToLobby_Action.k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue)
    k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECSUsrMsg_DisconnectToLobby_Action {
    const NAME: &'static str = "ECSUsrMsg_DisconnectToLobby_Action";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match value {
            0 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            1 => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECSUsrMsg_DisconnectToLobby_Action> {
        match str {
            "k_ECSUsrMsg_DisconnectToLobby_Action_Default" => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default),
            "k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue" => ::std::option::Option::Some(ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECSUsrMsg_DisconnectToLobby_Action] = &[
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default,
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_GoQueue,
    ];
}

impl ::std::default::Default for ECSUsrMsg_DisconnectToLobby_Action {
    fn default() -> Self {
        ECSUsrMsg_DisconnectToLobby_Action::k_ECSUsrMsg_DisconnectToLobby_Action_Default
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
#[allow(unused_imports)]
use crate::cstrike15_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VGUIMenu {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Geiger {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Train {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_HudText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_HudMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Shake {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Fade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Rumble {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_CloseCaption {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_CloseCaptionDirect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SendAudio {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_RawAudio {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VoiceMask {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_Damage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_RadioText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_HintText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_KeyHintText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ProcessSpottedEntityUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SendPlayerItemDrops {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SendPlayerItemFound {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ReloadEffect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_WeaponSound {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_UpdateScreenHealthBar {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_EntityOutlineHighlight {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_AdjustMoney {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ReportHit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_KillCam {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_DesiredTimescale {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_CurrentTimescale {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_AchievementEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_MatchEndConditions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_PlayerStatsUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_QuestProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ScoreLeaderboardData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_PlayerDecalDigitalSignature {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_XRankGet {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_XRankUpd {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_CallVoteFailed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VoteStart {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VotePass {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VoteFailed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_VoteSetup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SendLastKillerDamageToClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ServerRankUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_XpUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ItemPickup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ShowMenu {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_BarTime {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_AmmoDenied {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_MarkAchievement {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_MatchStatsUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ItemDrop {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_GlowPropTurnOff {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_RoundBackupFilenames {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SSUI {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SurvivalStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_EndOfMatchAllPlayersData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_RoundEndReportData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_PostRoundDamageReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_CurrentRoundOdds {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_DeepStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ShootInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ResetHud {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_GameTitle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_RequestState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_StopSpectatorMode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_DisconnectToLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_WarmupHasEnded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ClientInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_ServerRankRevealAll {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsgPreMatchSayText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CCSUsrMsg_SnapTapStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::MsgKindEnum for ECstrike15UserMessages {}
