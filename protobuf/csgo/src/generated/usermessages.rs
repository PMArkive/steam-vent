// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `usermessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CUserMessageAchievementEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAchievementEvent {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAchievementEvent.achievement)
    pub achievement: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAchievementEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAchievementEvent {
    fn default() -> &'a CUserMessageAchievementEvent {
        <CUserMessageAchievementEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAchievementEvent {
    pub fn new() -> CUserMessageAchievementEvent {
        ::std::default::Default::default()
    }

    // optional uint32 achievement = 1;

    pub fn achievement(&self) -> u32 {
        self.achievement.unwrap_or(0)
    }

    pub fn clear_achievement(&mut self) {
        self.achievement = ::std::option::Option::None;
    }

    pub fn has_achievement(&self) -> bool {
        self.achievement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_achievement(&mut self, v: u32) {
        self.achievement = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageAchievementEvent {
    const NAME: &'static str = "CUserMessageAchievementEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.achievement = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.achievement {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.achievement {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAchievementEvent {
        CUserMessageAchievementEvent::new()
    }

    fn clear(&mut self) {
        self.achievement = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAchievementEvent {
        static instance: CUserMessageAchievementEvent = CUserMessageAchievementEvent {
            achievement: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCloseCaption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaption {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaption.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaption.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaption {
    fn default() -> &'a CUserMessageCloseCaption {
        <CUserMessageCloseCaption as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaption {
    pub fn new() -> CUserMessageCloseCaption {
        ::std::default::Default::default()
    }

    // optional fixed32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCloseCaption {
    const NAME: &'static str = "CUserMessageCloseCaption";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaption {
        CUserMessageCloseCaption::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaption {
        static instance: CUserMessageCloseCaption = CUserMessageCloseCaption {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCloseCaptionDirect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaptionDirect {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.hash)
    pub hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionDirect.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaptionDirect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaptionDirect {
    fn default() -> &'a CUserMessageCloseCaptionDirect {
        <CUserMessageCloseCaptionDirect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaptionDirect {
    pub fn new() -> CUserMessageCloseCaptionDirect {
        ::std::default::Default::default()
    }

    // optional fixed32 hash = 1;

    pub fn hash(&self) -> u32 {
        self.hash.unwrap_or(0)
    }

    pub fn clear_hash(&mut self) {
        self.hash = ::std::option::Option::None;
    }

    pub fn has_hash(&self) -> bool {
        self.hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hash(&mut self, v: u32) {
        self.hash = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCloseCaptionDirect {
    const NAME: &'static str = "CUserMessageCloseCaptionDirect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.hash = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hash {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hash {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaptionDirect {
        CUserMessageCloseCaptionDirect::new()
    }

    fn clear(&mut self) {
        self.hash = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaptionDirect {
        static instance: CUserMessageCloseCaptionDirect = CUserMessageCloseCaptionDirect {
            hash: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCloseCaptionPlaceholder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCloseCaptionPlaceholder {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.string)
    pub string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.from_player)
    pub from_player: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageCloseCaptionPlaceholder.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCloseCaptionPlaceholder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCloseCaptionPlaceholder {
    fn default() -> &'a CUserMessageCloseCaptionPlaceholder {
        <CUserMessageCloseCaptionPlaceholder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCloseCaptionPlaceholder {
    pub fn new() -> CUserMessageCloseCaptionPlaceholder {
        ::std::default::Default::default()
    }

    // optional string string = 1;

    pub fn string(&self) -> &str {
        match self.string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_string(&mut self) {
        self.string = ::std::option::Option::None;
    }

    pub fn has_string(&self) -> bool {
        self.string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string(&mut self, v: ::std::string::String) {
        self.string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string(&mut self) -> &mut ::std::string::String {
        if self.string.is_none() {
            self.string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.string.as_mut().unwrap()
    }

    // Take field
    pub fn take_string(&mut self) -> ::std::string::String {
        self.string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool from_player = 3;

    pub fn from_player(&self) -> bool {
        self.from_player.unwrap_or(false)
    }

    pub fn clear_from_player(&mut self) {
        self.from_player = ::std::option::Option::None;
    }

    pub fn has_from_player(&self) -> bool {
        self.from_player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_player(&mut self, v: bool) {
        self.from_player = ::std::option::Option::Some(v);
    }

    // optional int32 ent_index = 4;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCloseCaptionPlaceholder {
    const NAME: &'static str = "CUserMessageCloseCaptionPlaceholder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.string = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.from_player = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.from_player {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.string.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.from_player {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.ent_index {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCloseCaptionPlaceholder {
        CUserMessageCloseCaptionPlaceholder::new()
    }

    fn clear(&mut self) {
        self.string = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.from_player = ::std::option::Option::None;
        self.ent_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCloseCaptionPlaceholder {
        static instance: CUserMessageCloseCaptionPlaceholder = CUserMessageCloseCaptionPlaceholder {
            string: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            from_player: ::std::option::Option::None,
            ent_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCurrentTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCurrentTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCurrentTimescale.current)
    pub current: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCurrentTimescale.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCurrentTimescale {
    fn default() -> &'a CUserMessageCurrentTimescale {
        <CUserMessageCurrentTimescale as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCurrentTimescale {
    pub fn new() -> CUserMessageCurrentTimescale {
        ::std::default::Default::default()
    }

    // optional float current = 1;

    pub fn current(&self) -> f32 {
        self.current.unwrap_or(0.)
    }

    pub fn clear_current(&mut self) {
        self.current = ::std::option::Option::None;
    }

    pub fn has_current(&self) -> bool {
        self.current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current(&mut self, v: f32) {
        self.current = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCurrentTimescale {
    const NAME: &'static str = "CUserMessageCurrentTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.current = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.current {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCurrentTimescale {
        CUserMessageCurrentTimescale::new()
    }

    fn clear(&mut self) {
        self.current = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCurrentTimescale {
        static instance: CUserMessageCurrentTimescale = CUserMessageCurrentTimescale {
            current: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageDesiredTimescale)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageDesiredTimescale {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.desired)
    pub desired: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.acceleration)
    pub acceleration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.minblendrate)
    pub minblendrate: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageDesiredTimescale.blenddeltamultiplier)
    pub blenddeltamultiplier: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageDesiredTimescale.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageDesiredTimescale {
    fn default() -> &'a CUserMessageDesiredTimescale {
        <CUserMessageDesiredTimescale as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageDesiredTimescale {
    pub fn new() -> CUserMessageDesiredTimescale {
        ::std::default::Default::default()
    }

    // optional float desired = 1;

    pub fn desired(&self) -> f32 {
        self.desired.unwrap_or(0.)
    }

    pub fn clear_desired(&mut self) {
        self.desired = ::std::option::Option::None;
    }

    pub fn has_desired(&self) -> bool {
        self.desired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired(&mut self, v: f32) {
        self.desired = ::std::option::Option::Some(v);
    }

    // optional float acceleration = 2;

    pub fn acceleration(&self) -> f32 {
        self.acceleration.unwrap_or(0.)
    }

    pub fn clear_acceleration(&mut self) {
        self.acceleration = ::std::option::Option::None;
    }

    pub fn has_acceleration(&self) -> bool {
        self.acceleration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acceleration(&mut self, v: f32) {
        self.acceleration = ::std::option::Option::Some(v);
    }

    // optional float minblendrate = 3;

    pub fn minblendrate(&self) -> f32 {
        self.minblendrate.unwrap_or(0.)
    }

    pub fn clear_minblendrate(&mut self) {
        self.minblendrate = ::std::option::Option::None;
    }

    pub fn has_minblendrate(&self) -> bool {
        self.minblendrate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minblendrate(&mut self, v: f32) {
        self.minblendrate = ::std::option::Option::Some(v);
    }

    // optional float blenddeltamultiplier = 4;

    pub fn blenddeltamultiplier(&self) -> f32 {
        self.blenddeltamultiplier.unwrap_or(0.)
    }

    pub fn clear_blenddeltamultiplier(&mut self) {
        self.blenddeltamultiplier = ::std::option::Option::None;
    }

    pub fn has_blenddeltamultiplier(&self) -> bool {
        self.blenddeltamultiplier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blenddeltamultiplier(&mut self, v: f32) {
        self.blenddeltamultiplier = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageDesiredTimescale {
    const NAME: &'static str = "CUserMessageDesiredTimescale";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.desired = ::std::option::Option::Some(is.read_float()?);
                },
                21 => {
                    self.acceleration = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.minblendrate = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.blenddeltamultiplier = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.desired {
            my_size += 1 + 4;
        }
        if let Some(v) = self.acceleration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.minblendrate {
            my_size += 1 + 4;
        }
        if let Some(v) = self.blenddeltamultiplier {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.desired {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.acceleration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.minblendrate {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.blenddeltamultiplier {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageDesiredTimescale {
        CUserMessageDesiredTimescale::new()
    }

    fn clear(&mut self) {
        self.desired = ::std::option::Option::None;
        self.acceleration = ::std::option::Option::None;
        self.minblendrate = ::std::option::Option::None;
        self.blenddeltamultiplier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageDesiredTimescale {
        static instance: CUserMessageDesiredTimescale = CUserMessageDesiredTimescale {
            desired: ::std::option::Option::None,
            acceleration: ::std::option::Option::None,
            minblendrate: ::std::option::Option::None,
            blenddeltamultiplier: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageFade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageFade {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageFade.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.hold_time)
    pub hold_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageFade.color)
    pub color: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageFade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageFade {
    fn default() -> &'a CUserMessageFade {
        <CUserMessageFade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageFade {
    pub fn new() -> CUserMessageFade {
        ::std::default::Default::default()
    }

    // optional uint32 duration = 1;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 hold_time = 2;

    pub fn hold_time(&self) -> u32 {
        self.hold_time.unwrap_or(0)
    }

    pub fn clear_hold_time(&mut self) {
        self.hold_time = ::std::option::Option::None;
    }

    pub fn has_hold_time(&self) -> bool {
        self.hold_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hold_time(&mut self, v: u32) {
        self.hold_time = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 4;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageFade {
    const NAME: &'static str = "CUserMessageFade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hold_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hold_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.duration {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hold_time {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageFade {
        CUserMessageFade::new()
    }

    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.hold_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageFade {
        static instance: CUserMessageFade = CUserMessageFade {
            duration: ::std::option::Option::None,
            hold_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            color: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageShake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShake {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShake.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShake.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageShake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageShake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShake.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShake {
    fn default() -> &'a CUserMessageShake {
        <CUserMessageShake as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShake {
    pub fn new() -> CUserMessageShake {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 2;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageShake {
    const NAME: &'static str = "CUserMessageShake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShake {
        CUserMessageShake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShake {
        static instance: CUserMessageShake = CUserMessageShake {
            command: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageShakeDir)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShakeDir {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShakeDir.shake)
    pub shake: ::steam_vent_proto_common::protobuf::MessageField<CUserMessageShake>,
    // @@protoc_insertion_point(field:CUserMessageShakeDir.direction)
    pub direction: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShakeDir.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShakeDir {
    fn default() -> &'a CUserMessageShakeDir {
        <CUserMessageShakeDir as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShakeDir {
    pub fn new() -> CUserMessageShakeDir {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageShakeDir {
    const NAME: &'static str = "CUserMessageShakeDir";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.shake)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.direction)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.shake.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.direction.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.shake.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.direction.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShakeDir {
        CUserMessageShakeDir::new()
    }

    fn clear(&mut self) {
        self.shake.clear();
        self.direction.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShakeDir {
        static instance: CUserMessageShakeDir = CUserMessageShakeDir {
            shake: ::steam_vent_proto_common::protobuf::MessageField::none(),
            direction: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageWaterShake)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageWaterShake {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageWaterShake.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.amplitude)
    pub amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.frequency)
    pub frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageWaterShake.duration)
    pub duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageWaterShake.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageWaterShake {
    fn default() -> &'a CUserMessageWaterShake {
        <CUserMessageWaterShake as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageWaterShake {
    pub fn new() -> CUserMessageWaterShake {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional float amplitude = 2;

    pub fn amplitude(&self) -> f32 {
        self.amplitude.unwrap_or(0.)
    }

    pub fn clear_amplitude(&mut self) {
        self.amplitude = ::std::option::Option::None;
    }

    pub fn has_amplitude(&self) -> bool {
        self.amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amplitude(&mut self, v: f32) {
        self.amplitude = ::std::option::Option::Some(v);
    }

    // optional float frequency = 3;

    pub fn frequency(&self) -> f32 {
        self.frequency.unwrap_or(0.)
    }

    pub fn clear_frequency(&mut self) {
        self.frequency = ::std::option::Option::None;
    }

    pub fn has_frequency(&self) -> bool {
        self.frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frequency(&mut self, v: f32) {
        self.frequency = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageWaterShake {
    const NAME: &'static str = "CUserMessageWaterShake";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageWaterShake {
        CUserMessageWaterShake::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.amplitude = ::std::option::Option::None;
        self.frequency = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageWaterShake {
        static instance: CUserMessageWaterShake = CUserMessageWaterShake {
            command: ::std::option::Option::None,
            amplitude: ::std::option::Option::None,
            frequency: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageScreenTilt)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageScreenTilt {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.command)
    pub command: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.ease_in_out)
    pub ease_in_out: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.angle)
    pub angle: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageScreenTilt.time)
    pub time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageScreenTilt.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageScreenTilt {
    fn default() -> &'a CUserMessageScreenTilt {
        <CUserMessageScreenTilt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageScreenTilt {
    pub fn new() -> CUserMessageScreenTilt {
        ::std::default::Default::default()
    }

    // optional uint32 command = 1;

    pub fn command(&self) -> u32 {
        self.command.unwrap_or(0)
    }

    pub fn clear_command(&mut self) {
        self.command = ::std::option::Option::None;
    }

    pub fn has_command(&self) -> bool {
        self.command.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: u32) {
        self.command = ::std::option::Option::Some(v);
    }

    // optional bool ease_in_out = 2;

    pub fn ease_in_out(&self) -> bool {
        self.ease_in_out.unwrap_or(false)
    }

    pub fn clear_ease_in_out(&mut self) {
        self.ease_in_out = ::std::option::Option::None;
    }

    pub fn has_ease_in_out(&self) -> bool {
        self.ease_in_out.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ease_in_out(&mut self, v: bool) {
        self.ease_in_out = ::std::option::Option::Some(v);
    }

    // optional float duration = 4;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional float time = 5;

    pub fn time(&self) -> f32 {
        self.time.unwrap_or(0.)
    }

    pub fn clear_time(&mut self) {
        self.time = ::std::option::Option::None;
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: f32) {
        self.time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageScreenTilt {
    const NAME: &'static str = "CUserMessageScreenTilt";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.command = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ease_in_out = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                37 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.command {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ease_in_out {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.command {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ease_in_out {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.duration {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.time {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageScreenTilt {
        CUserMessageScreenTilt::new()
    }

    fn clear(&mut self) {
        self.command = ::std::option::Option::None;
        self.ease_in_out = ::std::option::Option::None;
        self.angle.clear();
        self.duration = ::std::option::Option::None;
        self.time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageScreenTilt {
        static instance: CUserMessageScreenTilt = CUserMessageScreenTilt {
            command: ::std::option::Option::None,
            ease_in_out: ::std::option::Option::None,
            angle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            duration: ::std::option::Option::None,
            time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageSayText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayText.playerindex)
    pub playerindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText.chat)
    pub chat: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayText {
    fn default() -> &'a CUserMessageSayText {
        <CUserMessageSayText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayText {
    pub fn new() -> CUserMessageSayText {
        ::std::default::Default::default()
    }

    // optional int32 playerindex = 1;

    pub fn playerindex(&self) -> i32 {
        self.playerindex.unwrap_or(-1i32)
    }

    pub fn clear_playerindex(&mut self) {
        self.playerindex = ::std::option::Option::None;
    }

    pub fn has_playerindex(&self) -> bool {
        self.playerindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_playerindex(&mut self, v: i32) {
        self.playerindex = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool chat = 3;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageSayText {
    const NAME: &'static str = "CUserMessageSayText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.playerindex = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.playerindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.playerindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayText {
        CUserMessageSayText::new()
    }

    fn clear(&mut self) {
        self.playerindex = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayText {
        static instance: CUserMessageSayText = CUserMessageSayText {
            playerindex: ::std::option::Option::None,
            text: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageSayText2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayText2 {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayText2.entityindex)
    pub entityindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.chat)
    pub chat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.messagename)
    pub messagename: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param1)
    pub param1: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param2)
    pub param2: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param3)
    pub param3: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSayText2.param4)
    pub param4: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayText2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayText2 {
    fn default() -> &'a CUserMessageSayText2 {
        <CUserMessageSayText2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayText2 {
    pub fn new() -> CUserMessageSayText2 {
        ::std::default::Default::default()
    }

    // optional int32 entityindex = 1;

    pub fn entityindex(&self) -> i32 {
        self.entityindex.unwrap_or(-1i32)
    }

    pub fn clear_entityindex(&mut self) {
        self.entityindex = ::std::option::Option::None;
    }

    pub fn has_entityindex(&self) -> bool {
        self.entityindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityindex(&mut self, v: i32) {
        self.entityindex = ::std::option::Option::Some(v);
    }

    // optional bool chat = 2;

    pub fn chat(&self) -> bool {
        self.chat.unwrap_or(false)
    }

    pub fn clear_chat(&mut self) {
        self.chat = ::std::option::Option::None;
    }

    pub fn has_chat(&self) -> bool {
        self.chat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat(&mut self, v: bool) {
        self.chat = ::std::option::Option::Some(v);
    }

    // optional string messagename = 3;

    pub fn messagename(&self) -> &str {
        match self.messagename.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_messagename(&mut self) {
        self.messagename = ::std::option::Option::None;
    }

    pub fn has_messagename(&self) -> bool {
        self.messagename.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messagename(&mut self, v: ::std::string::String) {
        self.messagename = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_messagename(&mut self) -> &mut ::std::string::String {
        if self.messagename.is_none() {
            self.messagename = ::std::option::Option::Some(::std::string::String::new());
        }
        self.messagename.as_mut().unwrap()
    }

    // Take field
    pub fn take_messagename(&mut self) -> ::std::string::String {
        self.messagename.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param1 = 4;

    pub fn param1(&self) -> &str {
        match self.param1.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param1(&mut self) {
        self.param1 = ::std::option::Option::None;
    }

    pub fn has_param1(&self) -> bool {
        self.param1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param1(&mut self, v: ::std::string::String) {
        self.param1 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param1(&mut self) -> &mut ::std::string::String {
        if self.param1.is_none() {
            self.param1 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param1.as_mut().unwrap()
    }

    // Take field
    pub fn take_param1(&mut self) -> ::std::string::String {
        self.param1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param2 = 5;

    pub fn param2(&self) -> &str {
        match self.param2.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param2(&mut self) {
        self.param2 = ::std::option::Option::None;
    }

    pub fn has_param2(&self) -> bool {
        self.param2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param2(&mut self, v: ::std::string::String) {
        self.param2 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param2(&mut self) -> &mut ::std::string::String {
        if self.param2.is_none() {
            self.param2 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param2.as_mut().unwrap()
    }

    // Take field
    pub fn take_param2(&mut self) -> ::std::string::String {
        self.param2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param3 = 6;

    pub fn param3(&self) -> &str {
        match self.param3.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param3(&mut self) {
        self.param3 = ::std::option::Option::None;
    }

    pub fn has_param3(&self) -> bool {
        self.param3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param3(&mut self, v: ::std::string::String) {
        self.param3 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param3(&mut self) -> &mut ::std::string::String {
        if self.param3.is_none() {
            self.param3 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param3.as_mut().unwrap()
    }

    // Take field
    pub fn take_param3(&mut self) -> ::std::string::String {
        self.param3.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string param4 = 7;

    pub fn param4(&self) -> &str {
        match self.param4.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_param4(&mut self) {
        self.param4 = ::std::option::Option::None;
    }

    pub fn has_param4(&self) -> bool {
        self.param4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param4(&mut self, v: ::std::string::String) {
        self.param4 = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_param4(&mut self) -> &mut ::std::string::String {
        if self.param4.is_none() {
            self.param4 = ::std::option::Option::Some(::std::string::String::new());
        }
        self.param4.as_mut().unwrap()
    }

    // Take field
    pub fn take_param4(&mut self) -> ::std::string::String {
        self.param4.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageSayText2 {
    const NAME: &'static str = "CUserMessageSayText2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entityindex = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.chat = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.messagename = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.param1 = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.param2 = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.param3 = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.param4 = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entityindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.chat {
            my_size += 1 + 1;
        }
        if let Some(v) = self.messagename.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.param1.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.param2.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.param3.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.param4.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entityindex {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.chat {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.messagename.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.param1.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.param2.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.param3.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.param4.as_ref() {
            os.write_string(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayText2 {
        CUserMessageSayText2::new()
    }

    fn clear(&mut self) {
        self.entityindex = ::std::option::Option::None;
        self.chat = ::std::option::Option::None;
        self.messagename = ::std::option::Option::None;
        self.param1 = ::std::option::Option::None;
        self.param2 = ::std::option::Option::None;
        self.param3 = ::std::option::Option::None;
        self.param4 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayText2 {
        static instance: CUserMessageSayText2 = CUserMessageSayText2 {
            entityindex: ::std::option::Option::None,
            chat: ::std::option::Option::None,
            messagename: ::std::option::Option::None,
            param1: ::std::option::Option::None,
            param2: ::std::option::Option::None,
            param3: ::std::option::Option::None,
            param4: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageHudMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHudMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHudMsg.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.x)
    pub x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.y)
    pub y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.color1)
    pub color1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.color2)
    pub color2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.effect)
    pub effect: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHudMsg.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHudMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHudMsg {
    fn default() -> &'a CUserMessageHudMsg {
        <CUserMessageHudMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHudMsg {
    pub fn new() -> CUserMessageHudMsg {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional float x = 2;

    pub fn x(&self) -> f32 {
        self.x.unwrap_or(0.)
    }

    pub fn clear_x(&mut self) {
        self.x = ::std::option::Option::None;
    }

    pub fn has_x(&self) -> bool {
        self.x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_x(&mut self, v: f32) {
        self.x = ::std::option::Option::Some(v);
    }

    // optional float y = 3;

    pub fn y(&self) -> f32 {
        self.y.unwrap_or(0.)
    }

    pub fn clear_y(&mut self) {
        self.y = ::std::option::Option::None;
    }

    pub fn has_y(&self) -> bool {
        self.y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_y(&mut self, v: f32) {
        self.y = ::std::option::Option::Some(v);
    }

    // optional fixed32 color1 = 4;

    pub fn color1(&self) -> u32 {
        self.color1.unwrap_or(0)
    }

    pub fn clear_color1(&mut self) {
        self.color1 = ::std::option::Option::None;
    }

    pub fn has_color1(&self) -> bool {
        self.color1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color1(&mut self, v: u32) {
        self.color1 = ::std::option::Option::Some(v);
    }

    // optional fixed32 color2 = 5;

    pub fn color2(&self) -> u32 {
        self.color2.unwrap_or(0)
    }

    pub fn clear_color2(&mut self) {
        self.color2 = ::std::option::Option::None;
    }

    pub fn has_color2(&self) -> bool {
        self.color2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color2(&mut self, v: u32) {
        self.color2 = ::std::option::Option::Some(v);
    }

    // optional uint32 effect = 6;

    pub fn effect(&self) -> u32 {
        self.effect.unwrap_or(0)
    }

    pub fn clear_effect(&mut self) {
        self.effect = ::std::option::Option::None;
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: u32) {
        self.effect = ::std::option::Option::Some(v);
    }

    // optional string message = 11;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageHudMsg {
    const NAME: &'static str = "CUserMessageHudMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.color1 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                45 => {
                    self.color2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                48 => {
                    self.effect = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color1 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color1 {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.color2 {
            os.write_fixed32(5, v)?;
        }
        if let Some(v) = self.effect {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHudMsg {
        CUserMessageHudMsg::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.x = ::std::option::Option::None;
        self.y = ::std::option::Option::None;
        self.color1 = ::std::option::Option::None;
        self.color2 = ::std::option::Option::None;
        self.effect = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHudMsg {
        static instance: CUserMessageHudMsg = CUserMessageHudMsg {
            channel: ::std::option::Option::None,
            x: ::std::option::Option::None,
            y: ::std::option::Option::None,
            color1: ::std::option::Option::None,
            color2: ::std::option::Option::None,
            effect: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageHudText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHudText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHudText.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHudText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHudText {
    fn default() -> &'a CUserMessageHudText {
        <CUserMessageHudText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHudText {
    pub fn new() -> CUserMessageHudText {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageHudText {
    const NAME: &'static str = "CUserMessageHudText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHudText {
        CUserMessageHudText::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHudText {
        static instance: CUserMessageHudText = CUserMessageHudText {
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageTextMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageTextMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageTextMsg.dest)
    pub dest: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageTextMsg.param)
    pub param: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageTextMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageTextMsg {
    fn default() -> &'a CUserMessageTextMsg {
        <CUserMessageTextMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageTextMsg {
    pub fn new() -> CUserMessageTextMsg {
        ::std::default::Default::default()
    }

    // optional uint32 dest = 1;

    pub fn dest(&self) -> u32 {
        self.dest.unwrap_or(0)
    }

    pub fn clear_dest(&mut self) {
        self.dest = ::std::option::Option::None;
    }

    pub fn has_dest(&self) -> bool {
        self.dest.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dest(&mut self, v: u32) {
        self.dest = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageTextMsg {
    const NAME: &'static str = "CUserMessageTextMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.dest = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.param.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dest {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.param {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dest {
            os.write_uint32(1, v)?;
        }
        for v in &self.param {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageTextMsg {
        CUserMessageTextMsg::new()
    }

    fn clear(&mut self) {
        self.dest = ::std::option::Option::None;
        self.param.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageTextMsg {
        static instance: CUserMessageTextMsg = CUserMessageTextMsg {
            dest: ::std::option::Option::None,
            param: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageGameTitle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageGameTitle {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageGameTitle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageGameTitle {
    fn default() -> &'a CUserMessageGameTitle {
        <CUserMessageGameTitle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageGameTitle {
    pub fn new() -> CUserMessageGameTitle {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageGameTitle {
    const NAME: &'static str = "CUserMessageGameTitle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageGameTitle {
        CUserMessageGameTitle::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageGameTitle {
        static instance: CUserMessageGameTitle = CUserMessageGameTitle {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageResetHUD)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageResetHUD {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageResetHUD.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageResetHUD {
    fn default() -> &'a CUserMessageResetHUD {
        <CUserMessageResetHUD as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageResetHUD {
    pub fn new() -> CUserMessageResetHUD {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageResetHUD {
    const NAME: &'static str = "CUserMessageResetHUD";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageResetHUD {
        CUserMessageResetHUD::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageResetHUD {
        static instance: CUserMessageResetHUD = CUserMessageResetHUD {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageSendAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSendAudio {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSendAudio.soundname)
    pub soundname: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageSendAudio.stop)
    pub stop: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSendAudio.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSendAudio {
    fn default() -> &'a CUserMessageSendAudio {
        <CUserMessageSendAudio as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSendAudio {
    pub fn new() -> CUserMessageSendAudio {
        ::std::default::Default::default()
    }

    // optional string soundname = 1;

    pub fn soundname(&self) -> &str {
        match self.soundname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_soundname(&mut self) {
        self.soundname = ::std::option::Option::None;
    }

    pub fn has_soundname(&self) -> bool {
        self.soundname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_soundname(&mut self, v: ::std::string::String) {
        self.soundname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_soundname(&mut self) -> &mut ::std::string::String {
        if self.soundname.is_none() {
            self.soundname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.soundname.as_mut().unwrap()
    }

    // Take field
    pub fn take_soundname(&mut self) -> ::std::string::String {
        self.soundname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool stop = 2;

    pub fn stop(&self) -> bool {
        self.stop.unwrap_or(false)
    }

    pub fn clear_stop(&mut self) {
        self.stop = ::std::option::Option::None;
    }

    pub fn has_stop(&self) -> bool {
        self.stop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stop(&mut self, v: bool) {
        self.stop = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageSendAudio {
    const NAME: &'static str = "CUserMessageSendAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.soundname = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.stop = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.soundname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.stop {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.soundname.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.stop {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSendAudio {
        CUserMessageSendAudio::new()
    }

    fn clear(&mut self) {
        self.soundname = ::std::option::Option::None;
        self.stop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSendAudio {
        static instance: CUserMessageSendAudio = CUserMessageSendAudio {
            soundname: ::std::option::Option::None,
            stop: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageAudioParameter)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAudioParameter {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.parameter_type)
    pub parameter_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.name_hash_code)
    pub name_hash_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.value)
    pub value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageAudioParameter.int_value)
    pub int_value: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAudioParameter.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAudioParameter {
    fn default() -> &'a CUserMessageAudioParameter {
        <CUserMessageAudioParameter as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAudioParameter {
    pub fn new() -> CUserMessageAudioParameter {
        ::std::default::Default::default()
    }

    // optional uint32 parameter_type = 1;

    pub fn parameter_type(&self) -> u32 {
        self.parameter_type.unwrap_or(0)
    }

    pub fn clear_parameter_type(&mut self) {
        self.parameter_type = ::std::option::Option::None;
    }

    pub fn has_parameter_type(&self) -> bool {
        self.parameter_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter_type(&mut self, v: u32) {
        self.parameter_type = ::std::option::Option::Some(v);
    }

    // optional uint32 name_hash_code = 2;

    pub fn name_hash_code(&self) -> u32 {
        self.name_hash_code.unwrap_or(0)
    }

    pub fn clear_name_hash_code(&mut self) {
        self.name_hash_code = ::std::option::Option::None;
    }

    pub fn has_name_hash_code(&self) -> bool {
        self.name_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name_hash_code(&mut self, v: u32) {
        self.name_hash_code = ::std::option::Option::Some(v);
    }

    // optional float value = 3;

    pub fn value(&self) -> f32 {
        self.value.unwrap_or(0.)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional uint32 int_value = 4;

    pub fn int_value(&self) -> u32 {
        self.int_value.unwrap_or(0)
    }

    pub fn clear_int_value(&mut self) {
        self.int_value = ::std::option::Option::None;
    }

    pub fn has_int_value(&self) -> bool {
        self.int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_value(&mut self, v: u32) {
        self.int_value = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageAudioParameter {
    const NAME: &'static str = "CUserMessageAudioParameter";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.parameter_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.name_hash_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.value = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.int_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.parameter_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name_hash_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.int_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.parameter_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name_hash_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.int_value {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAudioParameter {
        CUserMessageAudioParameter::new()
    }

    fn clear(&mut self) {
        self.parameter_type = ::std::option::Option::None;
        self.name_hash_code = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.int_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAudioParameter {
        static instance: CUserMessageAudioParameter = CUserMessageAudioParameter {
            parameter_type: ::std::option::Option::None,
            name_hash_code: ::std::option::Option::None,
            value: ::std::option::Option::None,
            int_value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageVoiceMask)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageVoiceMask {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.gamerules_masks)
    pub gamerules_masks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.ban_masks)
    pub ban_masks: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CUserMessageVoiceMask.mod_enable)
    pub mod_enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageVoiceMask.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageVoiceMask {
    fn default() -> &'a CUserMessageVoiceMask {
        <CUserMessageVoiceMask as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageVoiceMask {
    pub fn new() -> CUserMessageVoiceMask {
        ::std::default::Default::default()
    }

    // optional bool mod_enable = 3;

    pub fn mod_enable(&self) -> bool {
        self.mod_enable.unwrap_or(false)
    }

    pub fn clear_mod_enable(&mut self) {
        self.mod_enable = ::std::option::Option::None;
    }

    pub fn has_mod_enable(&self) -> bool {
        self.mod_enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mod_enable(&mut self, v: bool) {
        self.mod_enable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageVoiceMask {
    const NAME: &'static str = "CUserMessageVoiceMask";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.gamerules_masks)?;
                },
                8 => {
                    self.gamerules_masks.push(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.ban_masks)?;
                },
                16 => {
                    self.ban_masks.push(is.read_uint32()?);
                },
                24 => {
                    self.mod_enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.gamerules_masks {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.ban_masks {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.mod_enable {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.gamerules_masks {
            os.write_uint32(1, *v)?;
        };
        for v in &self.ban_masks {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.mod_enable {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageVoiceMask {
        CUserMessageVoiceMask::new()
    }

    fn clear(&mut self) {
        self.gamerules_masks.clear();
        self.ban_masks.clear();
        self.mod_enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageVoiceMask {
        static instance: CUserMessageVoiceMask = CUserMessageVoiceMask {
            gamerules_masks: ::std::vec::Vec::new(),
            ban_masks: ::std::vec::Vec::new(),
            mod_enable: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestState {
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestState {
    fn default() -> &'a CUserMessageRequestState {
        <CUserMessageRequestState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestState {
    pub fn new() -> CUserMessageRequestState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRequestState {
    const NAME: &'static str = "CUserMessageRequestState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestState {
        CUserMessageRequestState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestState {
        static instance: CUserMessageRequestState = CUserMessageRequestState {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageRumble)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRumble {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRumble.index)
    pub index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRumble.data)
    pub data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRumble.flags)
    pub flags: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRumble.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRumble {
    fn default() -> &'a CUserMessageRumble {
        <CUserMessageRumble as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRumble {
    pub fn new() -> CUserMessageRumble {
        ::std::default::Default::default()
    }

    // optional int32 index = 1;

    pub fn index(&self) -> i32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i32) {
        self.index = ::std::option::Option::Some(v);
    }

    // optional int32 data = 2;

    pub fn data(&self) -> i32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: i32) {
        self.data = ::std::option::Option::Some(v);
    }

    // optional int32 flags = 3;

    pub fn flags(&self) -> i32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: i32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRumble {
    const NAME: &'static str = "CUserMessageRumble";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.index = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.data = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRumble {
        CUserMessageRumble::new()
    }

    fn clear(&mut self) {
        self.index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRumble {
        static instance: CUserMessageRumble = CUserMessageRumble {
            index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageSayTextChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageSayTextChannel {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.player)
    pub player: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.channel)
    pub channel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageSayTextChannel.text)
    pub text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageSayTextChannel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageSayTextChannel {
    fn default() -> &'a CUserMessageSayTextChannel {
        <CUserMessageSayTextChannel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageSayTextChannel {
    pub fn new() -> CUserMessageSayTextChannel {
        ::std::default::Default::default()
    }

    // optional int32 player = 1;

    pub fn player(&self) -> i32 {
        self.player.unwrap_or(0)
    }

    pub fn clear_player(&mut self) {
        self.player = ::std::option::Option::None;
    }

    pub fn has_player(&self) -> bool {
        self.player.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player(&mut self, v: i32) {
        self.player = ::std::option::Option::Some(v);
    }

    // optional int32 channel = 2;

    pub fn channel(&self) -> i32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: i32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional string text = 3;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageSayTextChannel {
    const NAME: &'static str = "CUserMessageSayTextChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.channel = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.channel {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageSayTextChannel {
        CUserMessageSayTextChannel::new()
    }

    fn clear(&mut self) {
        self.player = ::std::option::Option::None;
        self.channel = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageSayTextChannel {
        static instance: CUserMessageSayTextChannel = CUserMessageSayTextChannel {
            player: ::std::option::Option::None,
            channel: ::std::option::Option::None,
            text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageColoredText)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageColoredText {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageColoredText.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.text)
    pub text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.reset)
    pub reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_player_slot)
    pub context_player_slot: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_value)
    pub context_value: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageColoredText.context_team_id)
    pub context_team_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageColoredText.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageColoredText {
    fn default() -> &'a CUserMessageColoredText {
        <CUserMessageColoredText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageColoredText {
    pub fn new() -> CUserMessageColoredText {
        ::std::default::Default::default()
    }

    // optional uint32 color = 1;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional string text = 2;

    pub fn text(&self) -> &str {
        match self.text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_text(&mut self) {
        self.text = ::std::option::Option::None;
    }

    pub fn has_text(&self) -> bool {
        self.text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text(&mut self, v: ::std::string::String) {
        self.text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_text(&mut self) -> &mut ::std::string::String {
        if self.text.is_none() {
            self.text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.text.as_mut().unwrap()
    }

    // Take field
    pub fn take_text(&mut self) -> ::std::string::String {
        self.text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool reset = 3;

    pub fn reset(&self) -> bool {
        self.reset.unwrap_or(false)
    }

    pub fn clear_reset(&mut self) {
        self.reset = ::std::option::Option::None;
    }

    pub fn has_reset(&self) -> bool {
        self.reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset(&mut self, v: bool) {
        self.reset = ::std::option::Option::Some(v);
    }

    // optional int32 context_player_slot = 4;

    pub fn context_player_slot(&self) -> i32 {
        self.context_player_slot.unwrap_or(-1i32)
    }

    pub fn clear_context_player_slot(&mut self) {
        self.context_player_slot = ::std::option::Option::None;
    }

    pub fn has_context_player_slot(&self) -> bool {
        self.context_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_player_slot(&mut self, v: i32) {
        self.context_player_slot = ::std::option::Option::Some(v);
    }

    // optional int32 context_value = 5;

    pub fn context_value(&self) -> i32 {
        self.context_value.unwrap_or(0)
    }

    pub fn clear_context_value(&mut self) {
        self.context_value = ::std::option::Option::None;
    }

    pub fn has_context_value(&self) -> bool {
        self.context_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_value(&mut self, v: i32) {
        self.context_value = ::std::option::Option::Some(v);
    }

    // optional int32 context_team_id = 6;

    pub fn context_team_id(&self) -> i32 {
        self.context_team_id.unwrap_or(0)
    }

    pub fn clear_context_team_id(&mut self) {
        self.context_team_id = ::std::option::Option::None;
    }

    pub fn has_context_team_id(&self) -> bool {
        self.context_team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_context_team_id(&mut self, v: i32) {
        self.context_team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageColoredText {
    const NAME: &'static str = "CUserMessageColoredText";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.color = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.reset = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.context_player_slot = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.context_value = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.context_team_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.color {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.reset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.context_player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.context_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.context_team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.color {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.reset {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.context_player_slot {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.context_value {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.context_team_id {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageColoredText {
        CUserMessageColoredText::new()
    }

    fn clear(&mut self) {
        self.color = ::std::option::Option::None;
        self.text = ::std::option::Option::None;
        self.reset = ::std::option::Option::None;
        self.context_player_slot = ::std::option::Option::None;
        self.context_value = ::std::option::Option::None;
        self.context_team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageColoredText {
        static instance: CUserMessageColoredText = CUserMessageColoredText {
            color: ::std::option::Option::None,
            text: ::std::option::Option::None,
            reset: ::std::option::Option::None,
            context_player_slot: ::std::option::Option::None,
            context_value: ::std::option::Option::None,
            context_team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageItemPickup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageItemPickup {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageItemPickup.itemname)
    pub itemname: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageItemPickup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageItemPickup {
    fn default() -> &'a CUserMessageItemPickup {
        <CUserMessageItemPickup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageItemPickup {
    pub fn new() -> CUserMessageItemPickup {
        ::std::default::Default::default()
    }

    // optional string itemname = 1;

    pub fn itemname(&self) -> &str {
        match self.itemname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_itemname(&mut self) {
        self.itemname = ::std::option::Option::None;
    }

    pub fn has_itemname(&self) -> bool {
        self.itemname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemname(&mut self, v: ::std::string::String) {
        self.itemname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_itemname(&mut self) -> &mut ::std::string::String {
        if self.itemname.is_none() {
            self.itemname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.itemname.as_mut().unwrap()
    }

    // Take field
    pub fn take_itemname(&mut self) -> ::std::string::String {
        self.itemname.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageItemPickup {
    const NAME: &'static str = "CUserMessageItemPickup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.itemname = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.itemname.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.itemname.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageItemPickup {
        CUserMessageItemPickup::new()
    }

    fn clear(&mut self) {
        self.itemname = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageItemPickup {
        static instance: CUserMessageItemPickup = CUserMessageItemPickup {
            itemname: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageAmmoDenied)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAmmoDenied {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAmmoDenied.ammo_id)
    pub ammo_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAmmoDenied.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAmmoDenied {
    fn default() -> &'a CUserMessageAmmoDenied {
        <CUserMessageAmmoDenied as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAmmoDenied {
    pub fn new() -> CUserMessageAmmoDenied {
        ::std::default::Default::default()
    }

    // optional uint32 ammo_id = 1;

    pub fn ammo_id(&self) -> u32 {
        self.ammo_id.unwrap_or(0)
    }

    pub fn clear_ammo_id(&mut self) {
        self.ammo_id = ::std::option::Option::None;
    }

    pub fn has_ammo_id(&self) -> bool {
        self.ammo_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ammo_id(&mut self, v: u32) {
        self.ammo_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageAmmoDenied {
    const NAME: &'static str = "CUserMessageAmmoDenied";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ammo_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ammo_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ammo_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAmmoDenied {
        CUserMessageAmmoDenied::new()
    }

    fn clear(&mut self) {
        self.ammo_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAmmoDenied {
        static instance: CUserMessageAmmoDenied = CUserMessageAmmoDenied {
            ammo_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageShowMenu)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageShowMenu {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageShowMenu.validslots)
    pub validslots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.displaytime)
    pub displaytime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.needmore)
    pub needmore: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CUserMessageShowMenu.menustring)
    pub menustring: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageShowMenu.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageShowMenu {
    fn default() -> &'a CUserMessageShowMenu {
        <CUserMessageShowMenu as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageShowMenu {
    pub fn new() -> CUserMessageShowMenu {
        ::std::default::Default::default()
    }

    // optional uint32 validslots = 1;

    pub fn validslots(&self) -> u32 {
        self.validslots.unwrap_or(0)
    }

    pub fn clear_validslots(&mut self) {
        self.validslots = ::std::option::Option::None;
    }

    pub fn has_validslots(&self) -> bool {
        self.validslots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_validslots(&mut self, v: u32) {
        self.validslots = ::std::option::Option::Some(v);
    }

    // optional uint32 displaytime = 2;

    pub fn displaytime(&self) -> u32 {
        self.displaytime.unwrap_or(0)
    }

    pub fn clear_displaytime(&mut self) {
        self.displaytime = ::std::option::Option::None;
    }

    pub fn has_displaytime(&self) -> bool {
        self.displaytime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_displaytime(&mut self, v: u32) {
        self.displaytime = ::std::option::Option::Some(v);
    }

    // optional bool needmore = 3;

    pub fn needmore(&self) -> bool {
        self.needmore.unwrap_or(false)
    }

    pub fn clear_needmore(&mut self) {
        self.needmore = ::std::option::Option::None;
    }

    pub fn has_needmore(&self) -> bool {
        self.needmore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_needmore(&mut self, v: bool) {
        self.needmore = ::std::option::Option::Some(v);
    }

    // optional string menustring = 4;

    pub fn menustring(&self) -> &str {
        match self.menustring.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_menustring(&mut self) {
        self.menustring = ::std::option::Option::None;
    }

    pub fn has_menustring(&self) -> bool {
        self.menustring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menustring(&mut self, v: ::std::string::String) {
        self.menustring = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_menustring(&mut self) -> &mut ::std::string::String {
        if self.menustring.is_none() {
            self.menustring = ::std::option::Option::Some(::std::string::String::new());
        }
        self.menustring.as_mut().unwrap()
    }

    // Take field
    pub fn take_menustring(&mut self) -> ::std::string::String {
        self.menustring.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageShowMenu {
    const NAME: &'static str = "CUserMessageShowMenu";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.validslots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.displaytime = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.needmore = ::std::option::Option::Some(is.read_bool()?);
                },
                34 => {
                    self.menustring = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.validslots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.displaytime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.needmore {
            my_size += 1 + 1;
        }
        if let Some(v) = self.menustring.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.validslots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.displaytime {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.needmore {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.menustring.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageShowMenu {
        CUserMessageShowMenu::new()
    }

    fn clear(&mut self) {
        self.validslots = ::std::option::Option::None;
        self.displaytime = ::std::option::Option::None;
        self.needmore = ::std::option::Option::None;
        self.menustring = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageShowMenu {
        static instance: CUserMessageShowMenu = CUserMessageShowMenu {
            validslots: ::std::option::Option::None,
            displaytime: ::std::option::Option::None,
            needmore: ::std::option::Option::None,
            menustring: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCreditsMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCreditsMsg {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCreditsMsg.rolltype)
    pub rolltype: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ERollType>>,
    // @@protoc_insertion_point(field:CUserMessageCreditsMsg.logo_length)
    pub logo_length: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCreditsMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCreditsMsg {
    fn default() -> &'a CUserMessageCreditsMsg {
        <CUserMessageCreditsMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCreditsMsg {
    pub fn new() -> CUserMessageCreditsMsg {
        ::std::default::Default::default()
    }

    // optional .eRollType rolltype = 1;

    pub fn rolltype(&self) -> ERollType {
        match self.rolltype {
            Some(e) => e.enum_value_or(ERollType::ROLL_NONE),
            None => ERollType::ROLL_NONE,
        }
    }

    pub fn clear_rolltype(&mut self) {
        self.rolltype = ::std::option::Option::None;
    }

    pub fn has_rolltype(&self) -> bool {
        self.rolltype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rolltype(&mut self, v: ERollType) {
        self.rolltype = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional float logo_length = 2;

    pub fn logo_length(&self) -> f32 {
        self.logo_length.unwrap_or(0.)
    }

    pub fn clear_logo_length(&mut self) {
        self.logo_length = ::std::option::Option::None;
    }

    pub fn has_logo_length(&self) -> bool {
        self.logo_length.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo_length(&mut self, v: f32) {
        self.logo_length = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCreditsMsg {
    const NAME: &'static str = "CUserMessageCreditsMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rolltype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.logo_length = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rolltype {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.logo_length {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rolltype {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.logo_length {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCreditsMsg {
        CUserMessageCreditsMsg::new()
    }

    fn clear(&mut self) {
        self.rolltype = ::std::option::Option::None;
        self.logo_length = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCreditsMsg {
        static instance: CUserMessageCreditsMsg = CUserMessageCreditsMsg {
            rolltype: ::std::option::Option::None,
            logo_length: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessagePlayJingle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessagePlayJingle {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessagePlayJingle.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessagePlayJingle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessagePlayJingle {
    fn default() -> &'a CEntityMessagePlayJingle {
        <CEntityMessagePlayJingle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessagePlayJingle {
    pub fn new() -> CEntityMessagePlayJingle {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessagePlayJingle {
    const NAME: &'static str = "CEntityMessagePlayJingle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessagePlayJingle {
        CEntityMessagePlayJingle::new()
    }

    fn clear(&mut self) {
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessagePlayJingle {
        static instance: CEntityMessagePlayJingle = CEntityMessagePlayJingle {
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessageScreenOverlay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageScreenOverlay {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageScreenOverlay.start_effect)
    pub start_effect: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageScreenOverlay.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageScreenOverlay.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageScreenOverlay {
    fn default() -> &'a CEntityMessageScreenOverlay {
        <CEntityMessageScreenOverlay as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageScreenOverlay {
    pub fn new() -> CEntityMessageScreenOverlay {
        ::std::default::Default::default()
    }

    // optional bool start_effect = 1;

    pub fn start_effect(&self) -> bool {
        self.start_effect.unwrap_or(false)
    }

    pub fn clear_start_effect(&mut self) {
        self.start_effect = ::std::option::Option::None;
    }

    pub fn has_start_effect(&self) -> bool {
        self.start_effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_effect(&mut self, v: bool) {
        self.start_effect = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessageScreenOverlay {
    const NAME: &'static str = "CEntityMessageScreenOverlay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start_effect = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_effect {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.start_effect {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageScreenOverlay {
        CEntityMessageScreenOverlay::new()
    }

    fn clear(&mut self) {
        self.start_effect = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageScreenOverlay {
        static instance: CEntityMessageScreenOverlay = CEntityMessageScreenOverlay {
            start_effect: ::std::option::Option::None,
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessageRemoveAllDecals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageRemoveAllDecals {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageRemoveAllDecals.remove_decals)
    pub remove_decals: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageRemoveAllDecals.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageRemoveAllDecals.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageRemoveAllDecals {
    fn default() -> &'a CEntityMessageRemoveAllDecals {
        <CEntityMessageRemoveAllDecals as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageRemoveAllDecals {
    pub fn new() -> CEntityMessageRemoveAllDecals {
        ::std::default::Default::default()
    }

    // optional bool remove_decals = 1;

    pub fn remove_decals(&self) -> bool {
        self.remove_decals.unwrap_or(false)
    }

    pub fn clear_remove_decals(&mut self) {
        self.remove_decals = ::std::option::Option::None;
    }

    pub fn has_remove_decals(&self) -> bool {
        self.remove_decals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_decals(&mut self, v: bool) {
        self.remove_decals = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessageRemoveAllDecals {
    const NAME: &'static str = "CEntityMessageRemoveAllDecals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.remove_decals = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.remove_decals {
            my_size += 1 + 1;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.remove_decals {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageRemoveAllDecals {
        CEntityMessageRemoveAllDecals::new()
    }

    fn clear(&mut self) {
        self.remove_decals = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageRemoveAllDecals {
        static instance: CEntityMessageRemoveAllDecals = CEntityMessageRemoveAllDecals {
            remove_decals: ::std::option::Option::None,
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessagePropagateForce)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessagePropagateForce {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessagePropagateForce.impulse)
    pub impulse: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CEntityMessagePropagateForce.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessagePropagateForce.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessagePropagateForce {
    fn default() -> &'a CEntityMessagePropagateForce {
        <CEntityMessagePropagateForce as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessagePropagateForce {
    pub fn new() -> CEntityMessagePropagateForce {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessagePropagateForce {
    const NAME: &'static str = "CEntityMessagePropagateForce";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.impulse)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.impulse.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.impulse.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessagePropagateForce {
        CEntityMessagePropagateForce::new()
    }

    fn clear(&mut self) {
        self.impulse.clear();
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessagePropagateForce {
        static instance: CEntityMessagePropagateForce = CEntityMessagePropagateForce {
            impulse: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessageDoSpark)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageDoSpark {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.origin)
    pub origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.entityindex)
    pub entityindex: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.radius)
    pub radius: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.color)
    pub color: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.beams)
    pub beams: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.thick)
    pub thick: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CEntityMessageDoSpark.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageDoSpark.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageDoSpark {
    fn default() -> &'a CEntityMessageDoSpark {
        <CEntityMessageDoSpark as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageDoSpark {
    pub fn new() -> CEntityMessageDoSpark {
        ::std::default::Default::default()
    }

    // optional int32 entityindex = 2;

    pub fn entityindex(&self) -> i32 {
        self.entityindex.unwrap_or(-1i32)
    }

    pub fn clear_entityindex(&mut self) {
        self.entityindex = ::std::option::Option::None;
    }

    pub fn has_entityindex(&self) -> bool {
        self.entityindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entityindex(&mut self, v: i32) {
        self.entityindex = ::std::option::Option::Some(v);
    }

    // optional float radius = 3;

    pub fn radius(&self) -> f32 {
        self.radius.unwrap_or(0.)
    }

    pub fn clear_radius(&mut self) {
        self.radius = ::std::option::Option::None;
    }

    pub fn has_radius(&self) -> bool {
        self.radius.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radius(&mut self, v: f32) {
        self.radius = ::std::option::Option::Some(v);
    }

    // optional fixed32 color = 4;

    pub fn color(&self) -> u32 {
        self.color.unwrap_or(0)
    }

    pub fn clear_color(&mut self) {
        self.color = ::std::option::Option::None;
    }

    pub fn has_color(&self) -> bool {
        self.color.is_some()
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: u32) {
        self.color = ::std::option::Option::Some(v);
    }

    // optional uint32 beams = 5;

    pub fn beams(&self) -> u32 {
        self.beams.unwrap_or(0)
    }

    pub fn clear_beams(&mut self) {
        self.beams = ::std::option::Option::None;
    }

    pub fn has_beams(&self) -> bool {
        self.beams.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beams(&mut self, v: u32) {
        self.beams = ::std::option::Option::Some(v);
    }

    // optional float thick = 6;

    pub fn thick(&self) -> f32 {
        self.thick.unwrap_or(0.)
    }

    pub fn clear_thick(&mut self) {
        self.thick = ::std::option::Option::None;
    }

    pub fn has_thick(&self) -> bool {
        self.thick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thick(&mut self, v: f32) {
        self.thick = ::std::option::Option::Some(v);
    }

    // optional float duration = 7;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessageDoSpark {
    const NAME: &'static str = "CEntityMessageDoSpark";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin)?;
                },
                16 => {
                    self.entityindex = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.radius = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.color = ::std::option::Option::Some(is.read_fixed32()?);
                },
                40 => {
                    self.beams = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.thick = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entityindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.radius {
            my_size += 1 + 4;
        }
        if let Some(v) = self.color {
            my_size += 1 + 4;
        }
        if let Some(v) = self.beams {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.thick {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.entityindex {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.radius {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.color {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.beams {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.thick {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageDoSpark {
        CEntityMessageDoSpark::new()
    }

    fn clear(&mut self) {
        self.origin.clear();
        self.entityindex = ::std::option::Option::None;
        self.radius = ::std::option::Option::None;
        self.color = ::std::option::Option::None;
        self.beams = ::std::option::Option::None;
        self.thick = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageDoSpark {
        static instance: CEntityMessageDoSpark = CEntityMessageDoSpark {
            origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entityindex: ::std::option::Option::None,
            radius: ::std::option::Option::None,
            color: ::std::option::Option::None,
            beams: ::std::option::Option::None,
            thick: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEntityMessageFixAngle)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEntityMessageFixAngle {
    // message fields
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.relative)
    pub relative: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.angle)
    pub angle: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgQAngle>,
    // @@protoc_insertion_point(field:CEntityMessageFixAngle.entity_msg)
    pub entity_msg: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CEntityMsg>,
    // special fields
    // @@protoc_insertion_point(special_field:CEntityMessageFixAngle.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEntityMessageFixAngle {
    fn default() -> &'a CEntityMessageFixAngle {
        <CEntityMessageFixAngle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEntityMessageFixAngle {
    pub fn new() -> CEntityMessageFixAngle {
        ::std::default::Default::default()
    }

    // optional bool relative = 1;

    pub fn relative(&self) -> bool {
        self.relative.unwrap_or(false)
    }

    pub fn clear_relative(&mut self) {
        self.relative = ::std::option::Option::None;
    }

    pub fn has_relative(&self) -> bool {
        self.relative.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relative(&mut self, v: bool) {
        self.relative = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEntityMessageFixAngle {
    const NAME: &'static str = "CEntityMessageFixAngle";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.relative = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angle)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.entity_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relative {
            my_size += 1 + 1;
        }
        if let Some(v) = self.angle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.relative {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.angle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.entity_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEntityMessageFixAngle {
        CEntityMessageFixAngle::new()
    }

    fn clear(&mut self) {
        self.relative = ::std::option::Option::None;
        self.angle.clear();
        self.entity_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEntityMessageFixAngle {
        static instance: CEntityMessageFixAngle = CEntityMessageFixAngle {
            relative: ::std::option::Option::None,
            angle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entity_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageCameraTransition)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageCameraTransition {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.camera_type)
    pub camera_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageCameraTransition.params_data_driven)
    pub params_data_driven: ::steam_vent_proto_common::protobuf::MessageField<cuser_message_camera_transition::Transition_DataDriven>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageCameraTransition.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageCameraTransition {
    fn default() -> &'a CUserMessageCameraTransition {
        <CUserMessageCameraTransition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageCameraTransition {
    pub fn new() -> CUserMessageCameraTransition {
        ::std::default::Default::default()
    }

    // optional uint32 camera_type = 1;

    pub fn camera_type(&self) -> u32 {
        self.camera_type.unwrap_or(0)
    }

    pub fn clear_camera_type(&mut self) {
        self.camera_type = ::std::option::Option::None;
    }

    pub fn has_camera_type(&self) -> bool {
        self.camera_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camera_type(&mut self, v: u32) {
        self.camera_type = ::std::option::Option::Some(v);
    }

    // optional float duration = 2;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageCameraTransition {
    const NAME: &'static str = "CUserMessageCameraTransition";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.camera_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.params_data_driven)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.camera_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.params_data_driven.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.camera_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.params_data_driven.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageCameraTransition {
        CUserMessageCameraTransition::new()
    }

    fn clear(&mut self) {
        self.camera_type = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.params_data_driven.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageCameraTransition {
        static instance: CUserMessageCameraTransition = CUserMessageCameraTransition {
            camera_type: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            params_data_driven: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessageCameraTransition`
pub mod cuser_message_camera_transition {
    // @@protoc_insertion_point(message:CUserMessageCameraTransition.Transition_DataDriven)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Transition_DataDriven {
        // message fields
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.filename)
        pub filename: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.attach_ent_index)
        pub attach_ent_index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageCameraTransition.Transition_DataDriven.duration)
        pub duration: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessageCameraTransition.Transition_DataDriven.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Transition_DataDriven {
        fn default() -> &'a Transition_DataDriven {
            <Transition_DataDriven as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Transition_DataDriven {
        pub fn new() -> Transition_DataDriven {
            ::std::default::Default::default()
        }

        // optional string filename = 1;

        pub fn filename(&self) -> &str {
            match self.filename.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_filename(&mut self) {
            self.filename = ::std::option::Option::None;
        }

        pub fn has_filename(&self) -> bool {
            self.filename.is_some()
        }

        // Param is passed by value, moved
        pub fn set_filename(&mut self, v: ::std::string::String) {
            self.filename = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_filename(&mut self) -> &mut ::std::string::String {
            if self.filename.is_none() {
                self.filename = ::std::option::Option::Some(::std::string::String::new());
            }
            self.filename.as_mut().unwrap()
        }

        // Take field
        pub fn take_filename(&mut self) -> ::std::string::String {
            self.filename.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 attach_ent_index = 2;

        pub fn attach_ent_index(&self) -> i32 {
            self.attach_ent_index.unwrap_or(-1i32)
        }

        pub fn clear_attach_ent_index(&mut self) {
            self.attach_ent_index = ::std::option::Option::None;
        }

        pub fn has_attach_ent_index(&self) -> bool {
            self.attach_ent_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_ent_index(&mut self, v: i32) {
            self.attach_ent_index = ::std::option::Option::Some(v);
        }

        // optional float duration = 3;

        pub fn duration(&self) -> f32 {
            self.duration.unwrap_or(0.)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: f32) {
            self.duration = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Transition_DataDriven {
        const NAME: &'static str = "Transition_DataDriven";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.filename = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.attach_ent_index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.filename.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.attach_ent_index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.duration {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.filename.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.attach_ent_index {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.duration {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Transition_DataDriven {
            Transition_DataDriven::new()
        }

        fn clear(&mut self) {
            self.filename = ::std::option::Option::None;
            self.attach_ent_index = ::std::option::Option::None;
            self.duration = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Transition_DataDriven {
            static instance: Transition_DataDriven = Transition_DataDriven {
                filename: ::std::option::Option::None,
                attach_ent_index: ::std::option::Option::None,
                duration: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMsg_ParticleManager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_ParticleManager {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<PARTICLE_MESSAGE>>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.index)
    pub index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.release_particle_index)
    pub release_particle_index: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ReleaseParticleIndex>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.create_particle)
    pub create_particle: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::CreateParticle>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle)
    pub destroy_particle: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticle>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle_involving)
    pub destroy_particle_involving: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticleInvolving>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle)
    pub update_particle: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticle_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_fwd)
    pub update_particle_fwd: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleFwd_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_orient)
    pub update_particle_orient: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleOrient_OBSOLETE>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_fallback)
    pub update_particle_fallback: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleFallback>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_offset)
    pub update_particle_offset: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleOffset>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_ent)
    pub update_particle_ent: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleEnt>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_should_draw)
    pub update_particle_should_draw: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleShouldDraw>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_set_frozen)
    pub update_particle_set_frozen: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleSetFrozen>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.change_control_point_attachment)
    pub change_control_point_attachment: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ChangeControlPointAttachment>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_entity_position)
    pub update_entity_position: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateEntityPosition>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_fow_properties)
    pub set_particle_fow_properties: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetParticleFoWProperties>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_text)
    pub set_particle_text: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetParticleText>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_particle_should_check_fow)
    pub set_particle_should_check_fow: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetParticleShouldCheckFoW>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_control_point_model)
    pub set_control_point_model: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetControlPointModel>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_control_point_snapshot)
    pub set_control_point_snapshot: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetControlPointSnapshot>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_texture_attribute)
    pub set_texture_attribute: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetTextureAttribute>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_scene_object_generic_flag)
    pub set_scene_object_generic_flag: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetSceneObjectGenericFlag>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_scene_object_tint_and_desat)
    pub set_scene_object_tint_and_desat: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetSceneObjectTintAndDesat>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_particle_named)
    pub destroy_particle_named: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::DestroyParticleNamed>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_skip_to_time)
    pub particle_skip_to_time: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ParticleSkipToTime>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_can_freeze)
    pub particle_can_freeze: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ParticleCanFreeze>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_named_value_context)
    pub set_named_value_context: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetParticleNamedValueContext>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.update_particle_transform)
    pub update_particle_transform: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::UpdateParticleTransform>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.particle_freeze_transition_override)
    pub particle_freeze_transition_override: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ParticleFreezeTransitionOverride>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.freeze_particle_involving)
    pub freeze_particle_involving: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::FreezeParticleInvolving>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.add_modellist_override_element)
    pub add_modellist_override_element: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::AddModellistOverrideElement>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.clear_modellist_override)
    pub clear_modellist_override: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::ClearModellistOverride>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.create_physics_sim)
    pub create_physics_sim: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::CreatePhysicsSim>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.destroy_physics_sim)
    pub destroy_physics_sim: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::DestroyPhysicsSim>,
    // @@protoc_insertion_point(field:CUserMsg_ParticleManager.set_vdata)
    pub set_vdata: ::steam_vent_proto_common::protobuf::MessageField<cuser_msg_particle_manager::SetVData>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_ParticleManager {
    fn default() -> &'a CUserMsg_ParticleManager {
        <CUserMsg_ParticleManager as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_ParticleManager {
    pub fn new() -> CUserMsg_ParticleManager {
        ::std::default::Default::default()
    }

    // required .PARTICLE_MESSAGE type = 1;

    pub fn type_(&self) -> PARTICLE_MESSAGE {
        match self.type_ {
            Some(e) => e.enum_value_or(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            None => PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: PARTICLE_MESSAGE) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // required uint32 index = 2;

    pub fn index(&self) -> u32 {
        self.index.unwrap_or(0)
    }

    pub fn clear_index(&mut self) {
        self.index = ::std::option::Option::None;
    }

    pub fn has_index(&self) -> bool {
        self.index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: u32) {
        self.index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMsg_ParticleManager {
    const NAME: &'static str = "CUserMsg_ParticleManager";

    fn is_initialized(&self) -> bool {
        if self.type_.is_none() {
            return false;
        }
        if self.index.is_none() {
            return false;
        }
        for v in &self.release_particle_index {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle_involving {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fwd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_orient {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_fallback {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_offset {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_ent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_should_draw {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_set_frozen {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.change_control_point_attachment {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_entity_position {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_fow_properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_text {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_particle_should_check_fow {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_control_point_model {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_control_point_snapshot {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_texture_attribute {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_scene_object_generic_flag {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_scene_object_tint_and_desat {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_particle_named {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_skip_to_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_can_freeze {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_named_value_context {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.update_particle_transform {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.particle_freeze_transition_override {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.freeze_particle_involving {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.add_modellist_override_element {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clear_modellist_override {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.create_physics_sim {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destroy_physics_sim {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.set_vdata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.index = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.release_particle_index)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.create_particle)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle_involving)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_fwd)?;
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_orient)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_fallback)?;
                },
                90 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_offset)?;
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_ent)?;
                },
                114 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_should_draw)?;
                },
                122 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_set_frozen)?;
                },
                130 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.change_control_point_attachment)?;
                },
                138 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_entity_position)?;
                },
                146 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_fow_properties)?;
                },
                154 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_text)?;
                },
                162 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_particle_should_check_fow)?;
                },
                170 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_control_point_model)?;
                },
                178 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_control_point_snapshot)?;
                },
                186 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_texture_attribute)?;
                },
                194 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_scene_object_generic_flag)?;
                },
                202 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_scene_object_tint_and_desat)?;
                },
                210 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_particle_named)?;
                },
                218 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_skip_to_time)?;
                },
                226 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_can_freeze)?;
                },
                234 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_named_value_context)?;
                },
                242 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update_particle_transform)?;
                },
                250 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.particle_freeze_transition_override)?;
                },
                258 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.freeze_particle_involving)?;
                },
                266 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.add_modellist_override_element)?;
                },
                274 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.clear_modellist_override)?;
                },
                282 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.create_physics_sim)?;
                },
                290 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.destroy_physics_sim)?;
                },
                298 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.set_vdata)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.release_particle_index.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.create_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle_involving.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_fwd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_orient.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_fallback.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_offset.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_ent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_should_draw.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_set_frozen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.change_control_point_attachment.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_entity_position.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_fow_properties.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_text.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_particle_should_check_fow.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_control_point_model.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_control_point_snapshot.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_texture_attribute.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_scene_object_generic_flag.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_scene_object_tint_and_desat.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_particle_named.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_skip_to_time.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_can_freeze.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_named_value_context.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.update_particle_transform.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.particle_freeze_transition_override.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.freeze_particle_involving.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.add_modellist_override_element.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.clear_modellist_override.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.create_physics_sim.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.destroy_physics_sim.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.set_vdata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.release_particle_index.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.create_particle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.destroy_particle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.destroy_particle_involving.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.update_particle.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.update_particle_fwd.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.update_particle_orient.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.update_particle_fallback.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.update_particle_offset.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.update_particle_ent.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.update_particle_should_draw.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.update_particle_set_frozen.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.change_control_point_attachment.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.update_entity_position.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.set_particle_fow_properties.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        }
        if let Some(v) = self.set_particle_text.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(19, v, os)?;
        }
        if let Some(v) = self.set_particle_should_check_fow.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        }
        if let Some(v) = self.set_control_point_model.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        }
        if let Some(v) = self.set_control_point_snapshot.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        if let Some(v) = self.set_texture_attribute.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(23, v, os)?;
        }
        if let Some(v) = self.set_scene_object_generic_flag.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(24, v, os)?;
        }
        if let Some(v) = self.set_scene_object_tint_and_desat.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(25, v, os)?;
        }
        if let Some(v) = self.destroy_particle_named.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        }
        if let Some(v) = self.particle_skip_to_time.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
        }
        if let Some(v) = self.particle_can_freeze.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(28, v, os)?;
        }
        if let Some(v) = self.set_named_value_context.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(29, v, os)?;
        }
        if let Some(v) = self.update_particle_transform.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(30, v, os)?;
        }
        if let Some(v) = self.particle_freeze_transition_override.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.freeze_particle_involving.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
        }
        if let Some(v) = self.add_modellist_override_element.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
        }
        if let Some(v) = self.clear_modellist_override.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        }
        if let Some(v) = self.create_physics_sim.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        if let Some(v) = self.destroy_physics_sim.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        }
        if let Some(v) = self.set_vdata.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_ParticleManager {
        CUserMsg_ParticleManager::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.index = ::std::option::Option::None;
        self.release_particle_index.clear();
        self.create_particle.clear();
        self.destroy_particle.clear();
        self.destroy_particle_involving.clear();
        self.update_particle.clear();
        self.update_particle_fwd.clear();
        self.update_particle_orient.clear();
        self.update_particle_fallback.clear();
        self.update_particle_offset.clear();
        self.update_particle_ent.clear();
        self.update_particle_should_draw.clear();
        self.update_particle_set_frozen.clear();
        self.change_control_point_attachment.clear();
        self.update_entity_position.clear();
        self.set_particle_fow_properties.clear();
        self.set_particle_text.clear();
        self.set_particle_should_check_fow.clear();
        self.set_control_point_model.clear();
        self.set_control_point_snapshot.clear();
        self.set_texture_attribute.clear();
        self.set_scene_object_generic_flag.clear();
        self.set_scene_object_tint_and_desat.clear();
        self.destroy_particle_named.clear();
        self.particle_skip_to_time.clear();
        self.particle_can_freeze.clear();
        self.set_named_value_context.clear();
        self.update_particle_transform.clear();
        self.particle_freeze_transition_override.clear();
        self.freeze_particle_involving.clear();
        self.add_modellist_override_element.clear();
        self.clear_modellist_override.clear();
        self.create_physics_sim.clear();
        self.destroy_physics_sim.clear();
        self.set_vdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_ParticleManager {
        static instance: CUserMsg_ParticleManager = CUserMsg_ParticleManager {
            type_: ::std::option::Option::None,
            index: ::std::option::Option::None,
            release_particle_index: ::steam_vent_proto_common::protobuf::MessageField::none(),
            create_particle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            destroy_particle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            destroy_particle_involving: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_fwd: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_orient: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_fallback: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_ent: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_should_draw: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_set_frozen: ::steam_vent_proto_common::protobuf::MessageField::none(),
            change_control_point_attachment: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_entity_position: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_particle_fow_properties: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_particle_text: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_particle_should_check_fow: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_control_point_model: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_control_point_snapshot: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_texture_attribute: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_scene_object_generic_flag: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_scene_object_tint_and_desat: ::steam_vent_proto_common::protobuf::MessageField::none(),
            destroy_particle_named: ::steam_vent_proto_common::protobuf::MessageField::none(),
            particle_skip_to_time: ::steam_vent_proto_common::protobuf::MessageField::none(),
            particle_can_freeze: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_named_value_context: ::steam_vent_proto_common::protobuf::MessageField::none(),
            update_particle_transform: ::steam_vent_proto_common::protobuf::MessageField::none(),
            particle_freeze_transition_override: ::steam_vent_proto_common::protobuf::MessageField::none(),
            freeze_particle_involving: ::steam_vent_proto_common::protobuf::MessageField::none(),
            add_modellist_override_element: ::steam_vent_proto_common::protobuf::MessageField::none(),
            clear_modellist_override: ::steam_vent_proto_common::protobuf::MessageField::none(),
            create_physics_sim: ::steam_vent_proto_common::protobuf::MessageField::none(),
            destroy_physics_sim: ::steam_vent_proto_common::protobuf::MessageField::none(),
            set_vdata: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMsg_ParticleManager`
pub mod cuser_msg_particle_manager {
    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ReleaseParticleIndex)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReleaseParticleIndex {
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ReleaseParticleIndex.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReleaseParticleIndex {
        fn default() -> &'a ReleaseParticleIndex {
            <ReleaseParticleIndex as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ReleaseParticleIndex {
        pub fn new() -> ReleaseParticleIndex {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ReleaseParticleIndex {
        const NAME: &'static str = "ReleaseParticleIndex";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReleaseParticleIndex {
            ReleaseParticleIndex::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReleaseParticleIndex {
            static instance: ReleaseParticleIndex = ReleaseParticleIndex {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.CreateParticle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CreateParticle {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.particle_name_index)
        pub particle_name_index: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.attach_type)
        pub attach_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.entity_handle_for_modifiers)
        pub entity_handle_for_modifiers: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.apply_voice_ban_rules)
        pub apply_voice_ban_rules: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.team_behavior)
        pub team_behavior: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.control_point_configuration)
        pub control_point_configuration: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.cluster)
        pub cluster: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreateParticle.endcap_time)
        pub endcap_time: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.CreateParticle.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CreateParticle {
        fn default() -> &'a CreateParticle {
            <CreateParticle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CreateParticle {
        pub fn new() -> CreateParticle {
            ::std::default::Default::default()
        }

        // optional fixed64 particle_name_index = 1;

        pub fn particle_name_index(&self) -> u64 {
            self.particle_name_index.unwrap_or(0)
        }

        pub fn clear_particle_name_index(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
        }

        pub fn has_particle_name_index(&self) -> bool {
            self.particle_name_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_particle_name_index(&mut self, v: u64) {
            self.particle_name_index = ::std::option::Option::Some(v);
        }

        // optional int32 attach_type = 2;

        pub fn attach_type(&self) -> i32 {
            self.attach_type.unwrap_or(0)
        }

        pub fn clear_attach_type(&mut self) {
            self.attach_type = ::std::option::Option::None;
        }

        pub fn has_attach_type(&self) -> bool {
            self.attach_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_type(&mut self, v: i32) {
            self.attach_type = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle_for_modifiers = 4;

        pub fn entity_handle_for_modifiers(&self) -> u32 {
            self.entity_handle_for_modifiers.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle_for_modifiers(&mut self) {
            self.entity_handle_for_modifiers = ::std::option::Option::None;
        }

        pub fn has_entity_handle_for_modifiers(&self) -> bool {
            self.entity_handle_for_modifiers.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle_for_modifiers(&mut self, v: u32) {
            self.entity_handle_for_modifiers = ::std::option::Option::Some(v);
        }

        // optional bool apply_voice_ban_rules = 5;

        pub fn apply_voice_ban_rules(&self) -> bool {
            self.apply_voice_ban_rules.unwrap_or(false)
        }

        pub fn clear_apply_voice_ban_rules(&mut self) {
            self.apply_voice_ban_rules = ::std::option::Option::None;
        }

        pub fn has_apply_voice_ban_rules(&self) -> bool {
            self.apply_voice_ban_rules.is_some()
        }

        // Param is passed by value, moved
        pub fn set_apply_voice_ban_rules(&mut self, v: bool) {
            self.apply_voice_ban_rules = ::std::option::Option::Some(v);
        }

        // optional int32 team_behavior = 6;

        pub fn team_behavior(&self) -> i32 {
            self.team_behavior.unwrap_or(0)
        }

        pub fn clear_team_behavior(&mut self) {
            self.team_behavior = ::std::option::Option::None;
        }

        pub fn has_team_behavior(&self) -> bool {
            self.team_behavior.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_behavior(&mut self, v: i32) {
            self.team_behavior = ::std::option::Option::Some(v);
        }

        // optional string control_point_configuration = 7;

        pub fn control_point_configuration(&self) -> &str {
            match self.control_point_configuration.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_control_point_configuration(&mut self) {
            self.control_point_configuration = ::std::option::Option::None;
        }

        pub fn has_control_point_configuration(&self) -> bool {
            self.control_point_configuration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point_configuration(&mut self, v: ::std::string::String) {
            self.control_point_configuration = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_control_point_configuration(&mut self) -> &mut ::std::string::String {
            if self.control_point_configuration.is_none() {
                self.control_point_configuration = ::std::option::Option::Some(::std::string::String::new());
            }
            self.control_point_configuration.as_mut().unwrap()
        }

        // Take field
        pub fn take_control_point_configuration(&mut self) -> ::std::string::String {
            self.control_point_configuration.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool cluster = 8;

        pub fn cluster(&self) -> bool {
            self.cluster.unwrap_or(false)
        }

        pub fn clear_cluster(&mut self) {
            self.cluster = ::std::option::Option::None;
        }

        pub fn has_cluster(&self) -> bool {
            self.cluster.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cluster(&mut self, v: bool) {
            self.cluster = ::std::option::Option::Some(v);
        }

        // optional float endcap_time = 9;

        pub fn endcap_time(&self) -> f32 {
            self.endcap_time.unwrap_or(0.)
        }

        pub fn clear_endcap_time(&mut self) {
            self.endcap_time = ::std::option::Option::None;
        }

        pub fn has_endcap_time(&self) -> bool {
            self.endcap_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_endcap_time(&mut self, v: f32) {
            self.endcap_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CreateParticle {
        const NAME: &'static str = "CreateParticle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.particle_name_index = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.attach_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.entity_handle_for_modifiers = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.apply_voice_ban_rules = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.team_behavior = ::std::option::Option::Some(is.read_int32()?);
                    },
                    58 => {
                        self.control_point_configuration = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.cluster = ::std::option::Option::Some(is.read_bool()?);
                    },
                    77 => {
                        self.endcap_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.particle_name_index {
                my_size += 1 + 8;
            }
            if let Some(v) = self.attach_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.entity_handle_for_modifiers {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.apply_voice_ban_rules {
                my_size += 1 + 1;
            }
            if let Some(v) = self.team_behavior {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.control_point_configuration.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.cluster {
                my_size += 1 + 1;
            }
            if let Some(v) = self.endcap_time {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.particle_name_index {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.attach_type {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.entity_handle_for_modifiers {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.apply_voice_ban_rules {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.team_behavior {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.control_point_configuration.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.cluster {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.endcap_time {
                os.write_float(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CreateParticle {
            CreateParticle::new()
        }

        fn clear(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
            self.attach_type = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.entity_handle_for_modifiers = ::std::option::Option::None;
            self.apply_voice_ban_rules = ::std::option::Option::None;
            self.team_behavior = ::std::option::Option::None;
            self.control_point_configuration = ::std::option::Option::None;
            self.cluster = ::std::option::Option::None;
            self.endcap_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CreateParticle {
            static instance: CreateParticle = CreateParticle {
                particle_name_index: ::std::option::Option::None,
                attach_type: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                entity_handle_for_modifiers: ::std::option::Option::None,
                apply_voice_ban_rules: ::std::option::Option::None,
                team_behavior: ::std::option::Option::None,
                control_point_configuration: ::std::option::Option::None,
                cluster: ::std::option::Option::None,
                endcap_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticle)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticle {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticle.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticle.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticle {
        fn default() -> &'a DestroyParticle {
            <DestroyParticle as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticle {
        pub fn new() -> DestroyParticle {
            ::std::default::Default::default()
        }

        // optional bool destroy_immediately = 1;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DestroyParticle {
        const NAME: &'static str = "DestroyParticle";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.destroy_immediately {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticle {
            DestroyParticle::new()
        }

        fn clear(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticle {
            static instance: DestroyParticle = DestroyParticle {
                destroy_immediately: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticleInvolving)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticleInvolving {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleInvolving.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleInvolving.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticleInvolving.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticleInvolving {
        fn default() -> &'a DestroyParticleInvolving {
            <DestroyParticleInvolving as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticleInvolving {
        pub fn new() -> DestroyParticleInvolving {
            ::std::default::Default::default()
        }

        // optional bool destroy_immediately = 1;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DestroyParticleInvolving {
        const NAME: &'static str = "DestroyParticleInvolving";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.destroy_immediately {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticleInvolving {
            DestroyParticleInvolving::new()
        }

        fn clear(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticleInvolving {
            static instance: DestroyParticleInvolving = DestroyParticleInvolving {
                destroy_immediately: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyParticleNamed)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyParticleNamed {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.particle_name_index)
        pub particle_name_index: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.destroy_immediately)
        pub destroy_immediately: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.DestroyParticleNamed.play_endcap)
        pub play_endcap: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyParticleNamed.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyParticleNamed {
        fn default() -> &'a DestroyParticleNamed {
            <DestroyParticleNamed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DestroyParticleNamed {
        pub fn new() -> DestroyParticleNamed {
            ::std::default::Default::default()
        }

        // optional fixed64 particle_name_index = 1;

        pub fn particle_name_index(&self) -> u64 {
            self.particle_name_index.unwrap_or(0)
        }

        pub fn clear_particle_name_index(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
        }

        pub fn has_particle_name_index(&self) -> bool {
            self.particle_name_index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_particle_name_index(&mut self, v: u64) {
            self.particle_name_index = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 2;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional bool destroy_immediately = 3;

        pub fn destroy_immediately(&self) -> bool {
            self.destroy_immediately.unwrap_or(false)
        }

        pub fn clear_destroy_immediately(&mut self) {
            self.destroy_immediately = ::std::option::Option::None;
        }

        pub fn has_destroy_immediately(&self) -> bool {
            self.destroy_immediately.is_some()
        }

        // Param is passed by value, moved
        pub fn set_destroy_immediately(&mut self, v: bool) {
            self.destroy_immediately = ::std::option::Option::Some(v);
        }

        // optional bool play_endcap = 4;

        pub fn play_endcap(&self) -> bool {
            self.play_endcap.unwrap_or(false)
        }

        pub fn clear_play_endcap(&mut self) {
            self.play_endcap = ::std::option::Option::None;
        }

        pub fn has_play_endcap(&self) -> bool {
            self.play_endcap.is_some()
        }

        // Param is passed by value, moved
        pub fn set_play_endcap(&mut self, v: bool) {
            self.play_endcap = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DestroyParticleNamed {
        const NAME: &'static str = "DestroyParticleNamed";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.particle_name_index = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.destroy_immediately = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.play_endcap = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.particle_name_index {
                my_size += 1 + 8;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.destroy_immediately {
                my_size += 1 + 1;
            }
            if let Some(v) = self.play_endcap {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.particle_name_index {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.destroy_immediately {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.play_endcap {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyParticleNamed {
            DestroyParticleNamed::new()
        }

        fn clear(&mut self) {
            self.particle_name_index = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.destroy_immediately = ::std::option::Option::None;
            self.play_endcap = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyParticleNamed {
            static instance: DestroyParticleNamed = DestroyParticleNamed {
                particle_name_index: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                destroy_immediately: ::std::option::Option::None,
                play_endcap: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticle_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.position)
        pub position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticle_OBSOLETE.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticle_OBSOLETE {
        fn default() -> &'a UpdateParticle_OBSOLETE {
            <UpdateParticle_OBSOLETE as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticle_OBSOLETE {
        pub fn new() -> UpdateParticle_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticle_OBSOLETE {
        const NAME: &'static str = "UpdateParticle_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticle_OBSOLETE {
            UpdateParticle_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticle_OBSOLETE {
            static instance: UpdateParticle_OBSOLETE = UpdateParticle_OBSOLETE {
                control_point: ::std::option::Option::None,
                position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleFwd_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.forward)
        pub forward: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleFwd_OBSOLETE.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleFwd_OBSOLETE {
        fn default() -> &'a UpdateParticleFwd_OBSOLETE {
            <UpdateParticleFwd_OBSOLETE as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleFwd_OBSOLETE {
        pub fn new() -> UpdateParticleFwd_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleFwd_OBSOLETE {
        const NAME: &'static str = "UpdateParticleFwd_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.forward)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.forward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.forward.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleFwd_OBSOLETE {
            UpdateParticleFwd_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.forward.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleFwd_OBSOLETE {
            static instance: UpdateParticleFwd_OBSOLETE = UpdateParticleFwd_OBSOLETE {
                control_point: ::std::option::Option::None,
                forward: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleOrient_OBSOLETE {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.forward)
        pub forward: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.deprecated_right)
        pub deprecated_right: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.up)
        pub up: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.left)
        pub left: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleOrient_OBSOLETE.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleOrient_OBSOLETE {
        fn default() -> &'a UpdateParticleOrient_OBSOLETE {
            <UpdateParticleOrient_OBSOLETE as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleOrient_OBSOLETE {
        pub fn new() -> UpdateParticleOrient_OBSOLETE {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleOrient_OBSOLETE {
        const NAME: &'static str = "UpdateParticleOrient_OBSOLETE";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.forward)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.deprecated_right)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.up)?;
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.left)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.forward.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.deprecated_right.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.up.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.left.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.forward.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.deprecated_right.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.up.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.left.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleOrient_OBSOLETE {
            UpdateParticleOrient_OBSOLETE::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.forward.clear();
            self.deprecated_right.clear();
            self.up.clear();
            self.left.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleOrient_OBSOLETE {
            static instance: UpdateParticleOrient_OBSOLETE = UpdateParticleOrient_OBSOLETE {
                control_point: ::std::option::Option::None,
                forward: ::steam_vent_proto_common::protobuf::MessageField::none(),
                deprecated_right: ::steam_vent_proto_common::protobuf::MessageField::none(),
                up: ::steam_vent_proto_common::protobuf::MessageField::none(),
                left: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleTransform)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleTransform {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.position)
        pub position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.orientation)
        pub orientation: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgQuaternion>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleTransform.interpolation_interval)
        pub interpolation_interval: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleTransform.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleTransform {
        fn default() -> &'a UpdateParticleTransform {
            <UpdateParticleTransform as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleTransform {
        pub fn new() -> UpdateParticleTransform {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional float interpolation_interval = 4;

        pub fn interpolation_interval(&self) -> f32 {
            self.interpolation_interval.unwrap_or(0.)
        }

        pub fn clear_interpolation_interval(&mut self) {
            self.interpolation_interval = ::std::option::Option::None;
        }

        pub fn has_interpolation_interval(&self) -> bool {
            self.interpolation_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_interpolation_interval(&mut self, v: f32) {
            self.interpolation_interval = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleTransform {
        const NAME: &'static str = "UpdateParticleTransform";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.orientation)?;
                    },
                    37 => {
                        self.interpolation_interval = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.orientation.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.interpolation_interval {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.orientation.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.interpolation_interval {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleTransform {
            UpdateParticleTransform::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.orientation.clear();
            self.interpolation_interval = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleTransform {
            static instance: UpdateParticleTransform = UpdateParticleTransform {
                control_point: ::std::option::Option::None,
                position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                orientation: ::steam_vent_proto_common::protobuf::MessageField::none(),
                interpolation_interval: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleFallback)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleFallback {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFallback.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleFallback.position)
        pub position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleFallback.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleFallback {
        fn default() -> &'a UpdateParticleFallback {
            <UpdateParticleFallback as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleFallback {
        pub fn new() -> UpdateParticleFallback {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleFallback {
        const NAME: &'static str = "UpdateParticleFallback";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleFallback {
            UpdateParticleFallback::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleFallback {
            static instance: UpdateParticleFallback = UpdateParticleFallback {
                control_point: ::std::option::Option::None,
                position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleOffset)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleOffset {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.origin_offset)
        pub origin_offset: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleOffset.angle_offset)
        pub angle_offset: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgQAngle>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleOffset.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleOffset {
        fn default() -> &'a UpdateParticleOffset {
            <UpdateParticleOffset as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleOffset {
        pub fn new() -> UpdateParticleOffset {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleOffset {
        const NAME: &'static str = "UpdateParticleOffset";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.origin_offset)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angle_offset)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.origin_offset.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.angle_offset.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.origin_offset.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.angle_offset.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleOffset {
            UpdateParticleOffset::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.origin_offset.clear();
            self.angle_offset.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleOffset {
            static instance: UpdateParticleOffset = UpdateParticleOffset {
                control_point: ::std::option::Option::None,
                origin_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
                angle_offset: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleEnt)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleEnt {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.attach_type)
        pub attach_type: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.attachment)
        pub attachment: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.fallback_position)
        pub fallback_position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.include_wearables)
        pub include_wearables: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.offset_position)
        pub offset_position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleEnt.offset_angles)
        pub offset_angles: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgQAngle>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleEnt.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleEnt {
        fn default() -> &'a UpdateParticleEnt {
            <UpdateParticleEnt as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleEnt {
        pub fn new() -> UpdateParticleEnt {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 2;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }

        // optional int32 attach_type = 3;

        pub fn attach_type(&self) -> i32 {
            self.attach_type.unwrap_or(0)
        }

        pub fn clear_attach_type(&mut self) {
            self.attach_type = ::std::option::Option::None;
        }

        pub fn has_attach_type(&self) -> bool {
            self.attach_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attach_type(&mut self, v: i32) {
            self.attach_type = ::std::option::Option::Some(v);
        }

        // optional int32 attachment = 4;

        pub fn attachment(&self) -> i32 {
            self.attachment.unwrap_or(0)
        }

        pub fn clear_attachment(&mut self) {
            self.attachment = ::std::option::Option::None;
        }

        pub fn has_attachment(&self) -> bool {
            self.attachment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment(&mut self, v: i32) {
            self.attachment = ::std::option::Option::Some(v);
        }

        // optional bool include_wearables = 6;

        pub fn include_wearables(&self) -> bool {
            self.include_wearables.unwrap_or(false)
        }

        pub fn clear_include_wearables(&mut self) {
            self.include_wearables = ::std::option::Option::None;
        }

        pub fn has_include_wearables(&self) -> bool {
            self.include_wearables.is_some()
        }

        // Param is passed by value, moved
        pub fn set_include_wearables(&mut self, v: bool) {
            self.include_wearables = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleEnt {
        const NAME: &'static str = "UpdateParticleEnt";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.attach_type = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.attachment = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fallback_position)?;
                    },
                    48 => {
                        self.include_wearables = ::std::option::Option::Some(is.read_bool()?);
                    },
                    58 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_position)?;
                    },
                    66 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.offset_angles)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.attach_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.attachment {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.fallback_position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.include_wearables {
                my_size += 1 + 1;
            }
            if let Some(v) = self.offset_position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.offset_angles.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.attach_type {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.attachment {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.fallback_position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.include_wearables {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.offset_position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            if let Some(v) = self.offset_angles.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleEnt {
            UpdateParticleEnt::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.attach_type = ::std::option::Option::None;
            self.attachment = ::std::option::Option::None;
            self.fallback_position.clear();
            self.include_wearables = ::std::option::Option::None;
            self.offset_position.clear();
            self.offset_angles.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleEnt {
            static instance: UpdateParticleEnt = UpdateParticleEnt {
                control_point: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                attach_type: ::std::option::Option::None,
                attachment: ::std::option::Option::None,
                fallback_position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                include_wearables: ::std::option::Option::None,
                offset_position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                offset_angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleSetFrozen)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleSetFrozen {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.set_frozen)
        pub set_frozen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.transition_duration)
        pub transition_duration: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleSetFrozen.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleSetFrozen {
        fn default() -> &'a UpdateParticleSetFrozen {
            <UpdateParticleSetFrozen as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleSetFrozen {
        pub fn new() -> UpdateParticleSetFrozen {
            ::std::default::Default::default()
        }

        // optional bool set_frozen = 1;

        pub fn set_frozen(&self) -> bool {
            self.set_frozen.unwrap_or(false)
        }

        pub fn clear_set_frozen(&mut self) {
            self.set_frozen = ::std::option::Option::None;
        }

        pub fn has_set_frozen(&self) -> bool {
            self.set_frozen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_set_frozen(&mut self, v: bool) {
            self.set_frozen = ::std::option::Option::Some(v);
        }

        // optional float transition_duration = 2;

        pub fn transition_duration(&self) -> f32 {
            self.transition_duration.unwrap_or(0.)
        }

        pub fn clear_transition_duration(&mut self) {
            self.transition_duration = ::std::option::Option::None;
        }

        pub fn has_transition_duration(&self) -> bool {
            self.transition_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_transition_duration(&mut self, v: f32) {
            self.transition_duration = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleSetFrozen {
        const NAME: &'static str = "UpdateParticleSetFrozen";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.set_frozen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    21 => {
                        self.transition_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.set_frozen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.transition_duration {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.set_frozen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.transition_duration {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleSetFrozen {
            UpdateParticleSetFrozen::new()
        }

        fn clear(&mut self) {
            self.set_frozen = ::std::option::Option::None;
            self.transition_duration = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleSetFrozen {
            static instance: UpdateParticleSetFrozen = UpdateParticleSetFrozen {
                set_frozen: ::std::option::Option::None,
                transition_duration: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateParticleShouldDraw)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateParticleShouldDraw {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateParticleShouldDraw.should_draw)
        pub should_draw: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateParticleShouldDraw.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateParticleShouldDraw {
        fn default() -> &'a UpdateParticleShouldDraw {
            <UpdateParticleShouldDraw as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateParticleShouldDraw {
        pub fn new() -> UpdateParticleShouldDraw {
            ::std::default::Default::default()
        }

        // optional bool should_draw = 1;

        pub fn should_draw(&self) -> bool {
            self.should_draw.unwrap_or(false)
        }

        pub fn clear_should_draw(&mut self) {
            self.should_draw = ::std::option::Option::None;
        }

        pub fn has_should_draw(&self) -> bool {
            self.should_draw.is_some()
        }

        // Param is passed by value, moved
        pub fn set_should_draw(&mut self, v: bool) {
            self.should_draw = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateParticleShouldDraw {
        const NAME: &'static str = "UpdateParticleShouldDraw";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.should_draw = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.should_draw {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.should_draw {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateParticleShouldDraw {
            UpdateParticleShouldDraw::new()
        }

        fn clear(&mut self) {
            self.should_draw = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateParticleShouldDraw {
            static instance: UpdateParticleShouldDraw = UpdateParticleShouldDraw {
                should_draw: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ChangeControlPointAttachment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChangeControlPointAttachment {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_old)
        pub attachment_old: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.attachment_new)
        pub attachment_new: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ChangeControlPointAttachment.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ChangeControlPointAttachment.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChangeControlPointAttachment {
        fn default() -> &'a ChangeControlPointAttachment {
            <ChangeControlPointAttachment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ChangeControlPointAttachment {
        pub fn new() -> ChangeControlPointAttachment {
            ::std::default::Default::default()
        }

        // optional int32 attachment_old = 1;

        pub fn attachment_old(&self) -> i32 {
            self.attachment_old.unwrap_or(0)
        }

        pub fn clear_attachment_old(&mut self) {
            self.attachment_old = ::std::option::Option::None;
        }

        pub fn has_attachment_old(&self) -> bool {
            self.attachment_old.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment_old(&mut self, v: i32) {
            self.attachment_old = ::std::option::Option::Some(v);
        }

        // optional int32 attachment_new = 2;

        pub fn attachment_new(&self) -> i32 {
            self.attachment_new.unwrap_or(0)
        }

        pub fn clear_attachment_new(&mut self) {
            self.attachment_new = ::std::option::Option::None;
        }

        pub fn has_attachment_new(&self) -> bool {
            self.attachment_new.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attachment_new(&mut self, v: i32) {
            self.attachment_new = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ChangeControlPointAttachment {
        const NAME: &'static str = "ChangeControlPointAttachment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.attachment_old = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.attachment_new = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attachment_old {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.attachment_new {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.attachment_old {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.attachment_new {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChangeControlPointAttachment {
            ChangeControlPointAttachment::new()
        }

        fn clear(&mut self) {
            self.attachment_old = ::std::option::Option::None;
            self.attachment_new = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChangeControlPointAttachment {
            static instance: ChangeControlPointAttachment = ChangeControlPointAttachment {
                attachment_old: ::std::option::Option::None,
                attachment_new: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.UpdateEntityPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct UpdateEntityPosition {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateEntityPosition.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.UpdateEntityPosition.position)
        pub position: ::steam_vent_proto_common::protobuf::MessageField<super::super::networkbasetypes::CMsgVector>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.UpdateEntityPosition.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a UpdateEntityPosition {
        fn default() -> &'a UpdateEntityPosition {
            <UpdateEntityPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl UpdateEntityPosition {
        pub fn new() -> UpdateEntityPosition {
            ::std::default::Default::default()
        }

        // optional uint32 entity_handle = 1;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for UpdateEntityPosition {
        const NAME: &'static str = "UpdateEntityPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.position)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.position.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.entity_handle {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.position.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> UpdateEntityPosition {
            UpdateEntityPosition::new()
        }

        fn clear(&mut self) {
            self.entity_handle = ::std::option::Option::None;
            self.position.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static UpdateEntityPosition {
            static instance: UpdateEntityPosition = UpdateEntityPosition {
                entity_handle: ::std::option::Option::None,
                position: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleFoWProperties)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleFoWProperties {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_control_point)
        pub fow_control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_control_point2)
        pub fow_control_point2: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleFoWProperties.fow_radius)
        pub fow_radius: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleFoWProperties.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleFoWProperties {
        fn default() -> &'a SetParticleFoWProperties {
            <SetParticleFoWProperties as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleFoWProperties {
        pub fn new() -> SetParticleFoWProperties {
            ::std::default::Default::default()
        }

        // optional int32 fow_control_point = 1;

        pub fn fow_control_point(&self) -> i32 {
            self.fow_control_point.unwrap_or(0)
        }

        pub fn clear_fow_control_point(&mut self) {
            self.fow_control_point = ::std::option::Option::None;
        }

        pub fn has_fow_control_point(&self) -> bool {
            self.fow_control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_control_point(&mut self, v: i32) {
            self.fow_control_point = ::std::option::Option::Some(v);
        }

        // optional int32 fow_control_point2 = 2;

        pub fn fow_control_point2(&self) -> i32 {
            self.fow_control_point2.unwrap_or(0)
        }

        pub fn clear_fow_control_point2(&mut self) {
            self.fow_control_point2 = ::std::option::Option::None;
        }

        pub fn has_fow_control_point2(&self) -> bool {
            self.fow_control_point2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_control_point2(&mut self, v: i32) {
            self.fow_control_point2 = ::std::option::Option::Some(v);
        }

        // optional float fow_radius = 3;

        pub fn fow_radius(&self) -> f32 {
            self.fow_radius.unwrap_or(0.)
        }

        pub fn clear_fow_radius(&mut self) {
            self.fow_radius = ::std::option::Option::None;
        }

        pub fn has_fow_radius(&self) -> bool {
            self.fow_radius.is_some()
        }

        // Param is passed by value, moved
        pub fn set_fow_radius(&mut self, v: f32) {
            self.fow_radius = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetParticleFoWProperties {
        const NAME: &'static str = "SetParticleFoWProperties";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.fow_control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.fow_control_point2 = ::std::option::Option::Some(is.read_int32()?);
                    },
                    29 => {
                        self.fow_radius = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.fow_control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.fow_control_point2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.fow_radius {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.fow_control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.fow_control_point2 {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.fow_radius {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleFoWProperties {
            SetParticleFoWProperties::new()
        }

        fn clear(&mut self) {
            self.fow_control_point = ::std::option::Option::None;
            self.fow_control_point2 = ::std::option::Option::None;
            self.fow_radius = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleFoWProperties {
            static instance: SetParticleFoWProperties = SetParticleFoWProperties {
                fow_control_point: ::std::option::Option::None,
                fow_control_point2: ::std::option::Option::None,
                fow_radius: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleShouldCheckFoW)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleShouldCheckFoW {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleShouldCheckFoW.check_fow)
        pub check_fow: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleShouldCheckFoW.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleShouldCheckFoW {
        fn default() -> &'a SetParticleShouldCheckFoW {
            <SetParticleShouldCheckFoW as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleShouldCheckFoW {
        pub fn new() -> SetParticleShouldCheckFoW {
            ::std::default::Default::default()
        }

        // optional bool check_fow = 1;

        pub fn check_fow(&self) -> bool {
            self.check_fow.unwrap_or(false)
        }

        pub fn clear_check_fow(&mut self) {
            self.check_fow = ::std::option::Option::None;
        }

        pub fn has_check_fow(&self) -> bool {
            self.check_fow.is_some()
        }

        // Param is passed by value, moved
        pub fn set_check_fow(&mut self, v: bool) {
            self.check_fow = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetParticleShouldCheckFoW {
        const NAME: &'static str = "SetParticleShouldCheckFoW";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.check_fow = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.check_fow {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.check_fow {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleShouldCheckFoW {
            SetParticleShouldCheckFoW::new()
        }

        fn clear(&mut self) {
            self.check_fow = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleShouldCheckFoW {
            static instance: SetParticleShouldCheckFoW = SetParticleShouldCheckFoW {
                check_fow: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetControlPointModel)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetControlPointModel {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointModel.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointModel.model_name)
        pub model_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetControlPointModel.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetControlPointModel {
        fn default() -> &'a SetControlPointModel {
            <SetControlPointModel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetControlPointModel {
        pub fn new() -> SetControlPointModel {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional string model_name = 2;

        pub fn model_name(&self) -> &str {
            match self.model_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_model_name(&mut self) {
            self.model_name = ::std::option::Option::None;
        }

        pub fn has_model_name(&self) -> bool {
            self.model_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_model_name(&mut self, v: ::std::string::String) {
            self.model_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_model_name(&mut self) -> &mut ::std::string::String {
            if self.model_name.is_none() {
                self.model_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.model_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_model_name(&mut self) -> ::std::string::String {
            self.model_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetControlPointModel {
        const NAME: &'static str = "SetControlPointModel";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.model_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.model_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.model_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetControlPointModel {
            SetControlPointModel::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.model_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetControlPointModel {
            static instance: SetControlPointModel = SetControlPointModel {
                control_point: ::std::option::Option::None,
                model_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetControlPointSnapshot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetControlPointSnapshot {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointSnapshot.control_point)
        pub control_point: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetControlPointSnapshot.snapshot_name)
        pub snapshot_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetControlPointSnapshot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetControlPointSnapshot {
        fn default() -> &'a SetControlPointSnapshot {
            <SetControlPointSnapshot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetControlPointSnapshot {
        pub fn new() -> SetControlPointSnapshot {
            ::std::default::Default::default()
        }

        // optional int32 control_point = 1;

        pub fn control_point(&self) -> i32 {
            self.control_point.unwrap_or(0)
        }

        pub fn clear_control_point(&mut self) {
            self.control_point = ::std::option::Option::None;
        }

        pub fn has_control_point(&self) -> bool {
            self.control_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control_point(&mut self, v: i32) {
            self.control_point = ::std::option::Option::Some(v);
        }

        // optional string snapshot_name = 2;

        pub fn snapshot_name(&self) -> &str {
            match self.snapshot_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_snapshot_name(&mut self) {
            self.snapshot_name = ::std::option::Option::None;
        }

        pub fn has_snapshot_name(&self) -> bool {
            self.snapshot_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_snapshot_name(&mut self, v: ::std::string::String) {
            self.snapshot_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_snapshot_name(&mut self) -> &mut ::std::string::String {
            if self.snapshot_name.is_none() {
                self.snapshot_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.snapshot_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_snapshot_name(&mut self) -> ::std::string::String {
            self.snapshot_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetControlPointSnapshot {
        const NAME: &'static str = "SetControlPointSnapshot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.control_point = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.snapshot_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.control_point {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.snapshot_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.control_point {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.snapshot_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetControlPointSnapshot {
            SetControlPointSnapshot::new()
        }

        fn clear(&mut self) {
            self.control_point = ::std::option::Option::None;
            self.snapshot_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetControlPointSnapshot {
            static instance: SetControlPointSnapshot = SetControlPointSnapshot {
                control_point: ::std::option::Option::None,
                snapshot_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleText)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleText {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleText.text)
        pub text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleText.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleText {
        fn default() -> &'a SetParticleText {
            <SetParticleText as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleText {
        pub fn new() -> SetParticleText {
            ::std::default::Default::default()
        }

        // optional string text = 1;

        pub fn text(&self) -> &str {
            match self.text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_text(&mut self) {
            self.text = ::std::option::Option::None;
        }

        pub fn has_text(&self) -> bool {
            self.text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_text(&mut self, v: ::std::string::String) {
            self.text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_text(&mut self) -> &mut ::std::string::String {
            if self.text.is_none() {
                self.text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.text.as_mut().unwrap()
        }

        // Take field
        pub fn take_text(&mut self) -> ::std::string::String {
            self.text.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetParticleText {
        const NAME: &'static str = "SetParticleText";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.text.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.text.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleText {
            SetParticleText::new()
        }

        fn clear(&mut self) {
            self.text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleText {
            static instance: SetParticleText = SetParticleText {
                text: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetTextureAttribute)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetTextureAttribute {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetTextureAttribute.attribute_name)
        pub attribute_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetTextureAttribute.texture_name)
        pub texture_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetTextureAttribute.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetTextureAttribute {
        fn default() -> &'a SetTextureAttribute {
            <SetTextureAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetTextureAttribute {
        pub fn new() -> SetTextureAttribute {
            ::std::default::Default::default()
        }

        // optional string attribute_name = 1;

        pub fn attribute_name(&self) -> &str {
            match self.attribute_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_attribute_name(&mut self) {
            self.attribute_name = ::std::option::Option::None;
        }

        pub fn has_attribute_name(&self) -> bool {
            self.attribute_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attribute_name(&mut self, v: ::std::string::String) {
            self.attribute_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_attribute_name(&mut self) -> &mut ::std::string::String {
            if self.attribute_name.is_none() {
                self.attribute_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.attribute_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_attribute_name(&mut self) -> ::std::string::String {
            self.attribute_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string texture_name = 2;

        pub fn texture_name(&self) -> &str {
            match self.texture_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_texture_name(&mut self) {
            self.texture_name = ::std::option::Option::None;
        }

        pub fn has_texture_name(&self) -> bool {
            self.texture_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_texture_name(&mut self, v: ::std::string::String) {
            self.texture_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_texture_name(&mut self) -> &mut ::std::string::String {
            if self.texture_name.is_none() {
                self.texture_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.texture_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_texture_name(&mut self) -> ::std::string::String {
            self.texture_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetTextureAttribute {
        const NAME: &'static str = "SetTextureAttribute";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.attribute_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.texture_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.attribute_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.texture_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.attribute_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.texture_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetTextureAttribute {
            SetTextureAttribute::new()
        }

        fn clear(&mut self) {
            self.attribute_name = ::std::option::Option::None;
            self.texture_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetTextureAttribute {
            static instance: SetTextureAttribute = SetTextureAttribute {
                attribute_name: ::std::option::Option::None,
                texture_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetSceneObjectGenericFlag)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSceneObjectGenericFlag {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectGenericFlag.flag_value)
        pub flag_value: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetSceneObjectGenericFlag.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSceneObjectGenericFlag {
        fn default() -> &'a SetSceneObjectGenericFlag {
            <SetSceneObjectGenericFlag as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetSceneObjectGenericFlag {
        pub fn new() -> SetSceneObjectGenericFlag {
            ::std::default::Default::default()
        }

        // optional bool flag_value = 1;

        pub fn flag_value(&self) -> bool {
            self.flag_value.unwrap_or(false)
        }

        pub fn clear_flag_value(&mut self) {
            self.flag_value = ::std::option::Option::None;
        }

        pub fn has_flag_value(&self) -> bool {
            self.flag_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flag_value(&mut self, v: bool) {
            self.flag_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetSceneObjectGenericFlag {
        const NAME: &'static str = "SetSceneObjectGenericFlag";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.flag_value = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.flag_value {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.flag_value {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSceneObjectGenericFlag {
            SetSceneObjectGenericFlag::new()
        }

        fn clear(&mut self) {
            self.flag_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSceneObjectGenericFlag {
            static instance: SetSceneObjectGenericFlag = SetSceneObjectGenericFlag {
                flag_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetSceneObjectTintAndDesat {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.tint)
        pub tint: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.desat)
        pub desat: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetSceneObjectTintAndDesat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetSceneObjectTintAndDesat {
        fn default() -> &'a SetSceneObjectTintAndDesat {
            <SetSceneObjectTintAndDesat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetSceneObjectTintAndDesat {
        pub fn new() -> SetSceneObjectTintAndDesat {
            ::std::default::Default::default()
        }

        // optional fixed32 tint = 1;

        pub fn tint(&self) -> u32 {
            self.tint.unwrap_or(0)
        }

        pub fn clear_tint(&mut self) {
            self.tint = ::std::option::Option::None;
        }

        pub fn has_tint(&self) -> bool {
            self.tint.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tint(&mut self, v: u32) {
            self.tint = ::std::option::Option::Some(v);
        }

        // optional float desat = 2;

        pub fn desat(&self) -> f32 {
            self.desat.unwrap_or(0.)
        }

        pub fn clear_desat(&mut self) {
            self.desat = ::std::option::Option::None;
        }

        pub fn has_desat(&self) -> bool {
            self.desat.is_some()
        }

        // Param is passed by value, moved
        pub fn set_desat(&mut self, v: f32) {
            self.desat = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetSceneObjectTintAndDesat {
        const NAME: &'static str = "SetSceneObjectTintAndDesat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.tint = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.desat = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tint {
                my_size += 1 + 4;
            }
            if let Some(v) = self.desat {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.tint {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.desat {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetSceneObjectTintAndDesat {
            SetSceneObjectTintAndDesat::new()
        }

        fn clear(&mut self) {
            self.tint = ::std::option::Option::None;
            self.desat = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetSceneObjectTintAndDesat {
            static instance: SetSceneObjectTintAndDesat = SetSceneObjectTintAndDesat {
                tint: ::std::option::Option::None,
                desat: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleSkipToTime)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleSkipToTime {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleSkipToTime.skip_to_time)
        pub skip_to_time: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleSkipToTime.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleSkipToTime {
        fn default() -> &'a ParticleSkipToTime {
            <ParticleSkipToTime as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ParticleSkipToTime {
        pub fn new() -> ParticleSkipToTime {
            ::std::default::Default::default()
        }

        // optional float skip_to_time = 1;

        pub fn skip_to_time(&self) -> f32 {
            self.skip_to_time.unwrap_or(0.)
        }

        pub fn clear_skip_to_time(&mut self) {
            self.skip_to_time = ::std::option::Option::None;
        }

        pub fn has_skip_to_time(&self) -> bool {
            self.skip_to_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_skip_to_time(&mut self, v: f32) {
            self.skip_to_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ParticleSkipToTime {
        const NAME: &'static str = "ParticleSkipToTime";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.skip_to_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.skip_to_time {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.skip_to_time {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleSkipToTime {
            ParticleSkipToTime::new()
        }

        fn clear(&mut self) {
            self.skip_to_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleSkipToTime {
            static instance: ParticleSkipToTime = ParticleSkipToTime {
                skip_to_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleCanFreeze)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleCanFreeze {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleCanFreeze.can_freeze)
        pub can_freeze: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleCanFreeze.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleCanFreeze {
        fn default() -> &'a ParticleCanFreeze {
            <ParticleCanFreeze as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ParticleCanFreeze {
        pub fn new() -> ParticleCanFreeze {
            ::std::default::Default::default()
        }

        // optional bool can_freeze = 1;

        pub fn can_freeze(&self) -> bool {
            self.can_freeze.unwrap_or(false)
        }

        pub fn clear_can_freeze(&mut self) {
            self.can_freeze = ::std::option::Option::None;
        }

        pub fn has_can_freeze(&self) -> bool {
            self.can_freeze.is_some()
        }

        // Param is passed by value, moved
        pub fn set_can_freeze(&mut self, v: bool) {
            self.can_freeze = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ParticleCanFreeze {
        const NAME: &'static str = "ParticleCanFreeze";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.can_freeze = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.can_freeze {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.can_freeze {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleCanFreeze {
            ParticleCanFreeze::new()
        }

        fn clear(&mut self) {
            self.can_freeze = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleCanFreeze {
            static instance: ParticleCanFreeze = ParticleCanFreeze {
                can_freeze: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ParticleFreezeTransitionOverride {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.freeze_transition_override)
        pub freeze_transition_override: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ParticleFreezeTransitionOverride.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ParticleFreezeTransitionOverride {
        fn default() -> &'a ParticleFreezeTransitionOverride {
            <ParticleFreezeTransitionOverride as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ParticleFreezeTransitionOverride {
        pub fn new() -> ParticleFreezeTransitionOverride {
            ::std::default::Default::default()
        }

        // optional float freeze_transition_override = 1;

        pub fn freeze_transition_override(&self) -> f32 {
            self.freeze_transition_override.unwrap_or(0.)
        }

        pub fn clear_freeze_transition_override(&mut self) {
            self.freeze_transition_override = ::std::option::Option::None;
        }

        pub fn has_freeze_transition_override(&self) -> bool {
            self.freeze_transition_override.is_some()
        }

        // Param is passed by value, moved
        pub fn set_freeze_transition_override(&mut self, v: f32) {
            self.freeze_transition_override = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ParticleFreezeTransitionOverride {
        const NAME: &'static str = "ParticleFreezeTransitionOverride";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.freeze_transition_override = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.freeze_transition_override {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.freeze_transition_override {
                os.write_float(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ParticleFreezeTransitionOverride {
            ParticleFreezeTransitionOverride::new()
        }

        fn clear(&mut self) {
            self.freeze_transition_override = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ParticleFreezeTransitionOverride {
            static instance: ParticleFreezeTransitionOverride = ParticleFreezeTransitionOverride {
                freeze_transition_override: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.FreezeParticleInvolving)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FreezeParticleInvolving {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.set_frozen)
        pub set_frozen: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.transition_duration)
        pub transition_duration: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.FreezeParticleInvolving.entity_handle)
        pub entity_handle: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.FreezeParticleInvolving.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FreezeParticleInvolving {
        fn default() -> &'a FreezeParticleInvolving {
            <FreezeParticleInvolving as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FreezeParticleInvolving {
        pub fn new() -> FreezeParticleInvolving {
            ::std::default::Default::default()
        }

        // optional bool set_frozen = 1;

        pub fn set_frozen(&self) -> bool {
            self.set_frozen.unwrap_or(false)
        }

        pub fn clear_set_frozen(&mut self) {
            self.set_frozen = ::std::option::Option::None;
        }

        pub fn has_set_frozen(&self) -> bool {
            self.set_frozen.is_some()
        }

        // Param is passed by value, moved
        pub fn set_set_frozen(&mut self, v: bool) {
            self.set_frozen = ::std::option::Option::Some(v);
        }

        // optional float transition_duration = 2;

        pub fn transition_duration(&self) -> f32 {
            self.transition_duration.unwrap_or(0.)
        }

        pub fn clear_transition_duration(&mut self) {
            self.transition_duration = ::std::option::Option::None;
        }

        pub fn has_transition_duration(&self) -> bool {
            self.transition_duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_transition_duration(&mut self, v: f32) {
            self.transition_duration = ::std::option::Option::Some(v);
        }

        // optional uint32 entity_handle = 3;

        pub fn entity_handle(&self) -> u32 {
            self.entity_handle.unwrap_or(16777215u32)
        }

        pub fn clear_entity_handle(&mut self) {
            self.entity_handle = ::std::option::Option::None;
        }

        pub fn has_entity_handle(&self) -> bool {
            self.entity_handle.is_some()
        }

        // Param is passed by value, moved
        pub fn set_entity_handle(&mut self, v: u32) {
            self.entity_handle = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FreezeParticleInvolving {
        const NAME: &'static str = "FreezeParticleInvolving";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.set_frozen = ::std::option::Option::Some(is.read_bool()?);
                    },
                    21 => {
                        self.transition_duration = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.entity_handle = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.set_frozen {
                my_size += 1 + 1;
            }
            if let Some(v) = self.transition_duration {
                my_size += 1 + 4;
            }
            if let Some(v) = self.entity_handle {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.set_frozen {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.transition_duration {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.entity_handle {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FreezeParticleInvolving {
            FreezeParticleInvolving::new()
        }

        fn clear(&mut self) {
            self.set_frozen = ::std::option::Option::None;
            self.transition_duration = ::std::option::Option::None;
            self.entity_handle = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FreezeParticleInvolving {
            static instance: FreezeParticleInvolving = FreezeParticleInvolving {
                set_frozen: ::std::option::Option::None,
                transition_duration: ::std::option::Option::None,
                entity_handle: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.AddModellistOverrideElement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AddModellistOverrideElement {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.AddModellistOverrideElement.model_name)
        pub model_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.AddModellistOverrideElement.spawn_probability)
        pub spawn_probability: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.AddModellistOverrideElement.groupid)
        pub groupid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.AddModellistOverrideElement.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AddModellistOverrideElement {
        fn default() -> &'a AddModellistOverrideElement {
            <AddModellistOverrideElement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AddModellistOverrideElement {
        pub fn new() -> AddModellistOverrideElement {
            ::std::default::Default::default()
        }

        // optional string model_name = 1;

        pub fn model_name(&self) -> &str {
            match self.model_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_model_name(&mut self) {
            self.model_name = ::std::option::Option::None;
        }

        pub fn has_model_name(&self) -> bool {
            self.model_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_model_name(&mut self, v: ::std::string::String) {
            self.model_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_model_name(&mut self) -> &mut ::std::string::String {
            if self.model_name.is_none() {
                self.model_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.model_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_model_name(&mut self) -> ::std::string::String {
            self.model_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional float spawn_probability = 2;

        pub fn spawn_probability(&self) -> f32 {
            self.spawn_probability.unwrap_or(0.)
        }

        pub fn clear_spawn_probability(&mut self) {
            self.spawn_probability = ::std::option::Option::None;
        }

        pub fn has_spawn_probability(&self) -> bool {
            self.spawn_probability.is_some()
        }

        // Param is passed by value, moved
        pub fn set_spawn_probability(&mut self, v: f32) {
            self.spawn_probability = ::std::option::Option::Some(v);
        }

        // optional uint32 groupid = 3;

        pub fn groupid(&self) -> u32 {
            self.groupid.unwrap_or(0)
        }

        pub fn clear_groupid(&mut self) {
            self.groupid = ::std::option::Option::None;
        }

        pub fn has_groupid(&self) -> bool {
            self.groupid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_groupid(&mut self, v: u32) {
            self.groupid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AddModellistOverrideElement {
        const NAME: &'static str = "AddModellistOverrideElement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.model_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    21 => {
                        self.spawn_probability = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.groupid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.model_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.spawn_probability {
                my_size += 1 + 4;
            }
            if let Some(v) = self.groupid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.model_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.spawn_probability {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.groupid {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AddModellistOverrideElement {
            AddModellistOverrideElement::new()
        }

        fn clear(&mut self) {
            self.model_name = ::std::option::Option::None;
            self.spawn_probability = ::std::option::Option::None;
            self.groupid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AddModellistOverrideElement {
            static instance: AddModellistOverrideElement = AddModellistOverrideElement {
                model_name: ::std::option::Option::None,
                spawn_probability: ::std::option::Option::None,
                groupid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.ClearModellistOverride)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ClearModellistOverride {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.ClearModellistOverride.groupid)
        pub groupid: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.ClearModellistOverride.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ClearModellistOverride {
        fn default() -> &'a ClearModellistOverride {
            <ClearModellistOverride as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ClearModellistOverride {
        pub fn new() -> ClearModellistOverride {
            ::std::default::Default::default()
        }

        // optional uint32 groupid = 1;

        pub fn groupid(&self) -> u32 {
            self.groupid.unwrap_or(0)
        }

        pub fn clear_groupid(&mut self) {
            self.groupid = ::std::option::Option::None;
        }

        pub fn has_groupid(&self) -> bool {
            self.groupid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_groupid(&mut self, v: u32) {
            self.groupid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ClearModellistOverride {
        const NAME: &'static str = "ClearModellistOverride";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.groupid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.groupid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.groupid {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ClearModellistOverride {
            ClearModellistOverride::new()
        }

        fn clear(&mut self) {
            self.groupid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ClearModellistOverride {
            static instance: ClearModellistOverride = ClearModellistOverride {
                groupid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetParticleNamedValueContext {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.float_values)
        pub float_values: ::std::vec::Vec<set_particle_named_value_context::FloatContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.vector_values)
        pub vector_values: ::std::vec::Vec<set_particle_named_value_context::VectorContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.transform_values)
        pub transform_values: ::std::vec::Vec<set_particle_named_value_context::TransformContextValue>,
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.ehandle_values)
        pub ehandle_values: ::std::vec::Vec<set_particle_named_value_context::EHandleContext>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetParticleNamedValueContext {
        fn default() -> &'a SetParticleNamedValueContext {
            <SetParticleNamedValueContext as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetParticleNamedValueContext {
        pub fn new() -> SetParticleNamedValueContext {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetParticleNamedValueContext {
        const NAME: &'static str = "SetParticleNamedValueContext";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.float_values.push(is.read_message()?);
                    },
                    18 => {
                        self.vector_values.push(is.read_message()?);
                    },
                    26 => {
                        self.transform_values.push(is.read_message()?);
                    },
                    34 => {
                        self.ehandle_values.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.float_values {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.vector_values {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.transform_values {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.ehandle_values {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.float_values {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.vector_values {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.transform_values {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.ehandle_values {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetParticleNamedValueContext {
            SetParticleNamedValueContext::new()
        }

        fn clear(&mut self) {
            self.float_values.clear();
            self.vector_values.clear();
            self.transform_values.clear();
            self.ehandle_values.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetParticleNamedValueContext {
            static instance: SetParticleNamedValueContext = SetParticleNamedValueContext {
                float_values: ::std::vec::Vec::new(),
                vector_values: ::std::vec::Vec::new(),
                transform_values: ::std::vec::Vec::new(),
                ehandle_values: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `SetParticleNamedValueContext`
    pub mod set_particle_named_value_context {
        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct FloatContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.value)
            pub value: ::std::option::Option<f32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.FloatContextValue.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a FloatContextValue {
            fn default() -> &'a FloatContextValue {
                <FloatContextValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl FloatContextValue {
            pub fn new() -> FloatContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            // optional float value = 2;

            pub fn value(&self) -> f32 {
                self.value.unwrap_or(0.)
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: f32) {
                self.value = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for FloatContextValue {
            const NAME: &'static str = "FloatContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        21 => {
                            self.value = ::std::option::Option::Some(is.read_float()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value {
                    my_size += 1 + 4;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value {
                    os.write_float(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> FloatContextValue {
                FloatContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static FloatContextValue {
                static instance: FloatContextValue = FloatContextValue {
                    value_name_hash: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct VectorContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.value)
            pub value: ::steam_vent_proto_common::protobuf::MessageField<super::super::super::networkbasetypes::CMsgVector>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.VectorContextValue.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a VectorContextValue {
            fn default() -> &'a VectorContextValue {
                <VectorContextValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl VectorContextValue {
            pub fn new() -> VectorContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for VectorContextValue {
            const NAME: &'static str = "VectorContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.value)?;
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> VectorContextValue {
                VectorContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.value.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static VectorContextValue {
                static instance: VectorContextValue = VectorContextValue {
                    value_name_hash: ::std::option::Option::None,
                    value: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct TransformContextValue {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.angles)
            pub angles: ::steam_vent_proto_common::protobuf::MessageField<super::super::super::networkbasetypes::CMsgQAngle>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.translation)
            pub translation: ::steam_vent_proto_common::protobuf::MessageField<super::super::super::networkbasetypes::CMsgVector>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.TransformContextValue.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a TransformContextValue {
            fn default() -> &'a TransformContextValue {
                <TransformContextValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl TransformContextValue {
            pub fn new() -> TransformContextValue {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for TransformContextValue {
            const NAME: &'static str = "TransformContextValue";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.angles)?;
                        },
                        26 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.translation)?;
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.angles.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.translation.as_ref() {
                    let len = v.compute_size();
                    my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.angles.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                }
                if let Some(v) = self.translation.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> TransformContextValue {
                TransformContextValue::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.angles.clear();
                self.translation.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static TransformContextValue {
                static instance: TransformContextValue = TransformContextValue {
                    value_name_hash: ::std::option::Option::None,
                    angles: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    translation: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct EHandleContext {
            // message fields
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.value_name_hash)
            pub value_name_hash: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.ent_index)
            pub ent_index: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetParticleNamedValueContext.EHandleContext.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a EHandleContext {
            fn default() -> &'a EHandleContext {
                <EHandleContext as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl EHandleContext {
            pub fn new() -> EHandleContext {
                ::std::default::Default::default()
            }

            // optional uint32 value_name_hash = 1;

            pub fn value_name_hash(&self) -> u32 {
                self.value_name_hash.unwrap_or(0)
            }

            pub fn clear_value_name_hash(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
            }

            pub fn has_value_name_hash(&self) -> bool {
                self.value_name_hash.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value_name_hash(&mut self, v: u32) {
                self.value_name_hash = ::std::option::Option::Some(v);
            }

            // optional uint32 ent_index = 2;

            pub fn ent_index(&self) -> u32 {
                self.ent_index.unwrap_or(16777215u32)
            }

            pub fn clear_ent_index(&mut self) {
                self.ent_index = ::std::option::Option::None;
            }

            pub fn has_ent_index(&self) -> bool {
                self.ent_index.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ent_index(&mut self, v: u32) {
                self.ent_index = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for EHandleContext {
            const NAME: &'static str = "EHandleContext";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.value_name_hash = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.ent_index = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.value_name_hash {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.ent_index {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.value_name_hash {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.ent_index {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> EHandleContext {
                EHandleContext::new()
            }

            fn clear(&mut self) {
                self.value_name_hash = ::std::option::Option::None;
                self.ent_index = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static EHandleContext {
                static instance: EHandleContext = EHandleContext {
                    value_name_hash: ::std::option::Option::None,
                    ent_index: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.CreatePhysicsSim)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CreatePhysicsSim {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.CreatePhysicsSim.prop_group_name)
        pub prop_group_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.CreatePhysicsSim.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CreatePhysicsSim {
        fn default() -> &'a CreatePhysicsSim {
            <CreatePhysicsSim as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CreatePhysicsSim {
        pub fn new() -> CreatePhysicsSim {
            ::std::default::Default::default()
        }

        // optional string prop_group_name = 1;

        pub fn prop_group_name(&self) -> &str {
            match self.prop_group_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_prop_group_name(&mut self) {
            self.prop_group_name = ::std::option::Option::None;
        }

        pub fn has_prop_group_name(&self) -> bool {
            self.prop_group_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prop_group_name(&mut self, v: ::std::string::String) {
            self.prop_group_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_prop_group_name(&mut self) -> &mut ::std::string::String {
            if self.prop_group_name.is_none() {
                self.prop_group_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.prop_group_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_prop_group_name(&mut self) -> ::std::string::String {
            self.prop_group_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CreatePhysicsSim {
        const NAME: &'static str = "CreatePhysicsSim";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.prop_group_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prop_group_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.prop_group_name.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CreatePhysicsSim {
            CreatePhysicsSim::new()
        }

        fn clear(&mut self) {
            self.prop_group_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CreatePhysicsSim {
            static instance: CreatePhysicsSim = CreatePhysicsSim {
                prop_group_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.DestroyPhysicsSim)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct DestroyPhysicsSim {
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.DestroyPhysicsSim.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a DestroyPhysicsSim {
        fn default() -> &'a DestroyPhysicsSim {
            <DestroyPhysicsSim as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl DestroyPhysicsSim {
        pub fn new() -> DestroyPhysicsSim {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for DestroyPhysicsSim {
        const NAME: &'static str = "DestroyPhysicsSim";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> DestroyPhysicsSim {
            DestroyPhysicsSim::new()
        }

        fn clear(&mut self) {
            self.special_fields.clear();
        }

        fn default_instance() -> &'static DestroyPhysicsSim {
            static instance: DestroyPhysicsSim = DestroyPhysicsSim {
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMsg_ParticleManager.SetVData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SetVData {
        // message fields
        // @@protoc_insertion_point(field:CUserMsg_ParticleManager.SetVData.vdata_name)
        pub vdata_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMsg_ParticleManager.SetVData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SetVData {
        fn default() -> &'a SetVData {
            <SetVData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SetVData {
        pub fn new() -> SetVData {
            ::std::default::Default::default()
        }

        // optional string vdata_name = 1;

        pub fn vdata_name(&self) -> &str {
            match self.vdata_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_vdata_name(&mut self) {
            self.vdata_name = ::std::option::Option::None;
        }

        pub fn has_vdata_name(&self) -> bool {
            self.vdata_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vdata_name(&mut self, v: ::std::string::String) {
            self.vdata_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vdata_name(&mut self) -> &mut ::std::string::String {
            if self.vdata_name.is_none() {
                self.vdata_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.vdata_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_vdata_name(&mut self) -> ::std::string::String {
            self.vdata_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SetVData {
        const NAME: &'static str = "SetVData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.vdata_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.vdata_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.vdata_name.as_ref() {
                os.write_string(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SetVData {
            SetVData::new()
        }

        fn clear(&mut self) {
            self.vdata_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SetVData {
            static instance: SetVData = SetVData {
                vdata_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMsg_HudError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_HudError {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_HudError.order_id)
    pub order_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_HudError.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_HudError {
    fn default() -> &'a CUserMsg_HudError {
        <CUserMsg_HudError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_HudError {
    pub fn new() -> CUserMsg_HudError {
        ::std::default::Default::default()
    }

    // optional int32 order_id = 1;

    pub fn order_id(&self) -> i32 {
        self.order_id.unwrap_or(0)
    }

    pub fn clear_order_id(&mut self) {
        self.order_id = ::std::option::Option::None;
    }

    pub fn has_order_id(&self) -> bool {
        self.order_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_order_id(&mut self, v: i32) {
        self.order_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMsg_HudError {
    const NAME: &'static str = "CUserMsg_HudError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.order_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.order_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.order_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_HudError {
        CUserMsg_HudError::new()
    }

    fn clear(&mut self) {
        self.order_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_HudError {
        static instance: CUserMsg_HudError = CUserMsg_HudError {
            order_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMsg_CustomGameEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMsg_CustomGameEvent {
    // message fields
    // @@protoc_insertion_point(field:CUserMsg_CustomGameEvent.event_name)
    pub event_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMsg_CustomGameEvent.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMsg_CustomGameEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMsg_CustomGameEvent {
    fn default() -> &'a CUserMsg_CustomGameEvent {
        <CUserMsg_CustomGameEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMsg_CustomGameEvent {
    pub fn new() -> CUserMsg_CustomGameEvent {
        ::std::default::Default::default()
    }

    // optional string event_name = 1;

    pub fn event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_event_name(&mut self) {
        self.event_name = ::std::option::Option::None;
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMsg_CustomGameEvent {
    const NAME: &'static str = "CUserMsg_CustomGameEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMsg_CustomGameEvent {
        CUserMsg_CustomGameEvent::new()
    }

    fn clear(&mut self) {
        self.event_name = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMsg_CustomGameEvent {
        static instance: CUserMsg_CustomGameEvent = CUserMsg_CustomGameEvent {
            event_name: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageHapticsManagerPulse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHapticsManagerPulse {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.hand_id)
    pub hand_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_amplitude)
    pub effect_amplitude: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_frequency)
    pub effect_frequency: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerPulse.effect_duration)
    pub effect_duration: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHapticsManagerPulse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHapticsManagerPulse {
    fn default() -> &'a CUserMessageHapticsManagerPulse {
        <CUserMessageHapticsManagerPulse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHapticsManagerPulse {
    pub fn new() -> CUserMessageHapticsManagerPulse {
        ::std::default::Default::default()
    }

    // optional int32 hand_id = 1;

    pub fn hand_id(&self) -> i32 {
        self.hand_id.unwrap_or(0)
    }

    pub fn clear_hand_id(&mut self) {
        self.hand_id = ::std::option::Option::None;
    }

    pub fn has_hand_id(&self) -> bool {
        self.hand_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hand_id(&mut self, v: i32) {
        self.hand_id = ::std::option::Option::Some(v);
    }

    // optional float effect_amplitude = 2;

    pub fn effect_amplitude(&self) -> f32 {
        self.effect_amplitude.unwrap_or(0.)
    }

    pub fn clear_effect_amplitude(&mut self) {
        self.effect_amplitude = ::std::option::Option::None;
    }

    pub fn has_effect_amplitude(&self) -> bool {
        self.effect_amplitude.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_amplitude(&mut self, v: f32) {
        self.effect_amplitude = ::std::option::Option::Some(v);
    }

    // optional float effect_frequency = 3;

    pub fn effect_frequency(&self) -> f32 {
        self.effect_frequency.unwrap_or(0.)
    }

    pub fn clear_effect_frequency(&mut self) {
        self.effect_frequency = ::std::option::Option::None;
    }

    pub fn has_effect_frequency(&self) -> bool {
        self.effect_frequency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_frequency(&mut self, v: f32) {
        self.effect_frequency = ::std::option::Option::Some(v);
    }

    // optional float effect_duration = 4;

    pub fn effect_duration(&self) -> f32 {
        self.effect_duration.unwrap_or(0.)
    }

    pub fn clear_effect_duration(&mut self) {
        self.effect_duration = ::std::option::Option::None;
    }

    pub fn has_effect_duration(&self) -> bool {
        self.effect_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_duration(&mut self, v: f32) {
        self.effect_duration = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageHapticsManagerPulse {
    const NAME: &'static str = "CUserMessageHapticsManagerPulse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hand_id = ::std::option::Option::Some(is.read_int32()?);
                },
                21 => {
                    self.effect_amplitude = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.effect_frequency = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.effect_duration = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hand_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.effect_amplitude {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect_frequency {
            my_size += 1 + 4;
        }
        if let Some(v) = self.effect_duration {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hand_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.effect_amplitude {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.effect_frequency {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.effect_duration {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHapticsManagerPulse {
        CUserMessageHapticsManagerPulse::new()
    }

    fn clear(&mut self) {
        self.hand_id = ::std::option::Option::None;
        self.effect_amplitude = ::std::option::Option::None;
        self.effect_frequency = ::std::option::Option::None;
        self.effect_duration = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHapticsManagerPulse {
        static instance: CUserMessageHapticsManagerPulse = CUserMessageHapticsManagerPulse {
            hand_id: ::std::option::Option::None,
            effect_amplitude: ::std::option::Option::None,
            effect_frequency: ::std::option::Option::None,
            effect_duration: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageHapticsManagerEffect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageHapticsManagerEffect {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.hand_id)
    pub hand_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.effect_name_hash_code)
    pub effect_name_hash_code: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessageHapticsManagerEffect.effect_scale)
    pub effect_scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageHapticsManagerEffect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageHapticsManagerEffect {
    fn default() -> &'a CUserMessageHapticsManagerEffect {
        <CUserMessageHapticsManagerEffect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageHapticsManagerEffect {
    pub fn new() -> CUserMessageHapticsManagerEffect {
        ::std::default::Default::default()
    }

    // optional int32 hand_id = 1;

    pub fn hand_id(&self) -> i32 {
        self.hand_id.unwrap_or(0)
    }

    pub fn clear_hand_id(&mut self) {
        self.hand_id = ::std::option::Option::None;
    }

    pub fn has_hand_id(&self) -> bool {
        self.hand_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hand_id(&mut self, v: i32) {
        self.hand_id = ::std::option::Option::Some(v);
    }

    // optional uint32 effect_name_hash_code = 2;

    pub fn effect_name_hash_code(&self) -> u32 {
        self.effect_name_hash_code.unwrap_or(0)
    }

    pub fn clear_effect_name_hash_code(&mut self) {
        self.effect_name_hash_code = ::std::option::Option::None;
    }

    pub fn has_effect_name_hash_code(&self) -> bool {
        self.effect_name_hash_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_name_hash_code(&mut self, v: u32) {
        self.effect_name_hash_code = ::std::option::Option::Some(v);
    }

    // optional float effect_scale = 3;

    pub fn effect_scale(&self) -> f32 {
        self.effect_scale.unwrap_or(0.)
    }

    pub fn clear_effect_scale(&mut self) {
        self.effect_scale = ::std::option::Option::None;
    }

    pub fn has_effect_scale(&self) -> bool {
        self.effect_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect_scale(&mut self, v: f32) {
        self.effect_scale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageHapticsManagerEffect {
    const NAME: &'static str = "CUserMessageHapticsManagerEffect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hand_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.effect_name_hash_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.effect_scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hand_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.effect_name_hash_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.effect_scale {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hand_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.effect_name_hash_code {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.effect_scale {
            os.write_float(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageHapticsManagerEffect {
        CUserMessageHapticsManagerEffect::new()
    }

    fn clear(&mut self) {
        self.hand_id = ::std::option::Option::None;
        self.effect_name_hash_code = ::std::option::Option::None;
        self.effect_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageHapticsManagerEffect {
        static instance: CUserMessageHapticsManagerEffect = CUserMessageHapticsManagerEffect {
            hand_id: ::std::option::Option::None,
            effect_name_hash_code: ::std::option::Option::None,
            effect_scale: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageAnimStateGraphState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageAnimStateGraphState {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageAnimStateGraphState.entity_index)
    pub entity_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageAnimStateGraphState.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageAnimStateGraphState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageAnimStateGraphState {
    fn default() -> &'a CUserMessageAnimStateGraphState {
        <CUserMessageAnimStateGraphState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageAnimStateGraphState {
    pub fn new() -> CUserMessageAnimStateGraphState {
        ::std::default::Default::default()
    }

    // optional int32 entity_index = 1;

    pub fn entity_index(&self) -> i32 {
        self.entity_index.unwrap_or(0)
    }

    pub fn clear_entity_index(&mut self) {
        self.entity_index = ::std::option::Option::None;
    }

    pub fn has_entity_index(&self) -> bool {
        self.entity_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_entity_index(&mut self, v: i32) {
        self.entity_index = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageAnimStateGraphState {
    const NAME: &'static str = "CUserMessageAnimStateGraphState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.entity_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.entity_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.entity_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageAnimStateGraphState {
        CUserMessageAnimStateGraphState::new()
    }

    fn clear(&mut self) {
        self.entity_index = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageAnimStateGraphState {
        static instance: CUserMessageAnimStateGraphState = CUserMessageAnimStateGraphState {
            entity_index: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageUpdateCssClasses)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageUpdateCssClasses {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.target_world_panel)
    pub target_world_panel: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.css_classes)
    pub css_classes: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageUpdateCssClasses.is_add)
    pub is_add: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageUpdateCssClasses.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageUpdateCssClasses {
    fn default() -> &'a CUserMessageUpdateCssClasses {
        <CUserMessageUpdateCssClasses as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageUpdateCssClasses {
    pub fn new() -> CUserMessageUpdateCssClasses {
        ::std::default::Default::default()
    }

    // optional int32 target_world_panel = 1;

    pub fn target_world_panel(&self) -> i32 {
        self.target_world_panel.unwrap_or(0)
    }

    pub fn clear_target_world_panel(&mut self) {
        self.target_world_panel = ::std::option::Option::None;
    }

    pub fn has_target_world_panel(&self) -> bool {
        self.target_world_panel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_world_panel(&mut self, v: i32) {
        self.target_world_panel = ::std::option::Option::Some(v);
    }

    // optional string css_classes = 2;

    pub fn css_classes(&self) -> &str {
        match self.css_classes.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_css_classes(&mut self) {
        self.css_classes = ::std::option::Option::None;
    }

    pub fn has_css_classes(&self) -> bool {
        self.css_classes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_css_classes(&mut self, v: ::std::string::String) {
        self.css_classes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_css_classes(&mut self) -> &mut ::std::string::String {
        if self.css_classes.is_none() {
            self.css_classes = ::std::option::Option::Some(::std::string::String::new());
        }
        self.css_classes.as_mut().unwrap()
    }

    // Take field
    pub fn take_css_classes(&mut self) -> ::std::string::String {
        self.css_classes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool is_add = 3;

    pub fn is_add(&self) -> bool {
        self.is_add.unwrap_or(false)
    }

    pub fn clear_is_add(&mut self) {
        self.is_add = ::std::option::Option::None;
    }

    pub fn has_is_add(&self) -> bool {
        self.is_add.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_add(&mut self, v: bool) {
        self.is_add = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageUpdateCssClasses {
    const NAME: &'static str = "CUserMessageUpdateCssClasses";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_world_panel = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.css_classes = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.is_add = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_world_panel {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.css_classes.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.is_add {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_world_panel {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.css_classes.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.is_add {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageUpdateCssClasses {
        CUserMessageUpdateCssClasses::new()
    }

    fn clear(&mut self) {
        self.target_world_panel = ::std::option::Option::None;
        self.css_classes = ::std::option::Option::None;
        self.is_add = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageUpdateCssClasses {
        static instance: CUserMessageUpdateCssClasses = CUserMessageUpdateCssClasses {
            target_world_panel: ::std::option::Option::None,
            css_classes: ::std::option::Option::None,
            is_add: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageServerFrameTime)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageServerFrameTime {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageServerFrameTime.frame_time)
    pub frame_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageServerFrameTime.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageServerFrameTime {
    fn default() -> &'a CUserMessageServerFrameTime {
        <CUserMessageServerFrameTime as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageServerFrameTime {
    pub fn new() -> CUserMessageServerFrameTime {
        ::std::default::Default::default()
    }

    // optional float frame_time = 1;

    pub fn frame_time(&self) -> f32 {
        self.frame_time.unwrap_or(0.)
    }

    pub fn clear_frame_time(&mut self) {
        self.frame_time = ::std::option::Option::None;
    }

    pub fn has_frame_time(&self) -> bool {
        self.frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frame_time(&mut self, v: f32) {
        self.frame_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageServerFrameTime {
    const NAME: &'static str = "CUserMessageServerFrameTime";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.frame_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.frame_time {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageServerFrameTime {
        CUserMessageServerFrameTime::new()
    }

    fn clear(&mut self) {
        self.frame_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageServerFrameTime {
        static instance: CUserMessageServerFrameTime = CUserMessageServerFrameTime {
            frame_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageLagCompensationError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageLagCompensationError {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageLagCompensationError.distance)
    pub distance: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageLagCompensationError.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageLagCompensationError {
    fn default() -> &'a CUserMessageLagCompensationError {
        <CUserMessageLagCompensationError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageLagCompensationError {
    pub fn new() -> CUserMessageLagCompensationError {
        ::std::default::Default::default()
    }

    // optional float distance = 1;

    pub fn distance(&self) -> f32 {
        self.distance.unwrap_or(0.)
    }

    pub fn clear_distance(&mut self) {
        self.distance = ::std::option::Option::None;
    }

    pub fn has_distance(&self) -> bool {
        self.distance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: f32) {
        self.distance = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageLagCompensationError {
    const NAME: &'static str = "CUserMessageLagCompensationError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.distance = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.distance {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.distance {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageLagCompensationError {
        CUserMessageLagCompensationError::new()
    }

    fn clear(&mut self) {
        self.distance = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageLagCompensationError {
        static instance: CUserMessageLagCompensationError = CUserMessageLagCompensationError {
            distance: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestDllStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestDllStatus {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestDllStatus.dll_action)
    pub dll_action: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessageRequestDllStatus.full_report)
    pub full_report: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestDllStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestDllStatus {
    fn default() -> &'a CUserMessageRequestDllStatus {
        <CUserMessageRequestDllStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestDllStatus {
    pub fn new() -> CUserMessageRequestDllStatus {
        ::std::default::Default::default()
    }

    // optional string dll_action = 1;

    pub fn dll_action(&self) -> &str {
        match self.dll_action.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_dll_action(&mut self) {
        self.dll_action = ::std::option::Option::None;
    }

    pub fn has_dll_action(&self) -> bool {
        self.dll_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dll_action(&mut self, v: ::std::string::String) {
        self.dll_action = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dll_action(&mut self) -> &mut ::std::string::String {
        if self.dll_action.is_none() {
            self.dll_action = ::std::option::Option::Some(::std::string::String::new());
        }
        self.dll_action.as_mut().unwrap()
    }

    // Take field
    pub fn take_dll_action(&mut self) -> ::std::string::String {
        self.dll_action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool full_report = 2;

    pub fn full_report(&self) -> bool {
        self.full_report.unwrap_or(false)
    }

    pub fn clear_full_report(&mut self) {
        self.full_report = ::std::option::Option::None;
    }

    pub fn has_full_report(&self) -> bool {
        self.full_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_report(&mut self, v: bool) {
        self.full_report = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRequestDllStatus {
    const NAME: &'static str = "CUserMessageRequestDllStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.dll_action = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.full_report = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.dll_action.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.full_report {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.dll_action.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.full_report {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestDllStatus {
        CUserMessageRequestDllStatus::new()
    }

    fn clear(&mut self) {
        self.dll_action = ::std::option::Option::None;
        self.full_report = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestDllStatus {
        static instance: CUserMessageRequestDllStatus = CUserMessageRequestDllStatus {
            dll_action: ::std::option::Option::None,
            full_report: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestUtilAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestUtilAction {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util1)
    pub util1: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util2)
    pub util2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util3)
    pub util3: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util4)
    pub util4: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestUtilAction.util5)
    pub util5: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestUtilAction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestUtilAction {
    fn default() -> &'a CUserMessageRequestUtilAction {
        <CUserMessageRequestUtilAction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestUtilAction {
    pub fn new() -> CUserMessageRequestUtilAction {
        ::std::default::Default::default()
    }

    // optional int32 util1 = 2;

    pub fn util1(&self) -> i32 {
        self.util1.unwrap_or(0)
    }

    pub fn clear_util1(&mut self) {
        self.util1 = ::std::option::Option::None;
    }

    pub fn has_util1(&self) -> bool {
        self.util1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util1(&mut self, v: i32) {
        self.util1 = ::std::option::Option::Some(v);
    }

    // optional int32 util2 = 3;

    pub fn util2(&self) -> i32 {
        self.util2.unwrap_or(0)
    }

    pub fn clear_util2(&mut self) {
        self.util2 = ::std::option::Option::None;
    }

    pub fn has_util2(&self) -> bool {
        self.util2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util2(&mut self, v: i32) {
        self.util2 = ::std::option::Option::Some(v);
    }

    // optional int32 util3 = 4;

    pub fn util3(&self) -> i32 {
        self.util3.unwrap_or(0)
    }

    pub fn clear_util3(&mut self) {
        self.util3 = ::std::option::Option::None;
    }

    pub fn has_util3(&self) -> bool {
        self.util3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util3(&mut self, v: i32) {
        self.util3 = ::std::option::Option::Some(v);
    }

    // optional int32 util4 = 5;

    pub fn util4(&self) -> i32 {
        self.util4.unwrap_or(0)
    }

    pub fn clear_util4(&mut self) {
        self.util4 = ::std::option::Option::None;
    }

    pub fn has_util4(&self) -> bool {
        self.util4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util4(&mut self, v: i32) {
        self.util4 = ::std::option::Option::Some(v);
    }

    // optional int32 util5 = 6;

    pub fn util5(&self) -> i32 {
        self.util5.unwrap_or(0)
    }

    pub fn clear_util5(&mut self) {
        self.util5 = ::std::option::Option::None;
    }

    pub fn has_util5(&self) -> bool {
        self.util5.is_some()
    }

    // Param is passed by value, moved
    pub fn set_util5(&mut self, v: i32) {
        self.util5 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRequestUtilAction {
    const NAME: &'static str = "CUserMessageRequestUtilAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.util1 = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.util2 = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.util3 = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.util4 = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.util5 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.util1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.util2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.util3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.util4 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.util5 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.util1 {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.util2 {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.util3 {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.util4 {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.util5 {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestUtilAction {
        CUserMessageRequestUtilAction::new()
    }

    fn clear(&mut self) {
        self.util1 = ::std::option::Option::None;
        self.util2 = ::std::option::Option::None;
        self.util3 = ::std::option::Option::None;
        self.util4 = ::std::option::Option::None;
        self.util5 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestUtilAction {
        static instance: CUserMessageRequestUtilAction = CUserMessageRequestUtilAction {
            util1: ::std::option::Option::None,
            util2: ::std::option::Option::None,
            util3: ::std::option::Option::None,
            util4: ::std::option::Option::None,
            util5: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessage_UtilMsg_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_UtilMsg_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.item_count)
    pub item_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc2)
    pub crc2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.item_count2)
    pub item_count2: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc_part)
    pub crc_part: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.crc_part2)
    pub crc_part2: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.client_timestamp)
    pub client_timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.itemdetails)
    pub itemdetails: ::std::vec::Vec<cuser_message_util_msg_response::ItemDetail>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.itemgroup)
    pub itemgroup: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.total_count)
    pub total_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.total_count2)
    pub total_count2: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_UtilMsg_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_UtilMsg_Response {
    fn default() -> &'a CUserMessage_UtilMsg_Response {
        <CUserMessage_UtilMsg_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_UtilMsg_Response {
    pub fn new() -> CUserMessage_UtilMsg_Response {
        ::std::default::Default::default()
    }

    // optional fixed32 crc = 1;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 item_count = 2;

    pub fn item_count(&self) -> i32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: i32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional fixed32 crc2 = 3;

    pub fn crc2(&self) -> u32 {
        self.crc2.unwrap_or(0)
    }

    pub fn clear_crc2(&mut self) {
        self.crc2 = ::std::option::Option::None;
    }

    pub fn has_crc2(&self) -> bool {
        self.crc2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc2(&mut self, v: u32) {
        self.crc2 = ::std::option::Option::Some(v);
    }

    // optional int32 item_count2 = 4;

    pub fn item_count2(&self) -> i32 {
        self.item_count2.unwrap_or(0)
    }

    pub fn clear_item_count2(&mut self) {
        self.item_count2 = ::std::option::Option::None;
    }

    pub fn has_item_count2(&self) -> bool {
        self.item_count2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count2(&mut self, v: i32) {
        self.item_count2 = ::std::option::Option::Some(v);
    }

    // optional int32 client_timestamp = 7;

    pub fn client_timestamp(&self) -> i32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: i32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 8;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 itemgroup = 10;

    pub fn itemgroup(&self) -> i32 {
        self.itemgroup.unwrap_or(0)
    }

    pub fn clear_itemgroup(&mut self) {
        self.itemgroup = ::std::option::Option::None;
    }

    pub fn has_itemgroup(&self) -> bool {
        self.itemgroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_itemgroup(&mut self, v: i32) {
        self.itemgroup = ::std::option::Option::Some(v);
    }

    // optional int32 total_count = 11;

    pub fn total_count(&self) -> i32 {
        self.total_count.unwrap_or(0)
    }

    pub fn clear_total_count(&mut self) {
        self.total_count = ::std::option::Option::None;
    }

    pub fn has_total_count(&self) -> bool {
        self.total_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count(&mut self, v: i32) {
        self.total_count = ::std::option::Option::Some(v);
    }

    // optional int32 total_count2 = 12;

    pub fn total_count2(&self) -> i32 {
        self.total_count2.unwrap_or(0)
    }

    pub fn clear_total_count2(&mut self) {
        self.total_count2 = ::std::option::Option::None;
    }

    pub fn has_total_count2(&self) -> bool {
        self.total_count2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_count2(&mut self, v: i32) {
        self.total_count2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_UtilMsg_Response {
    const NAME: &'static str = "CUserMessage_UtilMsg_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.item_count = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.crc2 = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.item_count2 = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part)?;
                },
                40 => {
                    self.crc_part.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.crc_part2)?;
                },
                48 => {
                    self.crc_part2.push(is.read_int32()?);
                },
                56 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.itemdetails.push(is.read_message()?);
                },
                80 => {
                    self.itemgroup = ::std::option::Option::Some(is.read_int32()?);
                },
                88 => {
                    self.total_count = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.total_count2 = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.crc2 {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        for value in &self.crc_part {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.crc_part2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.client_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.platform {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        for value in &self.itemdetails {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.itemgroup {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
        }
        if let Some(v) = self.total_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.total_count2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.crc2 {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.item_count2 {
            os.write_int32(4, v)?;
        }
        for v in &self.crc_part {
            os.write_int32(5, *v)?;
        };
        for v in &self.crc_part2 {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.client_timestamp {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(8, v)?;
        }
        for v in &self.itemdetails {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.itemgroup {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.total_count {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.total_count2 {
            os.write_int32(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_UtilMsg_Response {
        CUserMessage_UtilMsg_Response::new()
    }

    fn clear(&mut self) {
        self.crc = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.crc2 = ::std::option::Option::None;
        self.item_count2 = ::std::option::Option::None;
        self.crc_part.clear();
        self.crc_part2.clear();
        self.client_timestamp = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.itemdetails.clear();
        self.itemgroup = ::std::option::Option::None;
        self.total_count = ::std::option::Option::None;
        self.total_count2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_UtilMsg_Response {
        static instance: CUserMessage_UtilMsg_Response = CUserMessage_UtilMsg_Response {
            crc: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            crc2: ::std::option::Option::None,
            item_count2: ::std::option::Option::None,
            crc_part: ::std::vec::Vec::new(),
            crc_part2: ::std::vec::Vec::new(),
            client_timestamp: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            itemdetails: ::std::vec::Vec::new(),
            itemgroup: ::std::option::Option::None,
            total_count: ::std::option::Option::None,
            total_count2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessage_UtilMsg_Response`
pub mod cuser_message_util_msg_response {
    // @@protoc_insertion_point(message:CUserMessage_UtilMsg_Response.ItemDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemDetail {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.hash)
        pub hash: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.crc)
        pub crc: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_UtilMsg_Response.ItemDetail.name)
        pub name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_UtilMsg_Response.ItemDetail.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemDetail {
        fn default() -> &'a ItemDetail {
            <ItemDetail as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemDetail {
        pub fn new() -> ItemDetail {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int32 hash = 2;

        pub fn hash(&self) -> i32 {
            self.hash.unwrap_or(0)
        }

        pub fn clear_hash(&mut self) {
            self.hash = ::std::option::Option::None;
        }

        pub fn has_hash(&self) -> bool {
            self.hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hash(&mut self, v: i32) {
            self.hash = ::std::option::Option::Some(v);
        }

        // optional int32 crc = 3;

        pub fn crc(&self) -> i32 {
            self.crc.unwrap_or(0)
        }

        pub fn clear_crc(&mut self) {
            self.crc = ::std::option::Option::None;
        }

        pub fn has_crc(&self) -> bool {
            self.crc.is_some()
        }

        // Param is passed by value, moved
        pub fn set_crc(&mut self, v: i32) {
            self.crc = ::std::option::Option::Some(v);
        }

        // optional string name = 4;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemDetail {
        const NAME: &'static str = "ItemDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.hash = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.crc = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.hash {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.crc {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.hash {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.crc {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemDetail {
            ItemDetail::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.hash = ::std::option::Option::None;
            self.crc = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemDetail {
            static instance: ItemDetail = ItemDetail {
                index: ::std::option::Option::None,
                hash: ::std::option::Option::None,
                crc: ::std::option::Option::None,
                name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessage_DllStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_DllStatus {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.file_report)
    pub file_report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.command_line)
    pub command_line: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.total_files)
    pub total_files: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.process_id)
    pub process_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.client_time)
    pub client_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_dll_status::CVDiagnostic>,
    // @@protoc_insertion_point(field:CUserMessage_DllStatus.modules)
    pub modules: ::std::vec::Vec<cuser_message_dll_status::CModule>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_DllStatus {
    fn default() -> &'a CUserMessage_DllStatus {
        <CUserMessage_DllStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_DllStatus {
    pub fn new() -> CUserMessage_DllStatus {
        ::std::default::Default::default()
    }

    // optional string file_report = 1;

    pub fn file_report(&self) -> &str {
        match self.file_report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_report(&mut self) {
        self.file_report = ::std::option::Option::None;
    }

    pub fn has_file_report(&self) -> bool {
        self.file_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_report(&mut self, v: ::std::string::String) {
        self.file_report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_report(&mut self) -> &mut ::std::string::String {
        if self.file_report.is_none() {
            self.file_report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_report.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_report(&mut self) -> ::std::string::String {
        self.file_report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string command_line = 2;

    pub fn command_line(&self) -> &str {
        match self.command_line.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_command_line(&mut self) {
        self.command_line = ::std::option::Option::None;
    }

    pub fn has_command_line(&self) -> bool {
        self.command_line.is_some()
    }

    // Param is passed by value, moved
    pub fn set_command_line(&mut self, v: ::std::string::String) {
        self.command_line = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_command_line(&mut self) -> &mut ::std::string::String {
        if self.command_line.is_none() {
            self.command_line = ::std::option::Option::Some(::std::string::String::new());
        }
        self.command_line.as_mut().unwrap()
    }

    // Take field
    pub fn take_command_line(&mut self) -> ::std::string::String {
        self.command_line.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 total_files = 3;

    pub fn total_files(&self) -> u32 {
        self.total_files.unwrap_or(0)
    }

    pub fn clear_total_files(&mut self) {
        self.total_files = ::std::option::Option::None;
    }

    pub fn has_total_files(&self) -> bool {
        self.total_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_files(&mut self, v: u32) {
        self.total_files = ::std::option::Option::Some(v);
    }

    // optional uint32 process_id = 4;

    pub fn process_id(&self) -> u32 {
        self.process_id.unwrap_or(0)
    }

    pub fn clear_process_id(&mut self) {
        self.process_id = ::std::option::Option::None;
    }

    pub fn has_process_id(&self) -> bool {
        self.process_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_process_id(&mut self, v: u32) {
        self.process_id = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional uint64 client_time = 6;

    pub fn client_time(&self) -> u64 {
        self.client_time.unwrap_or(0)
    }

    pub fn clear_client_time(&mut self) {
        self.client_time = ::std::option::Option::None;
    }

    pub fn has_client_time(&self) -> bool {
        self.client_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_time(&mut self, v: u64) {
        self.client_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_DllStatus {
    const NAME: &'static str = "CUserMessage_DllStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_report = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.command_line = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.total_files = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.process_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.client_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                58 => {
                    self.diagnostics.push(is.read_message()?);
                },
                66 => {
                    self.modules.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_report.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.command_line.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.total_files {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.process_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.client_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(6, v);
        }
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.modules {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.file_report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.command_line.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.total_files {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.process_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.client_time {
            os.write_uint64(6, v)?;
        }
        for v in &self.diagnostics {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.modules {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_DllStatus {
        CUserMessage_DllStatus::new()
    }

    fn clear(&mut self) {
        self.file_report = ::std::option::Option::None;
        self.command_line = ::std::option::Option::None;
        self.total_files = ::std::option::Option::None;
        self.process_id = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.client_time = ::std::option::Option::None;
        self.diagnostics.clear();
        self.modules.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_DllStatus {
        static instance: CUserMessage_DllStatus = CUserMessage_DllStatus {
            file_report: ::std::option::Option::None,
            command_line: ::std::option::Option::None,
            total_files: ::std::option::Option::None,
            process_id: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            client_time: ::std::option::Option::None,
            diagnostics: ::std::vec::Vec::new(),
            modules: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessage_DllStatus`
pub mod cuser_message_dll_status {
    // @@protoc_insertion_point(message:CUserMessage_DllStatus.CVDiagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CVDiagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.extended)
        pub extended: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.value)
        pub value: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CVDiagnostic.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.CVDiagnostic.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CVDiagnostic {
        fn default() -> &'a CVDiagnostic {
            <CVDiagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CVDiagnostic {
        pub fn new() -> CVDiagnostic {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 extended = 2;

        pub fn extended(&self) -> u32 {
            self.extended.unwrap_or(0)
        }

        pub fn clear_extended(&mut self) {
            self.extended = ::std::option::Option::None;
        }

        pub fn has_extended(&self) -> bool {
            self.extended.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extended(&mut self, v: u32) {
            self.extended = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 3;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional string string_value = 4;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CVDiagnostic {
        const NAME: &'static str = "CVDiagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.extended = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extended {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extended {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CVDiagnostic {
            CVDiagnostic::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.extended = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CVDiagnostic {
            static instance: CVDiagnostic = CVDiagnostic {
                id: ::std::option::Option::None,
                extended: ::std::option::Option::None,
                value: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CUserMessage_DllStatus.CModule)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CModule {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.base_addr)
        pub base_addr: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.size)
        pub size: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_DllStatus.CModule.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_DllStatus.CModule.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CModule {
        fn default() -> &'a CModule {
            <CModule as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CModule {
        pub fn new() -> CModule {
            ::std::default::Default::default()
        }

        // optional uint64 base_addr = 1;

        pub fn base_addr(&self) -> u64 {
            self.base_addr.unwrap_or(0)
        }

        pub fn clear_base_addr(&mut self) {
            self.base_addr = ::std::option::Option::None;
        }

        pub fn has_base_addr(&self) -> bool {
            self.base_addr.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_addr(&mut self, v: u64) {
            self.base_addr = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 size = 3;

        pub fn size(&self) -> u32 {
            self.size.unwrap_or(0)
        }

        pub fn clear_size(&mut self) {
            self.size = ::std::option::Option::None;
        }

        pub fn has_size(&self) -> bool {
            self.size.is_some()
        }

        // Param is passed by value, moved
        pub fn set_size(&mut self, v: u32) {
            self.size = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CModule {
        const NAME: &'static str = "CModule";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.base_addr = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.size = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.base_addr {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.size {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.base_addr {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.size {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CModule {
            CModule::new()
        }

        fn clear(&mut self) {
            self.base_addr = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.size = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CModule {
            static instance: CModule = CModule {
                base_addr: ::std::option::Option::None,
                name: ::std::option::Option::None,
                size: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestInventory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestInventory {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.inventory)
    pub inventory: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.offset)
    pub offset: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessageRequestInventory.options)
    pub options: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestInventory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestInventory {
    fn default() -> &'a CUserMessageRequestInventory {
        <CUserMessageRequestInventory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestInventory {
    pub fn new() -> CUserMessageRequestInventory {
        ::std::default::Default::default()
    }

    // optional int32 inventory = 1;

    pub fn inventory(&self) -> i32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: i32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional int32 offset = 2;

    pub fn offset(&self) -> i32 {
        self.offset.unwrap_or(0)
    }

    pub fn clear_offset(&mut self) {
        self.offset = ::std::option::Option::None;
    }

    pub fn has_offset(&self) -> bool {
        self.offset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i32) {
        self.offset = ::std::option::Option::Some(v);
    }

    // optional int32 options = 3;

    pub fn options(&self) -> i32 {
        self.options.unwrap_or(0)
    }

    pub fn clear_options(&mut self) {
        self.options = ::std::option::Option::None;
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: i32) {
        self.options = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRequestInventory {
    const NAME: &'static str = "CUserMessageRequestInventory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.inventory = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.offset = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.options = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.offset {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.options {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.inventory {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.offset {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestInventory {
        CUserMessageRequestInventory::new()
    }

    fn clear(&mut self) {
        self.inventory = ::std::option::Option::None;
        self.offset = ::std::option::Option::None;
        self.options = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestInventory {
        static instance: CUserMessageRequestInventory = CUserMessageRequestInventory {
            inventory: ::std::option::Option::None,
            offset: ::std::option::Option::None,
            options: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessage_Inventory_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_Inventory_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.crc)
    pub crc: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.item_count)
    pub item_count: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.perf_time)
    pub perf_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.client_timestamp)
    pub client_timestamp: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories)
    pub inventories: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories2)
    pub inventories2: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inventories3)
    pub inventories3: ::std::vec::Vec<cuser_message_inventory_response::InventoryDetail>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.inv_type)
    pub inv_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.build_version)
    pub build_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.instance)
    pub instance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.start_time)
    pub start_time: ::std::option::Option<i64>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_Inventory_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_Inventory_Response {
    fn default() -> &'a CUserMessage_Inventory_Response {
        <CUserMessage_Inventory_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_Inventory_Response {
    pub fn new() -> CUserMessage_Inventory_Response {
        ::std::default::Default::default()
    }

    // optional fixed32 crc = 1;

    pub fn crc(&self) -> u32 {
        self.crc.unwrap_or(0)
    }

    pub fn clear_crc(&mut self) {
        self.crc = ::std::option::Option::None;
    }

    pub fn has_crc(&self) -> bool {
        self.crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crc(&mut self, v: u32) {
        self.crc = ::std::option::Option::Some(v);
    }

    // optional int32 item_count = 2;

    pub fn item_count(&self) -> i32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: i32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional int32 perf_time = 6;

    pub fn perf_time(&self) -> i32 {
        self.perf_time.unwrap_or(0)
    }

    pub fn clear_perf_time(&mut self) {
        self.perf_time = ::std::option::Option::None;
    }

    pub fn has_perf_time(&self) -> bool {
        self.perf_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_perf_time(&mut self, v: i32) {
        self.perf_time = ::std::option::Option::Some(v);
    }

    // optional int32 client_timestamp = 7;

    pub fn client_timestamp(&self) -> i32 {
        self.client_timestamp.unwrap_or(0)
    }

    pub fn clear_client_timestamp(&mut self) {
        self.client_timestamp = ::std::option::Option::None;
    }

    pub fn has_client_timestamp(&self) -> bool {
        self.client_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_timestamp(&mut self, v: i32) {
        self.client_timestamp = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 8;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }

    // optional int32 inv_type = 11;

    pub fn inv_type(&self) -> i32 {
        self.inv_type.unwrap_or(0)
    }

    pub fn clear_inv_type(&mut self) {
        self.inv_type = ::std::option::Option::None;
    }

    pub fn has_inv_type(&self) -> bool {
        self.inv_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inv_type(&mut self, v: i32) {
        self.inv_type = ::std::option::Option::Some(v);
    }

    // optional int32 build_version = 12;

    pub fn build_version(&self) -> i32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: i32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional int32 instance = 13;

    pub fn instance(&self) -> i32 {
        self.instance.unwrap_or(0)
    }

    pub fn clear_instance(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: i32) {
        self.instance = ::std::option::Option::Some(v);
    }

    // optional int64 start_time = 15;

    pub fn start_time(&self) -> i64 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_Inventory_Response {
    const NAME: &'static str = "CUserMessage_Inventory_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.crc = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.item_count = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.perf_time = ::std::option::Option::Some(is.read_int32()?);
                },
                56 => {
                    self.client_timestamp = ::std::option::Option::Some(is.read_int32()?);
                },
                64 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                74 => {
                    self.inventories.push(is.read_message()?);
                },
                82 => {
                    self.inventories2.push(is.read_message()?);
                },
                114 => {
                    self.inventories3.push(is.read_message()?);
                },
                88 => {
                    self.inv_type = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.build_version = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.instance = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.start_time = ::std::option::Option::Some(is.read_int64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.crc {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.perf_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        if let Some(v) = self.client_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        if let Some(v) = self.platform {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
        }
        for value in &self.inventories {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.inventories2 {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.inventories3 {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.inv_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.build_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.instance {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(15, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.crc {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.perf_time {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.client_timestamp {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(8, v)?;
        }
        for v in &self.inventories {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.inventories2 {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        for v in &self.inventories3 {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        };
        if let Some(v) = self.inv_type {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.build_version {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.instance {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_int64(15, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_Inventory_Response {
        CUserMessage_Inventory_Response::new()
    }

    fn clear(&mut self) {
        self.crc = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.perf_time = ::std::option::Option::None;
        self.client_timestamp = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.inventories.clear();
        self.inventories2.clear();
        self.inventories3.clear();
        self.inv_type = ::std::option::Option::None;
        self.build_version = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_Inventory_Response {
        static instance: CUserMessage_Inventory_Response = CUserMessage_Inventory_Response {
            crc: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            perf_time: ::std::option::Option::None,
            client_timestamp: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            inventories: ::std::vec::Vec::new(),
            inventories2: ::std::vec::Vec::new(),
            inventories3: ::std::vec::Vec::new(),
            inv_type: ::std::option::Option::None,
            build_version: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessage_Inventory_Response`
pub mod cuser_message_inventory_response {
    // @@protoc_insertion_point(message:CUserMessage_Inventory_Response.InventoryDetail)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InventoryDetail {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.primary)
        pub primary: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.first)
        pub first: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_name)
        pub base_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_detail)
        pub base_detail: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_time)
        pub base_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Inventory_Response.InventoryDetail.base_hash)
        pub base_hash: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_Inventory_Response.InventoryDetail.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InventoryDetail {
        fn default() -> &'a InventoryDetail {
            <InventoryDetail as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl InventoryDetail {
        pub fn new() -> InventoryDetail {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 primary = 2;

        pub fn primary(&self) -> i64 {
            self.primary.unwrap_or(0)
        }

        pub fn clear_primary(&mut self) {
            self.primary = ::std::option::Option::None;
        }

        pub fn has_primary(&self) -> bool {
            self.primary.is_some()
        }

        // Param is passed by value, moved
        pub fn set_primary(&mut self, v: i64) {
            self.primary = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 3;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int64 first = 4;

        pub fn first(&self) -> i64 {
            self.first.unwrap_or(0)
        }

        pub fn clear_first(&mut self) {
            self.first = ::std::option::Option::None;
        }

        pub fn has_first(&self) -> bool {
            self.first.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first(&mut self, v: i64) {
            self.first = ::std::option::Option::Some(v);
        }

        // optional int64 base = 5;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional string name = 6;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string base_name = 7;

        pub fn base_name(&self) -> &str {
            match self.base_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_base_name(&mut self) {
            self.base_name = ::std::option::Option::None;
        }

        pub fn has_base_name(&self) -> bool {
            self.base_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_name(&mut self, v: ::std::string::String) {
            self.base_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_base_name(&mut self) -> &mut ::std::string::String {
            if self.base_name.is_none() {
                self.base_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.base_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_base_name(&mut self) -> ::std::string::String {
            self.base_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 base_detail = 8;

        pub fn base_detail(&self) -> i32 {
            self.base_detail.unwrap_or(0)
        }

        pub fn clear_base_detail(&mut self) {
            self.base_detail = ::std::option::Option::None;
        }

        pub fn has_base_detail(&self) -> bool {
            self.base_detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_detail(&mut self, v: i32) {
            self.base_detail = ::std::option::Option::Some(v);
        }

        // optional int32 base_time = 9;

        pub fn base_time(&self) -> i32 {
            self.base_time.unwrap_or(0)
        }

        pub fn clear_base_time(&mut self) {
            self.base_time = ::std::option::Option::None;
        }

        pub fn has_base_time(&self) -> bool {
            self.base_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_time(&mut self, v: i32) {
            self.base_time = ::std::option::Option::Some(v);
        }

        // optional int32 base_hash = 10;

        pub fn base_hash(&self) -> i32 {
            self.base_hash.unwrap_or(0)
        }

        pub fn clear_base_hash(&mut self) {
            self.base_hash = ::std::option::Option::None;
        }

        pub fn has_base_hash(&self) -> bool {
            self.base_hash.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base_hash(&mut self, v: i32) {
            self.base_hash = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for InventoryDetail {
        const NAME: &'static str = "InventoryDetail";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.primary = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    32 => {
                        self.first = ::std::option::Option::Some(is.read_int64()?);
                    },
                    40 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    50 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    58 => {
                        self.base_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    64 => {
                        self.base_detail = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.base_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.base_hash = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.primary {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.offset {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(3, v);
            }
            if let Some(v) = self.first {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(4, v);
            }
            if let Some(v) = self.base {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(5, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
            }
            if let Some(v) = self.base_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
            }
            if let Some(v) = self.base_detail {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.base_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.base_hash {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.primary {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(3, v)?;
            }
            if let Some(v) = self.first {
                os.write_int64(4, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(5, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(6, v)?;
            }
            if let Some(v) = self.base_name.as_ref() {
                os.write_string(7, v)?;
            }
            if let Some(v) = self.base_detail {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.base_time {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.base_hash {
                os.write_int32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InventoryDetail {
            InventoryDetail::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.primary = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.first = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.base_name = ::std::option::Option::None;
            self.base_detail = ::std::option::Option::None;
            self.base_time = ::std::option::Option::None;
            self.base_hash = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InventoryDetail {
            static instance: InventoryDetail = InventoryDetail {
                index: ::std::option::Option::None,
                primary: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                first: ::std::option::Option::None,
                base: ::std::option::Option::None,
                name: ::std::option::Option::None,
                base_name: ::std::option::Option::None,
                base_detail: ::std::option::Option::None,
                base_time: ::std::option::Option::None,
                base_hash: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessageRequestDiagnostic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessageRequestDiagnostic {
    // message fields
    // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_request_diagnostic::Diagnostic>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessageRequestDiagnostic.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessageRequestDiagnostic {
    fn default() -> &'a CUserMessageRequestDiagnostic {
        <CUserMessageRequestDiagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessageRequestDiagnostic {
    pub fn new() -> CUserMessageRequestDiagnostic {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessageRequestDiagnostic {
    const NAME: &'static str = "CUserMessageRequestDiagnostic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diagnostics.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.diagnostics {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessageRequestDiagnostic {
        CUserMessageRequestDiagnostic::new()
    }

    fn clear(&mut self) {
        self.diagnostics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessageRequestDiagnostic {
        static instance: CUserMessageRequestDiagnostic = CUserMessageRequestDiagnostic {
            diagnostics: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessageRequestDiagnostic`
pub mod cuser_message_request_diagnostic {
    // @@protoc_insertion_point(message:CUserMessageRequestDiagnostic.Diagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Diagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.param)
        pub param: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.length)
        pub length: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.range)
        pub range: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.extent)
        pub extent: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.detail)
        pub detail: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.alias)
        pub alias: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.vardetail)
        pub vardetail: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CUserMessageRequestDiagnostic.Diagnostic.context)
        pub context: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessageRequestDiagnostic.Diagnostic.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Diagnostic {
        fn default() -> &'a Diagnostic {
            <Diagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Diagnostic {
        pub fn new() -> Diagnostic {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 2;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int32 param = 3;

        pub fn param(&self) -> i32 {
            self.param.unwrap_or(0)
        }

        pub fn clear_param(&mut self) {
            self.param = ::std::option::Option::None;
        }

        pub fn has_param(&self) -> bool {
            self.param.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param(&mut self, v: i32) {
            self.param = ::std::option::Option::Some(v);
        }

        // optional int32 length = 4;

        pub fn length(&self) -> i32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: i32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional int32 type = 5;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional int64 base = 6;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional int64 range = 7;

        pub fn range(&self) -> i64 {
            self.range.unwrap_or(0)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: i64) {
            self.range = ::std::option::Option::Some(v);
        }

        // optional int64 extent = 8;

        pub fn extent(&self) -> i64 {
            self.extent.unwrap_or(0)
        }

        pub fn clear_extent(&mut self) {
            self.extent = ::std::option::Option::None;
        }

        pub fn has_extent(&self) -> bool {
            self.extent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extent(&mut self, v: i64) {
            self.extent = ::std::option::Option::Some(v);
        }

        // optional int64 detail = 9;

        pub fn detail(&self) -> i64 {
            self.detail.unwrap_or(0)
        }

        pub fn clear_detail(&mut self) {
            self.detail = ::std::option::Option::None;
        }

        pub fn has_detail(&self) -> bool {
            self.detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_detail(&mut self, v: i64) {
            self.detail = ::std::option::Option::Some(v);
        }

        // optional string name = 10;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string alias = 11;

        pub fn alias(&self) -> &str {
            match self.alias.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_alias(&mut self) {
            self.alias = ::std::option::Option::None;
        }

        pub fn has_alias(&self) -> bool {
            self.alias.is_some()
        }

        // Param is passed by value, moved
        pub fn set_alias(&mut self, v: ::std::string::String) {
            self.alias = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_alias(&mut self) -> &mut ::std::string::String {
            if self.alias.is_none() {
                self.alias = ::std::option::Option::Some(::std::string::String::new());
            }
            self.alias.as_mut().unwrap()
        }

        // Take field
        pub fn take_alias(&mut self) -> ::std::string::String {
            self.alias.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes vardetail = 12;

        pub fn vardetail(&self) -> &[u8] {
            match self.vardetail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_vardetail(&mut self) {
            self.vardetail = ::std::option::Option::None;
        }

        pub fn has_vardetail(&self) -> bool {
            self.vardetail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vardetail(&mut self, v: ::std::vec::Vec<u8>) {
            self.vardetail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_vardetail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.vardetail.is_none() {
                self.vardetail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.vardetail.as_mut().unwrap()
        }

        // Take field
        pub fn take_vardetail(&mut self) -> ::std::vec::Vec<u8> {
            self.vardetail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 context = 13;

        pub fn context(&self) -> i32 {
            self.context.unwrap_or(0)
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: i32) {
            self.context = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Diagnostic {
        const NAME: &'static str = "Diagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.param = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.length = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    48 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.range = ::std::option::Option::Some(is.read_int64()?);
                    },
                    64 => {
                        self.extent = ::std::option::Option::Some(is.read_int64()?);
                    },
                    72 => {
                        self.detail = ::std::option::Option::Some(is.read_int64()?);
                    },
                    82 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.alias = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.vardetail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    104 => {
                        self.context = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.offset {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.param {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.length {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
            }
            if let Some(v) = self.base {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.range {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(7, v);
            }
            if let Some(v) = self.extent {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(8, v);
            }
            if let Some(v) = self.detail {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(9, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.alias.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.vardetail.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(12, &v);
            }
            if let Some(v) = self.context {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.param {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.length {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_int32(5, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.range {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.extent {
                os.write_int64(8, v)?;
            }
            if let Some(v) = self.detail {
                os.write_int64(9, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.alias.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.vardetail.as_ref() {
                os.write_bytes(12, v)?;
            }
            if let Some(v) = self.context {
                os.write_int32(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Diagnostic {
            Diagnostic::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.param = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.extent = ::std::option::Option::None;
            self.detail = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.alias = ::std::option::Option::None;
            self.vardetail = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Diagnostic {
            static instance: Diagnostic = Diagnostic {
                index: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                param: ::std::option::Option::None,
                length: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                base: ::std::option::Option::None,
                range: ::std::option::Option::None,
                extent: ::std::option::Option::None,
                detail: ::std::option::Option::None,
                name: ::std::option::Option::None,
                alias: ::std::option::Option::None,
                vardetail: ::std::option::Option::None,
                context: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessage_Diagnostic_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_Diagnostic_Response {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.diagnostics)
    pub diagnostics: ::std::vec::Vec<cuser_message_diagnostic_response::Diagnostic>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.build_version)
    pub build_version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.instance)
    pub instance: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.start_time)
    pub start_time: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.osversion)
    pub osversion: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.platform)
    pub platform: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_Diagnostic_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_Diagnostic_Response {
    fn default() -> &'a CUserMessage_Diagnostic_Response {
        <CUserMessage_Diagnostic_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_Diagnostic_Response {
    pub fn new() -> CUserMessage_Diagnostic_Response {
        ::std::default::Default::default()
    }

    // optional int32 build_version = 2;

    pub fn build_version(&self) -> i32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: i32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional int32 instance = 3;

    pub fn instance(&self) -> i32 {
        self.instance.unwrap_or(0)
    }

    pub fn clear_instance(&mut self) {
        self.instance = ::std::option::Option::None;
    }

    pub fn has_instance(&self) -> bool {
        self.instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instance(&mut self, v: i32) {
        self.instance = ::std::option::Option::Some(v);
    }

    // optional int64 start_time = 4;

    pub fn start_time(&self) -> i64 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: i64) {
        self.start_time = ::std::option::Option::Some(v);
    }

    // optional int32 osversion = 5;

    pub fn osversion(&self) -> i32 {
        self.osversion.unwrap_or(0)
    }

    pub fn clear_osversion(&mut self) {
        self.osversion = ::std::option::Option::None;
    }

    pub fn has_osversion(&self) -> bool {
        self.osversion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osversion(&mut self, v: i32) {
        self.osversion = ::std::option::Option::Some(v);
    }

    // optional int32 platform = 6;

    pub fn platform(&self) -> i32 {
        self.platform.unwrap_or(0)
    }

    pub fn clear_platform(&mut self) {
        self.platform = ::std::option::Option::None;
    }

    pub fn has_platform(&self) -> bool {
        self.platform.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform(&mut self, v: i32) {
        self.platform = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_Diagnostic_Response {
    const NAME: &'static str = "CUserMessage_Diagnostic_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.diagnostics.push(is.read_message()?);
                },
                16 => {
                    self.build_version = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.instance = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_int64()?);
                },
                40 => {
                    self.osversion = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.platform = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.build_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.instance {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(4, v);
        }
        if let Some(v) = self.osversion {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.platform {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.diagnostics {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.build_version {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.instance {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.osversion {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.platform {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_Diagnostic_Response {
        CUserMessage_Diagnostic_Response::new()
    }

    fn clear(&mut self) {
        self.diagnostics.clear();
        self.build_version = ::std::option::Option::None;
        self.instance = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.osversion = ::std::option::Option::None;
        self.platform = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_Diagnostic_Response {
        static instance: CUserMessage_Diagnostic_Response = CUserMessage_Diagnostic_Response {
            diagnostics: ::std::vec::Vec::new(),
            build_version: ::std::option::Option::None,
            instance: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            osversion: ::std::option::Option::None,
            platform: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessage_Diagnostic_Response`
pub mod cuser_message_diagnostic_response {
    // @@protoc_insertion_point(message:CUserMessage_Diagnostic_Response.Diagnostic)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Diagnostic {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.index)
        pub index: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.offset)
        pub offset: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.param)
        pub param: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.length)
        pub length: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.detail)
        pub detail: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.base)
        pub base: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.range)
        pub range: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.type)
        pub type_: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.alias)
        pub alias: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.backup)
        pub backup: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.context)
        pub context: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.control)
        pub control: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.augment)
        pub augment: ::std::option::Option<i64>,
        // @@protoc_insertion_point(field:CUserMessage_Diagnostic_Response.Diagnostic.placebo)
        pub placebo: ::std::option::Option<i64>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_Diagnostic_Response.Diagnostic.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Diagnostic {
        fn default() -> &'a Diagnostic {
            <Diagnostic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Diagnostic {
        pub fn new() -> Diagnostic {
            ::std::default::Default::default()
        }

        // optional int32 index = 1;

        pub fn index(&self) -> i32 {
            self.index.unwrap_or(0)
        }

        pub fn clear_index(&mut self) {
            self.index = ::std::option::Option::None;
        }

        pub fn has_index(&self) -> bool {
            self.index.is_some()
        }

        // Param is passed by value, moved
        pub fn set_index(&mut self, v: i32) {
            self.index = ::std::option::Option::Some(v);
        }

        // optional int64 offset = 2;

        pub fn offset(&self) -> i64 {
            self.offset.unwrap_or(0)
        }

        pub fn clear_offset(&mut self) {
            self.offset = ::std::option::Option::None;
        }

        pub fn has_offset(&self) -> bool {
            self.offset.is_some()
        }

        // Param is passed by value, moved
        pub fn set_offset(&mut self, v: i64) {
            self.offset = ::std::option::Option::Some(v);
        }

        // optional int32 param = 3;

        pub fn param(&self) -> i32 {
            self.param.unwrap_or(0)
        }

        pub fn clear_param(&mut self) {
            self.param = ::std::option::Option::None;
        }

        pub fn has_param(&self) -> bool {
            self.param.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param(&mut self, v: i32) {
            self.param = ::std::option::Option::Some(v);
        }

        // optional int32 length = 4;

        pub fn length(&self) -> i32 {
            self.length.unwrap_or(0)
        }

        pub fn clear_length(&mut self) {
            self.length = ::std::option::Option::None;
        }

        pub fn has_length(&self) -> bool {
            self.length.is_some()
        }

        // Param is passed by value, moved
        pub fn set_length(&mut self, v: i32) {
            self.length = ::std::option::Option::Some(v);
        }

        // optional bytes detail = 5;

        pub fn detail(&self) -> &[u8] {
            match self.detail.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_detail(&mut self) {
            self.detail = ::std::option::Option::None;
        }

        pub fn has_detail(&self) -> bool {
            self.detail.is_some()
        }

        // Param is passed by value, moved
        pub fn set_detail(&mut self, v: ::std::vec::Vec<u8>) {
            self.detail = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_detail(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.detail.is_none() {
                self.detail = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.detail.as_mut().unwrap()
        }

        // Take field
        pub fn take_detail(&mut self) -> ::std::vec::Vec<u8> {
            self.detail.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int64 base = 6;

        pub fn base(&self) -> i64 {
            self.base.unwrap_or(0)
        }

        pub fn clear_base(&mut self) {
            self.base = ::std::option::Option::None;
        }

        pub fn has_base(&self) -> bool {
            self.base.is_some()
        }

        // Param is passed by value, moved
        pub fn set_base(&mut self, v: i64) {
            self.base = ::std::option::Option::Some(v);
        }

        // optional int64 range = 7;

        pub fn range(&self) -> i64 {
            self.range.unwrap_or(0)
        }

        pub fn clear_range(&mut self) {
            self.range = ::std::option::Option::None;
        }

        pub fn has_range(&self) -> bool {
            self.range.is_some()
        }

        // Param is passed by value, moved
        pub fn set_range(&mut self, v: i64) {
            self.range = ::std::option::Option::Some(v);
        }

        // optional int32 type = 8;

        pub fn type_(&self) -> i32 {
            self.type_.unwrap_or(0)
        }

        pub fn clear_type_(&mut self) {
            self.type_ = ::std::option::Option::None;
        }

        pub fn has_type(&self) -> bool {
            self.type_.is_some()
        }

        // Param is passed by value, moved
        pub fn set_type(&mut self, v: i32) {
            self.type_ = ::std::option::Option::Some(v);
        }

        // optional string name = 10;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string alias = 11;

        pub fn alias(&self) -> &str {
            match self.alias.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_alias(&mut self) {
            self.alias = ::std::option::Option::None;
        }

        pub fn has_alias(&self) -> bool {
            self.alias.is_some()
        }

        // Param is passed by value, moved
        pub fn set_alias(&mut self, v: ::std::string::String) {
            self.alias = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_alias(&mut self) -> &mut ::std::string::String {
            if self.alias.is_none() {
                self.alias = ::std::option::Option::Some(::std::string::String::new());
            }
            self.alias.as_mut().unwrap()
        }

        // Take field
        pub fn take_alias(&mut self) -> ::std::string::String {
            self.alias.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bytes backup = 12;

        pub fn backup(&self) -> &[u8] {
            match self.backup.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_backup(&mut self) {
            self.backup = ::std::option::Option::None;
        }

        pub fn has_backup(&self) -> bool {
            self.backup.is_some()
        }

        // Param is passed by value, moved
        pub fn set_backup(&mut self, v: ::std::vec::Vec<u8>) {
            self.backup = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_backup(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.backup.is_none() {
                self.backup = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.backup.as_mut().unwrap()
        }

        // Take field
        pub fn take_backup(&mut self) -> ::std::vec::Vec<u8> {
            self.backup.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 context = 13;

        pub fn context(&self) -> i32 {
            self.context.unwrap_or(0)
        }

        pub fn clear_context(&mut self) {
            self.context = ::std::option::Option::None;
        }

        pub fn has_context(&self) -> bool {
            self.context.is_some()
        }

        // Param is passed by value, moved
        pub fn set_context(&mut self, v: i32) {
            self.context = ::std::option::Option::Some(v);
        }

        // optional int64 control = 14;

        pub fn control(&self) -> i64 {
            self.control.unwrap_or(0)
        }

        pub fn clear_control(&mut self) {
            self.control = ::std::option::Option::None;
        }

        pub fn has_control(&self) -> bool {
            self.control.is_some()
        }

        // Param is passed by value, moved
        pub fn set_control(&mut self, v: i64) {
            self.control = ::std::option::Option::Some(v);
        }

        // optional int64 augment = 15;

        pub fn augment(&self) -> i64 {
            self.augment.unwrap_or(0)
        }

        pub fn clear_augment(&mut self) {
            self.augment = ::std::option::Option::None;
        }

        pub fn has_augment(&self) -> bool {
            self.augment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_augment(&mut self, v: i64) {
            self.augment = ::std::option::Option::Some(v);
        }

        // optional int64 placebo = 16;

        pub fn placebo(&self) -> i64 {
            self.placebo.unwrap_or(0)
        }

        pub fn clear_placebo(&mut self) {
            self.placebo = ::std::option::Option::None;
        }

        pub fn has_placebo(&self) -> bool {
            self.placebo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placebo(&mut self, v: i64) {
            self.placebo = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Diagnostic {
        const NAME: &'static str = "Diagnostic";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.index = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.offset = ::std::option::Option::Some(is.read_int64()?);
                    },
                    24 => {
                        self.param = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.length = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        self.detail = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    48 => {
                        self.base = ::std::option::Option::Some(is.read_int64()?);
                    },
                    56 => {
                        self.range = ::std::option::Option::Some(is.read_int64()?);
                    },
                    64 => {
                        self.type_ = ::std::option::Option::Some(is.read_int32()?);
                    },
                    82 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    90 => {
                        self.alias = ::std::option::Option::Some(is.read_string()?);
                    },
                    98 => {
                        self.backup = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    104 => {
                        self.context = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.control = ::std::option::Option::Some(is.read_int64()?);
                    },
                    120 => {
                        self.augment = ::std::option::Option::Some(is.read_int64()?);
                    },
                    128 => {
                        self.placebo = ::std::option::Option::Some(is.read_int64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.index {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.offset {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(2, v);
            }
            if let Some(v) = self.param {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.length {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.detail.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
            }
            if let Some(v) = self.base {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(6, v);
            }
            if let Some(v) = self.range {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(7, v);
            }
            if let Some(v) = self.type_ {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
            }
            if let Some(v) = self.alias.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
            }
            if let Some(v) = self.backup.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(12, &v);
            }
            if let Some(v) = self.context {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.control {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(14, v);
            }
            if let Some(v) = self.augment {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(15, v);
            }
            if let Some(v) = self.placebo {
                my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(16, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.index {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.offset {
                os.write_int64(2, v)?;
            }
            if let Some(v) = self.param {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.length {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.detail.as_ref() {
                os.write_bytes(5, v)?;
            }
            if let Some(v) = self.base {
                os.write_int64(6, v)?;
            }
            if let Some(v) = self.range {
                os.write_int64(7, v)?;
            }
            if let Some(v) = self.type_ {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(10, v)?;
            }
            if let Some(v) = self.alias.as_ref() {
                os.write_string(11, v)?;
            }
            if let Some(v) = self.backup.as_ref() {
                os.write_bytes(12, v)?;
            }
            if let Some(v) = self.context {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.control {
                os.write_int64(14, v)?;
            }
            if let Some(v) = self.augment {
                os.write_int64(15, v)?;
            }
            if let Some(v) = self.placebo {
                os.write_int64(16, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Diagnostic {
            Diagnostic::new()
        }

        fn clear(&mut self) {
            self.index = ::std::option::Option::None;
            self.offset = ::std::option::Option::None;
            self.param = ::std::option::Option::None;
            self.length = ::std::option::Option::None;
            self.detail = ::std::option::Option::None;
            self.base = ::std::option::Option::None;
            self.range = ::std::option::Option::None;
            self.type_ = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.alias = ::std::option::Option::None;
            self.backup = ::std::option::Option::None;
            self.context = ::std::option::Option::None;
            self.control = ::std::option::Option::None;
            self.augment = ::std::option::Option::None;
            self.placebo = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Diagnostic {
            static instance: Diagnostic = Diagnostic {
                index: ::std::option::Option::None,
                offset: ::std::option::Option::None,
                param: ::std::option::Option::None,
                length: ::std::option::Option::None,
                detail: ::std::option::Option::None,
                base: ::std::option::Option::None,
                range: ::std::option::Option::None,
                type_: ::std::option::Option::None,
                name: ::std::option::Option::None,
                alias: ::std::option::Option::None,
                backup: ::std::option::Option::None,
                context: ::std::option::Option::None,
                control: ::std::option::Option::None,
                augment: ::std::option::Option::None,
                placebo: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessage_ExtraUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_ExtraUserData {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.item)
    pub item: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.value1)
    pub value1: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.value2)
    pub value2: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.detail1)
    pub detail1: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CUserMessage_ExtraUserData.detail2)
    pub detail2: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_ExtraUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_ExtraUserData {
    fn default() -> &'a CUserMessage_ExtraUserData {
        <CUserMessage_ExtraUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_ExtraUserData {
    pub fn new() -> CUserMessage_ExtraUserData {
        ::std::default::Default::default()
    }

    // optional int32 item = 1;

    pub fn item(&self) -> i32 {
        self.item.unwrap_or(0)
    }

    pub fn clear_item(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_item(&self) -> bool {
        self.item.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: i32) {
        self.item = ::std::option::Option::Some(v);
    }

    // optional int64 value1 = 2;

    pub fn value1(&self) -> i64 {
        self.value1.unwrap_or(0)
    }

    pub fn clear_value1(&mut self) {
        self.value1 = ::std::option::Option::None;
    }

    pub fn has_value1(&self) -> bool {
        self.value1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value1(&mut self, v: i64) {
        self.value1 = ::std::option::Option::Some(v);
    }

    // optional int64 value2 = 3;

    pub fn value2(&self) -> i64 {
        self.value2.unwrap_or(0)
    }

    pub fn clear_value2(&mut self) {
        self.value2 = ::std::option::Option::None;
    }

    pub fn has_value2(&self) -> bool {
        self.value2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value2(&mut self, v: i64) {
        self.value2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_ExtraUserData {
    const NAME: &'static str = "CUserMessage_ExtraUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.value1 = ::std::option::Option::Some(is.read_int64()?);
                },
                24 => {
                    self.value2 = ::std::option::Option::Some(is.read_int64()?);
                },
                34 => {
                    self.detail1.push(is.read_bytes()?);
                },
                42 => {
                    self.detail2.push(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.value1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(2, v);
        }
        if let Some(v) = self.value2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::int64_size(3, v);
        }
        for value in &self.detail1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &value);
        };
        for value in &self.detail2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.value1 {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.value2 {
            os.write_int64(3, v)?;
        }
        for v in &self.detail1 {
            os.write_bytes(4, &v)?;
        };
        for v in &self.detail2 {
            os.write_bytes(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_ExtraUserData {
        CUserMessage_ExtraUserData::new()
    }

    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.value1 = ::std::option::Option::None;
        self.value2 = ::std::option::Option::None;
        self.detail1.clear();
        self.detail2.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_ExtraUserData {
        static instance: CUserMessage_ExtraUserData = CUserMessage_ExtraUserData {
            item: ::std::option::Option::None,
            value1: ::std::option::Option::None,
            value2: ::std::option::Option::None,
            detail1: ::std::vec::Vec::new(),
            detail2: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CUserMessage_NotifyResponseFound)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_NotifyResponseFound {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.rule_name)
    pub rule_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.response_value)
    pub response_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.response_concept)
    pub response_concept: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.criteria)
    pub criteria: ::std::vec::Vec<cuser_message_notify_response_found::Criteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_NotifyResponseFound.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_NotifyResponseFound {
    fn default() -> &'a CUserMessage_NotifyResponseFound {
        <CUserMessage_NotifyResponseFound as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_NotifyResponseFound {
    pub fn new() -> CUserMessage_NotifyResponseFound {
        ::std::default::Default::default()
    }

    // optional int32 ent_index = 1;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    // optional string rule_name = 2;

    pub fn rule_name(&self) -> &str {
        match self.rule_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_rule_name(&mut self) {
        self.rule_name = ::std::option::Option::None;
    }

    pub fn has_rule_name(&self) -> bool {
        self.rule_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rule_name(&mut self, v: ::std::string::String) {
        self.rule_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rule_name(&mut self) -> &mut ::std::string::String {
        if self.rule_name.is_none() {
            self.rule_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.rule_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_rule_name(&mut self) -> ::std::string::String {
        self.rule_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string response_value = 3;

    pub fn response_value(&self) -> &str {
        match self.response_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_value(&mut self) {
        self.response_value = ::std::option::Option::None;
    }

    pub fn has_response_value(&self) -> bool {
        self.response_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_value(&mut self, v: ::std::string::String) {
        self.response_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_value(&mut self) -> &mut ::std::string::String {
        if self.response_value.is_none() {
            self.response_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_value(&mut self) -> ::std::string::String {
        self.response_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string response_concept = 4;

    pub fn response_concept(&self) -> &str {
        match self.response_concept.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response_concept(&mut self) {
        self.response_concept = ::std::option::Option::None;
    }

    pub fn has_response_concept(&self) -> bool {
        self.response_concept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_concept(&mut self, v: ::std::string::String) {
        self.response_concept = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response_concept(&mut self) -> &mut ::std::string::String {
        if self.response_concept.is_none() {
            self.response_concept = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response_concept.as_mut().unwrap()
    }

    // Take field
    pub fn take_response_concept(&mut self) -> ::std::string::String {
        self.response_concept.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_NotifyResponseFound {
    const NAME: &'static str = "CUserMessage_NotifyResponseFound";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.rule_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.response_value = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.response_concept = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.criteria.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.rule_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.response_value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.response_concept.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        for value in &self.criteria {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ent_index {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.rule_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.response_value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.response_concept.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.criteria {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_NotifyResponseFound {
        CUserMessage_NotifyResponseFound::new()
    }

    fn clear(&mut self) {
        self.ent_index = ::std::option::Option::None;
        self.rule_name = ::std::option::Option::None;
        self.response_value = ::std::option::Option::None;
        self.response_concept = ::std::option::Option::None;
        self.criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_NotifyResponseFound {
        static instance: CUserMessage_NotifyResponseFound = CUserMessage_NotifyResponseFound {
            ent_index: ::std::option::Option::None,
            rule_name: ::std::option::Option::None,
            response_value: ::std::option::Option::None,
            response_concept: ::std::option::Option::None,
            criteria: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CUserMessage_NotifyResponseFound`
pub mod cuser_message_notify_response_found {
    // @@protoc_insertion_point(message:CUserMessage_NotifyResponseFound.Criteria)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Criteria {
        // message fields
        // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.Criteria.name_symbol)
        pub name_symbol: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CUserMessage_NotifyResponseFound.Criteria.value)
        pub value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CUserMessage_NotifyResponseFound.Criteria.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Criteria {
        fn default() -> &'a Criteria {
            <Criteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Criteria {
        pub fn new() -> Criteria {
            ::std::default::Default::default()
        }

        // optional uint32 name_symbol = 1;

        pub fn name_symbol(&self) -> u32 {
            self.name_symbol.unwrap_or(0)
        }

        pub fn clear_name_symbol(&mut self) {
            self.name_symbol = ::std::option::Option::None;
        }

        pub fn has_name_symbol(&self) -> bool {
            self.name_symbol.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_symbol(&mut self, v: u32) {
            self.name_symbol = ::std::option::Option::Some(v);
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Criteria {
        const NAME: &'static str = "Criteria";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.name_symbol = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_symbol {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name_symbol {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Criteria {
            Criteria::new()
        }

        fn clear(&mut self) {
            self.name_symbol = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Criteria {
            static instance: Criteria = Criteria {
                name_symbol: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CUserMessage_PlayResponseConditional)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CUserMessage_PlayResponseConditional {
    // message fields
    // @@protoc_insertion_point(field:CUserMessage_PlayResponseConditional.ent_index)
    pub ent_index: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CUserMessage_PlayResponseConditional.player_slots)
    pub player_slots: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CUserMessage_PlayResponseConditional.response)
    pub response: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CUserMessage_PlayResponseConditional.ent_origin)
    pub ent_origin: ::steam_vent_proto_common::protobuf::MessageField<super::networkbasetypes::CMsgVector>,
    // special fields
    // @@protoc_insertion_point(special_field:CUserMessage_PlayResponseConditional.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CUserMessage_PlayResponseConditional {
    fn default() -> &'a CUserMessage_PlayResponseConditional {
        <CUserMessage_PlayResponseConditional as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CUserMessage_PlayResponseConditional {
    pub fn new() -> CUserMessage_PlayResponseConditional {
        ::std::default::Default::default()
    }

    // optional int32 ent_index = 1;

    pub fn ent_index(&self) -> i32 {
        self.ent_index.unwrap_or(-1i32)
    }

    pub fn clear_ent_index(&mut self) {
        self.ent_index = ::std::option::Option::None;
    }

    pub fn has_ent_index(&self) -> bool {
        self.ent_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ent_index(&mut self, v: i32) {
        self.ent_index = ::std::option::Option::Some(v);
    }

    // optional string response = 3;

    pub fn response(&self) -> &str {
        match self.response.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::std::string::String) {
        self.response = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut ::std::string::String {
        if self.response.is_none() {
            self.response = ::std::option::Option::Some(::std::string::String::new());
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> ::std::string::String {
        self.response.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CUserMessage_PlayResponseConditional {
    const NAME: &'static str = "CUserMessage_PlayResponseConditional";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ent_index = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.player_slots)?;
                },
                16 => {
                    self.player_slots.push(is.read_int32()?);
                },
                26 => {
                    self.response = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ent_origin)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ent_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.player_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.response.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.ent_origin.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ent_index {
            os.write_int32(1, v)?;
        }
        for v in &self.player_slots {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.response.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.ent_origin.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CUserMessage_PlayResponseConditional {
        CUserMessage_PlayResponseConditional::new()
    }

    fn clear(&mut self) {
        self.ent_index = ::std::option::Option::None;
        self.player_slots.clear();
        self.response = ::std::option::Option::None;
        self.ent_origin.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CUserMessage_PlayResponseConditional {
        static instance: CUserMessage_PlayResponseConditional = CUserMessage_PlayResponseConditional {
            ent_index: ::std::option::Option::None,
            player_slots: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            ent_origin: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseUserMessages)
pub enum EBaseUserMessages {
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AchievementEvent)
    UM_AchievementEvent = 101,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaption)
    UM_CloseCaption = 102,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaptionDirect)
    UM_CloseCaptionDirect = 103,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CurrentTimescale)
    UM_CurrentTimescale = 104,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DesiredTimescale)
    UM_DesiredTimescale = 105,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Fade)
    UM_Fade = 106,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_GameTitle)
    UM_GameTitle = 107,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudMsg)
    UM_HudMsg = 110,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudText)
    UM_HudText = 111,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ColoredText)
    UM_ColoredText = 113,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestState)
    UM_RequestState = 114,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ResetHUD)
    UM_ResetHUD = 115,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Rumble)
    UM_Rumble = 116,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayText)
    UM_SayText = 117,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayText2)
    UM_SayText2 = 118,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SayTextChannel)
    UM_SayTextChannel = 119,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_Shake)
    UM_Shake = 120,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ShakeDir)
    UM_ShakeDir = 121,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_WaterShake)
    UM_WaterShake = 122,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_TextMsg)
    UM_TextMsg = 124,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ScreenTilt)
    UM_ScreenTilt = 125,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_VoiceMask)
    UM_VoiceMask = 128,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_SendAudio)
    UM_SendAudio = 130,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ItemPickup)
    UM_ItemPickup = 131,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AmmoDenied)
    UM_AmmoDenied = 132,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ShowMenu)
    UM_ShowMenu = 134,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CreditsMsg)
    UM_CreditsMsg = 135,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CloseCaptionPlaceholder)
    UM_CloseCaptionPlaceholder = 142,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CameraTransition)
    UM_CameraTransition = 143,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AudioParameter)
    UM_AudioParameter = 144,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ParticleManager)
    UM_ParticleManager = 145,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HudError)
    UM_HudError = 146,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CustomGameEvent)
    UM_CustomGameEvent = 148,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_AnimGraphUpdate)
    UM_AnimGraphUpdate = 149,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HapticsManagerPulse)
    UM_HapticsManagerPulse = 150,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_HapticsManagerEffect)
    UM_HapticsManagerEffect = 151,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_CommandQueueState)
    UM_CommandQueueState = 152,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_UpdateCssClasses)
    UM_UpdateCssClasses = 153,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ServerFrameTime)
    UM_ServerFrameTime = 154,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_LagCompensationError)
    UM_LagCompensationError = 155,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestDllStatus)
    UM_RequestDllStatus = 156,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestUtilAction)
    UM_RequestUtilAction = 157,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_UtilActionResponse)
    UM_UtilActionResponse = 158,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DllStatusResponse)
    UM_DllStatusResponse = 159,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestInventory)
    UM_RequestInventory = 160,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_InventoryResponse)
    UM_InventoryResponse = 161,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_RequestDiagnostic)
    UM_RequestDiagnostic = 162,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_DiagnosticResponse)
    UM_DiagnosticResponse = 163,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_ExtraUserData)
    UM_ExtraUserData = 164,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_NotifyResponseFound)
    UM_NotifyResponseFound = 165,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_PlayResponseConditional)
    UM_PlayResponseConditional = 166,
    // @@protoc_insertion_point(enum_value:EBaseUserMessages.UM_MAX_BASE)
    UM_MAX_BASE = 200,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBaseUserMessages {
    const NAME: &'static str = "EBaseUserMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseUserMessages> {
        match value {
            101 => ::std::option::Option::Some(EBaseUserMessages::UM_AchievementEvent),
            102 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaption),
            103 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionDirect),
            104 => ::std::option::Option::Some(EBaseUserMessages::UM_CurrentTimescale),
            105 => ::std::option::Option::Some(EBaseUserMessages::UM_DesiredTimescale),
            106 => ::std::option::Option::Some(EBaseUserMessages::UM_Fade),
            107 => ::std::option::Option::Some(EBaseUserMessages::UM_GameTitle),
            110 => ::std::option::Option::Some(EBaseUserMessages::UM_HudMsg),
            111 => ::std::option::Option::Some(EBaseUserMessages::UM_HudText),
            113 => ::std::option::Option::Some(EBaseUserMessages::UM_ColoredText),
            114 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestState),
            115 => ::std::option::Option::Some(EBaseUserMessages::UM_ResetHUD),
            116 => ::std::option::Option::Some(EBaseUserMessages::UM_Rumble),
            117 => ::std::option::Option::Some(EBaseUserMessages::UM_SayText),
            118 => ::std::option::Option::Some(EBaseUserMessages::UM_SayText2),
            119 => ::std::option::Option::Some(EBaseUserMessages::UM_SayTextChannel),
            120 => ::std::option::Option::Some(EBaseUserMessages::UM_Shake),
            121 => ::std::option::Option::Some(EBaseUserMessages::UM_ShakeDir),
            122 => ::std::option::Option::Some(EBaseUserMessages::UM_WaterShake),
            124 => ::std::option::Option::Some(EBaseUserMessages::UM_TextMsg),
            125 => ::std::option::Option::Some(EBaseUserMessages::UM_ScreenTilt),
            128 => ::std::option::Option::Some(EBaseUserMessages::UM_VoiceMask),
            130 => ::std::option::Option::Some(EBaseUserMessages::UM_SendAudio),
            131 => ::std::option::Option::Some(EBaseUserMessages::UM_ItemPickup),
            132 => ::std::option::Option::Some(EBaseUserMessages::UM_AmmoDenied),
            134 => ::std::option::Option::Some(EBaseUserMessages::UM_ShowMenu),
            135 => ::std::option::Option::Some(EBaseUserMessages::UM_CreditsMsg),
            142 => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionPlaceholder),
            143 => ::std::option::Option::Some(EBaseUserMessages::UM_CameraTransition),
            144 => ::std::option::Option::Some(EBaseUserMessages::UM_AudioParameter),
            145 => ::std::option::Option::Some(EBaseUserMessages::UM_ParticleManager),
            146 => ::std::option::Option::Some(EBaseUserMessages::UM_HudError),
            148 => ::std::option::Option::Some(EBaseUserMessages::UM_CustomGameEvent),
            149 => ::std::option::Option::Some(EBaseUserMessages::UM_AnimGraphUpdate),
            150 => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerPulse),
            151 => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerEffect),
            152 => ::std::option::Option::Some(EBaseUserMessages::UM_CommandQueueState),
            153 => ::std::option::Option::Some(EBaseUserMessages::UM_UpdateCssClasses),
            154 => ::std::option::Option::Some(EBaseUserMessages::UM_ServerFrameTime),
            155 => ::std::option::Option::Some(EBaseUserMessages::UM_LagCompensationError),
            156 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDllStatus),
            157 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestUtilAction),
            158 => ::std::option::Option::Some(EBaseUserMessages::UM_UtilActionResponse),
            159 => ::std::option::Option::Some(EBaseUserMessages::UM_DllStatusResponse),
            160 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestInventory),
            161 => ::std::option::Option::Some(EBaseUserMessages::UM_InventoryResponse),
            162 => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDiagnostic),
            163 => ::std::option::Option::Some(EBaseUserMessages::UM_DiagnosticResponse),
            164 => ::std::option::Option::Some(EBaseUserMessages::UM_ExtraUserData),
            165 => ::std::option::Option::Some(EBaseUserMessages::UM_NotifyResponseFound),
            166 => ::std::option::Option::Some(EBaseUserMessages::UM_PlayResponseConditional),
            200 => ::std::option::Option::Some(EBaseUserMessages::UM_MAX_BASE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseUserMessages> {
        match str {
            "UM_AchievementEvent" => ::std::option::Option::Some(EBaseUserMessages::UM_AchievementEvent),
            "UM_CloseCaption" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaption),
            "UM_CloseCaptionDirect" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionDirect),
            "UM_CurrentTimescale" => ::std::option::Option::Some(EBaseUserMessages::UM_CurrentTimescale),
            "UM_DesiredTimescale" => ::std::option::Option::Some(EBaseUserMessages::UM_DesiredTimescale),
            "UM_Fade" => ::std::option::Option::Some(EBaseUserMessages::UM_Fade),
            "UM_GameTitle" => ::std::option::Option::Some(EBaseUserMessages::UM_GameTitle),
            "UM_HudMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_HudMsg),
            "UM_HudText" => ::std::option::Option::Some(EBaseUserMessages::UM_HudText),
            "UM_ColoredText" => ::std::option::Option::Some(EBaseUserMessages::UM_ColoredText),
            "UM_RequestState" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestState),
            "UM_ResetHUD" => ::std::option::Option::Some(EBaseUserMessages::UM_ResetHUD),
            "UM_Rumble" => ::std::option::Option::Some(EBaseUserMessages::UM_Rumble),
            "UM_SayText" => ::std::option::Option::Some(EBaseUserMessages::UM_SayText),
            "UM_SayText2" => ::std::option::Option::Some(EBaseUserMessages::UM_SayText2),
            "UM_SayTextChannel" => ::std::option::Option::Some(EBaseUserMessages::UM_SayTextChannel),
            "UM_Shake" => ::std::option::Option::Some(EBaseUserMessages::UM_Shake),
            "UM_ShakeDir" => ::std::option::Option::Some(EBaseUserMessages::UM_ShakeDir),
            "UM_WaterShake" => ::std::option::Option::Some(EBaseUserMessages::UM_WaterShake),
            "UM_TextMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_TextMsg),
            "UM_ScreenTilt" => ::std::option::Option::Some(EBaseUserMessages::UM_ScreenTilt),
            "UM_VoiceMask" => ::std::option::Option::Some(EBaseUserMessages::UM_VoiceMask),
            "UM_SendAudio" => ::std::option::Option::Some(EBaseUserMessages::UM_SendAudio),
            "UM_ItemPickup" => ::std::option::Option::Some(EBaseUserMessages::UM_ItemPickup),
            "UM_AmmoDenied" => ::std::option::Option::Some(EBaseUserMessages::UM_AmmoDenied),
            "UM_ShowMenu" => ::std::option::Option::Some(EBaseUserMessages::UM_ShowMenu),
            "UM_CreditsMsg" => ::std::option::Option::Some(EBaseUserMessages::UM_CreditsMsg),
            "UM_CloseCaptionPlaceholder" => ::std::option::Option::Some(EBaseUserMessages::UM_CloseCaptionPlaceholder),
            "UM_CameraTransition" => ::std::option::Option::Some(EBaseUserMessages::UM_CameraTransition),
            "UM_AudioParameter" => ::std::option::Option::Some(EBaseUserMessages::UM_AudioParameter),
            "UM_ParticleManager" => ::std::option::Option::Some(EBaseUserMessages::UM_ParticleManager),
            "UM_HudError" => ::std::option::Option::Some(EBaseUserMessages::UM_HudError),
            "UM_CustomGameEvent" => ::std::option::Option::Some(EBaseUserMessages::UM_CustomGameEvent),
            "UM_AnimGraphUpdate" => ::std::option::Option::Some(EBaseUserMessages::UM_AnimGraphUpdate),
            "UM_HapticsManagerPulse" => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerPulse),
            "UM_HapticsManagerEffect" => ::std::option::Option::Some(EBaseUserMessages::UM_HapticsManagerEffect),
            "UM_CommandQueueState" => ::std::option::Option::Some(EBaseUserMessages::UM_CommandQueueState),
            "UM_UpdateCssClasses" => ::std::option::Option::Some(EBaseUserMessages::UM_UpdateCssClasses),
            "UM_ServerFrameTime" => ::std::option::Option::Some(EBaseUserMessages::UM_ServerFrameTime),
            "UM_LagCompensationError" => ::std::option::Option::Some(EBaseUserMessages::UM_LagCompensationError),
            "UM_RequestDllStatus" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDllStatus),
            "UM_RequestUtilAction" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestUtilAction),
            "UM_UtilActionResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_UtilActionResponse),
            "UM_DllStatusResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_DllStatusResponse),
            "UM_RequestInventory" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestInventory),
            "UM_InventoryResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_InventoryResponse),
            "UM_RequestDiagnostic" => ::std::option::Option::Some(EBaseUserMessages::UM_RequestDiagnostic),
            "UM_DiagnosticResponse" => ::std::option::Option::Some(EBaseUserMessages::UM_DiagnosticResponse),
            "UM_ExtraUserData" => ::std::option::Option::Some(EBaseUserMessages::UM_ExtraUserData),
            "UM_NotifyResponseFound" => ::std::option::Option::Some(EBaseUserMessages::UM_NotifyResponseFound),
            "UM_PlayResponseConditional" => ::std::option::Option::Some(EBaseUserMessages::UM_PlayResponseConditional),
            "UM_MAX_BASE" => ::std::option::Option::Some(EBaseUserMessages::UM_MAX_BASE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseUserMessages] = &[
        EBaseUserMessages::UM_AchievementEvent,
        EBaseUserMessages::UM_CloseCaption,
        EBaseUserMessages::UM_CloseCaptionDirect,
        EBaseUserMessages::UM_CurrentTimescale,
        EBaseUserMessages::UM_DesiredTimescale,
        EBaseUserMessages::UM_Fade,
        EBaseUserMessages::UM_GameTitle,
        EBaseUserMessages::UM_HudMsg,
        EBaseUserMessages::UM_HudText,
        EBaseUserMessages::UM_ColoredText,
        EBaseUserMessages::UM_RequestState,
        EBaseUserMessages::UM_ResetHUD,
        EBaseUserMessages::UM_Rumble,
        EBaseUserMessages::UM_SayText,
        EBaseUserMessages::UM_SayText2,
        EBaseUserMessages::UM_SayTextChannel,
        EBaseUserMessages::UM_Shake,
        EBaseUserMessages::UM_ShakeDir,
        EBaseUserMessages::UM_WaterShake,
        EBaseUserMessages::UM_TextMsg,
        EBaseUserMessages::UM_ScreenTilt,
        EBaseUserMessages::UM_VoiceMask,
        EBaseUserMessages::UM_SendAudio,
        EBaseUserMessages::UM_ItemPickup,
        EBaseUserMessages::UM_AmmoDenied,
        EBaseUserMessages::UM_ShowMenu,
        EBaseUserMessages::UM_CreditsMsg,
        EBaseUserMessages::UM_CloseCaptionPlaceholder,
        EBaseUserMessages::UM_CameraTransition,
        EBaseUserMessages::UM_AudioParameter,
        EBaseUserMessages::UM_ParticleManager,
        EBaseUserMessages::UM_HudError,
        EBaseUserMessages::UM_CustomGameEvent,
        EBaseUserMessages::UM_AnimGraphUpdate,
        EBaseUserMessages::UM_HapticsManagerPulse,
        EBaseUserMessages::UM_HapticsManagerEffect,
        EBaseUserMessages::UM_CommandQueueState,
        EBaseUserMessages::UM_UpdateCssClasses,
        EBaseUserMessages::UM_ServerFrameTime,
        EBaseUserMessages::UM_LagCompensationError,
        EBaseUserMessages::UM_RequestDllStatus,
        EBaseUserMessages::UM_RequestUtilAction,
        EBaseUserMessages::UM_UtilActionResponse,
        EBaseUserMessages::UM_DllStatusResponse,
        EBaseUserMessages::UM_RequestInventory,
        EBaseUserMessages::UM_InventoryResponse,
        EBaseUserMessages::UM_RequestDiagnostic,
        EBaseUserMessages::UM_DiagnosticResponse,
        EBaseUserMessages::UM_ExtraUserData,
        EBaseUserMessages::UM_NotifyResponseFound,
        EBaseUserMessages::UM_PlayResponseConditional,
        EBaseUserMessages::UM_MAX_BASE,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseUserMessages {
    fn default() -> Self {
        EBaseUserMessages::UM_AchievementEvent
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EBaseEntityMessages)
pub enum EBaseEntityMessages {
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_PlayJingle)
    EM_PlayJingle = 136,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_ScreenOverlay)
    EM_ScreenOverlay = 137,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_RemoveAllDecals)
    EM_RemoveAllDecals = 138,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_PropagateForce)
    EM_PropagateForce = 139,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_DoSpark)
    EM_DoSpark = 140,
    // @@protoc_insertion_point(enum_value:EBaseEntityMessages.EM_FixAngle)
    EM_FixAngle = 141,
}

impl ::steam_vent_proto_common::protobuf::Enum for EBaseEntityMessages {
    const NAME: &'static str = "EBaseEntityMessages";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EBaseEntityMessages> {
        match value {
            136 => ::std::option::Option::Some(EBaseEntityMessages::EM_PlayJingle),
            137 => ::std::option::Option::Some(EBaseEntityMessages::EM_ScreenOverlay),
            138 => ::std::option::Option::Some(EBaseEntityMessages::EM_RemoveAllDecals),
            139 => ::std::option::Option::Some(EBaseEntityMessages::EM_PropagateForce),
            140 => ::std::option::Option::Some(EBaseEntityMessages::EM_DoSpark),
            141 => ::std::option::Option::Some(EBaseEntityMessages::EM_FixAngle),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EBaseEntityMessages> {
        match str {
            "EM_PlayJingle" => ::std::option::Option::Some(EBaseEntityMessages::EM_PlayJingle),
            "EM_ScreenOverlay" => ::std::option::Option::Some(EBaseEntityMessages::EM_ScreenOverlay),
            "EM_RemoveAllDecals" => ::std::option::Option::Some(EBaseEntityMessages::EM_RemoveAllDecals),
            "EM_PropagateForce" => ::std::option::Option::Some(EBaseEntityMessages::EM_PropagateForce),
            "EM_DoSpark" => ::std::option::Option::Some(EBaseEntityMessages::EM_DoSpark),
            "EM_FixAngle" => ::std::option::Option::Some(EBaseEntityMessages::EM_FixAngle),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EBaseEntityMessages] = &[
        EBaseEntityMessages::EM_PlayJingle,
        EBaseEntityMessages::EM_ScreenOverlay,
        EBaseEntityMessages::EM_RemoveAllDecals,
        EBaseEntityMessages::EM_PropagateForce,
        EBaseEntityMessages::EM_DoSpark,
        EBaseEntityMessages::EM_FixAngle,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EBaseEntityMessages {
    fn default() -> Self {
        EBaseEntityMessages::EM_PlayJingle
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:eRollType)
pub enum ERollType {
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_NONE)
    ROLL_NONE = -1,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_STATS)
    ROLL_STATS = 0,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_CREDITS)
    ROLL_CREDITS = 1,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_LATE_JOIN_LOGO)
    ROLL_LATE_JOIN_LOGO = 2,
    // @@protoc_insertion_point(enum_value:eRollType.ROLL_OUTTRO)
    ROLL_OUTTRO = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for ERollType {
    const NAME: &'static str = "eRollType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ERollType> {
        match value {
            -1 => ::std::option::Option::Some(ERollType::ROLL_NONE),
            0 => ::std::option::Option::Some(ERollType::ROLL_STATS),
            1 => ::std::option::Option::Some(ERollType::ROLL_CREDITS),
            2 => ::std::option::Option::Some(ERollType::ROLL_LATE_JOIN_LOGO),
            3 => ::std::option::Option::Some(ERollType::ROLL_OUTTRO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ERollType> {
        match str {
            "ROLL_NONE" => ::std::option::Option::Some(ERollType::ROLL_NONE),
            "ROLL_STATS" => ::std::option::Option::Some(ERollType::ROLL_STATS),
            "ROLL_CREDITS" => ::std::option::Option::Some(ERollType::ROLL_CREDITS),
            "ROLL_LATE_JOIN_LOGO" => ::std::option::Option::Some(ERollType::ROLL_LATE_JOIN_LOGO),
            "ROLL_OUTTRO" => ::std::option::Option::Some(ERollType::ROLL_OUTTRO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ERollType] = &[
        ERollType::ROLL_NONE,
        ERollType::ROLL_STATS,
        ERollType::ROLL_CREDITS,
        ERollType::ROLL_LATE_JOIN_LOGO,
        ERollType::ROLL_OUTTRO,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ERollType {
    fn default() -> Self {
        ERollType::ROLL_NONE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:PARTICLE_MESSAGE)
pub enum PARTICLE_MESSAGE {
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CREATE)
    GAME_PARTICLE_MANAGER_EVENT_CREATE = 0,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE = 1,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD = 2,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION = 3,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK = 4,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT = 5,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET = 6,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY = 7,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING = 8,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_RELEASE)
    GAME_PARTICLE_MANAGER_EVENT_RELEASE = 9,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_LATENCY)
    GAME_PARTICLE_MANAGER_EVENT_LATENCY = 10,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW)
    GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW = 11,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FROZEN)
    GAME_PARTICLE_MANAGER_EVENT_FROZEN = 12,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT)
    GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT = 13,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION = 14,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES)
    GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES = 15,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_TEXT)
    GAME_PARTICLE_MANAGER_EVENT_SET_TEXT = 16,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW)
    GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW = 17,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL)
    GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL = 18,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT)
    GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT = 19,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE)
    GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE = 20,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG)
    GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG = 21,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT)
    GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT = 22,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED = 23,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME)
    GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME = 24,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE)
    GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE = 25,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT)
    GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT = 26,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM)
    GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM = 27,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE)
    GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE = 28,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING)
    GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING = 29,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT)
    GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT = 30,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE)
    GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE = 31,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM)
    GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM = 32,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM)
    GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM = 33,
    // @@protoc_insertion_point(enum_value:PARTICLE_MESSAGE.GAME_PARTICLE_MANAGER_EVENT_SET_VDATA)
    GAME_PARTICLE_MANAGER_EVENT_SET_VDATA = 34,
}

impl ::steam_vent_proto_common::protobuf::Enum for PARTICLE_MESSAGE {
    const NAME: &'static str = "PARTICLE_MESSAGE";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PARTICLE_MESSAGE> {
        match value {
            0 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            1 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE),
            2 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD),
            3 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION),
            4 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK),
            5 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT),
            6 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET),
            7 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY),
            8 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING),
            9 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE),
            10 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY),
            11 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW),
            12 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN),
            13 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT),
            14 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION),
            15 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES),
            16 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT),
            17 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW),
            18 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL),
            19 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT),
            20 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE),
            21 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG),
            22 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT),
            23 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED),
            24 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME),
            25 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE),
            26 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT),
            27 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM),
            28 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE),
            29 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING),
            30 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT),
            31 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE),
            32 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM),
            33 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM),
            34 => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_VDATA),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<PARTICLE_MESSAGE> {
        match str {
            "GAME_PARTICLE_MANAGER_EVENT_CREATE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING),
            "GAME_PARTICLE_MANAGER_EVENT_RELEASE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE),
            "GAME_PARTICLE_MANAGER_EVENT_LATENCY" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY),
            "GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW),
            "GAME_PARTICLE_MANAGER_EVENT_FROZEN" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN),
            "GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION),
            "GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL),
            "GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT),
            "GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG),
            "GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED),
            "GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME),
            "GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE),
            "GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT),
            "GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE),
            "GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING),
            "GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT),
            "GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE),
            "GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM),
            "GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM),
            "GAME_PARTICLE_MANAGER_EVENT_SET_VDATA" => ::std::option::Option::Some(PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_VDATA),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [PARTICLE_MESSAGE] = &[
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FORWARD,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ORIENTATION,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_FALLBACK,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_OFFSET,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_INVOLVING,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_RELEASE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_LATENCY,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SHOULD_DRAW,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FROZEN,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CHANGE_CONTROL_POINT_ATTACHMENT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_ENTITY_POSITION,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_FOW_PROPERTIES,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SHOULD_CHECK_FOW,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_MODEL,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_CONTROL_POINT_SNAPSHOT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_TEXTURE_ATTRIBUTE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_GENERIC_FLAG,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_SCENE_OBJECT_TINT_AND_DESAT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_NAMED,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SKIP_TO_TIME,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CAN_FREEZE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_NAMED_VALUE_CONTEXT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_UPDATE_TRANSFORM,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_TRANSITION_OVERRIDE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_FREEZE_INVOLVING,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_ADD_MODELLIST_OVERRIDE_ELEMENT,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CLEAR_MODELLIST_OVERRIDE,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE_PHYSICS_SIM,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_DESTROY_PHYSICS_SIM,
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_SET_VDATA,
    ];
}

impl ::std::default::Default for PARTICLE_MESSAGE {
    fn default() -> Self {
        PARTICLE_MESSAGE::GAME_PARTICLE_MANAGER_EVENT_CREATE
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EHapticPulseType)
pub enum EHapticPulseType {
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_LIGHT)
    VR_HAND_HAPTIC_PULSE_LIGHT = 0,
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_MEDIUM)
    VR_HAND_HAPTIC_PULSE_MEDIUM = 1,
    // @@protoc_insertion_point(enum_value:EHapticPulseType.VR_HAND_HAPTIC_PULSE_STRONG)
    VR_HAND_HAPTIC_PULSE_STRONG = 2,
}

impl ::steam_vent_proto_common::protobuf::Enum for EHapticPulseType {
    const NAME: &'static str = "EHapticPulseType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EHapticPulseType> {
        match value {
            0 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT),
            1 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM),
            2 => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EHapticPulseType> {
        match str {
            "VR_HAND_HAPTIC_PULSE_LIGHT" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT),
            "VR_HAND_HAPTIC_PULSE_MEDIUM" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM),
            "VR_HAND_HAPTIC_PULSE_STRONG" => ::std::option::Option::Some(EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EHapticPulseType] = &[
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT,
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_MEDIUM,
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_STRONG,
    ];
}

impl ::std::default::Default for EHapticPulseType {
    fn default() -> Self {
        EHapticPulseType::VR_HAND_HAPTIC_PULSE_LIGHT
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::networkbasetypes::*;
impl ::steam_vent_proto_common::RpcMessage for CUserMessageAchievementEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCloseCaption {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCloseCaptionDirect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCloseCaptionPlaceholder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCurrentTimescale {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageDesiredTimescale {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageFade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageShake {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageShakeDir {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageWaterShake {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageScreenTilt {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageSayText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageSayText2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageHudMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageHudText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageTextMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageGameTitle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageResetHUD {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageSendAudio {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageAudioParameter {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageVoiceMask {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRequestState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRumble {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageSayTextChannel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageColoredText {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageItemPickup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageAmmoDenied {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageShowMenu {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCreditsMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessagePlayJingle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessageScreenOverlay {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessageRemoveAllDecals {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessagePropagateForce {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessageDoSpark {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CEntityMessageFixAngle {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageCameraTransition {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMsg_ParticleManager {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMsg_HudError {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMsg_CustomGameEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageHapticsManagerPulse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageHapticsManagerEffect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageAnimStateGraphState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageUpdateCssClasses {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageServerFrameTime {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageLagCompensationError {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRequestDllStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRequestUtilAction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_UtilMsg_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_DllStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRequestInventory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_Inventory_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessageRequestDiagnostic {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_Diagnostic_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_ExtraUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_NotifyResponseFound {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CUserMessage_PlayResponseConditional {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::MsgKindEnum for EBaseUserMessages {}
impl ::steam_vent_proto_common::MsgKindEnum for EBaseEntityMessages {}
