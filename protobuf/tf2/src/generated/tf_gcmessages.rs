// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `tf_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgTFGoldenWrenchBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFGoldenWrenchBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.wrench_number)
    pub wrench_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.deleted)
    pub deleted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFGoldenWrenchBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFGoldenWrenchBroadcast.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFGoldenWrenchBroadcast {
    fn default() -> &'a CMsgTFGoldenWrenchBroadcast {
        <CMsgTFGoldenWrenchBroadcast as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFGoldenWrenchBroadcast {
    pub fn new() -> CMsgTFGoldenWrenchBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 wrench_number = 1;

    pub fn wrench_number(&self) -> i32 {
        self.wrench_number.unwrap_or(0)
    }

    pub fn clear_wrench_number(&mut self) {
        self.wrench_number = ::std::option::Option::None;
    }

    pub fn has_wrench_number(&self) -> bool {
        self.wrench_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wrench_number(&mut self, v: i32) {
        self.wrench_number = ::std::option::Option::Some(v);
    }

    // optional bool deleted = 2;

    pub fn deleted(&self) -> bool {
        self.deleted.unwrap_or(false)
    }

    pub fn clear_deleted(&mut self) {
        self.deleted = ::std::option::Option::None;
    }

    pub fn has_deleted(&self) -> bool {
        self.deleted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deleted(&mut self, v: bool) {
        self.deleted = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFGoldenWrenchBroadcast {
    const NAME: &'static str = "CMsgTFGoldenWrenchBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wrench_number = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.deleted = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wrench_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.deleted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wrench_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.deleted {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFGoldenWrenchBroadcast {
        CMsgTFGoldenWrenchBroadcast::new()
    }

    fn clear(&mut self) {
        self.wrench_number = ::std::option::Option::None;
        self.deleted = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFGoldenWrenchBroadcast {
        static instance: CMsgTFGoldenWrenchBroadcast = CMsgTFGoldenWrenchBroadcast {
            wrench_number: ::std::option::Option::None,
            deleted: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFSaxxyBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFSaxxyBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFSaxxyBroadcast.category_number)
    pub category_number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFSaxxyBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFSaxxyBroadcast.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFSaxxyBroadcast {
    fn default() -> &'a CMsgTFSaxxyBroadcast {
        <CMsgTFSaxxyBroadcast as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFSaxxyBroadcast {
    pub fn new() -> CMsgTFSaxxyBroadcast {
        ::std::default::Default::default()
    }

    // optional int32 category_number = 1;

    pub fn category_number(&self) -> i32 {
        self.category_number.unwrap_or(0)
    }

    pub fn clear_category_number(&mut self) {
        self.category_number = ::std::option::Option::None;
    }

    pub fn has_category_number(&self) -> bool {
        self.category_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category_number(&mut self, v: i32) {
        self.category_number = ::std::option::Option::Some(v);
    }

    // optional string user_name = 2;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFSaxxyBroadcast {
    const NAME: &'static str = "CMsgTFSaxxyBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category_number = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.category_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.category_number {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFSaxxyBroadcast {
        CMsgTFSaxxyBroadcast::new()
    }

    fn clear(&mut self) {
        self.category_number = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFSaxxyBroadcast {
        static instance: CMsgTFSaxxyBroadcast = CMsgTFSaxxyBroadcast {
            category_number: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCTFSpecificItemBroadcast)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCTFSpecificItemBroadcast {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.item_def_index)
    pub item_def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.was_destruction)
    pub was_destruction: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCTFSpecificItemBroadcast.user_name)
    pub user_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCTFSpecificItemBroadcast.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCTFSpecificItemBroadcast {
    fn default() -> &'a CMsgGCTFSpecificItemBroadcast {
        <CMsgGCTFSpecificItemBroadcast as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCTFSpecificItemBroadcast {
    pub fn new() -> CMsgGCTFSpecificItemBroadcast {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_index = 1;

    pub fn item_def_index(&self) -> u32 {
        self.item_def_index.unwrap_or(0)
    }

    pub fn clear_item_def_index(&mut self) {
        self.item_def_index = ::std::option::Option::None;
    }

    pub fn has_item_def_index(&self) -> bool {
        self.item_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_index(&mut self, v: u32) {
        self.item_def_index = ::std::option::Option::Some(v);
    }

    // optional bool was_destruction = 2;

    pub fn was_destruction(&self) -> bool {
        self.was_destruction.unwrap_or(false)
    }

    pub fn clear_was_destruction(&mut self) {
        self.was_destruction = ::std::option::Option::None;
    }

    pub fn has_was_destruction(&self) -> bool {
        self.was_destruction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_destruction(&mut self, v: bool) {
        self.was_destruction = ::std::option::Option::Some(v);
    }

    // optional string user_name = 3;

    pub fn user_name(&self) -> &str {
        match self.user_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_name(&mut self) {
        self.user_name = ::std::option::Option::None;
    }

    pub fn has_user_name(&self) -> bool {
        self.user_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_name(&mut self, v: ::std::string::String) {
        self.user_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_name(&mut self) -> &mut ::std::string::String {
        if self.user_name.is_none() {
            self.user_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_name(&mut self) -> ::std::string::String {
        self.user_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCTFSpecificItemBroadcast {
    const NAME: &'static str = "CMsgGCTFSpecificItemBroadcast";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.was_destruction = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.user_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.was_destruction {
            my_size += 1 + 1;
        }
        if let Some(v) = self.user_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_destruction {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.user_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCTFSpecificItemBroadcast {
        CMsgGCTFSpecificItemBroadcast::new()
    }

    fn clear(&mut self) {
        self.item_def_index = ::std::option::Option::None;
        self.was_destruction = ::std::option::Option::None;
        self.user_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCTFSpecificItemBroadcast {
        static instance: CMsgGCTFSpecificItemBroadcast = CMsgGCTFSpecificItemBroadcast {
            item_def_index: ::std::option::Option::None,
            was_destruction: ::std::option::Option::None,
            user_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFWorldStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFWorldStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.beta_stress_test_event_active)
    pub beta_stress_test_event_active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.event_match_group)
    pub event_match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.event_expire_time)
    pub event_expire_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.active_client_version)
    pub active_client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFWorldStatus.disabled_match_groups)
    pub disabled_match_groups: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFWorldStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFWorldStatus {
    fn default() -> &'a CMsgTFWorldStatus {
        <CMsgTFWorldStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFWorldStatus {
    pub fn new() -> CMsgTFWorldStatus {
        ::std::default::Default::default()
    }

    // optional bool beta_stress_test_event_active = 1;

    pub fn beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.unwrap_or(false)
    }

    pub fn clear_beta_stress_test_event_active(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
    }

    pub fn has_beta_stress_test_event_active(&self) -> bool {
        self.beta_stress_test_event_active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beta_stress_test_event_active(&mut self, v: bool) {
        self.beta_stress_test_event_active = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup event_match_group = 2;

    pub fn event_match_group(&self) -> ETFMatchGroup {
        match self.event_match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_event_match_group(&mut self) {
        self.event_match_group = ::std::option::Option::None;
    }

    pub fn has_event_match_group(&self) -> bool {
        self.event_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_match_group(&mut self, v: ETFMatchGroup) {
        self.event_match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 event_expire_time = 3;

    pub fn event_expire_time(&self) -> u32 {
        self.event_expire_time.unwrap_or(0u32)
    }

    pub fn clear_event_expire_time(&mut self) {
        self.event_expire_time = ::std::option::Option::None;
    }

    pub fn has_event_expire_time(&self) -> bool {
        self.event_expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_expire_time(&mut self, v: u32) {
        self.event_expire_time = ::std::option::Option::Some(v);
    }

    // optional uint32 active_client_version = 4;

    pub fn active_client_version(&self) -> u32 {
        self.active_client_version.unwrap_or(0)
    }

    pub fn clear_active_client_version(&mut self) {
        self.active_client_version = ::std::option::Option::None;
    }

    pub fn has_active_client_version(&self) -> bool {
        self.active_client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_client_version(&mut self, v: u32) {
        self.active_client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFWorldStatus {
    const NAME: &'static str = "CMsgTFWorldStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.beta_stress_test_event_active = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.event_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                29 => {
                    self.event_expire_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.active_client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.disabled_match_groups.push(is.read_enum_or_unknown()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.disabled_match_groups)?
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.beta_stress_test_event_active {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.event_expire_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.active_client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.disabled_match_groups {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, value.value());
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.beta_stress_test_event_active {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.event_match_group {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_expire_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.active_client_version {
            os.write_uint32(4, v)?;
        }
        for v in &self.disabled_match_groups {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFWorldStatus {
        CMsgTFWorldStatus::new()
    }

    fn clear(&mut self) {
        self.beta_stress_test_event_active = ::std::option::Option::None;
        self.event_match_group = ::std::option::Option::None;
        self.event_expire_time = ::std::option::Option::None;
        self.active_client_version = ::std::option::Option::None;
        self.disabled_match_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFWorldStatus {
        static instance: CMsgTFWorldStatus = CMsgTFWorldStatus {
            beta_stress_test_event_active: ::std::option::Option::None,
            event_match_group: ::std::option::Option::None,
            event_expire_time: ::std::option::Option::None,
            active_client_version: ::std::option::Option::None,
            disabled_match_groups: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFDuelSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFDuelSummary {
    // message fields
    // @@protoc_insertion_point(field:CSOTFDuelSummary.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.duel_wins)
    pub duel_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.duel_losses)
    pub duel_losses: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_account_id)
    pub last_duel_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_timestamp)
    pub last_duel_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFDuelSummary.last_duel_status)
    pub last_duel_status: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFDuelSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFDuelSummary {
    fn default() -> &'a CSOTFDuelSummary {
        <CSOTFDuelSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFDuelSummary {
    pub fn new() -> CSOTFDuelSummary {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_wins = 2;

    pub fn duel_wins(&self) -> u32 {
        self.duel_wins.unwrap_or(0)
    }

    pub fn clear_duel_wins(&mut self) {
        self.duel_wins = ::std::option::Option::None;
    }

    pub fn has_duel_wins(&self) -> bool {
        self.duel_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_wins(&mut self, v: u32) {
        self.duel_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 duel_losses = 3;

    pub fn duel_losses(&self) -> u32 {
        self.duel_losses.unwrap_or(0)
    }

    pub fn clear_duel_losses(&mut self) {
        self.duel_losses = ::std::option::Option::None;
    }

    pub fn has_duel_losses(&self) -> bool {
        self.duel_losses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_losses(&mut self, v: u32) {
        self.duel_losses = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_account_id = 4;

    pub fn last_duel_account_id(&self) -> u32 {
        self.last_duel_account_id.unwrap_or(0)
    }

    pub fn clear_last_duel_account_id(&mut self) {
        self.last_duel_account_id = ::std::option::Option::None;
    }

    pub fn has_last_duel_account_id(&self) -> bool {
        self.last_duel_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_account_id(&mut self, v: u32) {
        self.last_duel_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_timestamp = 5;

    pub fn last_duel_timestamp(&self) -> u32 {
        self.last_duel_timestamp.unwrap_or(0)
    }

    pub fn clear_last_duel_timestamp(&mut self) {
        self.last_duel_timestamp = ::std::option::Option::None;
    }

    pub fn has_last_duel_timestamp(&self) -> bool {
        self.last_duel_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_timestamp(&mut self, v: u32) {
        self.last_duel_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_duel_status = 6;

    pub fn last_duel_status(&self) -> u32 {
        self.last_duel_status.unwrap_or(0)
    }

    pub fn clear_last_duel_status(&mut self) {
        self.last_duel_status = ::std::option::Option::None;
    }

    pub fn has_last_duel_status(&self) -> bool {
        self.last_duel_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_duel_status(&mut self, v: u32) {
        self.last_duel_status = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFDuelSummary {
    const NAME: &'static str = "CSOTFDuelSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.duel_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.duel_losses = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_duel_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.last_duel_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.last_duel_status = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.duel_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duel_losses {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_duel_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.last_duel_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.last_duel_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.duel_wins {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duel_losses {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_duel_account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.last_duel_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.last_duel_status {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFDuelSummary {
        CSOTFDuelSummary::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.duel_wins = ::std::option::Option::None;
        self.duel_losses = ::std::option::Option::None;
        self.last_duel_account_id = ::std::option::Option::None;
        self.last_duel_timestamp = ::std::option::Option::None;
        self.last_duel_status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFDuelSummary {
        static instance: CSOTFDuelSummary = CSOTFDuelSummary {
            account_id: ::std::option::Option::None,
            duel_wins: ::std::option::Option::None,
            duel_losses: ::std::option::Option::None,
            last_duel_account_id: ::std::option::Option::None,
            last_duel_timestamp: ::std::option::Option::None,
            last_duel_status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFMapContribution)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFMapContribution {
    // message fields
    // @@protoc_insertion_point(field:CSOTFMapContribution.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMapContribution.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMapContribution.contribution_level)
    pub contribution_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFMapContribution.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFMapContribution {
    fn default() -> &'a CSOTFMapContribution {
        <CSOTFMapContribution as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFMapContribution {
    pub fn new() -> CSOTFMapContribution {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 2;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 contribution_level = 3;

    pub fn contribution_level(&self) -> u32 {
        self.contribution_level.unwrap_or(0)
    }

    pub fn clear_contribution_level(&mut self) {
        self.contribution_level = ::std::option::Option::None;
    }

    pub fn has_contribution_level(&self) -> bool {
        self.contribution_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contribution_level(&mut self, v: u32) {
        self.contribution_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFMapContribution {
    const NAME: &'static str = "CSOTFMapContribution";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.contribution_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.contribution_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.contribution_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFMapContribution {
        CSOTFMapContribution::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.contribution_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFMapContribution {
        static instance: CSOTFMapContribution = CSOTFMapContribution {
            account_id: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            contribution_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFFreeTrialChooseMostHelpfulFriend)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFFreeTrialChooseMostHelpfulFriend {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFFreeTrialChooseMostHelpfulFriend.account_id_friend)
    pub account_id_friend: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFFreeTrialChooseMostHelpfulFriend.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn default() -> &'a CMsgTFFreeTrialChooseMostHelpfulFriend {
        <CMsgTFFreeTrialChooseMostHelpfulFriend as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialChooseMostHelpfulFriend {
    pub fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend = 1;

    pub fn account_id_friend(&self) -> u32 {
        self.account_id_friend.unwrap_or(0)
    }

    pub fn clear_account_id_friend(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
    }

    pub fn has_account_id_friend(&self) -> bool {
        self.account_id_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend(&mut self, v: u32) {
        self.account_id_friend = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFFreeTrialChooseMostHelpfulFriend {
    const NAME: &'static str = "CMsgTFFreeTrialChooseMostHelpfulFriend";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_friend = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_friend {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFFreeTrialChooseMostHelpfulFriend {
        CMsgTFFreeTrialChooseMostHelpfulFriend::new()
    }

    fn clear(&mut self) {
        self.account_id_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFFreeTrialChooseMostHelpfulFriend {
        static instance: CMsgTFFreeTrialChooseMostHelpfulFriend = CMsgTFFreeTrialChooseMostHelpfulFriend {
            account_id_friend: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFRequestTF2Friends)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFRequestTF2Friends {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFRequestTF2Friends.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFRequestTF2Friends.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2Friends {
    fn default() -> &'a CMsgTFRequestTF2Friends {
        <CMsgTFRequestTF2Friends as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2Friends {
    pub fn new() -> CMsgTFRequestTF2Friends {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFRequestTF2Friends {
    const NAME: &'static str = "CMsgTFRequestTF2Friends";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFRequestTF2Friends {
        CMsgTFRequestTF2Friends::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFRequestTF2Friends {
        static instance: CMsgTFRequestTF2Friends = CMsgTFRequestTF2Friends {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFRequestTF2FriendsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFRequestTF2FriendsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFRequestTF2FriendsResponse.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFRequestTF2FriendsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFRequestTF2FriendsResponse {
    fn default() -> &'a CMsgTFRequestTF2FriendsResponse {
        <CMsgTFRequestTF2FriendsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFRequestTF2FriendsResponse {
    pub fn new() -> CMsgTFRequestTF2FriendsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFRequestTF2FriendsResponse {
    const NAME: &'static str = "CMsgTFRequestTF2FriendsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFRequestTF2FriendsResponse {
        CMsgTFRequestTF2FriendsResponse::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFRequestTF2FriendsResponse {
        static instance: CMsgTFRequestTF2FriendsResponse = CMsgTFRequestTF2FriendsResponse {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFPlayerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPlayerInfo {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPlayerInfo.num_new_users_helped)
    pub num_new_users_helped: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPlayerInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPlayerInfo {
    fn default() -> &'a CSOTFPlayerInfo {
        <CSOTFPlayerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFPlayerInfo {
    pub fn new() -> CSOTFPlayerInfo {
        ::std::default::Default::default()
    }

    // optional uint32 num_new_users_helped = 1;

    pub fn num_new_users_helped(&self) -> u32 {
        self.num_new_users_helped.unwrap_or(0)
    }

    pub fn clear_num_new_users_helped(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
    }

    pub fn has_num_new_users_helped(&self) -> bool {
        self.num_new_users_helped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_new_users_helped(&mut self, v: u32) {
        self.num_new_users_helped = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFPlayerInfo {
    const NAME: &'static str = "CSOTFPlayerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_new_users_helped = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_new_users_helped {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.num_new_users_helped {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPlayerInfo {
        CSOTFPlayerInfo::new()
    }

    fn clear(&mut self) {
        self.num_new_users_helped = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPlayerInfo {
        static instance: CSOTFPlayerInfo = CSOTFPlayerInfo {
            num_new_users_helped: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFThankedBySomeone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFThankedBySomeone {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFThankedBySomeone.thanker_steam_id)
    pub thanker_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFThankedBySomeone.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedBySomeone {
    fn default() -> &'a CMsgTFThankedBySomeone {
        <CMsgTFThankedBySomeone as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedBySomeone {
    pub fn new() -> CMsgTFThankedBySomeone {
        ::std::default::Default::default()
    }

    // optional uint64 thanker_steam_id = 1;

    pub fn thanker_steam_id(&self) -> u64 {
        self.thanker_steam_id.unwrap_or(0)
    }

    pub fn clear_thanker_steam_id(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
    }

    pub fn has_thanker_steam_id(&self) -> bool {
        self.thanker_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_thanker_steam_id(&mut self, v: u64) {
        self.thanker_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFThankedBySomeone {
    const NAME: &'static str = "CMsgTFThankedBySomeone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.thanker_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.thanker_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.thanker_steam_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFThankedBySomeone {
        CMsgTFThankedBySomeone::new()
    }

    fn clear(&mut self) {
        self.thanker_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFThankedBySomeone {
        static instance: CMsgTFThankedBySomeone = CMsgTFThankedBySomeone {
            thanker_steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFThankedSomeone)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFThankedSomeone {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFThankedSomeone.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFThankedSomeone {
    fn default() -> &'a CMsgTFThankedSomeone {
        <CMsgTFThankedSomeone as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFThankedSomeone {
    pub fn new() -> CMsgTFThankedSomeone {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFThankedSomeone {
    const NAME: &'static str = "CMsgTFThankedSomeone";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFThankedSomeone {
        CMsgTFThankedSomeone::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFThankedSomeone {
        static instance: CMsgTFThankedSomeone = CMsgTFThankedSomeone {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFFreeTrialConvertedToPremium)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFFreeTrialConvertedToPremium {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFFreeTrialConvertedToPremium.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFFreeTrialConvertedToPremium {
    fn default() -> &'a CMsgTFFreeTrialConvertedToPremium {
        <CMsgTFFreeTrialConvertedToPremium as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFFreeTrialConvertedToPremium {
    pub fn new() -> CMsgTFFreeTrialConvertedToPremium {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFFreeTrialConvertedToPremium {
    const NAME: &'static str = "CMsgTFFreeTrialConvertedToPremium";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFFreeTrialConvertedToPremium {
        CMsgTFFreeTrialConvertedToPremium::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFFreeTrialConvertedToPremium {
        static instance: CMsgTFFreeTrialConvertedToPremium = CMsgTFFreeTrialConvertedToPremium {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSaxxyAwarded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSaxxyAwarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgSaxxyAwarded.category)
    pub category: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSaxxyAwarded.winner_names)
    pub winner_names: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSaxxyAwarded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSaxxyAwarded {
    fn default() -> &'a CMsgSaxxyAwarded {
        <CMsgSaxxyAwarded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSaxxyAwarded {
    pub fn new() -> CMsgSaxxyAwarded {
        ::std::default::Default::default()
    }

    // optional uint32 category = 1;

    pub fn category(&self) -> u32 {
        self.category.unwrap_or(0)
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSaxxyAwarded {
    const NAME: &'static str = "CMsgSaxxyAwarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.category = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.winner_names.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.category {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.winner_names {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.category {
            os.write_uint32(1, v)?;
        }
        for v in &self.winner_names {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSaxxyAwarded {
        CMsgSaxxyAwarded::new()
    }

    fn clear(&mut self) {
        self.category = ::std::option::Option::None;
        self.winner_names.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSaxxyAwarded {
        static instance: CMsgSaxxyAwarded = CMsgSaxxyAwarded {
            category: ::std::option::Option::None,
            winner_names: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReplaySubmitContestEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplaySubmitContestEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntry.youtube_url)
    pub youtube_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntry.category)
    pub category: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplaySubmitContestEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntry {
    fn default() -> &'a CMsgReplaySubmitContestEntry {
        <CMsgReplaySubmitContestEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntry {
    pub fn new() -> CMsgReplaySubmitContestEntry {
        ::std::default::Default::default()
    }

    // optional string youtube_url = 1;

    pub fn youtube_url(&self) -> &str {
        match self.youtube_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_youtube_url(&mut self) {
        self.youtube_url = ::std::option::Option::None;
    }

    pub fn has_youtube_url(&self) -> bool {
        self.youtube_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_youtube_url(&mut self, v: ::std::string::String) {
        self.youtube_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_youtube_url(&mut self) -> &mut ::std::string::String {
        if self.youtube_url.is_none() {
            self.youtube_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.youtube_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_youtube_url(&mut self) -> ::std::string::String {
        self.youtube_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 category = 2;

    pub fn category(&self) -> u32 {
        self.category.unwrap_or(0)
    }

    pub fn clear_category(&mut self) {
        self.category = ::std::option::Option::None;
    }

    pub fn has_category(&self) -> bool {
        self.category.is_some()
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: u32) {
        self.category = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReplaySubmitContestEntry {
    const NAME: &'static str = "CMsgReplaySubmitContestEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.youtube_url = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.category = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.youtube_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.category {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.youtube_url.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.category {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplaySubmitContestEntry {
        CMsgReplaySubmitContestEntry::new()
    }

    fn clear(&mut self) {
        self.youtube_url = ::std::option::Option::None;
        self.category = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntry {
        static instance: CMsgReplaySubmitContestEntry = CMsgReplaySubmitContestEntry {
            youtube_url: ::std::option::Option::None,
            category: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReplaySubmitContestEntryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReplaySubmitContestEntryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgReplaySubmitContestEntryResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReplaySubmitContestEntryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReplaySubmitContestEntryResponse {
    fn default() -> &'a CMsgReplaySubmitContestEntryResponse {
        <CMsgReplaySubmitContestEntryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReplaySubmitContestEntryResponse {
    pub fn new() -> CMsgReplaySubmitContestEntryResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReplaySubmitContestEntryResponse {
    const NAME: &'static str = "CMsgReplaySubmitContestEntryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReplaySubmitContestEntryResponse {
        CMsgReplaySubmitContestEntryResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReplaySubmitContestEntryResponse {
        static instance: CMsgReplaySubmitContestEntryResponse = CMsgReplaySubmitContestEntryResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CReplayCachedContestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CReplayCachedContestData {
    // message fields
    // @@protoc_insertion_point(field:CReplayCachedContestData.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.num_votes_last_day)
    pub num_votes_last_day: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.video_entry_ids)
    pub video_entry_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CReplayCachedContestData.num_flags_last_day)
    pub num_flags_last_day: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CReplayCachedContestData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CReplayCachedContestData {
    fn default() -> &'a CReplayCachedContestData {
        <CReplayCachedContestData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CReplayCachedContestData {
    pub fn new() -> CReplayCachedContestData {
        ::std::default::Default::default()
    }

    // optional fixed32 timestamp = 1;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 num_votes_last_day = 2;

    pub fn num_votes_last_day(&self) -> u32 {
        self.num_votes_last_day.unwrap_or(0)
    }

    pub fn clear_num_votes_last_day(&mut self) {
        self.num_votes_last_day = ::std::option::Option::None;
    }

    pub fn has_num_votes_last_day(&self) -> bool {
        self.num_votes_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_votes_last_day(&mut self, v: u32) {
        self.num_votes_last_day = ::std::option::Option::Some(v);
    }

    // optional uint32 num_flags_last_day = 4;

    pub fn num_flags_last_day(&self) -> u32 {
        self.num_flags_last_day.unwrap_or(0)
    }

    pub fn clear_num_flags_last_day(&mut self) {
        self.num_flags_last_day = ::std::option::Option::None;
    }

    pub fn has_num_flags_last_day(&self) -> bool {
        self.num_flags_last_day.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_flags_last_day(&mut self, v: u32) {
        self.num_flags_last_day = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CReplayCachedContestData {
    const NAME: &'static str = "CReplayCachedContestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                16 => {
                    self.num_votes_last_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.video_entry_ids)?;
                },
                24 => {
                    self.video_entry_ids.push(is.read_uint32()?);
                },
                32 => {
                    self.num_flags_last_day = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp {
            my_size += 1 + 4;
        }
        if let Some(v) = self.num_votes_last_day {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.video_entry_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.num_flags_last_day {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.timestamp {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.num_votes_last_day {
            os.write_uint32(2, v)?;
        }
        for v in &self.video_entry_ids {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.num_flags_last_day {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CReplayCachedContestData {
        CReplayCachedContestData::new()
    }

    fn clear(&mut self) {
        self.timestamp = ::std::option::Option::None;
        self.num_votes_last_day = ::std::option::Option::None;
        self.video_entry_ids.clear();
        self.num_flags_last_day = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CReplayCachedContestData {
        static instance: CReplayCachedContestData = CReplayCachedContestData {
            timestamp: ::std::option::Option::None,
            num_votes_last_day: ::std::option::Option::None,
            video_entry_ids: ::std::vec::Vec::new(),
            num_flags_last_day: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AddToCoaches)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AddToCoaches {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AddToCoaches.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AddToCoaches {
    fn default() -> &'a CMsgTFCoaching_AddToCoaches {
        <CMsgTFCoaching_AddToCoaches as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AddToCoaches {
    pub fn new() -> CMsgTFCoaching_AddToCoaches {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_AddToCoaches {
    const NAME: &'static str = "CMsgTFCoaching_AddToCoaches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AddToCoaches {
        CMsgTFCoaching_AddToCoaches::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AddToCoaches {
        static instance: CMsgTFCoaching_AddToCoaches = CMsgTFCoaching_AddToCoaches {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_RemoveFromCoaches)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_RemoveFromCoaches {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_RemoveFromCoaches.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveFromCoaches {
    fn default() -> &'a CMsgTFCoaching_RemoveFromCoaches {
        <CMsgTFCoaching_RemoveFromCoaches as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveFromCoaches {
    pub fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_RemoveFromCoaches {
    const NAME: &'static str = "CMsgTFCoaching_RemoveFromCoaches";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_RemoveFromCoaches {
        CMsgTFCoaching_RemoveFromCoaches::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveFromCoaches {
        static instance: CMsgTFCoaching_RemoveFromCoaches = CMsgTFCoaching_RemoveFromCoaches {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_FindCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_FindCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoach.account_id_friend_as_coach)
    pub account_id_friend_as_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_FindCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoach {
    fn default() -> &'a CMsgTFCoaching_FindCoach {
        <CMsgTFCoaching_FindCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoach {
    pub fn new() -> CMsgTFCoaching_FindCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_friend_as_coach = 1;

    pub fn account_id_friend_as_coach(&self) -> u32 {
        self.account_id_friend_as_coach.unwrap_or(0)
    }

    pub fn clear_account_id_friend_as_coach(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_friend_as_coach(&self) -> bool {
        self.account_id_friend_as_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_friend_as_coach(&mut self, v: u32) {
        self.account_id_friend_as_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_FindCoach {
    const NAME: &'static str = "CMsgTFCoaching_FindCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_friend_as_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_friend_as_coach {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_friend_as_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_FindCoach {
        CMsgTFCoaching_FindCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_friend_as_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoach {
        static instance: CMsgTFCoaching_FindCoach = CMsgTFCoaching_FindCoach {
            account_id_friend_as_coach: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_FindCoachResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_FindCoachResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.found_coach)
    pub found_coach: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.num_likes)
    pub num_likes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_FindCoachResponse.coach_name)
    pub coach_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_FindCoachResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_FindCoachResponse {
    fn default() -> &'a CMsgTFCoaching_FindCoachResponse {
        <CMsgTFCoaching_FindCoachResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_FindCoachResponse {
    pub fn new() -> CMsgTFCoaching_FindCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool found_coach = 1;

    pub fn found_coach(&self) -> bool {
        self.found_coach.unwrap_or(false)
    }

    pub fn clear_found_coach(&mut self) {
        self.found_coach = ::std::option::Option::None;
    }

    pub fn has_found_coach(&self) -> bool {
        self.found_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_found_coach(&mut self, v: bool) {
        self.found_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 num_likes = 2;

    pub fn num_likes(&self) -> u32 {
        self.num_likes.unwrap_or(0)
    }

    pub fn clear_num_likes(&mut self) {
        self.num_likes = ::std::option::Option::None;
    }

    pub fn has_num_likes(&self) -> bool {
        self.num_likes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_likes(&mut self, v: u32) {
        self.num_likes = ::std::option::Option::Some(v);
    }

    // optional string coach_name = 3;

    pub fn coach_name(&self) -> &str {
        match self.coach_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_coach_name(&mut self) {
        self.coach_name = ::std::option::Option::None;
    }

    pub fn has_coach_name(&self) -> bool {
        self.coach_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coach_name(&mut self, v: ::std::string::String) {
        self.coach_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coach_name(&mut self) -> &mut ::std::string::String {
        if self.coach_name.is_none() {
            self.coach_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.coach_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_coach_name(&mut self) -> ::std::string::String {
        self.coach_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_FindCoachResponse {
    const NAME: &'static str = "CMsgTFCoaching_FindCoachResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.found_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.num_likes = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.coach_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.found_coach {
            my_size += 1 + 1;
        }
        if let Some(v) = self.num_likes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.coach_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.found_coach {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.num_likes {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.coach_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_FindCoachResponse {
        CMsgTFCoaching_FindCoachResponse::new()
    }

    fn clear(&mut self) {
        self.found_coach = ::std::option::Option::None;
        self.num_likes = ::std::option::Option::None;
        self.coach_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_FindCoachResponse {
        static instance: CMsgTFCoaching_FindCoachResponse = CMsgTFCoaching_FindCoachResponse {
            found_coach: ::std::option::Option::None,
            num_likes: ::std::option::Option::None,
            coach_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AskCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AskCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoach.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoach.student_is_friend)
    pub student_is_friend: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AskCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoach {
    fn default() -> &'a CMsgTFCoaching_AskCoach {
        <CMsgTFCoaching_AskCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoach {
    pub fn new() -> CMsgTFCoaching_AskCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_student = 1;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }

    // optional bool student_is_friend = 2;

    pub fn student_is_friend(&self) -> bool {
        self.student_is_friend.unwrap_or(false)
    }

    pub fn clear_student_is_friend(&mut self) {
        self.student_is_friend = ::std::option::Option::None;
    }

    pub fn has_student_is_friend(&self) -> bool {
        self.student_is_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_student_is_friend(&mut self, v: bool) {
        self.student_is_friend = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_AskCoach {
    const NAME: &'static str = "CMsgTFCoaching_AskCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.student_is_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_student {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.student_is_friend {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_student {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.student_is_friend {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AskCoach {
        CMsgTFCoaching_AskCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_student = ::std::option::Option::None;
        self.student_is_friend = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoach {
        static instance: CMsgTFCoaching_AskCoach = CMsgTFCoaching_AskCoach {
            account_id_student: ::std::option::Option::None,
            student_is_friend: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_AskCoachResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_AskCoachResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_AskCoachResponse.accept_coaching_assignment)
    pub accept_coaching_assignment: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_AskCoachResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_AskCoachResponse {
    fn default() -> &'a CMsgTFCoaching_AskCoachResponse {
        <CMsgTFCoaching_AskCoachResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_AskCoachResponse {
    pub fn new() -> CMsgTFCoaching_AskCoachResponse {
        ::std::default::Default::default()
    }

    // optional bool accept_coaching_assignment = 1;

    pub fn accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.unwrap_or(false)
    }

    pub fn clear_accept_coaching_assignment(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
    }

    pub fn has_accept_coaching_assignment(&self) -> bool {
        self.accept_coaching_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept_coaching_assignment(&mut self, v: bool) {
        self.accept_coaching_assignment = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_AskCoachResponse {
    const NAME: &'static str = "CMsgTFCoaching_AskCoachResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accept_coaching_assignment = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accept_coaching_assignment {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.accept_coaching_assignment {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_AskCoachResponse {
        CMsgTFCoaching_AskCoachResponse::new()
    }

    fn clear(&mut self) {
        self.accept_coaching_assignment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_AskCoachResponse {
        static instance: CMsgTFCoaching_AskCoachResponse = CMsgTFCoaching_AskCoachResponse {
            accept_coaching_assignment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoinGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoinGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.join_game)
    pub join_game: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.server_address)
    pub server_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoinGame.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoinGame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoinGame {
    fn default() -> &'a CMsgTFCoaching_CoachJoinGame {
        <CMsgTFCoaching_CoachJoinGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoinGame {
    pub fn new() -> CMsgTFCoaching_CoachJoinGame {
        ::std::default::Default::default()
    }

    // optional bool join_game = 1;

    pub fn join_game(&self) -> bool {
        self.join_game.unwrap_or(false)
    }

    pub fn clear_join_game(&mut self) {
        self.join_game = ::std::option::Option::None;
    }

    pub fn has_join_game(&self) -> bool {
        self.join_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_game(&mut self, v: bool) {
        self.join_game = ::std::option::Option::Some(v);
    }

    // optional uint32 server_address = 2;

    pub fn server_address(&self) -> u32 {
        self.server_address.unwrap_or(0)
    }

    pub fn clear_server_address(&mut self) {
        self.server_address = ::std::option::Option::None;
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: u32) {
        self.server_address = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 4;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_CoachJoinGame {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoinGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.join_game = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.join_game {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_address {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.server_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.join_game {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.server_address {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoinGame {
        CMsgTFCoaching_CoachJoinGame::new()
    }

    fn clear(&mut self) {
        self.join_game = ::std::option::Option::None;
        self.server_address = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoinGame {
        static instance: CMsgTFCoaching_CoachJoinGame = CMsgTFCoaching_CoachJoinGame {
            join_game: ::std::option::Option::None,
            server_address: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            account_id_student: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoining {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoining.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoining.account_id_student)
    pub account_id_student: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoining.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoining {
    fn default() -> &'a CMsgTFCoaching_CoachJoining {
        <CMsgTFCoaching_CoachJoining as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoining {
    pub fn new() -> CMsgTFCoaching_CoachJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id_student = 2;

    pub fn account_id_student(&self) -> u32 {
        self.account_id_student.unwrap_or(0)
    }

    pub fn clear_account_id_student(&mut self) {
        self.account_id_student = ::std::option::Option::None;
    }

    pub fn has_account_id_student(&self) -> bool {
        self.account_id_student.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_student(&mut self, v: u32) {
        self.account_id_student = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_CoachJoining {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id_student = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id_student {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id_student {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoining {
        CMsgTFCoaching_CoachJoining::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.account_id_student = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoining {
        static instance: CMsgTFCoaching_CoachJoining = CMsgTFCoaching_CoachJoining {
            account_id_coach: ::std::option::Option::None,
            account_id_student: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_CoachJoined)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_CoachJoined {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_CoachJoined.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_CoachJoined.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_CoachJoined {
    fn default() -> &'a CMsgTFCoaching_CoachJoined {
        <CMsgTFCoaching_CoachJoined as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_CoachJoined {
    pub fn new() -> CMsgTFCoaching_CoachJoined {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_CoachJoined {
    const NAME: &'static str = "CMsgTFCoaching_CoachJoined";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_CoachJoined {
        CMsgTFCoaching_CoachJoined::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_CoachJoined {
        static instance: CMsgTFCoaching_CoachJoined = CMsgTFCoaching_CoachJoined {
            account_id_coach: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_LikeCurrentCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_LikeCurrentCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_LikeCurrentCoach.like_coach)
    pub like_coach: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_LikeCurrentCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_LikeCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_LikeCurrentCoach {
        <CMsgTFCoaching_LikeCurrentCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_LikeCurrentCoach {
    pub fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        ::std::default::Default::default()
    }

    // optional bool like_coach = 1;

    pub fn like_coach(&self) -> bool {
        self.like_coach.unwrap_or(false)
    }

    pub fn clear_like_coach(&mut self) {
        self.like_coach = ::std::option::Option::None;
    }

    pub fn has_like_coach(&self) -> bool {
        self.like_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_like_coach(&mut self, v: bool) {
        self.like_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_LikeCurrentCoach {
    const NAME: &'static str = "CMsgTFCoaching_LikeCurrentCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.like_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.like_coach {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.like_coach {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_LikeCurrentCoach {
        CMsgTFCoaching_LikeCurrentCoach::new()
    }

    fn clear(&mut self) {
        self.like_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_LikeCurrentCoach {
        static instance: CMsgTFCoaching_LikeCurrentCoach = CMsgTFCoaching_LikeCurrentCoach {
            like_coach: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFCoaching_RemoveCurrentCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFCoaching_RemoveCurrentCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFCoaching_RemoveCurrentCoach.account_id_coach)
    pub account_id_coach: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFCoaching_RemoveCurrentCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFCoaching_RemoveCurrentCoach {
    fn default() -> &'a CMsgTFCoaching_RemoveCurrentCoach {
        <CMsgTFCoaching_RemoveCurrentCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFCoaching_RemoveCurrentCoach {
    pub fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_coach = 1;

    pub fn account_id_coach(&self) -> u32 {
        self.account_id_coach.unwrap_or(0)
    }

    pub fn clear_account_id_coach(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
    }

    pub fn has_account_id_coach(&self) -> bool {
        self.account_id_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_coach(&mut self, v: u32) {
        self.account_id_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFCoaching_RemoveCurrentCoach {
    const NAME: &'static str = "CMsgTFCoaching_RemoveCurrentCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_coach = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_coach {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_coach {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFCoaching_RemoveCurrentCoach {
        CMsgTFCoaching_RemoveCurrentCoach::new()
    }

    fn clear(&mut self) {
        self.account_id_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFCoaching_RemoveCurrentCoach {
        static instance: CMsgTFCoaching_RemoveCurrentCoach = CMsgTFCoaching_RemoveCurrentCoach {
            account_id_coach: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_ScoreServers {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.servers)
    pub servers: ::std::vec::Vec<cmsg_tfquickplay_score_servers::ServerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServers {
    fn default() -> &'a CMsgTFQuickplay_ScoreServers {
        <CMsgTFQuickplay_ScoreServers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServers {
    pub fn new() -> CMsgTFQuickplay_ScoreServers {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFQuickplay_ScoreServers {
    const NAME: &'static str = "CMsgTFQuickplay_ScoreServers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.servers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_ScoreServers {
        CMsgTFQuickplay_ScoreServers::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServers {
        static instance: CMsgTFQuickplay_ScoreServers = CMsgTFQuickplay_ScoreServers {
            servers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTFQuickplay_ScoreServers`
pub mod cmsg_tfquickplay_score_servers {
    // @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServers.ServerInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ServerInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.server_address)
        pub server_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.server_port)
        pub server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.num_users)
        pub num_users: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.max_users)
        pub max_users: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServers.ServerInfo.user_score)
        pub user_score: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServers.ServerInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ServerInfo {
        fn default() -> &'a ServerInfo {
            <ServerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ServerInfo {
        pub fn new() -> ServerInfo {
            ::std::default::Default::default()
        }

        // optional uint32 server_address = 1;

        pub fn server_address(&self) -> u32 {
            self.server_address.unwrap_or(0)
        }

        pub fn clear_server_address(&mut self) {
            self.server_address = ::std::option::Option::None;
        }

        pub fn has_server_address(&self) -> bool {
            self.server_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_address(&mut self, v: u32) {
            self.server_address = ::std::option::Option::Some(v);
        }

        // optional uint32 server_port = 2;

        pub fn server_port(&self) -> u32 {
            self.server_port.unwrap_or(0)
        }

        pub fn clear_server_port(&mut self) {
            self.server_port = ::std::option::Option::None;
        }

        pub fn has_server_port(&self) -> bool {
            self.server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_port(&mut self, v: u32) {
            self.server_port = ::std::option::Option::Some(v);
        }

        // optional uint32 num_users = 3;

        pub fn num_users(&self) -> u32 {
            self.num_users.unwrap_or(0)
        }

        pub fn clear_num_users(&mut self) {
            self.num_users = ::std::option::Option::None;
        }

        pub fn has_num_users(&self) -> bool {
            self.num_users.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_users(&mut self, v: u32) {
            self.num_users = ::std::option::Option::Some(v);
        }

        // optional uint64 steam_id = 4;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 max_users = 5;

        pub fn max_users(&self) -> u32 {
            self.max_users.unwrap_or(0)
        }

        pub fn clear_max_users(&mut self) {
            self.max_users = ::std::option::Option::None;
        }

        pub fn has_max_users(&self) -> bool {
            self.max_users.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_users(&mut self, v: u32) {
            self.max_users = ::std::option::Option::Some(v);
        }

        // optional float user_score = 6;

        pub fn user_score(&self) -> f32 {
            self.user_score.unwrap_or(0.)
        }

        pub fn clear_user_score(&mut self) {
            self.user_score = ::std::option::Option::None;
        }

        pub fn has_user_score(&self) -> bool {
            self.user_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_user_score(&mut self, v: f32) {
            self.user_score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ServerInfo {
        const NAME: &'static str = "ServerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.num_users = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.max_users = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.user_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_address {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_port {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.num_users {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.steam_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.max_users {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.user_score {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.server_address {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.num_users {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.max_users {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.user_score {
                os.write_float(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ServerInfo {
            ServerInfo::new()
        }

        fn clear(&mut self) {
            self.server_address = ::std::option::Option::None;
            self.server_port = ::std::option::Option::None;
            self.num_users = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.max_users = ::std::option::Option::None;
            self.user_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ServerInfo {
            static instance: ServerInfo = ServerInfo {
                server_address: ::std::option::Option::None,
                server_port: ::std::option::Option::None,
                num_users: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                max_users: ::std::option::Option::None,
                user_score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_ScoreServersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.servers)
    pub servers: ::std::vec::Vec<cmsg_tfquickplay_score_servers_response::ServerInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_ScoreServersResponse {
    fn default() -> &'a CMsgTFQuickplay_ScoreServersResponse {
        <CMsgTFQuickplay_ScoreServersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_ScoreServersResponse {
    pub fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFQuickplay_ScoreServersResponse {
    const NAME: &'static str = "CMsgTFQuickplay_ScoreServersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.servers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.servers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.servers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_ScoreServersResponse {
        CMsgTFQuickplay_ScoreServersResponse::new()
    }

    fn clear(&mut self) {
        self.servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_ScoreServersResponse {
        static instance: CMsgTFQuickplay_ScoreServersResponse = CMsgTFQuickplay_ScoreServersResponse {
            servers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTFQuickplay_ScoreServersResponse`
pub mod cmsg_tfquickplay_score_servers_response {
    // @@protoc_insertion_point(message:CMsgTFQuickplay_ScoreServersResponse.ServerInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ServerInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.server_address)
        pub server_address: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.server_port)
        pub server_port: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.options_score)
        pub options_score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgTFQuickplay_ScoreServersResponse.ServerInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ServerInfo {
        fn default() -> &'a ServerInfo {
            <ServerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ServerInfo {
        pub fn new() -> ServerInfo {
            ::std::default::Default::default()
        }

        // optional uint32 server_address = 1;

        pub fn server_address(&self) -> u32 {
            self.server_address.unwrap_or(0)
        }

        pub fn clear_server_address(&mut self) {
            self.server_address = ::std::option::Option::None;
        }

        pub fn has_server_address(&self) -> bool {
            self.server_address.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_address(&mut self, v: u32) {
            self.server_address = ::std::option::Option::Some(v);
        }

        // optional uint32 server_port = 2;

        pub fn server_port(&self) -> u32 {
            self.server_port.unwrap_or(0)
        }

        pub fn clear_server_port(&mut self) {
            self.server_port = ::std::option::Option::None;
        }

        pub fn has_server_port(&self) -> bool {
            self.server_port.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_port(&mut self, v: u32) {
            self.server_port = ::std::option::Option::Some(v);
        }

        // optional float total_score = 3;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional uint64 steam_id = 4;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 options_score = 5;

        pub fn options_score(&self) -> u32 {
            self.options_score.unwrap_or(0)
        }

        pub fn clear_options_score(&mut self) {
            self.options_score = ::std::option::Option::None;
        }

        pub fn has_options_score(&self) -> bool {
            self.options_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_options_score(&mut self, v: u32) {
            self.options_score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ServerInfo {
        const NAME: &'static str = "ServerInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_address = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    32 => {
                        self.steam_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.options_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_address {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.server_port {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.steam_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.options_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.server_address {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.server_port {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.total_score {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.options_score {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ServerInfo {
            ServerInfo::new()
        }

        fn clear(&mut self) {
            self.server_address = ::std::option::Option::None;
            self.server_port = ::std::option::Option::None;
            self.total_score = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.options_score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ServerInfo {
            static instance: ServerInfo = ServerInfo {
                server_address: ::std::option::Option::None,
                server_port: ::std::option::Option::None,
                total_score: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                options_score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTFQuickplay_PlayerJoining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFQuickplay_PlayerJoining {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFQuickplay_PlayerJoining.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFQuickplay_PlayerJoining.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFQuickplay_PlayerJoining {
    fn default() -> &'a CMsgTFQuickplay_PlayerJoining {
        <CMsgTFQuickplay_PlayerJoining as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFQuickplay_PlayerJoining {
    pub fn new() -> CMsgTFQuickplay_PlayerJoining {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFQuickplay_PlayerJoining {
    const NAME: &'static str = "CMsgTFQuickplay_PlayerJoining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFQuickplay_PlayerJoining {
        CMsgTFQuickplay_PlayerJoining::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFQuickplay_PlayerJoining {
        static instance: CMsgTFQuickplay_PlayerJoining = CMsgTFQuickplay_PlayerJoining {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_LevelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_LevelInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_LevelInfo.level_loaded)
    pub level_loaded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_LevelInfo.level_name)
    pub level_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_LevelInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_LevelInfo {
    fn default() -> &'a CMsgGC_GameServer_LevelInfo {
        <CMsgGC_GameServer_LevelInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_LevelInfo {
    pub fn new() -> CMsgGC_GameServer_LevelInfo {
        ::std::default::Default::default()
    }

    // optional bool level_loaded = 1;

    pub fn level_loaded(&self) -> bool {
        self.level_loaded.unwrap_or(false)
    }

    pub fn clear_level_loaded(&mut self) {
        self.level_loaded = ::std::option::Option::None;
    }

    pub fn has_level_loaded(&self) -> bool {
        self.level_loaded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_loaded(&mut self, v: bool) {
        self.level_loaded = ::std::option::Option::Some(v);
    }

    // optional string level_name = 2;

    pub fn level_name(&self) -> &str {
        match self.level_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_level_name(&mut self) {
        self.level_name = ::std::option::Option::None;
    }

    pub fn has_level_name(&self) -> bool {
        self.level_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_name(&mut self, v: ::std::string::String) {
        self.level_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level_name(&mut self) -> &mut ::std::string::String {
        if self.level_name.is_none() {
            self.level_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.level_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_level_name(&mut self) -> ::std::string::String {
        self.level_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_LevelInfo {
    const NAME: &'static str = "CMsgGC_GameServer_LevelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level_loaded = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.level_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.level_loaded {
            my_size += 1 + 1;
        }
        if let Some(v) = self.level_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.level_loaded {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.level_name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_LevelInfo {
        CMsgGC_GameServer_LevelInfo::new()
    }

    fn clear(&mut self) {
        self.level_loaded = ::std::option::Option::None;
        self.level_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_LevelInfo {
        static instance: CMsgGC_GameServer_LevelInfo = CMsgGC_GameServer_LevelInfo {
            level_loaded: ::std::option::Option::None,
            level_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallenge.challenge_string)
    pub challenge_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallenge {
    fn default() -> &'a CMsgGC_GameServer_AuthChallenge {
        <CMsgGC_GameServer_AuthChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallenge {
    pub fn new() -> CMsgGC_GameServer_AuthChallenge {
        ::std::default::Default::default()
    }

    // optional string challenge_string = 1;

    pub fn challenge_string(&self) -> &str {
        match self.challenge_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_challenge_string(&mut self) {
        self.challenge_string = ::std::option::Option::None;
    }

    pub fn has_challenge_string(&self) -> bool {
        self.challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_string(&mut self, v: ::std::string::String) {
        self.challenge_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_challenge_string(&mut self) -> &mut ::std::string::String {
        if self.challenge_string.is_none() {
            self.challenge_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_challenge_string(&mut self) -> ::std::string::String {
        self.challenge_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_AuthChallenge {
    const NAME: &'static str = "CMsgGC_GameServer_AuthChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.challenge_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.challenge_string.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthChallenge {
        CMsgGC_GameServer_AuthChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallenge {
        static instance: CMsgGC_GameServer_AuthChallenge = CMsgGC_GameServer_AuthChallenge {
            challenge_string: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.authenticated)
    pub authenticated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.game_server_standing)
    pub game_server_standing: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.game_server_standing_trend)
    pub game_server_standing_trend: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.is_valve_server)
    pub is_valve_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthResult.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthResult {
    fn default() -> &'a CMsgGC_GameServer_AuthResult {
        <CMsgGC_GameServer_AuthResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthResult {
    pub fn new() -> CMsgGC_GameServer_AuthResult {
        ::std::default::Default::default()
    }

    // optional bool authenticated = 1;

    pub fn authenticated(&self) -> bool {
        self.authenticated.unwrap_or(false)
    }

    pub fn clear_authenticated(&mut self) {
        self.authenticated = ::std::option::Option::None;
    }

    pub fn has_authenticated(&self) -> bool {
        self.authenticated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticated(&mut self, v: bool) {
        self.authenticated = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing = 2;

    pub fn game_server_standing(&self) -> i32 {
        self.game_server_standing.unwrap_or(0)
    }

    pub fn clear_game_server_standing(&mut self) {
        self.game_server_standing = ::std::option::Option::None;
    }

    pub fn has_game_server_standing(&self) -> bool {
        self.game_server_standing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing(&mut self, v: i32) {
        self.game_server_standing = ::std::option::Option::Some(v);
    }

    // optional int32 game_server_standing_trend = 3;

    pub fn game_server_standing_trend(&self) -> i32 {
        self.game_server_standing_trend.unwrap_or(0)
    }

    pub fn clear_game_server_standing_trend(&mut self) {
        self.game_server_standing_trend = ::std::option::Option::None;
    }

    pub fn has_game_server_standing_trend(&self) -> bool {
        self.game_server_standing_trend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_standing_trend(&mut self, v: i32) {
        self.game_server_standing_trend = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 4;

    pub fn is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }

    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional string message = 5;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_AuthResult {
    const NAME: &'static str = "CMsgGC_GameServer_AuthResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.authenticated = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_standing = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.game_server_standing_trend = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.is_valve_server = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.authenticated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_standing {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.game_server_standing_trend {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.is_valve_server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.authenticated {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_standing {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.game_server_standing_trend {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthResult {
        CMsgGC_GameServer_AuthResult::new()
    }

    fn clear(&mut self) {
        self.authenticated = ::std::option::Option::None;
        self.game_server_standing = ::std::option::Option::None;
        self.game_server_standing_trend = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthResult {
        static instance: CMsgGC_GameServer_AuthResult = CMsgGC_GameServer_AuthResult {
            authenticated: ::std::option::Option::None,
            game_server_standing: ::std::option::Option::None,
            game_server_standing_trend: ::std::option::Option::None,
            is_valve_server: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AuthChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AuthChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallengeResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AuthChallengeResponse.hashed_challenge_string)
    pub hashed_challenge_string: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AuthChallengeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AuthChallengeResponse {
    fn default() -> &'a CMsgGC_GameServer_AuthChallengeResponse {
        <CMsgGC_GameServer_AuthChallengeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AuthChallengeResponse {
    pub fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional bytes hashed_challenge_string = 2;

    pub fn hashed_challenge_string(&self) -> &[u8] {
        match self.hashed_challenge_string.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_hashed_challenge_string(&mut self) {
        self.hashed_challenge_string = ::std::option::Option::None;
    }

    pub fn has_hashed_challenge_string(&self) -> bool {
        self.hashed_challenge_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hashed_challenge_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.hashed_challenge_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hashed_challenge_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.hashed_challenge_string.is_none() {
            self.hashed_challenge_string = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.hashed_challenge_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_hashed_challenge_string(&mut self) -> ::std::vec::Vec<u8> {
        self.hashed_challenge_string.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_AuthChallengeResponse {
    const NAME: &'static str = "CMsgGC_GameServer_AuthChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.hashed_challenge_string = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hashed_challenge_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hashed_challenge_string.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AuthChallengeResponse {
        CMsgGC_GameServer_AuthChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.hashed_challenge_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AuthChallengeResponse {
        static instance: CMsgGC_GameServer_AuthChallengeResponse = CMsgGC_GameServer_AuthChallengeResponse {
            game_server_account_id: ::std::option::Option::None,
            hashed_challenge_string: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_CreateIdentity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_CreateIdentity {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentity.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_CreateIdentity.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentity {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentity {
        <CMsgGC_GameServer_CreateIdentity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentity {
    pub fn new() -> CMsgGC_GameServer_CreateIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_CreateIdentity {
    const NAME: &'static str = "CMsgGC_GameServer_CreateIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_CreateIdentity {
        CMsgGC_GameServer_CreateIdentity::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentity {
        static instance: CMsgGC_GameServer_CreateIdentity = CMsgGC_GameServer_CreateIdentity {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_CreateIdentityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_CreateIdentityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.account_created)
    pub account_created: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.game_server_identity_token)
    pub game_server_identity_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_CreateIdentityResponse.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gc_game_server_create_identity_response::EStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_CreateIdentityResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_CreateIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_CreateIdentityResponse {
        <CMsgGC_GameServer_CreateIdentityResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_CreateIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool account_created = 1;

    pub fn account_created(&self) -> bool {
        self.account_created.unwrap_or(false)
    }

    pub fn clear_account_created(&mut self) {
        self.account_created = ::std::option::Option::None;
    }

    pub fn has_account_created(&self) -> bool {
        self.account_created.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_created(&mut self, v: bool) {
        self.account_created = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;

    pub fn game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgGC_GameServer_CreateIdentityResponse.EStatus status = 4;

    pub fn status(&self) -> cmsg_gc_game_server_create_identity_response::EStatus {
        match self.status {
            Some(e) => e.enum_value_or(cmsg_gc_game_server_create_identity_response::EStatus::kStatus_GenericFailure),
            None => cmsg_gc_game_server_create_identity_response::EStatus::kStatus_GenericFailure,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: cmsg_gc_game_server_create_identity_response::EStatus) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_CreateIdentityResponse {
    const NAME: &'static str = "CMsgGC_GameServer_CreateIdentityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_created = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_created {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_created {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_CreateIdentityResponse {
        CMsgGC_GameServer_CreateIdentityResponse::new()
    }

    fn clear(&mut self) {
        self.account_created = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_CreateIdentityResponse {
        static instance: CMsgGC_GameServer_CreateIdentityResponse = CMsgGC_GameServer_CreateIdentityResponse {
            account_created: ::std::option::Option::None,
            game_server_account_id: ::std::option::Option::None,
            game_server_identity_token: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_GameServer_CreateIdentityResponse`
pub mod cmsg_gc_game_server_create_identity_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_GameServer_CreateIdentityResponse.EStatus)
    pub enum EStatus {
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_GenericFailure)
        kStatus_GenericFailure = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_TooMany)
        kStatus_TooMany = -1,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_NoPrivs)
        kStatus_NoPrivs = -2,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_CreateIdentityResponse.EStatus.kStatus_Created)
        kStatus_Created = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EStatus {
        const NAME: &'static str = "EStatus";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EStatus> {
            match value {
                0 => ::std::option::Option::Some(EStatus::kStatus_GenericFailure),
                -1 => ::std::option::Option::Some(EStatus::kStatus_TooMany),
                -2 => ::std::option::Option::Some(EStatus::kStatus_NoPrivs),
                1 => ::std::option::Option::Some(EStatus::kStatus_Created),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EStatus> {
            match str {
                "kStatus_GenericFailure" => ::std::option::Option::Some(EStatus::kStatus_GenericFailure),
                "kStatus_TooMany" => ::std::option::Option::Some(EStatus::kStatus_TooMany),
                "kStatus_NoPrivs" => ::std::option::Option::Some(EStatus::kStatus_NoPrivs),
                "kStatus_Created" => ::std::option::Option::Some(EStatus::kStatus_Created),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EStatus] = &[
            EStatus::kStatus_GenericFailure,
            EStatus::kStatus_TooMany,
            EStatus::kStatus_NoPrivs,
            EStatus::kStatus_Created,
        ];
    }

    impl ::std::default::Default for EStatus {
        fn default() -> Self {
            EStatus::kStatus_GenericFailure
        }
    }

}

// @@protoc_insertion_point(message:CMsgGC_GameServer_List)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_List {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_List.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_List.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_List {
    fn default() -> &'a CMsgGC_GameServer_List {
        <CMsgGC_GameServer_List as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_List {
    pub fn new() -> CMsgGC_GameServer_List {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_List {
    const NAME: &'static str = "CMsgGC_GameServer_List";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_List {
        CMsgGC_GameServer_List::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_List {
        static instance: CMsgGC_GameServer_List = CMsgGC_GameServer_List {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.owned_game_servers)
    pub owned_game_servers: ::std::vec::Vec<cmsg_gc_game_server_list_response::GameServerIdentity>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ListResponse {
    fn default() -> &'a CMsgGC_GameServer_ListResponse {
        <CMsgGC_GameServer_ListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ListResponse {
    pub fn new() -> CMsgGC_GameServer_ListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_ListResponse {
    const NAME: &'static str = "CMsgGC_GameServer_ListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.owned_game_servers.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.owned_game_servers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.owned_game_servers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ListResponse {
        CMsgGC_GameServer_ListResponse::new()
    }

    fn clear(&mut self) {
        self.owned_game_servers.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ListResponse {
        static instance: CMsgGC_GameServer_ListResponse = CMsgGC_GameServer_ListResponse {
            owned_game_servers: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_GameServer_ListResponse`
pub mod cmsg_gc_game_server_list_response {
    // @@protoc_insertion_point(message:CMsgGC_GameServer_ListResponse.GameServerIdentity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GameServerIdentity {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_account_id)
        pub game_server_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_identity_token)
        pub game_server_identity_token: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_standing)
        pub game_server_standing: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGC_GameServer_ListResponse.GameServerIdentity.game_server_standing_trend)
        pub game_server_standing_trend: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ListResponse.GameServerIdentity.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GameServerIdentity {
        fn default() -> &'a GameServerIdentity {
            <GameServerIdentity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GameServerIdentity {
        pub fn new() -> GameServerIdentity {
            ::std::default::Default::default()
        }

        // optional uint32 game_server_account_id = 1;

        pub fn game_server_account_id(&self) -> u32 {
            self.game_server_account_id.unwrap_or(0)
        }

        pub fn clear_game_server_account_id(&mut self) {
            self.game_server_account_id = ::std::option::Option::None;
        }

        pub fn has_game_server_account_id(&self) -> bool {
            self.game_server_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_account_id(&mut self, v: u32) {
            self.game_server_account_id = ::std::option::Option::Some(v);
        }

        // optional string game_server_identity_token = 2;

        pub fn game_server_identity_token(&self) -> &str {
            match self.game_server_identity_token.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_server_identity_token(&mut self) {
            self.game_server_identity_token = ::std::option::Option::None;
        }

        pub fn has_game_server_identity_token(&self) -> bool {
            self.game_server_identity_token.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
            self.game_server_identity_token = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
            if self.game_server_identity_token.is_none() {
                self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_server_identity_token.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
            self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 game_server_standing = 3;

        pub fn game_server_standing(&self) -> i32 {
            self.game_server_standing.unwrap_or(0)
        }

        pub fn clear_game_server_standing(&mut self) {
            self.game_server_standing = ::std::option::Option::None;
        }

        pub fn has_game_server_standing(&self) -> bool {
            self.game_server_standing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_standing(&mut self, v: i32) {
            self.game_server_standing = ::std::option::Option::Some(v);
        }

        // optional int32 game_server_standing_trend = 4;

        pub fn game_server_standing_trend(&self) -> i32 {
            self.game_server_standing_trend.unwrap_or(0)
        }

        pub fn clear_game_server_standing_trend(&mut self) {
            self.game_server_standing_trend = ::std::option::Option::None;
        }

        pub fn has_game_server_standing_trend(&self) -> bool {
            self.game_server_standing_trend.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_server_standing_trend(&mut self, v: i32) {
            self.game_server_standing_trend = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GameServerIdentity {
        const NAME: &'static str = "GameServerIdentity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.game_server_standing = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.game_server_standing_trend = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_server_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.game_server_identity_token.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.game_server_standing {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.game_server_standing_trend {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_server_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.game_server_identity_token.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.game_server_standing {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.game_server_standing_trend {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GameServerIdentity {
            GameServerIdentity::new()
        }

        fn clear(&mut self) {
            self.game_server_account_id = ::std::option::Option::None;
            self.game_server_identity_token = ::std::option::Option::None;
            self.game_server_standing = ::std::option::Option::None;
            self.game_server_standing_trend = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GameServerIdentity {
            static instance: GameServerIdentity = GameServerIdentity {
                game_server_account_id: ::std::option::Option::None,
                game_server_identity_token: ::std::option::Option::None,
                game_server_standing: ::std::option::Option::None,
                game_server_standing_trend: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ResetIdentity)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ResetIdentity {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentity.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ResetIdentity.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentity {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentity {
        <CMsgGC_GameServer_ResetIdentity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentity {
    pub fn new() -> CMsgGC_GameServer_ResetIdentity {
        ::std::default::Default::default()
    }

    // optional uint32 game_server_account_id = 1;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_ResetIdentity {
    const NAME: &'static str = "CMsgGC_GameServer_ResetIdentity";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ResetIdentity {
        CMsgGC_GameServer_ResetIdentity::new()
    }

    fn clear(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentity {
        static instance: CMsgGC_GameServer_ResetIdentity = CMsgGC_GameServer_ResetIdentity {
            game_server_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ResetIdentityResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ResetIdentityResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_identity_token_reset)
    pub game_server_identity_token_reset: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_account_id)
    pub game_server_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ResetIdentityResponse.game_server_identity_token)
    pub game_server_identity_token: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ResetIdentityResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ResetIdentityResponse {
    fn default() -> &'a CMsgGC_GameServer_ResetIdentityResponse {
        <CMsgGC_GameServer_ResetIdentityResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ResetIdentityResponse {
    pub fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        ::std::default::Default::default()
    }

    // optional bool game_server_identity_token_reset = 1;

    pub fn game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.unwrap_or(false)
    }

    pub fn clear_game_server_identity_token_reset(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token_reset(&self) -> bool {
        self.game_server_identity_token_reset.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token_reset(&mut self, v: bool) {
        self.game_server_identity_token_reset = ::std::option::Option::Some(v);
    }

    // optional uint32 game_server_account_id = 2;

    pub fn game_server_account_id(&self) -> u32 {
        self.game_server_account_id.unwrap_or(0)
    }

    pub fn clear_game_server_account_id(&mut self) {
        self.game_server_account_id = ::std::option::Option::None;
    }

    pub fn has_game_server_account_id(&self) -> bool {
        self.game_server_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_account_id(&mut self, v: u32) {
        self.game_server_account_id = ::std::option::Option::Some(v);
    }

    // optional string game_server_identity_token = 3;

    pub fn game_server_identity_token(&self) -> &str {
        match self.game_server_identity_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_server_identity_token(&mut self) {
        self.game_server_identity_token = ::std::option::Option::None;
    }

    pub fn has_game_server_identity_token(&self) -> bool {
        self.game_server_identity_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_identity_token(&mut self, v: ::std::string::String) {
        self.game_server_identity_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_server_identity_token(&mut self) -> &mut ::std::string::String {
        if self.game_server_identity_token.is_none() {
            self.game_server_identity_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_server_identity_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_server_identity_token(&mut self) -> ::std::string::String {
        self.game_server_identity_token.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_ResetIdentityResponse {
    const NAME: &'static str = "CMsgGC_GameServer_ResetIdentityResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_server_identity_token_reset = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.game_server_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.game_server_identity_token = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_server_identity_token_reset {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_server_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_server_identity_token_reset {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.game_server_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.game_server_identity_token.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ResetIdentityResponse {
        CMsgGC_GameServer_ResetIdentityResponse::new()
    }

    fn clear(&mut self) {
        self.game_server_identity_token_reset = ::std::option::Option::None;
        self.game_server_account_id = ::std::option::Option::None;
        self.game_server_identity_token = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ResetIdentityResponse {
        static instance: CMsgGC_GameServer_ResetIdentityResponse = CMsgGC_GameServer_ResetIdentityResponse {
            game_server_identity_token_reset: ::std::option::Option::None,
            game_server_account_id: ::std::option::Option::None,
            game_server_identity_token: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AckPolicy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AckPolicy {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AckPolicy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicy {
    fn default() -> &'a CMsgGC_GameServer_AckPolicy {
        <CMsgGC_GameServer_AckPolicy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicy {
    pub fn new() -> CMsgGC_GameServer_AckPolicy {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_AckPolicy {
    const NAME: &'static str = "CMsgGC_GameServer_AckPolicy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AckPolicy {
        CMsgGC_GameServer_AckPolicy::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicy {
        static instance: CMsgGC_GameServer_AckPolicy = CMsgGC_GameServer_AckPolicy {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_AckPolicyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_AckPolicyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AckPolicyResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_AckPolicyResponse.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_AckPolicyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_AckPolicyResponse {
    fn default() -> &'a CMsgGC_GameServer_AckPolicyResponse {
        <CMsgGC_GameServer_AckPolicyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_AckPolicyResponse {
    pub fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_AckPolicyResponse {
    const NAME: &'static str = "CMsgGC_GameServer_AckPolicyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_AckPolicyResponse {
        CMsgGC_GameServer_AckPolicyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_AckPolicyResponse {
        static instance: CMsgGC_GameServer_AckPolicyResponse = CMsgGC_GameServer_AckPolicyResponse {
            result: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Client_UseServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client_UseServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client_UseServerModificationItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client_UseServerModificationItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem {
        <CMsgGC_Client_UseServerModificationItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Client_UseServerModificationItem {
    const NAME: &'static str = "CMsgGC_Client_UseServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem {
        CMsgGC_Client_UseServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem {
        static instance: CMsgGC_Client_UseServerModificationItem = CMsgGC_Client_UseServerModificationItem {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Client_UseServerModificationItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client_UseServerModificationItem_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client_UseServerModificationItem_Response.response_code)
    pub response_code: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client_UseServerModificationItem_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_Client_UseServerModificationItem_Response {
        <CMsgGC_Client_UseServerModificationItem_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse response_code = 1;

    pub fn response_code(&self) -> cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse {
        match self.response_code {
            Some(e) => e.enum_value_or(cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
            None => cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse,
        }
    }

    pub fn clear_response_code(&mut self) {
        self.response_code = ::std::option::Option::None;
    }

    pub fn has_response_code(&self) -> bool {
        self.response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response_code(&mut self, v: cmsg_gc_client_use_server_modification_item_response::EServerModificationItemResponse) {
        self.response_code = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Client_UseServerModificationItem_Response {
    const NAME: &'static str = "CMsgGC_Client_UseServerModificationItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response_code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response_code {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client_UseServerModificationItem_Response {
        CMsgGC_Client_UseServerModificationItem_Response::new()
    }

    fn clear(&mut self) {
        self.response_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client_UseServerModificationItem_Response {
        static instance: CMsgGC_Client_UseServerModificationItem_Response = CMsgGC_Client_UseServerModificationItem_Response {
            response_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_Client_UseServerModificationItem_Response`
pub mod cmsg_gc_client_use_server_modification_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse)
    pub enum EServerModificationItemResponse {
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_AlreadyInUse)
        kServerModificationItemResponse_AlreadyInUse = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_NotOnAuthenticatedServer)
        kServerModificationItemResponse_NotOnAuthenticatedServer = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_ServerReject)
        kServerModificationItemResponse_ServerReject = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_InternalError)
        kServerModificationItemResponse_InternalError = 4,
        // @@protoc_insertion_point(enum_value:CMsgGC_Client_UseServerModificationItem_Response.EServerModificationItemResponse.kServerModificationItemResponse_EventAlreadyActive)
        kServerModificationItemResponse_EventAlreadyActive = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EServerModificationItemResponse {
        const NAME: &'static str = "EServerModificationItemResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemResponse> {
            match value {
                1 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
                2 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer),
                3 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_ServerReject),
                4 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_InternalError),
                5 => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemResponse> {
            match str {
                "kServerModificationItemResponse_AlreadyInUse" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse),
                "kServerModificationItemResponse_NotOnAuthenticatedServer" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer),
                "kServerModificationItemResponse_ServerReject" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_ServerReject),
                "kServerModificationItemResponse_InternalError" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_InternalError),
                "kServerModificationItemResponse_EventAlreadyActive" => ::std::option::Option::Some(EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EServerModificationItemResponse] = &[
            EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse,
            EServerModificationItemResponse::kServerModificationItemResponse_NotOnAuthenticatedServer,
            EServerModificationItemResponse::kServerModificationItemResponse_ServerReject,
            EServerModificationItemResponse::kServerModificationItemResponse_InternalError,
            EServerModificationItemResponse::kServerModificationItemResponse_EventAlreadyActive,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EServerModificationItemResponse {
        fn default() -> Self {
            EServerModificationItemResponse::kServerModificationItemResponse_AlreadyInUse
        }
    }

}

// @@protoc_insertion_point(message:CMsgGC_GameServer_UseServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_UseServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem.modification_type)
    pub modification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_UseServerModificationItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem {
        <CMsgGC_GameServer_UseServerModificationItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem {
    const NAME: &'static str = "CMsgGC_GameServer_UseServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem {
        CMsgGC_GameServer_UseServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem {
        static instance: CMsgGC_GameServer_UseServerModificationItem = CMsgGC_GameServer_UseServerModificationItem {
            modification_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_UseServerModificationItem_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_UseServerModificationItem_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem_Response.modification_type)
    pub modification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_UseServerModificationItem_Response.server_response_code)
    pub server_response_code: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_UseServerModificationItem_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_UseServerModificationItem_Response {
    fn default() -> &'a CMsgGC_GameServer_UseServerModificationItem_Response {
        <CMsgGC_GameServer_UseServerModificationItem_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_UseServerModificationItem_Response {
    pub fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse server_response_code = 2;

    pub fn server_response_code(&self) -> cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse {
        match self.server_response_code {
            Some(e) => e.enum_value_or(cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
            None => cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted,
        }
    }

    pub fn clear_server_response_code(&mut self) {
        self.server_response_code = ::std::option::Option::None;
    }

    pub fn has_server_response_code(&self) -> bool {
        self.server_response_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_response_code(&mut self, v: cmsg_gc_game_server_use_server_modification_item_response::EServerModificationItemServerResponse) {
        self.server_response_code = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_UseServerModificationItem_Response {
    const NAME: &'static str = "CMsgGC_GameServer_UseServerModificationItem_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.server_response_code = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.server_response_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.server_response_code {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_UseServerModificationItem_Response {
        CMsgGC_GameServer_UseServerModificationItem_Response::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.server_response_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_UseServerModificationItem_Response {
        static instance: CMsgGC_GameServer_UseServerModificationItem_Response = CMsgGC_GameServer_UseServerModificationItem_Response {
            modification_type: ::std::option::Option::None,
            server_response_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_GameServer_UseServerModificationItem_Response`
pub mod cmsg_gc_game_server_use_server_modification_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse)
    pub enum EServerModificationItemServerResponse {
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_Accepted)
        kServerModificationItemServerResponse_Accepted = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_NoVoteCalled)
        kServerModificationItemServerResponse_NoVoteCalled = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_GameServer_UseServerModificationItem_Response.EServerModificationItemServerResponse.kServerModificationItemServerResponse_VoteFailed)
        kServerModificationItemServerResponse_VoteFailed = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EServerModificationItemServerResponse {
        const NAME: &'static str = "EServerModificationItemServerResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemServerResponse> {
            match value {
                1 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
                2 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled),
                3 => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemServerResponse> {
            match str {
                "kServerModificationItemServerResponse_Accepted" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted),
                "kServerModificationItemServerResponse_NoVoteCalled" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled),
                "kServerModificationItemServerResponse_VoteFailed" => ::std::option::Option::Some(EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EServerModificationItemServerResponse] = &[
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted,
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_NoVoteCalled,
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_VoteFailed,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for EServerModificationItemServerResponse {
        fn default() -> Self {
            EServerModificationItemServerResponse::kServerModificationItemServerResponse_Accepted
        }
    }

}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ServerModificationItemExpired)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ServerModificationItemExpired {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItemExpired.modification_type)
    pub modification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ServerModificationItemExpired.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItemExpired {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItemExpired {
        <CMsgGC_GameServer_ServerModificationItemExpired as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItemExpired {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_ServerModificationItemExpired {
    const NAME: &'static str = "CMsgGC_GameServer_ServerModificationItemExpired";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItemExpired {
        CMsgGC_GameServer_ServerModificationItemExpired::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItemExpired {
        static instance: CMsgGC_GameServer_ServerModificationItemExpired = CMsgGC_GameServer_ServerModificationItemExpired {
            modification_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_GameServer_ServerModificationItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_GameServer_ServerModificationItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItem.modification_type)
    pub modification_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EServerModificationItemType>>,
    // @@protoc_insertion_point(field:CMsgGC_GameServer_ServerModificationItem.active)
    pub active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_GameServer_ServerModificationItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_GameServer_ServerModificationItem {
    fn default() -> &'a CMsgGC_GameServer_ServerModificationItem {
        <CMsgGC_GameServer_ServerModificationItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_GameServer_ServerModificationItem {
    pub fn new() -> CMsgGC_GameServer_ServerModificationItem {
        ::std::default::Default::default()
    }

    // optional .EServerModificationItemType modification_type = 1;

    pub fn modification_type(&self) -> EServerModificationItemType {
        match self.modification_type {
            Some(e) => e.enum_value_or(EServerModificationItemType::kGameServerModificationItem_Halloween),
            None => EServerModificationItemType::kGameServerModificationItem_Halloween,
        }
    }

    pub fn clear_modification_type(&mut self) {
        self.modification_type = ::std::option::Option::None;
    }

    pub fn has_modification_type(&self) -> bool {
        self.modification_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modification_type(&mut self, v: EServerModificationItemType) {
        self.modification_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool active = 2;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_GameServer_ServerModificationItem {
    const NAME: &'static str = "CMsgGC_GameServer_ServerModificationItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.modification_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.modification_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.modification_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_GameServer_ServerModificationItem {
        CMsgGC_GameServer_ServerModificationItem::new()
    }

    fn clear(&mut self) {
        self.modification_type = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_GameServer_ServerModificationItem {
        static instance: CMsgGC_GameServer_ServerModificationItem = CMsgGC_GameServer_ServerModificationItem {
            modification_type: ::std::option::Option::None,
            active: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_ReservedItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_ReservedItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.x)
    pub x: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.y)
    pub y: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.z)
    pub z: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_ReservedItem.spawn_meta_info)
    pub spawn_meta_info: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_ReservedItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ReservedItem {
    fn default() -> &'a CMsgGC_Halloween_ReservedItem {
        <CMsgGC_Halloween_ReservedItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ReservedItem {
    pub fn new() -> CMsgGC_Halloween_ReservedItem {
        ::std::default::Default::default()
    }

    // optional uint32 spawn_meta_info = 7;

    pub fn spawn_meta_info(&self) -> u32 {
        self.spawn_meta_info.unwrap_or(0)
    }

    pub fn clear_spawn_meta_info(&mut self) {
        self.spawn_meta_info = ::std::option::Option::None;
    }

    pub fn has_spawn_meta_info(&self) -> bool {
        self.spawn_meta_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawn_meta_info(&mut self, v: u32) {
        self.spawn_meta_info = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Halloween_ReservedItem {
    const NAME: &'static str = "CMsgGC_Halloween_ReservedItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.x)?;
                },
                13 => {
                    self.x.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.y)?;
                },
                21 => {
                    self.y.push(is.read_float()?);
                },
                26 => {
                    is.read_repeated_packed_float_into(&mut self.z)?;
                },
                29 => {
                    self.z.push(is.read_float()?);
                },
                56 => {
                    self.spawn_meta_info = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.x.len() as u64;
        my_size += 5 * self.y.len() as u64;
        my_size += 5 * self.z.len() as u64;
        if let Some(v) = self.spawn_meta_info {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.x {
            os.write_float(1, *v)?;
        };
        for v in &self.y {
            os.write_float(2, *v)?;
        };
        for v in &self.z {
            os.write_float(3, *v)?;
        };
        if let Some(v) = self.spawn_meta_info {
            os.write_uint32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_ReservedItem {
        CMsgGC_Halloween_ReservedItem::new()
    }

    fn clear(&mut self) {
        self.x.clear();
        self.y.clear();
        self.z.clear();
        self.spawn_meta_info = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ReservedItem {
        static instance: CMsgGC_Halloween_ReservedItem = CMsgGC_Halloween_ReservedItem {
            x: ::std::vec::Vec::new(),
            y: ::std::vec::Vec::new(),
            z: ::std::vec::Vec::new(),
            spawn_meta_info: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_GrantItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_GrantItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.recipient_account_id)
    pub recipient_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.level_id)
    pub level_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItem.flagged)
    pub flagged: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_GrantItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItem {
    fn default() -> &'a CMsgGC_Halloween_GrantItem {
        <CMsgGC_Halloween_GrantItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItem {
    pub fn new() -> CMsgGC_Halloween_GrantItem {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;

    pub fn recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 2;

    pub fn level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }

    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }

    // optional bool flagged = 3;

    pub fn flagged(&self) -> bool {
        self.flagged.unwrap_or(false)
    }

    pub fn clear_flagged(&mut self) {
        self.flagged = ::std::option::Option::None;
    }

    pub fn has_flagged(&self) -> bool {
        self.flagged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flagged(&mut self, v: bool) {
        self.flagged = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Halloween_GrantItem {
    const NAME: &'static str = "CMsgGC_Halloween_GrantItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.level_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.flagged = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.level_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.flagged {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.flagged {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_GrantItem {
        CMsgGC_Halloween_GrantItem::new()
    }

    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.flagged = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItem {
        static instance: CMsgGC_Halloween_GrantItem = CMsgGC_Halloween_GrantItem {
            recipient_account_id: ::std::option::Option::None,
            level_id: ::std::option::Option::None,
            flagged: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_GrantItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_GrantItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Halloween_GrantItemResponse.recipient_account_id)
    pub recipient_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_GrantItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_GrantItemResponse {
    fn default() -> &'a CMsgGC_Halloween_GrantItemResponse {
        <CMsgGC_Halloween_GrantItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_GrantItemResponse {
    pub fn new() -> CMsgGC_Halloween_GrantItemResponse {
        ::std::default::Default::default()
    }

    // optional uint32 recipient_account_id = 1;

    pub fn recipient_account_id(&self) -> u32 {
        self.recipient_account_id.unwrap_or(0)
    }

    pub fn clear_recipient_account_id(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
    }

    pub fn has_recipient_account_id(&self) -> bool {
        self.recipient_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_recipient_account_id(&mut self, v: u32) {
        self.recipient_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Halloween_GrantItemResponse {
    const NAME: &'static str = "CMsgGC_Halloween_GrantItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.recipient_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.recipient_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.recipient_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_GrantItemResponse {
        CMsgGC_Halloween_GrantItemResponse::new()
    }

    fn clear(&mut self) {
        self.recipient_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_GrantItemResponse {
        static instance: CMsgGC_Halloween_GrantItemResponse = CMsgGC_Halloween_GrantItemResponse {
            recipient_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Halloween_ItemClaimed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Halloween_ItemClaimed {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Halloween_ItemClaimed.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Halloween_ItemClaimed {
    fn default() -> &'a CMsgGC_Halloween_ItemClaimed {
        <CMsgGC_Halloween_ItemClaimed as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Halloween_ItemClaimed {
    pub fn new() -> CMsgGC_Halloween_ItemClaimed {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Halloween_ItemClaimed {
    const NAME: &'static str = "CMsgGC_Halloween_ItemClaimed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Halloween_ItemClaimed {
        CMsgGC_Halloween_ItemClaimed::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Halloween_ItemClaimed {
        static instance: CMsgGC_Halloween_ItemClaimed = CMsgGC_Halloween_ItemClaimed {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_PickupItemEligibility_Query)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_PickupItemEligibility_Query {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_Query.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_Query.seconds_ago)
    pub seconds_ago: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_PickupItemEligibility_Query.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_Query {
    fn default() -> &'a CMsgGC_PickupItemEligibility_Query {
        <CMsgGC_PickupItemEligibility_Query as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_Query {
    pub fn new() -> CMsgGC_PickupItemEligibility_Query {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_ago = 2;

    pub fn seconds_ago(&self) -> u32 {
        self.seconds_ago.unwrap_or(0)
    }

    pub fn clear_seconds_ago(&mut self) {
        self.seconds_ago = ::std::option::Option::None;
    }

    pub fn has_seconds_ago(&self) -> bool {
        self.seconds_ago.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_ago(&mut self, v: u32) {
        self.seconds_ago = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_PickupItemEligibility_Query {
    const NAME: &'static str = "CMsgGC_PickupItemEligibility_Query";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.seconds_ago = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.seconds_ago {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.seconds_ago {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_PickupItemEligibility_Query {
        CMsgGC_PickupItemEligibility_Query::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.seconds_ago = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_Query {
        static instance: CMsgGC_PickupItemEligibility_Query = CMsgGC_PickupItemEligibility_Query {
            account_id: ::std::option::Option::None,
            seconds_ago: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_PickupItemEligibility_QueryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_PickupItemEligibility_QueryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.was_eligible)
    pub was_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_PickupItemEligibility_QueryResponse.level_id)
    pub level_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_PickupItemEligibility_QueryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_PickupItemEligibility_QueryResponse {
    fn default() -> &'a CMsgGC_PickupItemEligibility_QueryResponse {
        <CMsgGC_PickupItemEligibility_QueryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_PickupItemEligibility_QueryResponse {
    pub fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool was_eligible = 2;

    pub fn was_eligible(&self) -> bool {
        self.was_eligible.unwrap_or(false)
    }

    pub fn clear_was_eligible(&mut self) {
        self.was_eligible = ::std::option::Option::None;
    }

    pub fn has_was_eligible(&self) -> bool {
        self.was_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_eligible(&mut self, v: bool) {
        self.was_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 level_id = 3;

    pub fn level_id(&self) -> u32 {
        self.level_id.unwrap_or(0)
    }

    pub fn clear_level_id(&mut self) {
        self.level_id = ::std::option::Option::None;
    }

    pub fn has_level_id(&self) -> bool {
        self.level_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level_id(&mut self, v: u32) {
        self.level_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_PickupItemEligibility_QueryResponse {
    const NAME: &'static str = "CMsgGC_PickupItemEligibility_QueryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.was_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.level_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.was_eligible {
            my_size += 1 + 1;
        }
        if let Some(v) = self.level_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.was_eligible {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.level_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_PickupItemEligibility_QueryResponse {
        CMsgGC_PickupItemEligibility_QueryResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.was_eligible = ::std::option::Option::None;
        self.level_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_PickupItemEligibility_QueryResponse {
        static instance: CMsgGC_PickupItemEligibility_QueryResponse = CMsgGC_PickupItemEligibility_QueryResponse {
            account_id: ::std::option::Option::None,
            was_eligible: ::std::option::Option::None,
            level_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFPartyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPartyMember {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPartyMember.owns_ticket)
    pub owns_ticket: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.completed_missions)
    pub completed_missions: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.competitive_access)
    pub competitive_access: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.experience)
    pub experience: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.player_criteria)
    pub player_criteria: ::steam_vent_proto_common::protobuf::MessageField<CTFPerPlayerMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.activity)
    pub activity: ::steam_vent_proto_common::protobuf::MessageField<csotfparty_member::Activity>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.casual_banned)
    pub casual_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.ranked_banned)
    pub ranked_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.casual_low_priority)
    pub casual_low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.ranked_low_priority)
    pub ranked_low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFPartyMember.lobby_standby)
    pub lobby_standby: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPartyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyMember {
    fn default() -> &'a CSOTFPartyMember {
        <CSOTFPartyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyMember {
    pub fn new() -> CSOTFPartyMember {
        ::std::default::Default::default()
    }

    // optional bool owns_ticket = 2;

    pub fn owns_ticket(&self) -> bool {
        self.owns_ticket.unwrap_or(false)
    }

    pub fn clear_owns_ticket(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
    }

    pub fn has_owns_ticket(&self) -> bool {
        self.owns_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owns_ticket(&mut self, v: bool) {
        self.owns_ticket = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_missions = 3;

    pub fn completed_missions(&self) -> u32 {
        self.completed_missions.unwrap_or(0)
    }

    pub fn clear_completed_missions(&mut self) {
        self.completed_missions = ::std::option::Option::None;
    }

    pub fn has_completed_missions(&self) -> bool {
        self.completed_missions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_missions(&mut self, v: u32) {
        self.completed_missions = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 4;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional bool competitive_access = 9;

    pub fn competitive_access(&self) -> bool {
        self.competitive_access.unwrap_or(false)
    }

    pub fn clear_competitive_access(&mut self) {
        self.competitive_access = ::std::option::Option::None;
    }

    pub fn has_competitive_access(&self) -> bool {
        self.competitive_access.is_some()
    }

    // Param is passed by value, moved
    pub fn set_competitive_access(&mut self, v: bool) {
        self.competitive_access = ::std::option::Option::Some(v);
    }

    // optional uint32 experience = 14;

    pub fn experience(&self) -> u32 {
        self.experience.unwrap_or(0)
    }

    pub fn clear_experience(&mut self) {
        self.experience = ::std::option::Option::None;
    }

    pub fn has_experience(&self) -> bool {
        self.experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_experience(&mut self, v: u32) {
        self.experience = ::std::option::Option::Some(v);
    }

    // optional bool casual_banned = 18;

    pub fn casual_banned(&self) -> bool {
        self.casual_banned.unwrap_or(false)
    }

    pub fn clear_casual_banned(&mut self) {
        self.casual_banned = ::std::option::Option::None;
    }

    pub fn has_casual_banned(&self) -> bool {
        self.casual_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned(&mut self, v: bool) {
        self.casual_banned = ::std::option::Option::Some(v);
    }

    // optional bool ranked_banned = 19;

    pub fn ranked_banned(&self) -> bool {
        self.ranked_banned.unwrap_or(false)
    }

    pub fn clear_ranked_banned(&mut self) {
        self.ranked_banned = ::std::option::Option::None;
    }

    pub fn has_ranked_banned(&self) -> bool {
        self.ranked_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned(&mut self, v: bool) {
        self.ranked_banned = ::std::option::Option::Some(v);
    }

    // optional bool casual_low_priority = 20;

    pub fn casual_low_priority(&self) -> bool {
        self.casual_low_priority.unwrap_or(false)
    }

    pub fn clear_casual_low_priority(&mut self) {
        self.casual_low_priority = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority(&self) -> bool {
        self.casual_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority(&mut self, v: bool) {
        self.casual_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool ranked_low_priority = 21;

    pub fn ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.unwrap_or(false)
    }

    pub fn clear_ranked_low_priority(&mut self) {
        self.ranked_low_priority = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority(&self) -> bool {
        self.ranked_low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority(&mut self, v: bool) {
        self.ranked_low_priority = ::std::option::Option::Some(v);
    }

    // optional bool lobby_standby = 22;

    pub fn lobby_standby(&self) -> bool {
        self.lobby_standby.unwrap_or(false)
    }

    pub fn clear_lobby_standby(&mut self) {
        self.lobby_standby = ::std::option::Option::None;
    }

    pub fn has_lobby_standby(&self) -> bool {
        self.lobby_standby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_standby(&mut self, v: bool) {
        self.lobby_standby = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFPartyMember {
    const NAME: &'static str = "CSOTFPartyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.owns_ticket = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.completed_missions = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.competitive_access = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.experience = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_criteria)?;
                },
                138 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.activity)?;
                },
                144 => {
                    self.casual_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.ranked_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.casual_low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.ranked_low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.lobby_standby = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owns_ticket {
            my_size += 1 + 1;
        }
        if let Some(v) = self.completed_missions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.badge_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.competitive_access {
            my_size += 1 + 1;
        }
        if let Some(v) = self.experience {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.activity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.casual_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ranked_banned {
            my_size += 2 + 1;
        }
        if let Some(v) = self.casual_low_priority {
            my_size += 2 + 1;
        }
        if let Some(v) = self.ranked_low_priority {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lobby_standby {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owns_ticket {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.completed_missions {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.competitive_access {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.experience {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.activity.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        if let Some(v) = self.casual_banned {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.ranked_banned {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.casual_low_priority {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.ranked_low_priority {
            os.write_bool(21, v)?;
        }
        if let Some(v) = self.lobby_standby {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPartyMember {
        CSOTFPartyMember::new()
    }

    fn clear(&mut self) {
        self.owns_ticket = ::std::option::Option::None;
        self.completed_missions = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.competitive_access = ::std::option::Option::None;
        self.experience = ::std::option::Option::None;
        self.player_criteria.clear();
        self.activity.clear();
        self.casual_banned = ::std::option::Option::None;
        self.ranked_banned = ::std::option::Option::None;
        self.casual_low_priority = ::std::option::Option::None;
        self.ranked_low_priority = ::std::option::Option::None;
        self.lobby_standby = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPartyMember {
        static instance: CSOTFPartyMember = CSOTFPartyMember {
            owns_ticket: ::std::option::Option::None,
            completed_missions: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            competitive_access: ::std::option::Option::None,
            experience: ::std::option::Option::None,
            player_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            activity: ::steam_vent_proto_common::protobuf::MessageField::none(),
            casual_banned: ::std::option::Option::None,
            ranked_banned: ::std::option::Option::None,
            casual_low_priority: ::std::option::Option::None,
            ranked_low_priority: ::std::option::Option::None,
            lobby_standby: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSOTFPartyMember`
pub mod csotfparty_member {
    // @@protoc_insertion_point(message:CSOTFPartyMember.Activity)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Activity {
        // message fields
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.lobby_id)
        pub lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.lobby_match_group)
        pub lobby_match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ETFMatchGroup>>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.multiqueue_blocked)
        pub multiqueue_blocked: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.online)
        pub online: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CSOTFPartyMember.Activity.client_version)
        pub client_version: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFPartyMember.Activity.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Activity {
        fn default() -> &'a Activity {
            <Activity as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Activity {
        pub fn new() -> Activity {
            ::std::default::Default::default()
        }

        // optional fixed64 lobby_id = 1;

        pub fn lobby_id(&self) -> u64 {
            self.lobby_id.unwrap_or(0)
        }

        pub fn clear_lobby_id(&mut self) {
            self.lobby_id = ::std::option::Option::None;
        }

        pub fn has_lobby_id(&self) -> bool {
            self.lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_id(&mut self, v: u64) {
            self.lobby_id = ::std::option::Option::Some(v);
        }

        // optional .ETFMatchGroup lobby_match_group = 2;

        pub fn lobby_match_group(&self) -> super::ETFMatchGroup {
            match self.lobby_match_group {
                Some(e) => e.enum_value_or(super::ETFMatchGroup::k_eTFMatchGroup_Invalid),
                None => super::ETFMatchGroup::k_eTFMatchGroup_Invalid,
            }
        }

        pub fn clear_lobby_match_group(&mut self) {
            self.lobby_match_group = ::std::option::Option::None;
        }

        pub fn has_lobby_match_group(&self) -> bool {
            self.lobby_match_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_match_group(&mut self, v: super::ETFMatchGroup) {
            self.lobby_match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional bool multiqueue_blocked = 3;

        pub fn multiqueue_blocked(&self) -> bool {
            self.multiqueue_blocked.unwrap_or(false)
        }

        pub fn clear_multiqueue_blocked(&mut self) {
            self.multiqueue_blocked = ::std::option::Option::None;
        }

        pub fn has_multiqueue_blocked(&self) -> bool {
            self.multiqueue_blocked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_multiqueue_blocked(&mut self, v: bool) {
            self.multiqueue_blocked = ::std::option::Option::Some(v);
        }

        // optional bool online = 4;

        pub fn online(&self) -> bool {
            self.online.unwrap_or(false)
        }

        pub fn clear_online(&mut self) {
            self.online = ::std::option::Option::None;
        }

        pub fn has_online(&self) -> bool {
            self.online.is_some()
        }

        // Param is passed by value, moved
        pub fn set_online(&mut self, v: bool) {
            self.online = ::std::option::Option::Some(v);
        }

        // optional uint32 client_version = 5;

        pub fn client_version(&self) -> u32 {
            self.client_version.unwrap_or(0)
        }

        pub fn clear_client_version(&mut self) {
            self.client_version = ::std::option::Option::None;
        }

        pub fn has_client_version(&self) -> bool {
            self.client_version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_version(&mut self, v: u32) {
            self.client_version = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Activity {
        const NAME: &'static str = "Activity";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.lobby_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.multiqueue_blocked = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.online = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.lobby_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.lobby_match_group {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.multiqueue_blocked {
                my_size += 1 + 1;
            }
            if let Some(v) = self.online {
                my_size += 1 + 1;
            }
            if let Some(v) = self.client_version {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.lobby_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.lobby_match_group {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.multiqueue_blocked {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.online {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.client_version {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Activity {
            Activity::new()
        }

        fn clear(&mut self) {
            self.lobby_id = ::std::option::Option::None;
            self.lobby_match_group = ::std::option::Option::None;
            self.multiqueue_blocked = ::std::option::Option::None;
            self.online = ::std::option::Option::None;
            self.client_version = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Activity {
            static instance: Activity = Activity {
                lobby_id: ::std::option::Option::None,
                lobby_match_group: ::std::option::Option::None,
                multiqueue_blocked: ::std::option::Option::None,
                online: ::std::option::Option::None,
                client_version: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:TFPendingPartyMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TFPendingPartyMember {
    // message fields
    // @@protoc_insertion_point(field:TFPendingPartyMember.steamid)
    pub steamid: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:TFPendingPartyMember.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<tfpending_party_member::EType>>,
    // @@protoc_insertion_point(field:TFPendingPartyMember.inviter)
    pub inviter: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:TFPendingPartyMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TFPendingPartyMember {
    fn default() -> &'a TFPendingPartyMember {
        <TFPendingPartyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl TFPendingPartyMember {
    pub fn new() -> TFPendingPartyMember {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }

    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional .TFPendingPartyMember.EType type = 2;

    pub fn type_(&self) -> tfpending_party_member::EType {
        match self.type_ {
            Some(e) => e.enum_value_or(tfpending_party_member::EType::Invited),
            None => tfpending_party_member::EType::Invited,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: tfpending_party_member::EType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 inviter = 3;

    pub fn inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }

    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for TFPendingPartyMember {
    const NAME: &'static str = "TFPendingPartyMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                25 => {
                    self.inviter = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 1 + 8;
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.inviter {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TFPendingPartyMember {
        TFPendingPartyMember::new()
    }

    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TFPendingPartyMember {
        static instance: TFPendingPartyMember = TFPendingPartyMember {
            steamid: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            inviter: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `TFPendingPartyMember`
pub mod tfpending_party_member {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:TFPendingPartyMember.EType)
    pub enum EType {
        // @@protoc_insertion_point(enum_value:TFPendingPartyMember.EType.Invited)
        Invited = 0,
        // @@protoc_insertion_point(enum_value:TFPendingPartyMember.EType.RequestedToJoin)
        RequestedToJoin = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EType {
        const NAME: &'static str = "EType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EType> {
            match value {
                0 => ::std::option::Option::Some(EType::Invited),
                1 => ::std::option::Option::Some(EType::RequestedToJoin),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EType> {
            match str {
                "Invited" => ::std::option::Option::Some(EType::Invited),
                "RequestedToJoin" => ::std::option::Option::Some(EType::RequestedToJoin),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EType] = &[
            EType::Invited,
            EType::RequestedToJoin,
        ];
    }

    impl ::std::default::Default for EType {
        fn default() -> Self {
            EType::Invited
        }
    }

}

// @@protoc_insertion_point(message:TFSyncedMMUIState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TFSyncedMMUIState {
    // message fields
    // @@protoc_insertion_point(field:TFSyncedMMUIState.menu_step)
    pub menu_step: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFSyncedMMMenuStep>>,
    // @@protoc_insertion_point(field:TFSyncedMMUIState.match_group)
    pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:TFSyncedMMUIState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TFSyncedMMUIState {
    fn default() -> &'a TFSyncedMMUIState {
        <TFSyncedMMUIState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl TFSyncedMMUIState {
    pub fn new() -> TFSyncedMMUIState {
        ::std::default::Default::default()
    }

    // optional .ETFSyncedMMMenuStep menu_step = 1;

    pub fn menu_step(&self) -> ETFSyncedMMMenuStep {
        match self.menu_step {
            Some(e) => e.enum_value_or(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            None => ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None,
        }
    }

    pub fn clear_menu_step(&mut self) {
        self.menu_step = ::std::option::Option::None;
    }

    pub fn has_menu_step(&self) -> bool {
        self.menu_step.is_some()
    }

    // Param is passed by value, moved
    pub fn set_menu_step(&mut self, v: ETFSyncedMMMenuStep) {
        self.menu_step = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for TFSyncedMMUIState {
    const NAME: &'static str = "TFSyncedMMUIState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.menu_step = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.menu_step {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.menu_step {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TFSyncedMMUIState {
        TFSyncedMMUIState::new()
    }

    fn clear(&mut self) {
        self.menu_step = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TFSyncedMMUIState {
        static instance: TFSyncedMMUIState = TFSyncedMMUIState {
            menu_step: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTFGroupMatchCriteriaProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFGroupMatchCriteriaProto {
    // message fields
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.late_join_ok)
    pub late_join_ok: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.custom_ping_tolerance)
    pub custom_ping_tolerance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_mannup_tour)
    pub mvm_mannup_tour: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_mannup_missions)
    pub mvm_mannup_missions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.mvm_bootcamp_missions)
    pub mvm_bootcamp_missions: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CTFGroupMatchCriteriaProto.casual_criteria)
    pub casual_criteria: ::steam_vent_proto_common::protobuf::MessageField<CTFCasualMatchCriteria>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFGroupMatchCriteriaProto.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFGroupMatchCriteriaProto {
    fn default() -> &'a CTFGroupMatchCriteriaProto {
        <CTFGroupMatchCriteriaProto as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFGroupMatchCriteriaProto {
    pub fn new() -> CTFGroupMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool late_join_ok = 5;

    pub fn late_join_ok(&self) -> bool {
        self.late_join_ok.unwrap_or(false)
    }

    pub fn clear_late_join_ok(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
    }

    pub fn has_late_join_ok(&self) -> bool {
        self.late_join_ok.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_ok(&mut self, v: bool) {
        self.late_join_ok = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_ping_tolerance = 13;

    pub fn custom_ping_tolerance(&self) -> u32 {
        self.custom_ping_tolerance.unwrap_or(0u32)
    }

    pub fn clear_custom_ping_tolerance(&mut self) {
        self.custom_ping_tolerance = ::std::option::Option::None;
    }

    pub fn has_custom_ping_tolerance(&self) -> bool {
        self.custom_ping_tolerance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_ping_tolerance(&mut self, v: u32) {
        self.custom_ping_tolerance = ::std::option::Option::Some(v);
    }

    // optional string mvm_mannup_tour = 10;

    pub fn mvm_mannup_tour(&self) -> &str {
        match self.mvm_mannup_tour.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mvm_mannup_tour(&mut self) {
        self.mvm_mannup_tour = ::std::option::Option::None;
    }

    pub fn has_mvm_mannup_tour(&self) -> bool {
        self.mvm_mannup_tour.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_mannup_tour(&mut self, v: ::std::string::String) {
        self.mvm_mannup_tour = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mvm_mannup_tour(&mut self) -> &mut ::std::string::String {
        if self.mvm_mannup_tour.is_none() {
            self.mvm_mannup_tour = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mvm_mannup_tour.as_mut().unwrap()
    }

    // Take field
    pub fn take_mvm_mannup_tour(&mut self) -> ::std::string::String {
        self.mvm_mannup_tour.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFGroupMatchCriteriaProto {
    const NAME: &'static str = "CTFGroupMatchCriteriaProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.late_join_ok = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.custom_ping_tolerance = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.mvm_mannup_tour = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.mvm_mannup_missions.push(is.read_string()?);
                },
                130 => {
                    self.mvm_bootcamp_missions.push(is.read_string()?);
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.casual_criteria)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.late_join_ok {
            my_size += 1 + 1;
        }
        if let Some(v) = self.custom_ping_tolerance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.mvm_mannup_tour.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        for value in &self.mvm_mannup_missions {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &value);
        };
        for value in &self.mvm_bootcamp_missions {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(16, &value);
        };
        if let Some(v) = self.casual_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.late_join_ok {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.custom_ping_tolerance {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.mvm_mannup_tour.as_ref() {
            os.write_string(10, v)?;
        }
        for v in &self.mvm_mannup_missions {
            os.write_string(15, &v)?;
        };
        for v in &self.mvm_bootcamp_missions {
            os.write_string(16, &v)?;
        };
        if let Some(v) = self.casual_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFGroupMatchCriteriaProto {
        CTFGroupMatchCriteriaProto::new()
    }

    fn clear(&mut self) {
        self.late_join_ok = ::std::option::Option::None;
        self.custom_ping_tolerance = ::std::option::Option::None;
        self.mvm_mannup_tour = ::std::option::Option::None;
        self.mvm_mannup_missions.clear();
        self.mvm_bootcamp_missions.clear();
        self.casual_criteria.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFGroupMatchCriteriaProto {
        static instance: CTFGroupMatchCriteriaProto = CTFGroupMatchCriteriaProto {
            late_join_ok: ::std::option::Option::None,
            custom_ping_tolerance: ::std::option::Option::None,
            mvm_mannup_tour: ::std::option::Option::None,
            mvm_mannup_missions: ::std::vec::Vec::new(),
            mvm_bootcamp_missions: ::std::vec::Vec::new(),
            casual_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTFCasualMatchCriteria)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFCasualMatchCriteria {
    // message fields
    // @@protoc_insertion_point(field:CTFCasualMatchCriteria.selected_maps_bits)
    pub selected_maps_bits: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFCasualMatchCriteria.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFCasualMatchCriteria {
    fn default() -> &'a CTFCasualMatchCriteria {
        <CTFCasualMatchCriteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFCasualMatchCriteria {
    pub fn new() -> CTFCasualMatchCriteria {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFCasualMatchCriteria {
    const NAME: &'static str = "CTFCasualMatchCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    is.read_repeated_packed_fixed32_into(&mut self.selected_maps_bits)?;
                },
                29 => {
                    self.selected_maps_bits.push(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.selected_maps_bits.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.selected_maps_bits {
            os.write_fixed32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFCasualMatchCriteria {
        CTFCasualMatchCriteria::new()
    }

    fn clear(&mut self) {
        self.selected_maps_bits.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFCasualMatchCriteria {
        static instance: CTFCasualMatchCriteria = CTFCasualMatchCriteria {
            selected_maps_bits: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTFPerPlayerMatchCriteriaProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFPerPlayerMatchCriteriaProto {
    // message fields
    // @@protoc_insertion_point(field:CTFPerPlayerMatchCriteriaProto.mvm_squad_surplus)
    pub mvm_squad_surplus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFPerPlayerMatchCriteriaProto.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFPerPlayerMatchCriteriaProto {
    fn default() -> &'a CTFPerPlayerMatchCriteriaProto {
        <CTFPerPlayerMatchCriteriaProto as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFPerPlayerMatchCriteriaProto {
    pub fn new() -> CTFPerPlayerMatchCriteriaProto {
        ::std::default::Default::default()
    }

    // optional bool mvm_squad_surplus = 1;

    pub fn mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.unwrap_or(false)
    }

    pub fn clear_mvm_squad_surplus(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
    }

    pub fn has_mvm_squad_surplus(&self) -> bool {
        self.mvm_squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_squad_surplus(&mut self, v: bool) {
        self.mvm_squad_surplus = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFPerPlayerMatchCriteriaProto {
    const NAME: &'static str = "CTFPerPlayerMatchCriteriaProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mvm_squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mvm_squad_surplus {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mvm_squad_surplus {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFPerPlayerMatchCriteriaProto {
        CTFPerPlayerMatchCriteriaProto::new()
    }

    fn clear(&mut self) {
        self.mvm_squad_surplus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFPerPlayerMatchCriteriaProto {
        static instance: CTFPerPlayerMatchCriteriaProto = CTFPerPlayerMatchCriteriaProto {
            mvm_squad_surplus: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CTFPartyOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFPartyOptions {
    // message fields
    // @@protoc_insertion_point(field:CTFPartyOptions.overwrite_existing)
    pub overwrite_existing: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFPartyOptions.group_criteria)
    pub group_criteria: ::steam_vent_proto_common::protobuf::MessageField<CTFGroupMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CTFPartyOptions.player_criteria)
    pub player_criteria: ::steam_vent_proto_common::protobuf::MessageField<CTFPerPlayerMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CTFPartyOptions.player_uistate)
    pub player_uistate: ::steam_vent_proto_common::protobuf::MessageField<TFSyncedMMUIState>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFPartyOptions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFPartyOptions {
    fn default() -> &'a CTFPartyOptions {
        <CTFPartyOptions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFPartyOptions {
    pub fn new() -> CTFPartyOptions {
        ::std::default::Default::default()
    }

    // optional bool overwrite_existing = 1;

    pub fn overwrite_existing(&self) -> bool {
        self.overwrite_existing.unwrap_or(false)
    }

    pub fn clear_overwrite_existing(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
    }

    pub fn has_overwrite_existing(&self) -> bool {
        self.overwrite_existing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwrite_existing(&mut self, v: bool) {
        self.overwrite_existing = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFPartyOptions {
    const NAME: &'static str = "CTFPartyOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwrite_existing = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.group_criteria)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_criteria)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_uistate)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwrite_existing {
            my_size += 1 + 1;
        }
        if let Some(v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.player_uistate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overwrite_existing {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.group_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.player_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.player_uistate.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFPartyOptions {
        CTFPartyOptions::new()
    }

    fn clear(&mut self) {
        self.overwrite_existing = ::std::option::Option::None;
        self.group_criteria.clear();
        self.player_criteria.clear();
        self.player_uistate.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFPartyOptions {
        static instance: CTFPartyOptions = CTFPartyOptions {
            overwrite_existing: ::std::option::Option::None,
            group_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_uistate: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartySetOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySetOptions {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartySetOptions.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartySetOptions.options)
    pub options: ::steam_vent_proto_common::protobuf::MessageField<CTFPartyOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySetOptions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptions {
    fn default() -> &'a CMsgPartySetOptions {
        <CMsgPartySetOptions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptions {
    pub fn new() -> CMsgPartySetOptions {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartySetOptions {
    const NAME: &'static str = "CMsgPartySetOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySetOptions {
        CMsgPartySetOptions::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySetOptions {
        static instance: CMsgPartySetOptions = CMsgPartySetOptions {
            party_id: ::std::option::Option::None,
            options: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartySetOptionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySetOptionsResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySetOptionsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySetOptionsResponse {
    fn default() -> &'a CMsgPartySetOptionsResponse {
        <CMsgPartySetOptionsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySetOptionsResponse {
    pub fn new() -> CMsgPartySetOptionsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartySetOptionsResponse {
    const NAME: &'static str = "CMsgPartySetOptionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySetOptionsResponse {
        CMsgPartySetOptionsResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySetOptionsResponse {
        static instance: CMsgPartySetOptionsResponse = CMsgPartySetOptionsResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyQueueForMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.final_options)
    pub final_options: ::steam_vent_proto_common::protobuf::MessageField<CTFPartyOptions>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForMatch.match_group)
    pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatch {
    fn default() -> &'a CMsgPartyQueueForMatch {
        <CMsgPartyQueueForMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatch {
    pub fn new() -> CMsgPartyQueueForMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 3;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyQueueForMatch {
    const NAME: &'static str = "CMsgPartyQueueForMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.final_options)?;
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.final_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.final_options.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForMatch {
        CMsgPartyQueueForMatch::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.final_options.clear();
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatch {
        static instance: CMsgPartyQueueForMatch = CMsgPartyQueueForMatch {
            party_id: ::std::option::Option::None,
            final_options: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyQueueForMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForMatchResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForMatchResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForMatchResponse {
    fn default() -> &'a CMsgPartyQueueForMatchResponse {
        <CMsgPartyQueueForMatchResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForMatchResponse {
    pub fn new() -> CMsgPartyQueueForMatchResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyQueueForMatchResponse {
    const NAME: &'static str = "CMsgPartyQueueForMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForMatchResponse {
        CMsgPartyQueueForMatchResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForMatchResponse {
        static instance: CMsgPartyQueueForMatchResponse = CMsgPartyQueueForMatchResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyQueueForStandby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForStandby {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyQueueForStandby.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyQueueForStandby.party_lobby_id)
    pub party_lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForStandby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandby {
    fn default() -> &'a CMsgPartyQueueForStandby {
        <CMsgPartyQueueForStandby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandby {
    pub fn new() -> CMsgPartyQueueForStandby {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 party_lobby_id = 2;

    pub fn party_lobby_id(&self) -> u64 {
        self.party_lobby_id.unwrap_or(0)
    }

    pub fn clear_party_lobby_id(&mut self) {
        self.party_lobby_id = ::std::option::Option::None;
    }

    pub fn has_party_lobby_id(&self) -> bool {
        self.party_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_lobby_id(&mut self, v: u64) {
        self.party_lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyQueueForStandby {
    const NAME: &'static str = "CMsgPartyQueueForStandby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.party_lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.party_lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.party_lobby_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForStandby {
        CMsgPartyQueueForStandby::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.party_lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandby {
        static instance: CMsgPartyQueueForStandby = CMsgPartyQueueForStandby {
            party_id: ::std::option::Option::None,
            party_lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyQueueForStandbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyQueueForStandbyResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyQueueForStandbyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyQueueForStandbyResponse {
    fn default() -> &'a CMsgPartyQueueForStandbyResponse {
        <CMsgPartyQueueForStandbyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyQueueForStandbyResponse {
    pub fn new() -> CMsgPartyQueueForStandbyResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyQueueForStandbyResponse {
    const NAME: &'static str = "CMsgPartyQueueForStandbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyQueueForStandbyResponse {
        CMsgPartyQueueForStandbyResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyQueueForStandbyResponse {
        static instance: CMsgPartyQueueForStandbyResponse = CMsgPartyQueueForStandbyResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromQueue.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromQueue.match_group)
    pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueue {
    fn default() -> &'a CMsgPartyRemoveFromQueue {
        <CMsgPartyRemoveFromQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueue {
    pub fn new() -> CMsgPartyRemoveFromQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyRemoveFromQueue {
    const NAME: &'static str = "CMsgPartyRemoveFromQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromQueue {
        CMsgPartyRemoveFromQueue::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueue {
        static instance: CMsgPartyRemoveFromQueue = CMsgPartyRemoveFromQueue {
            party_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromQueueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromQueueResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromQueueResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromQueueResponse {
        <CMsgPartyRemoveFromQueueResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromQueueResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyRemoveFromQueueResponse {
    const NAME: &'static str = "CMsgPartyRemoveFromQueueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromQueueResponse {
        CMsgPartyRemoveFromQueueResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromQueueResponse {
        static instance: CMsgPartyRemoveFromQueueResponse = CMsgPartyRemoveFromQueueResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromStandbyQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromStandbyQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRemoveFromStandbyQueue.party_id)
    pub party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromStandbyQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueue {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueue {
        <CMsgPartyRemoveFromStandbyQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueue {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueue {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyRemoveFromStandbyQueue {
    const NAME: &'static str = "CMsgPartyRemoveFromStandbyQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueue {
        CMsgPartyRemoveFromStandbyQueue::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueue {
        static instance: CMsgPartyRemoveFromStandbyQueue = CMsgPartyRemoveFromStandbyQueue {
            party_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyRemoveFromStandbyQueueResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRemoveFromStandbyQueueResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRemoveFromStandbyQueueResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRemoveFromStandbyQueueResponse {
    fn default() -> &'a CMsgPartyRemoveFromStandbyQueueResponse {
        <CMsgPartyRemoveFromStandbyQueueResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRemoveFromStandbyQueueResponse {
    pub fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyRemoveFromStandbyQueueResponse {
    const NAME: &'static str = "CMsgPartyRemoveFromStandbyQueueResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRemoveFromStandbyQueueResponse {
        CMsgPartyRemoveFromStandbyQueueResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRemoveFromStandbyQueueResponse {
        static instance: CMsgPartyRemoveFromStandbyQueueResponse = CMsgPartyRemoveFromStandbyQueueResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyInvitePlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyInvitePlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.player_id)
    pub player_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInvitePlayer.expecting_request_to_join)
    pub expecting_request_to_join: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyInvitePlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInvitePlayer {
    fn default() -> &'a CMsgPartyInvitePlayer {
        <CMsgPartyInvitePlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInvitePlayer {
    pub fn new() -> CMsgPartyInvitePlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 player_id = 2;

    pub fn player_id(&self) -> u64 {
        self.player_id.unwrap_or(0)
    }

    pub fn clear_player_id(&mut self) {
        self.player_id = ::std::option::Option::None;
    }

    pub fn has_player_id(&self) -> bool {
        self.player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_id(&mut self, v: u64) {
        self.player_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_request_to_join = 3;

    pub fn expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.unwrap_or(false)
    }

    pub fn clear_expecting_request_to_join(&mut self) {
        self.expecting_request_to_join = ::std::option::Option::None;
    }

    pub fn has_expecting_request_to_join(&self) -> bool {
        self.expecting_request_to_join.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_request_to_join(&mut self, v: bool) {
        self.expecting_request_to_join = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyInvitePlayer {
    const NAME: &'static str = "CMsgPartyInvitePlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.expecting_request_to_join = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.player_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expecting_request_to_join {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.expecting_request_to_join {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyInvitePlayer {
        CMsgPartyInvitePlayer::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.player_id = ::std::option::Option::None;
        self.expecting_request_to_join = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyInvitePlayer {
        static instance: CMsgPartyInvitePlayer = CMsgPartyInvitePlayer {
            party_id: ::std::option::Option::None,
            player_id: ::std::option::Option::None,
            expecting_request_to_join: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyRequestJoinPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyRequestJoinPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.current_party_id)
    pub current_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.join_player_id)
    pub join_player_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.join_party_id)
    pub join_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyRequestJoinPlayer.expecting_invite)
    pub expecting_invite: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyRequestJoinPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyRequestJoinPlayer {
    fn default() -> &'a CMsgPartyRequestJoinPlayer {
        <CMsgPartyRequestJoinPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyRequestJoinPlayer {
    pub fn new() -> CMsgPartyRequestJoinPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 current_party_id = 1;

    pub fn current_party_id(&self) -> u64 {
        self.current_party_id.unwrap_or(0)
    }

    pub fn clear_current_party_id(&mut self) {
        self.current_party_id = ::std::option::Option::None;
    }

    pub fn has_current_party_id(&self) -> bool {
        self.current_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_party_id(&mut self, v: u64) {
        self.current_party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_player_id = 2;

    pub fn join_player_id(&self) -> u64 {
        self.join_player_id.unwrap_or(0)
    }

    pub fn clear_join_player_id(&mut self) {
        self.join_player_id = ::std::option::Option::None;
    }

    pub fn has_join_player_id(&self) -> bool {
        self.join_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_player_id(&mut self, v: u64) {
        self.join_player_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 join_party_id = 3;

    pub fn join_party_id(&self) -> u64 {
        self.join_party_id.unwrap_or(0)
    }

    pub fn clear_join_party_id(&mut self) {
        self.join_party_id = ::std::option::Option::None;
    }

    pub fn has_join_party_id(&self) -> bool {
        self.join_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_join_party_id(&mut self, v: u64) {
        self.join_party_id = ::std::option::Option::Some(v);
    }

    // optional bool expecting_invite = 4;

    pub fn expecting_invite(&self) -> bool {
        self.expecting_invite.unwrap_or(false)
    }

    pub fn clear_expecting_invite(&mut self) {
        self.expecting_invite = ::std::option::Option::None;
    }

    pub fn has_expecting_invite(&self) -> bool {
        self.expecting_invite.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expecting_invite(&mut self, v: bool) {
        self.expecting_invite = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyRequestJoinPlayer {
    const NAME: &'static str = "CMsgPartyRequestJoinPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.current_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.join_player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.join_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.expecting_invite = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.join_player_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.join_party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.expecting_invite {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.current_party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.join_player_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.join_party_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.expecting_invite {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyRequestJoinPlayer {
        CMsgPartyRequestJoinPlayer::new()
    }

    fn clear(&mut self) {
        self.current_party_id = ::std::option::Option::None;
        self.join_player_id = ::std::option::Option::None;
        self.join_party_id = ::std::option::Option::None;
        self.expecting_invite = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyRequestJoinPlayer {
        static instance: CMsgPartyRequestJoinPlayer = CMsgPartyRequestJoinPlayer {
            current_party_id: ::std::option::Option::None,
            join_player_id: ::std::option::Option::None,
            join_party_id: ::std::option::Option::None,
            expecting_invite: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyClearPendingPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearPendingPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyClearPendingPlayer.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyClearPendingPlayer.pending_player_id)
    pub pending_player_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearPendingPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayer {
    fn default() -> &'a CMsgPartyClearPendingPlayer {
        <CMsgPartyClearPendingPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayer {
    pub fn new() -> CMsgPartyClearPendingPlayer {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 pending_player_id = 2;

    pub fn pending_player_id(&self) -> u64 {
        self.pending_player_id.unwrap_or(0)
    }

    pub fn clear_pending_player_id(&mut self) {
        self.pending_player_id = ::std::option::Option::None;
    }

    pub fn has_pending_player_id(&self) -> bool {
        self.pending_player_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pending_player_id(&mut self, v: u64) {
        self.pending_player_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyClearPendingPlayer {
    const NAME: &'static str = "CMsgPartyClearPendingPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.pending_player_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.pending_player_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.pending_player_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearPendingPlayer {
        CMsgPartyClearPendingPlayer::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.pending_player_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayer {
        static instance: CMsgPartyClearPendingPlayer = CMsgPartyClearPendingPlayer {
            party_id: ::std::option::Option::None,
            pending_player_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyClearPendingPlayerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearPendingPlayerResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearPendingPlayerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearPendingPlayerResponse {
    fn default() -> &'a CMsgPartyClearPendingPlayerResponse {
        <CMsgPartyClearPendingPlayerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearPendingPlayerResponse {
    pub fn new() -> CMsgPartyClearPendingPlayerResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyClearPendingPlayerResponse {
    const NAME: &'static str = "CMsgPartyClearPendingPlayerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearPendingPlayerResponse {
        CMsgPartyClearPendingPlayerResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearPendingPlayerResponse {
        static instance: CMsgPartyClearPendingPlayerResponse = CMsgPartyClearPendingPlayerResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyClearOtherPartyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearOtherPartyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyClearOtherPartyRequest.other_party_id)
    pub other_party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearOtherPartyRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequest {
    fn default() -> &'a CMsgPartyClearOtherPartyRequest {
        <CMsgPartyClearOtherPartyRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequest {
    pub fn new() -> CMsgPartyClearOtherPartyRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 other_party_id = 1;

    pub fn other_party_id(&self) -> u64 {
        self.other_party_id.unwrap_or(0)
    }

    pub fn clear_other_party_id(&mut self) {
        self.other_party_id = ::std::option::Option::None;
    }

    pub fn has_other_party_id(&self) -> bool {
        self.other_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_party_id(&mut self, v: u64) {
        self.other_party_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyClearOtherPartyRequest {
    const NAME: &'static str = "CMsgPartyClearOtherPartyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.other_party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_party_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.other_party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearOtherPartyRequest {
        CMsgPartyClearOtherPartyRequest::new()
    }

    fn clear(&mut self) {
        self.other_party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequest {
        static instance: CMsgPartyClearOtherPartyRequest = CMsgPartyClearOtherPartyRequest {
            other_party_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyClearOtherPartyRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyClearOtherPartyRequestResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyClearOtherPartyRequestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyClearOtherPartyRequestResponse {
    fn default() -> &'a CMsgPartyClearOtherPartyRequestResponse {
        <CMsgPartyClearOtherPartyRequestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyClearOtherPartyRequestResponse {
    pub fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyClearOtherPartyRequestResponse {
    const NAME: &'static str = "CMsgPartyClearOtherPartyRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyClearOtherPartyRequestResponse {
        CMsgPartyClearOtherPartyRequestResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyClearOtherPartyRequestResponse {
        static instance: CMsgPartyClearOtherPartyRequestResponse = CMsgPartyClearOtherPartyRequestResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyPromoteToLeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyPromoteToLeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyPromoteToLeader.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyPromoteToLeader.new_leader_id)
    pub new_leader_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyPromoteToLeader.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyPromoteToLeader {
    fn default() -> &'a CMsgPartyPromoteToLeader {
        <CMsgPartyPromoteToLeader as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyPromoteToLeader {
    pub fn new() -> CMsgPartyPromoteToLeader {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 new_leader_id = 2;

    pub fn new_leader_id(&self) -> u64 {
        self.new_leader_id.unwrap_or(0)
    }

    pub fn clear_new_leader_id(&mut self) {
        self.new_leader_id = ::std::option::Option::None;
    }

    pub fn has_new_leader_id(&self) -> bool {
        self.new_leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_leader_id(&mut self, v: u64) {
        self.new_leader_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyPromoteToLeader {
    const NAME: &'static str = "CMsgPartyPromoteToLeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.new_leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.new_leader_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.new_leader_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyPromoteToLeader {
        CMsgPartyPromoteToLeader::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.new_leader_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyPromoteToLeader {
        static instance: CMsgPartyPromoteToLeader = CMsgPartyPromoteToLeader {
            party_id: ::std::option::Option::None,
            new_leader_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyKickMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyKickMember {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyKickMember.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyKickMember.target_id)
    pub target_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyKickMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyKickMember {
    fn default() -> &'a CMsgPartyKickMember {
        <CMsgPartyKickMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyKickMember {
    pub fn new() -> CMsgPartyKickMember {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_id = 2;

    pub fn target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }

    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyKickMember {
    const NAME: &'static str = "CMsgPartyKickMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.target_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_id {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyKickMember {
        CMsgPartyKickMember::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.target_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyKickMember {
        static instance: CMsgPartyKickMember = CMsgPartyKickMember {
            party_id: ::std::option::Option::None,
            target_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartySendChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySendChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartySendChat.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartySendChat.msg)
    pub msg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySendChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySendChat {
    fn default() -> &'a CMsgPartySendChat {
        <CMsgPartySendChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySendChat {
    pub fn new() -> CMsgPartySendChat {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 2;

    pub fn msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartySendChat {
    const NAME: &'static str = "CMsgPartySendChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    self.msg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.msg.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySendChat {
        CMsgPartySendChat::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySendChat {
        static instance: CMsgPartySendChat = CMsgPartySendChat {
            party_id: ::std::option::Option::None,
            msg: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyChatMsg)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyChatMsg {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFPartyChatType>>,
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.actor_id)
    pub actor_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyChatMsg.msg)
    pub msg: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyChatMsg.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyChatMsg {
    fn default() -> &'a CMsgPartyChatMsg {
        <CMsgPartyChatMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyChatMsg {
    pub fn new() -> CMsgPartyChatMsg {
        ::std::default::Default::default()
    }

    // optional .ETFPartyChatType type = 1;

    pub fn type_(&self) -> ETFPartyChatType {
        match self.type_ {
            Some(e) => e.enum_value_or(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            None => ETFPartyChatType::k_eTFPartyChatType_Invalid,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ETFPartyChatType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 actor_id = 2;

    pub fn actor_id(&self) -> u64 {
        self.actor_id.unwrap_or(0)
    }

    pub fn clear_actor_id(&mut self) {
        self.actor_id = ::std::option::Option::None;
    }

    pub fn has_actor_id(&self) -> bool {
        self.actor_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actor_id(&mut self, v: u64) {
        self.actor_id = ::std::option::Option::Some(v);
    }

    // optional string msg = 3;

    pub fn msg(&self) -> &str {
        match self.msg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_msg(&mut self) {
        self.msg = ::std::option::Option::None;
    }

    pub fn has_msg(&self) -> bool {
        self.msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_msg(&mut self, v: ::std::string::String) {
        self.msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_msg(&mut self) -> &mut ::std::string::String {
        if self.msg.is_none() {
            self.msg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_msg(&mut self) -> ::std::string::String {
        self.msg.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyChatMsg {
    const NAME: &'static str = "CMsgPartyChatMsg";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.actor_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    self.msg = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.actor_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.actor_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.msg.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyChatMsg {
        CMsgPartyChatMsg::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.actor_id = ::std::option::Option::None;
        self.msg = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyChatMsg {
        static instance: CMsgPartyChatMsg = CMsgPartyChatMsg {
            type_: ::std::option::Option::None,
            actor_id: ::std::option::Option::None,
            msg: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFParty {
    // message fields
    // @@protoc_insertion_point(field:CSOTFParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.leader_id)
    pub leader_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.member_ids)
    pub member_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.members)
    pub members: ::std::vec::Vec<CSOTFPartyMember>,
    // @@protoc_insertion_point(field:CSOTFParty.associated_lobby_id)
    pub associated_lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFParty.associated_lobby_match_group)
    pub associated_lobby_match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // @@protoc_insertion_point(field:CSOTFParty.matchmaking_queues)
    pub matchmaking_queues: ::std::vec::Vec<csotfparty::QueueEntry>,
    // @@protoc_insertion_point(field:CSOTFParty.group_criteria)
    pub group_criteria: ::steam_vent_proto_common::protobuf::MessageField<CTFGroupMatchCriteriaProto>,
    // @@protoc_insertion_point(field:CSOTFParty.casual_banned_time)
    pub casual_banned_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.casual_low_priority_time)
    pub casual_low_priority_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.ranked_banned_time)
    pub ranked_banned_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.ranked_low_priority_time)
    pub ranked_low_priority_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFParty.leader_ui_state)
    pub leader_ui_state: ::steam_vent_proto_common::protobuf::MessageField<TFSyncedMMUIState>,
    // @@protoc_insertion_point(field:CSOTFParty.pending_members)
    pub pending_members: ::std::vec::Vec<TFPendingPartyMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFParty {
    fn default() -> &'a CSOTFParty {
        <CSOTFParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFParty {
    pub fn new() -> CSOTFParty {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 leader_id = 2;

    pub fn leader_id(&self) -> u64 {
        self.leader_id.unwrap_or(0)
    }

    pub fn clear_leader_id(&mut self) {
        self.leader_id = ::std::option::Option::None;
    }

    pub fn has_leader_id(&self) -> bool {
        self.leader_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_id(&mut self, v: u64) {
        self.leader_id = ::std::option::Option::Some(v);
    }

    // optional uint64 associated_lobby_id = 35;

    pub fn associated_lobby_id(&self) -> u64 {
        self.associated_lobby_id.unwrap_or(0)
    }

    pub fn clear_associated_lobby_id(&mut self) {
        self.associated_lobby_id = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_id(&self) -> bool {
        self.associated_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_id(&mut self, v: u64) {
        self.associated_lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup associated_lobby_match_group = 40;

    pub fn associated_lobby_match_group(&self) -> ETFMatchGroup {
        match self.associated_lobby_match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_associated_lobby_match_group(&mut self) {
        self.associated_lobby_match_group = ::std::option::Option::None;
    }

    pub fn has_associated_lobby_match_group(&self) -> bool {
        self.associated_lobby_match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_associated_lobby_match_group(&mut self, v: ETFMatchGroup) {
        self.associated_lobby_match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 casual_banned_time = 18;

    pub fn casual_banned_time(&self) -> u32 {
        self.casual_banned_time.unwrap_or(0)
    }

    pub fn clear_casual_banned_time(&mut self) {
        self.casual_banned_time = ::std::option::Option::None;
    }

    pub fn has_casual_banned_time(&self) -> bool {
        self.casual_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_banned_time(&mut self, v: u32) {
        self.casual_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 casual_low_priority_time = 20;

    pub fn casual_low_priority_time(&self) -> u32 {
        self.casual_low_priority_time.unwrap_or(0)
    }

    pub fn clear_casual_low_priority_time(&mut self) {
        self.casual_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_casual_low_priority_time(&self) -> bool {
        self.casual_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_casual_low_priority_time(&mut self, v: u32) {
        self.casual_low_priority_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_banned_time = 41;

    pub fn ranked_banned_time(&self) -> u32 {
        self.ranked_banned_time.unwrap_or(0)
    }

    pub fn clear_ranked_banned_time(&mut self) {
        self.ranked_banned_time = ::std::option::Option::None;
    }

    pub fn has_ranked_banned_time(&self) -> bool {
        self.ranked_banned_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_banned_time(&mut self, v: u32) {
        self.ranked_banned_time = ::std::option::Option::Some(v);
    }

    // optional uint32 ranked_low_priority_time = 42;

    pub fn ranked_low_priority_time(&self) -> u32 {
        self.ranked_low_priority_time.unwrap_or(0)
    }

    pub fn clear_ranked_low_priority_time(&mut self) {
        self.ranked_low_priority_time = ::std::option::Option::None;
    }

    pub fn has_ranked_low_priority_time(&self) -> bool {
        self.ranked_low_priority_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ranked_low_priority_time(&mut self, v: u32) {
        self.ranked_low_priority_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFParty {
    const NAME: &'static str = "CSOTFParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.leader_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.member_ids)?;
                },
                25 => {
                    self.member_ids.push(is.read_fixed64()?);
                },
                106 => {
                    self.members.push(is.read_message()?);
                },
                280 => {
                    self.associated_lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                320 => {
                    self.associated_lobby_match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                346 => {
                    self.matchmaking_queues.push(is.read_message()?);
                },
                298 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.group_criteria)?;
                },
                144 => {
                    self.casual_banned_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.casual_low_priority_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                328 => {
                    self.ranked_banned_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                336 => {
                    self.ranked_low_priority_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                354 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.leader_ui_state)?;
                },
                314 => {
                    self.pending_members.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.leader_id {
            my_size += 1 + 8;
        }
        my_size += 9 * self.member_ids.len() as u64;
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.associated_lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(35, v);
        }
        if let Some(v) = self.associated_lobby_match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(40, v.value());
        }
        for value in &self.matchmaking_queues {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.group_criteria.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.casual_banned_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.casual_low_priority_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.ranked_banned_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.ranked_low_priority_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
        }
        if let Some(v) = self.leader_ui_state.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.leader_id {
            os.write_fixed64(2, v)?;
        }
        for v in &self.member_ids {
            os.write_fixed64(3, *v)?;
        };
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.associated_lobby_id {
            os.write_uint64(35, v)?;
        }
        if let Some(v) = self.associated_lobby_match_group {
            os.write_enum(40, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.matchmaking_queues {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.group_criteria.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.casual_banned_time {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.casual_low_priority_time {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.ranked_banned_time {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.ranked_low_priority_time {
            os.write_uint32(42, v)?;
        }
        if let Some(v) = self.leader_ui_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.pending_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(39, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFParty {
        CSOTFParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.leader_id = ::std::option::Option::None;
        self.member_ids.clear();
        self.members.clear();
        self.associated_lobby_id = ::std::option::Option::None;
        self.associated_lobby_match_group = ::std::option::Option::None;
        self.matchmaking_queues.clear();
        self.group_criteria.clear();
        self.casual_banned_time = ::std::option::Option::None;
        self.casual_low_priority_time = ::std::option::Option::None;
        self.ranked_banned_time = ::std::option::Option::None;
        self.ranked_low_priority_time = ::std::option::Option::None;
        self.leader_ui_state.clear();
        self.pending_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFParty {
        static instance: CSOTFParty = CSOTFParty {
            party_id: ::std::option::Option::None,
            leader_id: ::std::option::Option::None,
            member_ids: ::std::vec::Vec::new(),
            members: ::std::vec::Vec::new(),
            associated_lobby_id: ::std::option::Option::None,
            associated_lobby_match_group: ::std::option::Option::None,
            matchmaking_queues: ::std::vec::Vec::new(),
            group_criteria: ::steam_vent_proto_common::protobuf::MessageField::none(),
            casual_banned_time: ::std::option::Option::None,
            casual_low_priority_time: ::std::option::Option::None,
            ranked_banned_time: ::std::option::Option::None,
            ranked_low_priority_time: ::std::option::Option::None,
            leader_ui_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            pending_members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSOTFParty`
pub mod csotfparty {
    // @@protoc_insertion_point(message:CSOTFParty.QueueEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct QueueEntry {
        // message fields
        // @@protoc_insertion_point(field:CSOTFParty.QueueEntry.match_group)
        pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::ETFMatchGroup>>,
        // @@protoc_insertion_point(field:CSOTFParty.QueueEntry.queued_time)
        pub queued_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFParty.QueueEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a QueueEntry {
        fn default() -> &'a QueueEntry {
            <QueueEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl QueueEntry {
        pub fn new() -> QueueEntry {
            ::std::default::Default::default()
        }

        // optional .ETFMatchGroup match_group = 1;

        pub fn match_group(&self) -> super::ETFMatchGroup {
            match self.match_group {
                Some(e) => e.enum_value_or(super::ETFMatchGroup::k_eTFMatchGroup_Invalid),
                None => super::ETFMatchGroup::k_eTFMatchGroup_Invalid,
            }
        }

        pub fn clear_match_group(&mut self) {
            self.match_group = ::std::option::Option::None;
        }

        pub fn has_match_group(&self) -> bool {
            self.match_group.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_group(&mut self, v: super::ETFMatchGroup) {
            self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional fixed32 queued_time = 2;

        pub fn queued_time(&self) -> u32 {
            self.queued_time.unwrap_or(0)
        }

        pub fn clear_queued_time(&mut self) {
            self.queued_time = ::std::option::Option::None;
        }

        pub fn has_queued_time(&self) -> bool {
            self.queued_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_queued_time(&mut self, v: u32) {
            self.queued_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for QueueEntry {
        const NAME: &'static str = "QueueEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    21 => {
                        self.queued_time = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_group {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.queued_time {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_group {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.queued_time {
                os.write_fixed32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> QueueEntry {
            QueueEntry::new()
        }

        fn clear(&mut self) {
            self.match_group = ::std::option::Option::None;
            self.queued_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static QueueEntry {
            static instance: QueueEntry = QueueEntry {
                match_group: ::std::option::Option::None,
                queued_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSOTFPartyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFPartyInvite {
    // message fields
    // @@protoc_insertion_point(field:CSOTFPartyInvite.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.inviter)
    pub inviter: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.members)
    pub members: ::std::vec::Vec<csotfparty_invite::PartyMember>,
    // @@protoc_insertion_point(field:CSOTFPartyInvite.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<csotfparty_invite::Type>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFPartyInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFPartyInvite {
    fn default() -> &'a CSOTFPartyInvite {
        <CSOTFPartyInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFPartyInvite {
    pub fn new() -> CSOTFPartyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 inviter = 2;

    pub fn inviter(&self) -> u64 {
        self.inviter.unwrap_or(0)
    }

    pub fn clear_inviter(&mut self) {
        self.inviter = ::std::option::Option::None;
    }

    pub fn has_inviter(&self) -> bool {
        self.inviter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inviter(&mut self, v: u64) {
        self.inviter = ::std::option::Option::Some(v);
    }

    // optional .CSOTFPartyInvite.Type type = 5;

    pub fn type_(&self) -> csotfparty_invite::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(csotfparty_invite::Type::PENDING_INVITE),
            None => csotfparty_invite::Type::PENDING_INVITE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: csotfparty_invite::Type) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFPartyInvite {
    const NAME: &'static str = "CSOTFPartyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.inviter = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.inviter {
            my_size += 1 + 8;
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.inviter {
            os.write_fixed64(2, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.type_ {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFPartyInvite {
        CSOTFPartyInvite::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.inviter = ::std::option::Option::None;
        self.members.clear();
        self.type_ = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFPartyInvite {
        static instance: CSOTFPartyInvite = CSOTFPartyInvite {
            group_id: ::std::option::Option::None,
            inviter: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            type_: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSOTFPartyInvite`
pub mod csotfparty_invite {
    // @@protoc_insertion_point(message:CSOTFPartyInvite.PartyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PartyMember {
        // message fields
        // @@protoc_insertion_point(field:CSOTFPartyInvite.PartyMember.steamid)
        pub steamid: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CSOTFPartyInvite.PartyMember.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PartyMember {
        fn default() -> &'a PartyMember {
            <PartyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PartyMember {
        pub fn new() -> PartyMember {
            ::std::default::Default::default()
        }

        // optional fixed64 steamid = 2;

        pub fn steamid(&self) -> u64 {
            self.steamid.unwrap_or(0)
        }

        pub fn clear_steamid(&mut self) {
            self.steamid = ::std::option::Option::None;
        }

        pub fn has_steamid(&self) -> bool {
            self.steamid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steamid(&mut self, v: u64) {
            self.steamid = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PartyMember {
        const NAME: &'static str = "PartyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    17 => {
                        self.steamid = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steamid {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steamid {
                os.write_fixed64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PartyMember {
            PartyMember::new()
        }

        fn clear(&mut self) {
            self.steamid = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PartyMember {
            static instance: PartyMember = PartyMember {
                steamid: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFPartyInvite.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:CSOTFPartyInvite.Type.PENDING_INVITE)
        PENDING_INVITE = 1,
        // @@protoc_insertion_point(enum_value:CSOTFPartyInvite.Type.PENDING_JOIN_REQUEST)
        PENDING_JOIN_REQUEST = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::PENDING_INVITE),
                2 => ::std::option::Option::Some(Type::PENDING_JOIN_REQUEST),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "PENDING_INVITE" => ::std::option::Option::Some(Type::PENDING_INVITE),
                "PENDING_JOIN_REQUEST" => ::std::option::Option::Some(Type::PENDING_JOIN_REQUEST),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::PENDING_INVITE,
            Type::PENDING_JOIN_REQUEST,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::PENDING_INVITE
        }
    }

}

// @@protoc_insertion_point(message:CTFLobbyPlayerProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFLobbyPlayerProto {
    // message fields
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TF_GC_TEAM>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.connect_state)
    pub connect_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ctflobby_player_proto::ConnectState>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.original_party_id)
    pub original_party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.squad_surplus)
    pub squad_surplus: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.badge_level)
    pub badge_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.last_connect_time)
    pub last_connect_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ctflobby_player_proto::Type>>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.normalized_rating)
    pub normalized_rating: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.normalized_uncertainty)
    pub normalized_uncertainty: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CTFLobbyPlayerProto.chat_suspension)
    pub chat_suspension: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFLobbyPlayerProto.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFLobbyPlayerProto {
    fn default() -> &'a CTFLobbyPlayerProto {
        <CTFLobbyPlayerProto as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyPlayerProto {
    pub fn new() -> CTFLobbyPlayerProto {
        ::std::default::Default::default()
    }

    // optional fixed64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional .TF_GC_TEAM team = 3;

    pub fn team(&self) -> TF_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            None => TF_GC_TEAM::TF_GC_TEAM_DEFENDERS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: TF_GC_TEAM) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CTFLobbyPlayerProto.ConnectState connect_state = 13;

    pub fn connect_state(&self) -> ctflobby_player_proto::ConnectState {
        match self.connect_state {
            Some(e) => e.enum_value_or(ctflobby_player_proto::ConnectState::INVALID),
            None => ctflobby_player_proto::ConnectState::INVALID,
        }
    }

    pub fn clear_connect_state(&mut self) {
        self.connect_state = ::std::option::Option::None;
    }

    pub fn has_connect_state(&self) -> bool {
        self.connect_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect_state(&mut self, v: ctflobby_player_proto::ConnectState) {
        self.connect_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string name = 6;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 original_party_id = 12;

    pub fn original_party_id(&self) -> u64 {
        self.original_party_id.unwrap_or(0)
    }

    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u64) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional bool squad_surplus = 14;

    pub fn squad_surplus(&self) -> bool {
        self.squad_surplus.unwrap_or(false)
    }

    pub fn clear_squad_surplus(&mut self) {
        self.squad_surplus = ::std::option::Option::None;
    }

    pub fn has_squad_surplus(&self) -> bool {
        self.squad_surplus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_squad_surplus(&mut self, v: bool) {
        self.squad_surplus = ::std::option::Option::Some(v);
    }

    // optional uint32 badge_level = 15;

    pub fn badge_level(&self) -> u32 {
        self.badge_level.unwrap_or(0)
    }

    pub fn clear_badge_level(&mut self) {
        self.badge_level = ::std::option::Option::None;
    }

    pub fn has_badge_level(&self) -> bool {
        self.badge_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_level(&mut self, v: u32) {
        self.badge_level = ::std::option::Option::Some(v);
    }

    // optional uint32 last_connect_time = 17;

    pub fn last_connect_time(&self) -> u32 {
        self.last_connect_time.unwrap_or(0)
    }

    pub fn clear_last_connect_time(&mut self) {
        self.last_connect_time = ::std::option::Option::None;
    }

    pub fn has_last_connect_time(&self) -> bool {
        self.last_connect_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_connect_time(&mut self, v: u32) {
        self.last_connect_time = ::std::option::Option::Some(v);
    }

    // optional .CTFLobbyPlayerProto.Type type = 19;

    pub fn type_(&self) -> ctflobby_player_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(ctflobby_player_proto::Type::INVALID_PLAYER),
            None => ctflobby_player_proto::Type::INVALID_PLAYER,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: ctflobby_player_proto::Type) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional double normalized_rating = 20;

    pub fn normalized_rating(&self) -> f64 {
        self.normalized_rating.unwrap_or(0.)
    }

    pub fn clear_normalized_rating(&mut self) {
        self.normalized_rating = ::std::option::Option::None;
    }

    pub fn has_normalized_rating(&self) -> bool {
        self.normalized_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_rating(&mut self, v: f64) {
        self.normalized_rating = ::std::option::Option::Some(v);
    }

    // optional double normalized_uncertainty = 22;

    pub fn normalized_uncertainty(&self) -> f64 {
        self.normalized_uncertainty.unwrap_or(0.)
    }

    pub fn clear_normalized_uncertainty(&mut self) {
        self.normalized_uncertainty = ::std::option::Option::None;
    }

    pub fn has_normalized_uncertainty(&self) -> bool {
        self.normalized_uncertainty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_uncertainty(&mut self, v: f64) {
        self.normalized_uncertainty = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 21;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional bool chat_suspension = 23;

    pub fn chat_suspension(&self) -> bool {
        self.chat_suspension.unwrap_or(false)
    }

    pub fn clear_chat_suspension(&mut self) {
        self.chat_suspension = ::std::option::Option::None;
    }

    pub fn has_chat_suspension(&self) -> bool {
        self.chat_suspension.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chat_suspension(&mut self, v: bool) {
        self.chat_suspension = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFLobbyPlayerProto {
    const NAME: &'static str = "CTFLobbyPlayerProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.connect_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.original_party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                112 => {
                    self.squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                },
                120 => {
                    self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.last_connect_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                161 => {
                    self.normalized_rating = ::std::option::Option::Some(is.read_double()?);
                },
                177 => {
                    self.normalized_uncertainty = ::std::option::Option::Some(is.read_double()?);
                },
                168 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.chat_suspension = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.connect_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v.value());
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(12, v);
        }
        if let Some(v) = self.squad_surplus {
            my_size += 1 + 1;
        }
        if let Some(v) = self.badge_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.last_connect_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v.value());
        }
        if let Some(v) = self.normalized_rating {
            my_size += 2 + 8;
        }
        if let Some(v) = self.normalized_uncertainty {
            my_size += 2 + 8;
        }
        if let Some(v) = self.rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.chat_suspension {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.team {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect_state {
            os.write_enum(13, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint64(12, v)?;
        }
        if let Some(v) = self.squad_surplus {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.badge_level {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.last_connect_time {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(19, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.normalized_rating {
            os.write_double(20, v)?;
        }
        if let Some(v) = self.normalized_uncertainty {
            os.write_double(22, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.chat_suspension {
            os.write_bool(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFLobbyPlayerProto {
        CTFLobbyPlayerProto::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.connect_state = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.squad_surplus = ::std::option::Option::None;
        self.badge_level = ::std::option::Option::None;
        self.last_connect_time = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.normalized_rating = ::std::option::Option::None;
        self.normalized_uncertainty = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.chat_suspension = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFLobbyPlayerProto {
        static instance: CTFLobbyPlayerProto = CTFLobbyPlayerProto {
            id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            connect_state: ::std::option::Option::None,
            name: ::std::option::Option::None,
            original_party_id: ::std::option::Option::None,
            squad_surplus: ::std::option::Option::None,
            badge_level: ::std::option::Option::None,
            last_connect_time: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            normalized_rating: ::std::option::Option::None,
            normalized_uncertainty: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            chat_suspension: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CTFLobbyPlayerProto`
pub mod ctflobby_player_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CTFLobbyPlayerProto.ConnectState)
    pub enum ConnectState {
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.RESERVATION_PENDING)
        RESERVATION_PENDING = 1,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.RESERVED)
        RESERVED = 2,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.CONNECTED)
        CONNECTED = 3,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.ConnectState.DISCONNECTED)
        DISCONNECTED = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ConnectState {
        const NAME: &'static str = "ConnectState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ConnectState> {
            match value {
                0 => ::std::option::Option::Some(ConnectState::INVALID),
                1 => ::std::option::Option::Some(ConnectState::RESERVATION_PENDING),
                2 => ::std::option::Option::Some(ConnectState::RESERVED),
                3 => ::std::option::Option::Some(ConnectState::CONNECTED),
                5 => ::std::option::Option::Some(ConnectState::DISCONNECTED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ConnectState> {
            match str {
                "INVALID" => ::std::option::Option::Some(ConnectState::INVALID),
                "RESERVATION_PENDING" => ::std::option::Option::Some(ConnectState::RESERVATION_PENDING),
                "RESERVED" => ::std::option::Option::Some(ConnectState::RESERVED),
                "CONNECTED" => ::std::option::Option::Some(ConnectState::CONNECTED),
                "DISCONNECTED" => ::std::option::Option::Some(ConnectState::DISCONNECTED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ConnectState] = &[
            ConnectState::INVALID,
            ConnectState::RESERVATION_PENDING,
            ConnectState::RESERVED,
            ConnectState::CONNECTED,
            ConnectState::DISCONNECTED,
        ];
    }

    impl ::std::default::Default for ConnectState {
        fn default() -> Self {
            ConnectState::INVALID
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CTFLobbyPlayerProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.INVALID_PLAYER)
        INVALID_PLAYER = 0,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.MATCH_PLAYER)
        MATCH_PLAYER = 1,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.STANDBY_PLAYER)
        STANDBY_PLAYER = 2,
        // @@protoc_insertion_point(enum_value:CTFLobbyPlayerProto.Type.OBSERVING_PLAYER)
        OBSERVING_PLAYER = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                0 => ::std::option::Option::Some(Type::INVALID_PLAYER),
                1 => ::std::option::Option::Some(Type::MATCH_PLAYER),
                2 => ::std::option::Option::Some(Type::STANDBY_PLAYER),
                3 => ::std::option::Option::Some(Type::OBSERVING_PLAYER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "INVALID_PLAYER" => ::std::option::Option::Some(Type::INVALID_PLAYER),
                "MATCH_PLAYER" => ::std::option::Option::Some(Type::MATCH_PLAYER),
                "STANDBY_PLAYER" => ::std::option::Option::Some(Type::STANDBY_PLAYER),
                "OBSERVING_PLAYER" => ::std::option::Option::Some(Type::OBSERVING_PLAYER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::INVALID_PLAYER,
            Type::MATCH_PLAYER,
            Type::STANDBY_PLAYER,
            Type::OBSERVING_PLAYER,
        ];
    }

    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::INVALID_PLAYER
        }
    }

}

// @@protoc_insertion_point(message:CTFLobbyInviteProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CTFLobbyInviteProto {
    // message fields
    // @@protoc_insertion_point(field:CTFLobbyInviteProto.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CTFLobbyInviteProto.match_group)
    pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CTFLobbyInviteProto.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CTFLobbyInviteProto {
    fn default() -> &'a CTFLobbyInviteProto {
        <CTFLobbyInviteProto as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CTFLobbyInviteProto {
    pub fn new() -> CTFLobbyInviteProto {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .ETFMatchGroup match_group = 2;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CTFLobbyInviteProto {
    const NAME: &'static str = "CTFLobbyInviteProto";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CTFLobbyInviteProto {
        CTFLobbyInviteProto::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CTFLobbyInviteProto {
        static instance: CTFLobbyInviteProto = CTFLobbyInviteProto {
            lobby_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFGameServerLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFGameServerLobby {
    // message fields
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.members)
    pub members: ::std::vec::Vec<CTFLobbyPlayerProto>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.server_id)
    pub server_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.state)
    pub state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<csotfgame_server_lobby::State>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.connect)
    pub connect: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.game_state)
    pub game_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TF_GC_GameState>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.initial_average_mm_rating)
    pub initial_average_mm_rating: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.mannup_tour_name)
    pub mannup_tour_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.match_group)
    pub match_group: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.formed_time)
    pub formed_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.late_join_eligible)
    pub late_join_eligible: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.fixed_match_size)
    pub fixed_match_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.is_war_match)
    pub is_war_match: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<csotfgame_server_lobby::WarMatch>>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.next_maps_for_vote)
    pub next_maps_for_vote: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.lobby_mm_version)
    pub lobby_mm_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFGameServerLobby.pending_members)
    pub pending_members: ::std::vec::Vec<CTFLobbyPlayerProto>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFGameServerLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFGameServerLobby {
    fn default() -> &'a CSOTFGameServerLobby {
        <CSOTFGameServerLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFGameServerLobby {
    pub fn new() -> CSOTFGameServerLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_id = 6;

    pub fn server_id(&self) -> u64 {
        self.server_id.unwrap_or(0u64)
    }

    pub fn clear_server_id(&mut self) {
        self.server_id = ::std::option::Option::None;
    }

    pub fn has_server_id(&self) -> bool {
        self.server_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_id(&mut self, v: u64) {
        self.server_id = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.State state = 4;

    pub fn state(&self) -> csotfgame_server_lobby::State {
        match self.state {
            Some(e) => e.enum_value_or(csotfgame_server_lobby::State::UNKNOWN),
            None => csotfgame_server_lobby::State::UNKNOWN,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: csotfgame_server_lobby::State) {
        self.state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string connect = 5;

    pub fn connect(&self) -> &str {
        match self.connect.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_connect(&mut self) {
        self.connect = ::std::option::Option::None;
    }

    pub fn has_connect(&self) -> bool {
        self.connect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_connect(&mut self, v: ::std::string::String) {
        self.connect = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_connect(&mut self) -> &mut ::std::string::String {
        if self.connect.is_none() {
            self.connect = ::std::option::Option::Some(::std::string::String::new());
        }
        self.connect.as_mut().unwrap()
    }

    // Take field
    pub fn take_connect(&mut self) -> ::std::string::String {
        self.connect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .TF_GC_GameState game_state = 22;

    pub fn game_state(&self) -> TF_GC_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            None => TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional double initial_average_mm_rating = 32;

    pub fn initial_average_mm_rating(&self) -> f64 {
        self.initial_average_mm_rating.unwrap_or(0.)
    }

    pub fn clear_initial_average_mm_rating(&mut self) {
        self.initial_average_mm_rating = ::std::option::Option::None;
    }

    pub fn has_initial_average_mm_rating(&self) -> bool {
        self.initial_average_mm_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_average_mm_rating(&mut self, v: f64) {
        self.initial_average_mm_rating = ::std::option::Option::Some(v);
    }

    // optional string mannup_tour_name = 42;

    pub fn mannup_tour_name(&self) -> &str {
        match self.mannup_tour_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mannup_tour_name(&mut self) {
        self.mannup_tour_name = ::std::option::Option::None;
    }

    pub fn has_mannup_tour_name(&self) -> bool {
        self.mannup_tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mannup_tour_name(&mut self, v: ::std::string::String) {
        self.mannup_tour_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mannup_tour_name(&mut self) -> &mut ::std::string::String {
        if self.mannup_tour_name.is_none() {
            self.mannup_tour_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mannup_tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mannup_tour_name(&mut self) -> ::std::string::String {
        self.mannup_tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 38;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 39;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 match_group = 41;

    pub fn match_group(&self) -> u32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: u32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 30;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0u64)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 formed_time = 36;

    pub fn formed_time(&self) -> u32 {
        self.formed_time.unwrap_or(0)
    }

    pub fn clear_formed_time(&mut self) {
        self.formed_time = ::std::option::Option::None;
    }

    pub fn has_formed_time(&self) -> bool {
        self.formed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_formed_time(&mut self, v: u32) {
        self.formed_time = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 43;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional bool late_join_eligible = 44;

    pub fn late_join_eligible(&self) -> bool {
        self.late_join_eligible.unwrap_or(false)
    }

    pub fn clear_late_join_eligible(&mut self) {
        self.late_join_eligible = ::std::option::Option::None;
    }

    pub fn has_late_join_eligible(&self) -> bool {
        self.late_join_eligible.is_some()
    }

    // Param is passed by value, moved
    pub fn set_late_join_eligible(&mut self, v: bool) {
        self.late_join_eligible = ::std::option::Option::Some(v);
    }

    // optional uint32 fixed_match_size = 45;

    pub fn fixed_match_size(&self) -> u32 {
        self.fixed_match_size.unwrap_or(0)
    }

    pub fn clear_fixed_match_size(&mut self) {
        self.fixed_match_size = ::std::option::Option::None;
    }

    pub fn has_fixed_match_size(&self) -> bool {
        self.fixed_match_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fixed_match_size(&mut self, v: u32) {
        self.fixed_match_size = ::std::option::Option::Some(v);
    }

    // optional .CSOTFGameServerLobby.WarMatch is_war_match = 46;

    pub fn is_war_match(&self) -> csotfgame_server_lobby::WarMatch {
        match self.is_war_match {
            Some(e) => e.enum_value_or(csotfgame_server_lobby::WarMatch::NOPE),
            None => csotfgame_server_lobby::WarMatch::NOPE,
        }
    }

    pub fn clear_is_war_match(&mut self) {
        self.is_war_match = ::std::option::Option::None;
    }

    pub fn has_is_war_match(&self) -> bool {
        self.is_war_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_war_match(&mut self, v: csotfgame_server_lobby::WarMatch) {
        self.is_war_match = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 lobby_mm_version = 48;

    pub fn lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }

    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFGameServerLobby {
    const NAME: &'static str = "CSOTFGameServerLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                49 => {
                    self.server_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.connect = ::std::option::Option::Some(is.read_string()?);
                },
                176 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                257 => {
                    self.initial_average_mm_rating = ::std::option::Option::Some(is.read_double()?);
                },
                338 => {
                    self.mannup_tour_name = ::std::option::Option::Some(is.read_string()?);
                },
                306 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                328 => {
                    self.match_group = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                288 => {
                    self.formed_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                344 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                352 => {
                    self.late_join_eligible = ::std::option::Option::Some(is.read_bool()?);
                },
                360 => {
                    self.fixed_match_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                368 => {
                    self.is_war_match = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                378 => {
                    is.read_repeated_packed_uint32_into(&mut self.next_maps_for_vote)?;
                },
                376 => {
                    self.next_maps_for_vote.push(is.read_uint32()?);
                },
                384 => {
                    self.lobby_mm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                394 => {
                    self.pending_members.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.connect.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.game_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(22, v.value());
        }
        if let Some(v) = self.initial_average_mm_rating {
            my_size += 2 + 8;
        }
        if let Some(v) = self.mannup_tour_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(42, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(38, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(39, &v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(41, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(30, v);
        }
        if let Some(v) = self.formed_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(43, v);
        }
        if let Some(v) = self.late_join_eligible {
            my_size += 2 + 1;
        }
        if let Some(v) = self.fixed_match_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
        }
        if let Some(v) = self.is_war_match {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v.value());
        }
        for value in &self.next_maps_for_vote {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(47, *value);
        };
        if let Some(v) = self.lobby_mm_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(48, v);
        }
        for value in &self.pending_members {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.server_id {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.state {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.connect.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(22, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.initial_average_mm_rating {
            os.write_double(32, v)?;
        }
        if let Some(v) = self.mannup_tour_name.as_ref() {
            os.write_string(42, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(38, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_uint32(41, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(30, v)?;
        }
        if let Some(v) = self.formed_time {
            os.write_uint32(36, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(43, v)?;
        }
        if let Some(v) = self.late_join_eligible {
            os.write_bool(44, v)?;
        }
        if let Some(v) = self.fixed_match_size {
            os.write_uint32(45, v)?;
        }
        if let Some(v) = self.is_war_match {
            os.write_enum(46, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.next_maps_for_vote {
            os.write_uint32(47, *v)?;
        };
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(48, v)?;
        }
        for v in &self.pending_members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(49, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFGameServerLobby {
        CSOTFGameServerLobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.members.clear();
        self.server_id = ::std::option::Option::None;
        self.state = ::std::option::Option::None;
        self.connect = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.initial_average_mm_rating = ::std::option::Option::None;
        self.mannup_tour_name = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.formed_time = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.late_join_eligible = ::std::option::Option::None;
        self.fixed_match_size = ::std::option::Option::None;
        self.is_war_match = ::std::option::Option::None;
        self.next_maps_for_vote.clear();
        self.lobby_mm_version = ::std::option::Option::None;
        self.pending_members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFGameServerLobby {
        static instance: CSOTFGameServerLobby = CSOTFGameServerLobby {
            lobby_id: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            server_id: ::std::option::Option::None,
            state: ::std::option::Option::None,
            connect: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            initial_average_mm_rating: ::std::option::Option::None,
            mannup_tour_name: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            formed_time: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            late_join_eligible: ::std::option::Option::None,
            fixed_match_size: ::std::option::Option::None,
            is_war_match: ::std::option::Option::None,
            next_maps_for_vote: ::std::vec::Vec::new(),
            lobby_mm_version: ::std::option::Option::None,
            pending_members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSOTFGameServerLobby`
pub mod csotfgame_server_lobby {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFGameServerLobby.State)
    pub enum State {
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.UNKNOWN)
        UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.SERVERSETUP)
        SERVERSETUP = 1,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.State.RUN)
        RUN = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for State {
        const NAME: &'static str = "State";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<State> {
            match value {
                0 => ::std::option::Option::Some(State::UNKNOWN),
                1 => ::std::option::Option::Some(State::SERVERSETUP),
                2 => ::std::option::Option::Some(State::RUN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<State> {
            match str {
                "UNKNOWN" => ::std::option::Option::Some(State::UNKNOWN),
                "SERVERSETUP" => ::std::option::Option::Some(State::SERVERSETUP),
                "RUN" => ::std::option::Option::Some(State::RUN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [State] = &[
            State::UNKNOWN,
            State::SERVERSETUP,
            State::RUN,
        ];
    }

    impl ::std::default::Default for State {
        fn default() -> Self {
            State::UNKNOWN
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CSOTFGameServerLobby.WarMatch)
    pub enum WarMatch {
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.NOPE)
        NOPE = 0,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.INVADERS_ARE_PYRO)
        INVADERS_ARE_PYRO = 1,
        // @@protoc_insertion_point(enum_value:CSOTFGameServerLobby.WarMatch.INVADERS_ARE_HEAVY)
        INVADERS_ARE_HEAVY = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for WarMatch {
        const NAME: &'static str = "WarMatch";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<WarMatch> {
            match value {
                0 => ::std::option::Option::Some(WarMatch::NOPE),
                1 => ::std::option::Option::Some(WarMatch::INVADERS_ARE_PYRO),
                2 => ::std::option::Option::Some(WarMatch::INVADERS_ARE_HEAVY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<WarMatch> {
            match str {
                "NOPE" => ::std::option::Option::Some(WarMatch::NOPE),
                "INVADERS_ARE_PYRO" => ::std::option::Option::Some(WarMatch::INVADERS_ARE_PYRO),
                "INVADERS_ARE_HEAVY" => ::std::option::Option::Some(WarMatch::INVADERS_ARE_HEAVY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [WarMatch] = &[
            WarMatch::NOPE,
            WarMatch::INVADERS_ARE_PYRO,
            WarMatch::INVADERS_ARE_HEAVY,
        ];
    }

    impl ::std::default::Default for WarMatch {
        fn default() -> Self {
            WarMatch::NOPE
        }
    }

}

// @@protoc_insertion_point(message:CMsgExitMatchmaking)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExitMatchmaking {
    // message fields
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.explicit_abandon)
    pub explicit_abandon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgExitMatchmaking.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExitMatchmaking.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExitMatchmaking {
    fn default() -> &'a CMsgExitMatchmaking {
        <CMsgExitMatchmaking as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgExitMatchmaking {
    pub fn new() -> CMsgExitMatchmaking {
        ::std::default::Default::default()
    }

    // optional bool explicit_abandon = 1;

    pub fn explicit_abandon(&self) -> bool {
        self.explicit_abandon.unwrap_or(false)
    }

    pub fn clear_explicit_abandon(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
    }

    pub fn has_explicit_abandon(&self) -> bool {
        self.explicit_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_explicit_abandon(&mut self, v: bool) {
        self.explicit_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 party_id = 2;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgExitMatchmaking {
    const NAME: &'static str = "CMsgExitMatchmaking";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.explicit_abandon = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.explicit_abandon {
            my_size += 1 + 1;
        }
        if let Some(v) = self.party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.explicit_abandon {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.party_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExitMatchmaking {
        CMsgExitMatchmaking::new()
    }

    fn clear(&mut self) {
        self.explicit_abandon = ::std::option::Option::None;
        self.party_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExitMatchmaking {
        static instance: CMsgExitMatchmaking = CMsgExitMatchmaking {
            explicit_abandon: ::std::option::Option::None,
            party_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAcceptLobbyInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcceptLobbyInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.invited_lobby_id)
    pub invited_lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.abandoning_match_id)
    pub abandoning_match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAcceptLobbyInvite.abandoning_invite_lobby_ids)
    pub abandoning_invite_lobby_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcceptLobbyInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInvite {
    fn default() -> &'a CMsgAcceptLobbyInvite {
        <CMsgAcceptLobbyInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInvite {
    pub fn new() -> CMsgAcceptLobbyInvite {
        ::std::default::Default::default()
    }

    // optional uint64 invited_lobby_id = 1;

    pub fn invited_lobby_id(&self) -> u64 {
        self.invited_lobby_id.unwrap_or(0)
    }

    pub fn clear_invited_lobby_id(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
    }

    pub fn has_invited_lobby_id(&self) -> bool {
        self.invited_lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invited_lobby_id(&mut self, v: u64) {
        self.invited_lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 abandoning_match_id = 2;

    pub fn abandoning_match_id(&self) -> u64 {
        self.abandoning_match_id.unwrap_or(0)
    }

    pub fn clear_abandoning_match_id(&mut self) {
        self.abandoning_match_id = ::std::option::Option::None;
    }

    pub fn has_abandoning_match_id(&self) -> bool {
        self.abandoning_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandoning_match_id(&mut self, v: u64) {
        self.abandoning_match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAcceptLobbyInvite {
    const NAME: &'static str = "CMsgAcceptLobbyInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invited_lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.abandoning_match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.abandoning_invite_lobby_ids)?;
                },
                24 => {
                    self.abandoning_invite_lobby_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.invited_lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.abandoning_match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.abandoning_invite_lobby_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.invited_lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.abandoning_match_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.abandoning_invite_lobby_ids {
            os.write_uint64(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcceptLobbyInvite {
        CMsgAcceptLobbyInvite::new()
    }

    fn clear(&mut self) {
        self.invited_lobby_id = ::std::option::Option::None;
        self.abandoning_match_id = ::std::option::Option::None;
        self.abandoning_invite_lobby_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInvite {
        static instance: CMsgAcceptLobbyInvite = CMsgAcceptLobbyInvite {
            invited_lobby_id: ::std::option::Option::None,
            abandoning_match_id: ::std::option::Option::None,
            abandoning_invite_lobby_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAcceptLobbyInviteReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcceptLobbyInviteReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcceptLobbyInviteReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcceptLobbyInviteReply {
    fn default() -> &'a CMsgAcceptLobbyInviteReply {
        <CMsgAcceptLobbyInviteReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAcceptLobbyInviteReply {
    pub fn new() -> CMsgAcceptLobbyInviteReply {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAcceptLobbyInviteReply {
    const NAME: &'static str = "CMsgAcceptLobbyInviteReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcceptLobbyInviteReply {
        CMsgAcceptLobbyInviteReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcceptLobbyInviteReply {
        static instance: CMsgAcceptLobbyInviteReply = CMsgAcceptLobbyInviteReply {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMatchmakingSearchCountRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingSearchCountRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingSearchCountRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountRequest {
    fn default() -> &'a CMsgMatchmakingSearchCountRequest {
        <CMsgMatchmakingSearchCountRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountRequest {
    pub fn new() -> CMsgMatchmakingSearchCountRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchmakingSearchCountRequest {
    const NAME: &'static str = "CMsgMatchmakingSearchCountRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingSearchCountRequest {
        CMsgMatchmakingSearchCountRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountRequest {
        static instance: CMsgMatchmakingSearchCountRequest = CMsgMatchmakingSearchCountRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMatchmakingSearchCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingSearchCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchmakingSearchCountResponse.searching_players_by_group)
    pub searching_players_by_group: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingSearchCountResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingSearchCountResponse {
    fn default() -> &'a CMsgMatchmakingSearchCountResponse {
        <CMsgMatchmakingSearchCountResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingSearchCountResponse {
    pub fn new() -> CMsgMatchmakingSearchCountResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchmakingSearchCountResponse {
    const NAME: &'static str = "CMsgMatchmakingSearchCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.searching_players_by_group)?;
                },
                8 => {
                    self.searching_players_by_group.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.searching_players_by_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.searching_players_by_group {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingSearchCountResponse {
        CMsgMatchmakingSearchCountResponse::new()
    }

    fn clear(&mut self) {
        self.searching_players_by_group.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingSearchCountResponse {
        static instance: CMsgMatchmakingSearchCountResponse = CMsgMatchmakingSearchCountResponse {
            searching_players_by_group: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgKickedFromMatchmakingQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKickedFromMatchmakingQueue {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKickedFromMatchmakingQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKickedFromMatchmakingQueue {
    fn default() -> &'a CMsgKickedFromMatchmakingQueue {
        <CMsgKickedFromMatchmakingQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgKickedFromMatchmakingQueue {
    pub fn new() -> CMsgKickedFromMatchmakingQueue {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgKickedFromMatchmakingQueue {
    const NAME: &'static str = "CMsgKickedFromMatchmakingQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKickedFromMatchmakingQueue {
        CMsgKickedFromMatchmakingQueue::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKickedFromMatchmakingQueue {
        static instance: CMsgKickedFromMatchmakingQueue = CMsgKickedFromMatchmakingQueue {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerMatchmakingStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerMatchmakingStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.matchmaking_state)
    pub matchmaking_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ServerMatchmakingState>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.map)
    pub map: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.bot_count)
    pub bot_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.num_spectators)
    pub num_spectators: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.max_players)
    pub max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.slots_free)
    pub slots_free: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_loadavg)
    pub server_loadavg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_trusted)
    pub server_trusted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.server_dedicated)
    pub server_dedicated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.strict)
    pub strict: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.fake_ip)
    pub fake_ip: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.players)
    pub players: ::std::vec::Vec<cmsg_game_server_matchmaking_status::Player>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.game_state)
    pub game_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TF_GC_GameState>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.event)
    pub event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_game_server_matchmaking_status::Event>>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_wave)
    pub mvm_wave: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_credits_acquired)
    pub mvm_credits_acquired: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.mvm_credits_dropped)
    pub mvm_credits_dropped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.lobby_mm_version)
    pub lobby_mm_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerMatchmakingStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerMatchmakingStatus {
    fn default() -> &'a CMsgGameServerMatchmakingStatus {
        <CMsgGameServerMatchmakingStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerMatchmakingStatus {
    pub fn new() -> CMsgGameServerMatchmakingStatus {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 16;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(1225u32)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional .ServerMatchmakingState matchmaking_state = 1;

    pub fn matchmaking_state(&self) -> ServerMatchmakingState {
        match self.matchmaking_state {
            Some(e) => e.enum_value_or(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            None => ServerMatchmakingState::ServerMatchmakingState_INVALID,
        }
    }

    pub fn clear_matchmaking_state(&mut self) {
        self.matchmaking_state = ::std::option::Option::None;
    }

    pub fn has_matchmaking_state(&self) -> bool {
        self.matchmaking_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchmaking_state(&mut self, v: ServerMatchmakingState) {
        self.matchmaking_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string map = 3;

    pub fn map(&self) -> &str {
        match self.map.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map(&mut self) {
        self.map = ::std::option::Option::None;
    }

    pub fn has_map(&self) -> bool {
        self.map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map(&mut self, v: ::std::string::String) {
        self.map = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map(&mut self) -> &mut ::std::string::String {
        if self.map.is_none() {
            self.map = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map.as_mut().unwrap()
    }

    // Take field
    pub fn take_map(&mut self) -> ::std::string::String {
        self.map.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tags = 4;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 bot_count = 5;

    pub fn bot_count(&self) -> u32 {
        self.bot_count.unwrap_or(0)
    }

    pub fn clear_bot_count(&mut self) {
        self.bot_count = ::std::option::Option::None;
    }

    pub fn has_bot_count(&self) -> bool {
        self.bot_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_count(&mut self, v: u32) {
        self.bot_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_spectators = 6;

    pub fn num_spectators(&self) -> u32 {
        self.num_spectators.unwrap_or(0)
    }

    pub fn clear_num_spectators(&mut self) {
        self.num_spectators = ::std::option::Option::None;
    }

    pub fn has_num_spectators(&self) -> bool {
        self.num_spectators.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_spectators(&mut self, v: u32) {
        self.num_spectators = ::std::option::Option::Some(v);
    }

    // optional uint32 max_players = 7;

    pub fn max_players(&self) -> u32 {
        self.max_players.unwrap_or(0)
    }

    pub fn clear_max_players(&mut self) {
        self.max_players = ::std::option::Option::None;
    }

    pub fn has_max_players(&self) -> bool {
        self.max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_players(&mut self, v: u32) {
        self.max_players = ::std::option::Option::Some(v);
    }

    // optional uint32 slots_free = 8;

    pub fn slots_free(&self) -> u32 {
        self.slots_free.unwrap_or(0)
    }

    pub fn clear_slots_free(&mut self) {
        self.slots_free = ::std::option::Option::None;
    }

    pub fn has_slots_free(&self) -> bool {
        self.slots_free.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slots_free(&mut self, v: u32) {
        self.slots_free = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 9;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 10;

    pub fn server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional bool server_trusted = 11;

    pub fn server_trusted(&self) -> bool {
        self.server_trusted.unwrap_or(false)
    }

    pub fn clear_server_trusted(&mut self) {
        self.server_trusted = ::std::option::Option::None;
    }

    pub fn has_server_trusted(&self) -> bool {
        self.server_trusted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_trusted(&mut self, v: bool) {
        self.server_trusted = ::std::option::Option::Some(v);
    }

    // optional bool server_dedicated = 12;

    pub fn server_dedicated(&self) -> bool {
        self.server_dedicated.unwrap_or(false)
    }

    pub fn clear_server_dedicated(&mut self) {
        self.server_dedicated = ::std::option::Option::None;
    }

    pub fn has_server_dedicated(&self) -> bool {
        self.server_dedicated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_dedicated(&mut self, v: bool) {
        self.server_dedicated = ::std::option::Option::Some(v);
    }

    // optional uint32 strict = 17;

    pub fn strict(&self) -> u32 {
        self.strict.unwrap_or(0)
    }

    pub fn clear_strict(&mut self) {
        self.strict = ::std::option::Option::None;
    }

    pub fn has_strict(&self) -> bool {
        self.strict.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strict(&mut self, v: u32) {
        self.strict = ::std::option::Option::Some(v);
    }

    // optional string fake_ip = 25;

    pub fn fake_ip(&self) -> &str {
        match self.fake_ip.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_fake_ip(&mut self) {
        self.fake_ip = ::std::option::Option::None;
    }

    pub fn has_fake_ip(&self) -> bool {
        self.fake_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fake_ip(&mut self, v: ::std::string::String) {
        self.fake_ip = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fake_ip(&mut self) -> &mut ::std::string::String {
        if self.fake_ip.is_none() {
            self.fake_ip = ::std::option::Option::Some(::std::string::String::new());
        }
        self.fake_ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_fake_ip(&mut self) -> ::std::string::String {
        self.fake_ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .TF_GC_GameState game_state = 14;

    pub fn game_state(&self) -> TF_GC_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            None => TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: TF_GC_GameState) {
        self.game_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .CMsgGameServerMatchmakingStatus.Event event = 15;

    pub fn event(&self) -> cmsg_game_server_matchmaking_status::Event {
        match self.event {
            Some(e) => e.enum_value_or(cmsg_game_server_matchmaking_status::Event::None),
            None => cmsg_game_server_matchmaking_status::Event::None,
        }
    }

    pub fn clear_event(&mut self) {
        self.event = ::std::option::Option::None;
    }

    pub fn has_event(&self) -> bool {
        self.event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event(&mut self, v: cmsg_game_server_matchmaking_status::Event) {
        self.event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 mvm_wave = 18;

    pub fn mvm_wave(&self) -> u32 {
        self.mvm_wave.unwrap_or(0)
    }

    pub fn clear_mvm_wave(&mut self) {
        self.mvm_wave = ::std::option::Option::None;
    }

    pub fn has_mvm_wave(&self) -> bool {
        self.mvm_wave.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_wave(&mut self, v: u32) {
        self.mvm_wave = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_acquired = 19;

    pub fn mvm_credits_acquired(&self) -> u32 {
        self.mvm_credits_acquired.unwrap_or(0)
    }

    pub fn clear_mvm_credits_acquired(&mut self) {
        self.mvm_credits_acquired = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_acquired(&self) -> bool {
        self.mvm_credits_acquired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_acquired(&mut self, v: u32) {
        self.mvm_credits_acquired = ::std::option::Option::Some(v);
    }

    // optional uint32 mvm_credits_dropped = 20;

    pub fn mvm_credits_dropped(&self) -> u32 {
        self.mvm_credits_dropped.unwrap_or(0)
    }

    pub fn clear_mvm_credits_dropped(&mut self) {
        self.mvm_credits_dropped = ::std::option::Option::None;
    }

    pub fn has_mvm_credits_dropped(&self) -> bool {
        self.mvm_credits_dropped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mvm_credits_dropped(&mut self, v: u32) {
        self.mvm_credits_dropped = ::std::option::Option::Some(v);
    }

    // optional sint32 match_group = 23;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(-1i32)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_mm_version = 24;

    pub fn lobby_mm_version(&self) -> u32 {
        self.lobby_mm_version.unwrap_or(0)
    }

    pub fn clear_lobby_mm_version(&mut self) {
        self.lobby_mm_version = ::std::option::Option::None;
    }

    pub fn has_lobby_mm_version(&self) -> bool {
        self.lobby_mm_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_mm_version(&mut self, v: u32) {
        self.lobby_mm_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerMatchmakingStatus {
    const NAME: &'static str = "CMsgGameServerMatchmakingStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                128 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    self.matchmaking_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.map = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.bot_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_spectators = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.slots_free = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                85 => {
                    self.server_loadavg = ::std::option::Option::Some(is.read_float()?);
                },
                88 => {
                    self.server_trusted = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.server_dedicated = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.strict = ::std::option::Option::Some(is.read_uint32()?);
                },
                202 => {
                    self.fake_ip = ::std::option::Option::Some(is.read_string()?);
                },
                106 => {
                    self.players.push(is.read_message()?);
                },
                112 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                120 => {
                    self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                144 => {
                    self.mvm_wave = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.mvm_credits_acquired = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.mvm_credits_dropped = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.match_group = ::std::option::Option::Some(is.read_sint32()?);
                },
                192 => {
                    self.lobby_mm_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.matchmaking_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.map.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.tags.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.bot_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_spectators {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.max_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.slots_free {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_trusted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_dedicated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.strict {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.fake_ip.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(25, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
        }
        if let Some(v) = self.event {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v.value());
        }
        if let Some(v) = self.mvm_wave {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.mvm_credits_acquired {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.mvm_credits_dropped {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(23, v);
        }
        if let Some(v) = self.lobby_mm_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.matchmaking_state {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.map.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.tags.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.bot_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_spectators {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.max_players {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.slots_free {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_trusted {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.server_dedicated {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.strict {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.fake_ip.as_ref() {
            os.write_string(25, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event {
            os.write_enum(15, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.mvm_wave {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.mvm_credits_acquired {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.mvm_credits_dropped {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_sint32(23, v)?;
        }
        if let Some(v) = self.lobby_mm_version {
            os.write_uint32(24, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerMatchmakingStatus {
        CMsgGameServerMatchmakingStatus::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.matchmaking_state = ::std::option::Option::None;
        self.map = ::std::option::Option::None;
        self.tags = ::std::option::Option::None;
        self.bot_count = ::std::option::Option::None;
        self.num_spectators = ::std::option::Option::None;
        self.max_players = ::std::option::Option::None;
        self.slots_free = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_trusted = ::std::option::Option::None;
        self.server_dedicated = ::std::option::Option::None;
        self.strict = ::std::option::Option::None;
        self.fake_ip = ::std::option::Option::None;
        self.players.clear();
        self.game_state = ::std::option::Option::None;
        self.event = ::std::option::Option::None;
        self.mvm_wave = ::std::option::Option::None;
        self.mvm_credits_acquired = ::std::option::Option::None;
        self.mvm_credits_dropped = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.lobby_mm_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerMatchmakingStatus {
        static instance: CMsgGameServerMatchmakingStatus = CMsgGameServerMatchmakingStatus {
            server_version: ::std::option::Option::None,
            matchmaking_state: ::std::option::Option::None,
            map: ::std::option::Option::None,
            tags: ::std::option::Option::None,
            bot_count: ::std::option::Option::None,
            num_spectators: ::std::option::Option::None,
            max_players: ::std::option::Option::None,
            slots_free: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            server_loadavg: ::std::option::Option::None,
            server_trusted: ::std::option::Option::None,
            server_dedicated: ::std::option::Option::None,
            strict: ::std::option::Option::None,
            fake_ip: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            game_state: ::std::option::Option::None,
            event: ::std::option::Option::None,
            mvm_wave: ::std::option::Option::None,
            mvm_credits_acquired: ::std::option::Option::None,
            mvm_credits_dropped: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            lobby_mm_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameServerMatchmakingStatus`
pub mod cmsg_game_server_matchmaking_status {
    // @@protoc_insertion_point(message:CMsgGameServerMatchmakingStatus.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGameServerMatchmakingStatus.Player.connect_state)
        pub connect_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<PlayerConnectState>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameServerMatchmakingStatus.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional .CMsgGameServerMatchmakingStatus.PlayerConnectState connect_state = 2;

        pub fn connect_state(&self) -> PlayerConnectState {
            match self.connect_state {
                Some(e) => e.enum_value_or(PlayerConnectState::INVALID),
                None => PlayerConnectState::INVALID,
            }
        }

        pub fn clear_connect_state(&mut self) {
            self.connect_state = ::std::option::Option::None;
        }

        pub fn has_connect_state(&self) -> bool {
            self.connect_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_state(&mut self, v: PlayerConnectState) {
            self.connect_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.connect_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.connect_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.connect_state {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.connect_state = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                connect_state: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerMatchmakingStatus.PlayerConnectState)
    pub enum PlayerConnectState {
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.CONNECTED)
        CONNECTED = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.PlayerConnectState.RESERVED)
        RESERVED = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for PlayerConnectState {
        const NAME: &'static str = "PlayerConnectState";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PlayerConnectState> {
            match value {
                0 => ::std::option::Option::Some(PlayerConnectState::INVALID),
                1 => ::std::option::Option::Some(PlayerConnectState::CONNECTED),
                2 => ::std::option::Option::Some(PlayerConnectState::RESERVED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PlayerConnectState> {
            match str {
                "INVALID" => ::std::option::Option::Some(PlayerConnectState::INVALID),
                "CONNECTED" => ::std::option::Option::Some(PlayerConnectState::CONNECTED),
                "RESERVED" => ::std::option::Option::Some(PlayerConnectState::RESERVED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PlayerConnectState] = &[
            PlayerConnectState::INVALID,
            PlayerConnectState::CONNECTED,
            PlayerConnectState::RESERVED,
        ];
    }

    impl ::std::default::Default for PlayerConnectState {
        fn default() -> Self {
            PlayerConnectState::INVALID
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerMatchmakingStatus.Event)
    pub enum Event {
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.None)
        None = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.MvMVictory)
        MvMVictory = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.MvMDefeat)
        MvMDefeat = 2,
        // @@protoc_insertion_point(enum_value:CMsgGameServerMatchmakingStatus.Event.AcknowledgePlayers)
        AcknowledgePlayers = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Event {
        const NAME: &'static str = "Event";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Event> {
            match value {
                0 => ::std::option::Option::Some(Event::None),
                1 => ::std::option::Option::Some(Event::MvMVictory),
                2 => ::std::option::Option::Some(Event::MvMDefeat),
                3 => ::std::option::Option::Some(Event::AcknowledgePlayers),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Event> {
            match str {
                "None" => ::std::option::Option::Some(Event::None),
                "MvMVictory" => ::std::option::Option::Some(Event::MvMVictory),
                "MvMDefeat" => ::std::option::Option::Some(Event::MvMDefeat),
                "AcknowledgePlayers" => ::std::option::Option::Some(Event::AcknowledgePlayers),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Event] = &[
            Event::None,
            Event::MvMVictory,
            Event::MvMDefeat,
            Event::AcknowledgePlayers,
        ];
    }

    impl ::std::default::Default for Event {
        fn default() -> Self {
            Event::None
        }
    }

}

// @@protoc_insertion_point(message:CMsgMatchmakingProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.avg_wait_time_new)
    pub avg_wait_time_new: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.avg_wait_time_join_late)
    pub avg_wait_time_join_late: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.your_wait_time)
    pub your_wait_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_searching_players)
    pub matching_worldwide_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_searching_players)
    pub matching_near_you_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_searching_players)
    pub total_worldwide_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_searching_players)
    pub total_near_you_searching_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_active_players)
    pub matching_worldwide_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_active_players)
    pub matching_near_you_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_active_players)
    pub total_worldwide_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_active_players)
    pub total_near_you_active_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_worldwide_empty_gameservers)
    pub matching_worldwide_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.matching_near_you_empty_gameservers)
    pub matching_near_you_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_worldwide_empty_gameservers)
    pub total_worldwide_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.total_near_you_empty_gameservers)
    pub total_near_you_empty_gameservers: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingProgress.urgency_pct)
    pub urgency_pct: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingProgress {
    fn default() -> &'a CMsgMatchmakingProgress {
        <CMsgMatchmakingProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingProgress {
    pub fn new() -> CMsgMatchmakingProgress {
        ::std::default::Default::default()
    }

    // optional uint32 avg_wait_time_new = 4;

    pub fn avg_wait_time_new(&self) -> u32 {
        self.avg_wait_time_new.unwrap_or(0)
    }

    pub fn clear_avg_wait_time_new(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_new(&self) -> bool {
        self.avg_wait_time_new.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_new(&mut self, v: u32) {
        self.avg_wait_time_new = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_wait_time_join_late = 5;

    pub fn avg_wait_time_join_late(&self) -> u32 {
        self.avg_wait_time_join_late.unwrap_or(0)
    }

    pub fn clear_avg_wait_time_join_late(&mut self) {
        self.avg_wait_time_join_late = ::std::option::Option::None;
    }

    pub fn has_avg_wait_time_join_late(&self) -> bool {
        self.avg_wait_time_join_late.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_wait_time_join_late(&mut self, v: u32) {
        self.avg_wait_time_join_late = ::std::option::Option::Some(v);
    }

    // optional uint32 your_wait_time = 6;

    pub fn your_wait_time(&self) -> u32 {
        self.your_wait_time.unwrap_or(0)
    }

    pub fn clear_your_wait_time(&mut self) {
        self.your_wait_time = ::std::option::Option::None;
    }

    pub fn has_your_wait_time(&self) -> bool {
        self.your_wait_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_your_wait_time(&mut self, v: u32) {
        self.your_wait_time = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_searching_players = 8;

    pub fn matching_worldwide_searching_players(&self) -> u32 {
        self.matching_worldwide_searching_players.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_searching_players(&mut self) {
        self.matching_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_searching_players(&self) -> bool {
        self.matching_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_searching_players(&mut self, v: u32) {
        self.matching_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_searching_players = 9;

    pub fn matching_near_you_searching_players(&self) -> u32 {
        self.matching_near_you_searching_players.unwrap_or(0)
    }

    pub fn clear_matching_near_you_searching_players(&mut self) {
        self.matching_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_searching_players(&self) -> bool {
        self.matching_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_searching_players(&mut self, v: u32) {
        self.matching_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_searching_players = 13;

    pub fn total_worldwide_searching_players(&self) -> u32 {
        self.total_worldwide_searching_players.unwrap_or(0)
    }

    pub fn clear_total_worldwide_searching_players(&mut self) {
        self.total_worldwide_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_searching_players(&self) -> bool {
        self.total_worldwide_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_searching_players(&mut self, v: u32) {
        self.total_worldwide_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_searching_players = 14;

    pub fn total_near_you_searching_players(&self) -> u32 {
        self.total_near_you_searching_players.unwrap_or(0)
    }

    pub fn clear_total_near_you_searching_players(&mut self) {
        self.total_near_you_searching_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_searching_players(&self) -> bool {
        self.total_near_you_searching_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_searching_players(&mut self, v: u32) {
        self.total_near_you_searching_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_active_players = 15;

    pub fn matching_worldwide_active_players(&self) -> u32 {
        self.matching_worldwide_active_players.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_active_players(&mut self) {
        self.matching_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_active_players(&self) -> bool {
        self.matching_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_active_players(&mut self, v: u32) {
        self.matching_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_active_players = 16;

    pub fn matching_near_you_active_players(&self) -> u32 {
        self.matching_near_you_active_players.unwrap_or(0)
    }

    pub fn clear_matching_near_you_active_players(&mut self) {
        self.matching_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_active_players(&self) -> bool {
        self.matching_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_active_players(&mut self, v: u32) {
        self.matching_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_active_players = 17;

    pub fn total_worldwide_active_players(&self) -> u32 {
        self.total_worldwide_active_players.unwrap_or(0)
    }

    pub fn clear_total_worldwide_active_players(&mut self) {
        self.total_worldwide_active_players = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_active_players(&self) -> bool {
        self.total_worldwide_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_active_players(&mut self, v: u32) {
        self.total_worldwide_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_active_players = 18;

    pub fn total_near_you_active_players(&self) -> u32 {
        self.total_near_you_active_players.unwrap_or(0)
    }

    pub fn clear_total_near_you_active_players(&mut self) {
        self.total_near_you_active_players = ::std::option::Option::None;
    }

    pub fn has_total_near_you_active_players(&self) -> bool {
        self.total_near_you_active_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_active_players(&mut self, v: u32) {
        self.total_near_you_active_players = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_worldwide_empty_gameservers = 19;

    pub fn matching_worldwide_empty_gameservers(&self) -> u32 {
        self.matching_worldwide_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_matching_worldwide_empty_gameservers(&mut self) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_worldwide_empty_gameservers(&self) -> bool {
        self.matching_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_worldwide_empty_gameservers(&mut self, v: u32) {
        self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 matching_near_you_empty_gameservers = 20;

    pub fn matching_near_you_empty_gameservers(&self) -> u32 {
        self.matching_near_you_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_matching_near_you_empty_gameservers(&mut self) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_matching_near_you_empty_gameservers(&self) -> bool {
        self.matching_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matching_near_you_empty_gameservers(&mut self, v: u32) {
        self.matching_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_worldwide_empty_gameservers = 21;

    pub fn total_worldwide_empty_gameservers(&self) -> u32 {
        self.total_worldwide_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_total_worldwide_empty_gameservers(&mut self) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_worldwide_empty_gameservers(&self) -> bool {
        self.total_worldwide_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_worldwide_empty_gameservers(&mut self, v: u32) {
        self.total_worldwide_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 total_near_you_empty_gameservers = 22;

    pub fn total_near_you_empty_gameservers(&self) -> u32 {
        self.total_near_you_empty_gameservers.unwrap_or(0)
    }

    pub fn clear_total_near_you_empty_gameservers(&mut self) {
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
    }

    pub fn has_total_near_you_empty_gameservers(&self) -> bool {
        self.total_near_you_empty_gameservers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_near_you_empty_gameservers(&mut self, v: u32) {
        self.total_near_you_empty_gameservers = ::std::option::Option::Some(v);
    }

    // optional uint32 urgency_pct = 1;

    pub fn urgency_pct(&self) -> u32 {
        self.urgency_pct.unwrap_or(0)
    }

    pub fn clear_urgency_pct(&mut self) {
        self.urgency_pct = ::std::option::Option::None;
    }

    pub fn has_urgency_pct(&self) -> bool {
        self.urgency_pct.is_some()
    }

    // Param is passed by value, moved
    pub fn set_urgency_pct(&mut self, v: u32) {
        self.urgency_pct = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchmakingProgress {
    const NAME: &'static str = "CMsgMatchmakingProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                32 => {
                    self.avg_wait_time_new = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.avg_wait_time_join_late = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.your_wait_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.matching_worldwide_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.matching_near_you_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.total_worldwide_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.total_near_you_searching_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.matching_worldwide_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.matching_near_you_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.total_worldwide_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.total_near_you_active_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.matching_worldwide_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.matching_near_you_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.total_worldwide_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.total_near_you_empty_gameservers = ::std::option::Option::Some(is.read_uint32()?);
                },
                8 => {
                    self.urgency_pct = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.avg_wait_time_new {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.avg_wait_time_join_late {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.your_wait_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.matching_near_you_searching_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.total_worldwide_searching_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.total_near_you_searching_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.matching_worldwide_active_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.matching_near_you_active_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.total_worldwide_active_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.total_near_you_active_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.urgency_pct {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.avg_wait_time_new {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_wait_time_join_late {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.your_wait_time {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matching_worldwide_searching_players {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.matching_near_you_searching_players {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.total_worldwide_searching_players {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.total_near_you_searching_players {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.matching_worldwide_active_players {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.matching_near_you_active_players {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.total_worldwide_active_players {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.total_near_you_active_players {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.matching_worldwide_empty_gameservers {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.matching_near_you_empty_gameservers {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.total_worldwide_empty_gameservers {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.total_near_you_empty_gameservers {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.urgency_pct {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingProgress {
        CMsgMatchmakingProgress::new()
    }

    fn clear(&mut self) {
        self.avg_wait_time_new = ::std::option::Option::None;
        self.avg_wait_time_join_late = ::std::option::Option::None;
        self.your_wait_time = ::std::option::Option::None;
        self.matching_worldwide_searching_players = ::std::option::Option::None;
        self.matching_near_you_searching_players = ::std::option::Option::None;
        self.total_worldwide_searching_players = ::std::option::Option::None;
        self.total_near_you_searching_players = ::std::option::Option::None;
        self.matching_worldwide_active_players = ::std::option::Option::None;
        self.matching_near_you_active_players = ::std::option::Option::None;
        self.total_worldwide_active_players = ::std::option::Option::None;
        self.total_near_you_active_players = ::std::option::Option::None;
        self.matching_worldwide_empty_gameservers = ::std::option::Option::None;
        self.matching_near_you_empty_gameservers = ::std::option::Option::None;
        self.total_worldwide_empty_gameservers = ::std::option::Option::None;
        self.total_near_you_empty_gameservers = ::std::option::Option::None;
        self.urgency_pct = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingProgress {
        static instance: CMsgMatchmakingProgress = CMsgMatchmakingProgress {
            avg_wait_time_new: ::std::option::Option::None,
            avg_wait_time_join_late: ::std::option::Option::None,
            your_wait_time: ::std::option::Option::None,
            matching_worldwide_searching_players: ::std::option::Option::None,
            matching_near_you_searching_players: ::std::option::Option::None,
            total_worldwide_searching_players: ::std::option::Option::None,
            total_near_you_searching_players: ::std::option::Option::None,
            matching_worldwide_active_players: ::std::option::Option::None,
            matching_near_you_active_players: ::std::option::Option::None,
            total_worldwide_active_players: ::std::option::Option::None,
            total_near_you_active_players: ::std::option::Option::None,
            matching_worldwide_empty_gameservers: ::std::option::Option::None,
            matching_near_you_empty_gameservers: ::std::option::Option::None,
            total_worldwide_empty_gameservers: ::std::option::Option::None,
            total_near_you_empty_gameservers: ::std::option::Option::None,
            urgency_pct: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMvMVictoryInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMVictoryInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.players)
    pub players: ::std::vec::Vec<cmsg_mv_mvictory_info::Player>,
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.tour_name)
    pub tour_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictoryInfo {
    fn default() -> &'a CMsgMvMVictoryInfo {
        <CMsgMvMVictoryInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictoryInfo {
    pub fn new() -> CMsgMvMVictoryInfo {
        ::std::default::Default::default()
    }

    // optional string tour_name = 2;

    pub fn tour_name(&self) -> &str {
        match self.tour_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tour_name(&mut self) {
        self.tour_name = ::std::option::Option::None;
    }

    pub fn has_tour_name(&self) -> bool {
        self.tour_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name(&mut self, v: ::std::string::String) {
        self.tour_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name(&mut self) -> &mut ::std::string::String {
        if self.tour_name.is_none() {
            self.tour_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tour_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name(&mut self) -> ::std::string::String {
        self.tour_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 3;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMvMVictoryInfo {
    const NAME: &'static str = "CMsgMvMVictoryInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                18 => {
                    self.tour_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.tour_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.tour_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMVictoryInfo {
        CMsgMvMVictoryInfo::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.tour_name = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMVictoryInfo {
        static instance: CMsgMvMVictoryInfo = CMsgMvMVictoryInfo {
            players: ::std::vec::Vec::new(),
            tour_name: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMvMVictoryInfo`
pub mod cmsg_mv_mvictory_info {
    // @@protoc_insertion_point(message:CMsgMvMVictoryInfo.Item)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Item {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.grant_reason)
        pub grant_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<GrantReason>>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.item_data)
        pub item_data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Item.squad_surplus_claimer_steam_id)
        pub squad_surplus_claimer_steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.Item.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Item {
        fn default() -> &'a Item {
            <Item as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Item {
        pub fn new() -> Item {
            ::std::default::Default::default()
        }

        // optional .CMsgMvMVictoryInfo.GrantReason grant_reason = 1;

        pub fn grant_reason(&self) -> GrantReason {
            match self.grant_reason {
                Some(e) => e.enum_value_or(GrantReason::INVALID),
                None => GrantReason::INVALID,
            }
        }

        pub fn clear_grant_reason(&mut self) {
            self.grant_reason = ::std::option::Option::None;
        }

        pub fn has_grant_reason(&self) -> bool {
            self.grant_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_grant_reason(&mut self, v: GrantReason) {
            self.grant_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional bytes item_data = 2;

        pub fn item_data(&self) -> &[u8] {
            match self.item_data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_item_data(&mut self) {
            self.item_data = ::std::option::Option::None;
        }

        pub fn has_item_data(&self) -> bool {
            self.item_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.item_data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_item_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.item_data.is_none() {
                self.item_data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.item_data.as_mut().unwrap()
        }

        // Take field
        pub fn take_item_data(&mut self) -> ::std::vec::Vec<u8> {
            self.item_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional fixed64 squad_surplus_claimer_steam_id = 3;

        pub fn squad_surplus_claimer_steam_id(&self) -> u64 {
            self.squad_surplus_claimer_steam_id.unwrap_or(0)
        }

        pub fn clear_squad_surplus_claimer_steam_id(&mut self) {
            self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
        }

        pub fn has_squad_surplus_claimer_steam_id(&self) -> bool {
            self.squad_surplus_claimer_steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_squad_surplus_claimer_steam_id(&mut self, v: u64) {
            self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Item {
        const NAME: &'static str = "Item";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.grant_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    18 => {
                        self.item_data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    25 => {
                        self.squad_surplus_claimer_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.grant_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.item_data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            if let Some(v) = self.squad_surplus_claimer_steam_id {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.grant_reason {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.item_data.as_ref() {
                os.write_bytes(2, v)?;
            }
            if let Some(v) = self.squad_surplus_claimer_steam_id {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Item {
            Item::new()
        }

        fn clear(&mut self) {
            self.grant_reason = ::std::option::Option::None;
            self.item_data = ::std::option::Option::None;
            self.squad_surplus_claimer_steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Item {
            static instance: Item = Item {
                grant_reason: ::std::option::Option::None,
                item_data: ::std::option::Option::None,
                squad_surplus_claimer_steam_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgMvMVictoryInfo.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_granted)
        pub badge_granted: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_progress_updated)
        pub badge_progress_updated: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_leveled)
        pub badge_leveled: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_level)
        pub badge_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_progress_bits)
        pub badge_progress_bits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.items)
        pub items: ::std::vec::Vec<Item>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.voucher_missing)
        pub voucher_missing: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMvMVictoryInfo.Player.badge_points)
        pub badge_points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictoryInfo.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool badge_granted = 3;

        pub fn badge_granted(&self) -> bool {
            self.badge_granted.unwrap_or(false)
        }

        pub fn clear_badge_granted(&mut self) {
            self.badge_granted = ::std::option::Option::None;
        }

        pub fn has_badge_granted(&self) -> bool {
            self.badge_granted.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_granted(&mut self, v: bool) {
            self.badge_granted = ::std::option::Option::Some(v);
        }

        // optional bool badge_progress_updated = 4;

        pub fn badge_progress_updated(&self) -> bool {
            self.badge_progress_updated.unwrap_or(false)
        }

        pub fn clear_badge_progress_updated(&mut self) {
            self.badge_progress_updated = ::std::option::Option::None;
        }

        pub fn has_badge_progress_updated(&self) -> bool {
            self.badge_progress_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_progress_updated(&mut self, v: bool) {
            self.badge_progress_updated = ::std::option::Option::Some(v);
        }

        // optional bool badge_leveled = 5;

        pub fn badge_leveled(&self) -> bool {
            self.badge_leveled.unwrap_or(false)
        }

        pub fn clear_badge_leveled(&mut self) {
            self.badge_leveled = ::std::option::Option::None;
        }

        pub fn has_badge_leveled(&self) -> bool {
            self.badge_leveled.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_leveled(&mut self, v: bool) {
            self.badge_leveled = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_level = 6;

        pub fn badge_level(&self) -> u32 {
            self.badge_level.unwrap_or(0)
        }

        pub fn clear_badge_level(&mut self) {
            self.badge_level = ::std::option::Option::None;
        }

        pub fn has_badge_level(&self) -> bool {
            self.badge_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_level(&mut self, v: u32) {
            self.badge_level = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_progress_bits = 7;

        pub fn badge_progress_bits(&self) -> u32 {
            self.badge_progress_bits.unwrap_or(0)
        }

        pub fn clear_badge_progress_bits(&mut self) {
            self.badge_progress_bits = ::std::option::Option::None;
        }

        pub fn has_badge_progress_bits(&self) -> bool {
            self.badge_progress_bits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_progress_bits(&mut self, v: u32) {
            self.badge_progress_bits = ::std::option::Option::Some(v);
        }

        // optional bool voucher_missing = 9;

        pub fn voucher_missing(&self) -> bool {
            self.voucher_missing.unwrap_or(false)
        }

        pub fn clear_voucher_missing(&mut self) {
            self.voucher_missing = ::std::option::Option::None;
        }

        pub fn has_voucher_missing(&self) -> bool {
            self.voucher_missing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voucher_missing(&mut self, v: bool) {
            self.voucher_missing = ::std::option::Option::Some(v);
        }

        // optional uint32 badge_points = 10;

        pub fn badge_points(&self) -> u32 {
            self.badge_points.unwrap_or(0)
        }

        pub fn clear_badge_points(&mut self) {
            self.badge_points = ::std::option::Option::None;
        }

        pub fn has_badge_points(&self) -> bool {
            self.badge_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_badge_points(&mut self, v: u32) {
            self.badge_points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    24 => {
                        self.badge_granted = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.badge_progress_updated = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.badge_leveled = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.badge_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.badge_progress_bits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    66 => {
                        self.items.push(is.read_message()?);
                    },
                    72 => {
                        self.voucher_missing = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.badge_points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.badge_granted {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_progress_updated {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_leveled {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.badge_progress_bits {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            for value in &self.items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.voucher_missing {
                my_size += 1 + 1;
            }
            if let Some(v) = self.badge_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.badge_granted {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.badge_progress_updated {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.badge_leveled {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.badge_level {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.badge_progress_bits {
                os.write_uint32(7, v)?;
            }
            for v in &self.items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
            };
            if let Some(v) = self.voucher_missing {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.badge_points {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.badge_granted = ::std::option::Option::None;
            self.badge_progress_updated = ::std::option::Option::None;
            self.badge_leveled = ::std::option::Option::None;
            self.badge_level = ::std::option::Option::None;
            self.badge_progress_bits = ::std::option::Option::None;
            self.items.clear();
            self.voucher_missing = ::std::option::Option::None;
            self.badge_points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                badge_granted: ::std::option::Option::None,
                badge_progress_updated: ::std::option::Option::None,
                badge_leveled: ::std::option::Option::None,
                badge_level: ::std::option::Option::None,
                badge_progress_bits: ::std::option::Option::None,
                items: ::std::vec::Vec::new(),
                voucher_missing: ::std::option::Option::None,
                badge_points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgMvMVictoryInfo.GrantReason)
    pub enum GrantReason {
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.BADGE_LEVELED)
        BADGE_LEVELED = 1,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.SQUAD_SURPLUS)
        SQUAD_SURPLUS = 2,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.MANN_UP)
        MANN_UP = 3,
        // @@protoc_insertion_point(enum_value:CMsgMvMVictoryInfo.GrantReason.HELP_A_NOOB)
        HELP_A_NOOB = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for GrantReason {
        const NAME: &'static str = "GrantReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<GrantReason> {
            match value {
                0 => ::std::option::Option::Some(GrantReason::INVALID),
                1 => ::std::option::Option::Some(GrantReason::BADGE_LEVELED),
                2 => ::std::option::Option::Some(GrantReason::SQUAD_SURPLUS),
                3 => ::std::option::Option::Some(GrantReason::MANN_UP),
                4 => ::std::option::Option::Some(GrantReason::HELP_A_NOOB),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<GrantReason> {
            match str {
                "INVALID" => ::std::option::Option::Some(GrantReason::INVALID),
                "BADGE_LEVELED" => ::std::option::Option::Some(GrantReason::BADGE_LEVELED),
                "SQUAD_SURPLUS" => ::std::option::Option::Some(GrantReason::SQUAD_SURPLUS),
                "MANN_UP" => ::std::option::Option::Some(GrantReason::MANN_UP),
                "HELP_A_NOOB" => ::std::option::Option::Some(GrantReason::HELP_A_NOOB),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [GrantReason] = &[
            GrantReason::INVALID,
            GrantReason::BADGE_LEVELED,
            GrantReason::SQUAD_SURPLUS,
            GrantReason::MANN_UP,
            GrantReason::HELP_A_NOOB,
        ];
    }

    impl ::std::default::Default for GrantReason {
        fn default() -> Self {
            GrantReason::INVALID
        }
    }

}

// @@protoc_insertion_point(message:CGCMsgTFHelloResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFHelloResponse {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_check)
    pub version_check: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_checksum)
    pub version_checksum: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CGCMsgTFHelloResponse.version_verbose)
    pub version_verbose: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFHelloResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFHelloResponse {
    fn default() -> &'a CGCMsgTFHelloResponse {
        <CGCMsgTFHelloResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFHelloResponse {
    pub fn new() -> CGCMsgTFHelloResponse {
        ::std::default::Default::default()
    }

    // optional uint32 version_check = 1;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // optional uint32 version_verbose = 3;

    pub fn version_verbose(&self) -> u32 {
        self.version_verbose.unwrap_or(0)
    }

    pub fn clear_version_verbose(&mut self) {
        self.version_verbose = ::std::option::Option::None;
    }

    pub fn has_version_verbose(&self) -> bool {
        self.version_verbose.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_verbose(&mut self, v: u32) {
        self.version_verbose = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgTFHelloResponse {
    const NAME: &'static str = "CGCMsgTFHelloResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.version_checksum)?;
                },
                16 => {
                    self.version_checksum.push(is.read_uint64()?);
                },
                24 => {
                    self.version_verbose = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_check {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.version_checksum {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        if let Some(v) = self.version_verbose {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version_check {
            os.write_uint32(1, v)?;
        }
        for v in &self.version_checksum {
            os.write_uint64(2, *v)?;
        };
        if let Some(v) = self.version_verbose {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFHelloResponse {
        CGCMsgTFHelloResponse::new()
    }

    fn clear(&mut self) {
        self.version_check = ::std::option::Option::None;
        self.version_checksum.clear();
        self.version_verbose = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFHelloResponse {
        static instance: CGCMsgTFHelloResponse = CGCMsgTFHelloResponse {
            version_check: ::std::option::Option::None,
            version_checksum: ::std::vec::Vec::new(),
            version_verbose: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgTFSync)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFSync {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_checksum)
    pub version_checksum: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check)
    pub version_check: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check_ex)
    pub version_check_ex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_check_ex2)
    pub version_check_ex2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgTFSync.version_checksum_ex)
    pub version_checksum_ex: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFSync.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSync {
    fn default() -> &'a CGCMsgTFSync {
        <CGCMsgTFSync as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSync {
    pub fn new() -> CGCMsgTFSync {
        ::std::default::Default::default()
    }

    // optional bytes version_checksum = 1;

    pub fn version_checksum(&self) -> &[u8] {
        match self.version_checksum.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum(&mut self) {
        self.version_checksum = ::std::option::Option::None;
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum.is_none() {
            self.version_checksum = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 2;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex = 3;

    pub fn version_check_ex(&self) -> u32 {
        self.version_check_ex.unwrap_or(0)
    }

    pub fn clear_version_check_ex(&mut self) {
        self.version_check_ex = ::std::option::Option::None;
    }

    pub fn has_version_check_ex(&self) -> bool {
        self.version_check_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex(&mut self, v: u32) {
        self.version_check_ex = ::std::option::Option::Some(v);
    }

    // optional uint32 version_check_ex2 = 4;

    pub fn version_check_ex2(&self) -> u32 {
        self.version_check_ex2.unwrap_or(0)
    }

    pub fn clear_version_check_ex2(&mut self) {
        self.version_check_ex2 = ::std::option::Option::None;
    }

    pub fn has_version_check_ex2(&self) -> bool {
        self.version_check_ex2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check_ex2(&mut self, v: u32) {
        self.version_check_ex2 = ::std::option::Option::Some(v);
    }

    // optional bytes version_checksum_ex = 5;

    pub fn version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex = ::std::option::Option::None;
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgTFSync {
    const NAME: &'static str = "CGCMsgTFSync";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_checksum = ::std::option::Option::Some(is.read_bytes()?);
                },
                16 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.version_check_ex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.version_check_ex2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.version_checksum_ex = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_checksum.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.version_check_ex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.version_check_ex2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version_checksum.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.version_check_ex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.version_check_ex2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFSync {
        CGCMsgTFSync::new()
    }

    fn clear(&mut self) {
        self.version_checksum = ::std::option::Option::None;
        self.version_check = ::std::option::Option::None;
        self.version_check_ex = ::std::option::Option::None;
        self.version_check_ex2 = ::std::option::Option::None;
        self.version_checksum_ex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFSync {
        static instance: CGCMsgTFSync = CGCMsgTFSync {
            version_checksum: ::std::option::Option::None,
            version_check: ::std::option::Option::None,
            version_check_ex: ::std::option::Option::None,
            version_check_ex2: ::std::option::Option::None,
            version_checksum_ex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgTFSyncEx)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgTFSyncEx {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_checksum)
    pub version_checksum: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_checksum_ex)
    pub version_checksum_ex: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgTFSyncEx.version_check)
    pub version_check: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgTFSyncEx.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgTFSyncEx {
    fn default() -> &'a CGCMsgTFSyncEx {
        <CGCMsgTFSyncEx as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgTFSyncEx {
    pub fn new() -> CGCMsgTFSyncEx {
        ::std::default::Default::default()
    }

    // optional string version_checksum = 1;

    pub fn version_checksum(&self) -> &str {
        match self.version_checksum.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_version_checksum(&mut self) {
        self.version_checksum = ::std::option::Option::None;
    }

    pub fn has_version_checksum(&self) -> bool {
        self.version_checksum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum(&mut self, v: ::std::string::String) {
        self.version_checksum = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum(&mut self) -> &mut ::std::string::String {
        if self.version_checksum.is_none() {
            self.version_checksum = ::std::option::Option::Some(::std::string::String::new());
        }
        self.version_checksum.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum(&mut self) -> ::std::string::String {
        self.version_checksum.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes version_checksum_ex = 2;

    pub fn version_checksum_ex(&self) -> &[u8] {
        match self.version_checksum_ex.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_version_checksum_ex(&mut self) {
        self.version_checksum_ex = ::std::option::Option::None;
    }

    pub fn has_version_checksum_ex(&self) -> bool {
        self.version_checksum_ex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_checksum_ex(&mut self, v: ::std::vec::Vec<u8>) {
        self.version_checksum_ex = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_checksum_ex(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.version_checksum_ex.is_none() {
            self.version_checksum_ex = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.version_checksum_ex.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_checksum_ex(&mut self) -> ::std::vec::Vec<u8> {
        self.version_checksum_ex.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 version_check = 3;

    pub fn version_check(&self) -> u32 {
        self.version_check.unwrap_or(0)
    }

    pub fn clear_version_check(&mut self) {
        self.version_check = ::std::option::Option::None;
    }

    pub fn has_version_check(&self) -> bool {
        self.version_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_check(&mut self, v: u32) {
        self.version_check = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgTFSyncEx {
    const NAME: &'static str = "CGCMsgTFSyncEx";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.version_checksum = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.version_checksum_ex = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.version_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version_checksum.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.version_check {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version_checksum.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.version_checksum_ex.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.version_check {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgTFSyncEx {
        CGCMsgTFSyncEx::new()
    }

    fn clear(&mut self) {
        self.version_checksum = ::std::option::Option::None;
        self.version_checksum_ex = ::std::option::Option::None;
        self.version_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgTFSyncEx {
        static instance: CGCMsgTFSyncEx = CGCMsgTFSyncEx {
            version_checksum: ::std::option::Option::None,
            version_checksum_ex: ::std::option::Option::None,
            version_check: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgMvMVictory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMVictory {
    // message fields
    // @@protoc_insertion_point(field:CMsgMvMVictory.legacy_mission_index)
    pub legacy_mission_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.tour_name_mannup)
    pub tour_name_mannup: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.mission_name)
    pub mission_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.players)
    pub players: ::std::vec::Vec<cmsg_mv_mvictory::Player>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgMvMVictory.event_time)
    pub event_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMVictory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMVictory {
    fn default() -> &'a CMsgMvMVictory {
        <CMsgMvMVictory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMVictory {
    pub fn new() -> CMsgMvMVictory {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_mission_index = 1;

    pub fn legacy_mission_index(&self) -> u32 {
        self.legacy_mission_index.unwrap_or(0)
    }

    pub fn clear_legacy_mission_index(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
    }

    pub fn has_legacy_mission_index(&self) -> bool {
        self.legacy_mission_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_mission_index(&mut self, v: u32) {
        self.legacy_mission_index = ::std::option::Option::Some(v);
    }

    // optional string tour_name_mannup = 5;

    pub fn tour_name_mannup(&self) -> &str {
        match self.tour_name_mannup.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tour_name_mannup(&mut self) {
        self.tour_name_mannup = ::std::option::Option::None;
    }

    pub fn has_tour_name_mannup(&self) -> bool {
        self.tour_name_mannup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tour_name_mannup(&mut self, v: ::std::string::String) {
        self.tour_name_mannup = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tour_name_mannup(&mut self) -> &mut ::std::string::String {
        if self.tour_name_mannup.is_none() {
            self.tour_name_mannup = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tour_name_mannup.as_mut().unwrap()
    }

    // Take field
    pub fn take_tour_name_mannup(&mut self) -> ::std::string::String {
        self.tour_name_mannup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mission_name = 6;

    pub fn mission_name(&self) -> &str {
        match self.mission_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_mission_name(&mut self) {
        self.mission_name = ::std::option::Option::None;
    }

    pub fn has_mission_name(&self) -> bool {
        self.mission_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mission_name(&mut self, v: ::std::string::String) {
        self.mission_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mission_name(&mut self) -> &mut ::std::string::String {
        if self.mission_name.is_none() {
            self.mission_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.mission_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_mission_name(&mut self) -> ::std::string::String {
        self.mission_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 event_time = 4;

    pub fn event_time(&self) -> u32 {
        self.event_time.unwrap_or(0)
    }

    pub fn clear_event_time(&mut self) {
        self.event_time = ::std::option::Option::None;
    }

    pub fn has_event_time(&self) -> bool {
        self.event_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_time(&mut self, v: u32) {
        self.event_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMvMVictory {
    const NAME: &'static str = "CMsgMvMVictory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_mission_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.tour_name_mannup = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.mission_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                37 => {
                    self.event_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_mission_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tour_name_mannup.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.mission_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.event_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_mission_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tour_name_mannup.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.mission_name.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.event_time {
            os.write_fixed32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMVictory {
        CMsgMvMVictory::new()
    }

    fn clear(&mut self) {
        self.legacy_mission_index = ::std::option::Option::None;
        self.tour_name_mannup = ::std::option::Option::None;
        self.mission_name = ::std::option::Option::None;
        self.players.clear();
        self.lobby_id = ::std::option::Option::None;
        self.event_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMVictory {
        static instance: CMsgMvMVictory = CMsgMvMVictory {
            legacy_mission_index: ::std::option::Option::None,
            tour_name_mannup: ::std::option::Option::None,
            mission_name: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            lobby_id: ::std::option::Option::None,
            event_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMvMVictory`
pub mod cmsg_mv_mvictory {
    // @@protoc_insertion_point(message:CMsgMvMVictory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgMvMVictory.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgMvMVictory.Player.squad_surplus)
        pub squad_surplus: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMvMVictory.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool squad_surplus = 2;

        pub fn squad_surplus(&self) -> bool {
            self.squad_surplus.unwrap_or(false)
        }

        pub fn clear_squad_surplus(&mut self) {
            self.squad_surplus = ::std::option::Option::None;
        }

        pub fn has_squad_surplus(&self) -> bool {
            self.squad_surplus.is_some()
        }

        // Param is passed by value, moved
        pub fn set_squad_surplus(&mut self, v: bool) {
            self.squad_surplus = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.squad_surplus = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.squad_surplus {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.squad_surplus {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.squad_surplus = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                squad_surplus: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMvMMannUpVictoryReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMvMMannUpVictoryReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMvMMannUpVictoryReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMvMMannUpVictoryReply {
    fn default() -> &'a CMsgMvMMannUpVictoryReply {
        <CMsgMvMMannUpVictoryReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMvMMannUpVictoryReply {
    pub fn new() -> CMsgMvMMannUpVictoryReply {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMvMMannUpVictoryReply {
    const NAME: &'static str = "CMsgMvMMannUpVictoryReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMvMMannUpVictoryReply {
        CMsgMvMMannUpVictoryReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMvMMannUpVictoryReply {
        static instance: CMsgMvMMannUpVictoryReply = CMsgMvMMannUpVictoryReply {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerKickingLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerKickingLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerKickingLobby.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerKickingLobby.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerKickingLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobby {
    fn default() -> &'a CMsgGameServerKickingLobby {
        <CMsgGameServerKickingLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobby {
    pub fn new() -> CMsgGameServerKickingLobby {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerKickingLobby {
    const NAME: &'static str = "CMsgGameServerKickingLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerKickingLobby {
        CMsgGameServerKickingLobby::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobby {
        static instance: CMsgGameServerKickingLobby = CMsgGameServerKickingLobby {
            lobby_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerKickingLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerKickingLobbyResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerKickingLobbyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerKickingLobbyResponse {
    fn default() -> &'a CMsgGameServerKickingLobbyResponse {
        <CMsgGameServerKickingLobbyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerKickingLobbyResponse {
    pub fn new() -> CMsgGameServerKickingLobbyResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerKickingLobbyResponse {
    const NAME: &'static str = "CMsgGameServerKickingLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerKickingLobbyResponse {
        CMsgGameServerKickingLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerKickingLobbyResponse {
        static instance: CMsgGameServerKickingLobbyResponse = CMsgGameServerKickingLobbyResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLeaveGameAndPrepareToJoinParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaveGameAndPrepareToJoinParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeaveGameAndPrepareToJoinParty.party_id)
    pub party_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaveGameAndPrepareToJoinParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveGameAndPrepareToJoinParty {
    fn default() -> &'a CMsgLeaveGameAndPrepareToJoinParty {
        <CMsgLeaveGameAndPrepareToJoinParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveGameAndPrepareToJoinParty {
    pub fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeaveGameAndPrepareToJoinParty {
    const NAME: &'static str = "CMsgLeaveGameAndPrepareToJoinParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaveGameAndPrepareToJoinParty {
        CMsgLeaveGameAndPrepareToJoinParty::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaveGameAndPrepareToJoinParty {
        static instance: CMsgLeaveGameAndPrepareToJoinParty = CMsgLeaveGameAndPrepareToJoinParty {
            party_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerLeftMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerLeftMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.leave_reason)
    pub leave_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TFMatchLeaveReason>>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.was_abandon)
    pub was_abandon: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerLeftMatch.xp_breakdown)
    pub xp_breakdown: ::std::vec::Vec<CMsgTFXPSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerLeftMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatch {
    fn default() -> &'a CMsgPlayerLeftMatch {
        <CMsgPlayerLeftMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatch {
    pub fn new() -> CMsgPlayerLeftMatch {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFMatchLeaveReason leave_reason = 2;

    pub fn leave_reason(&self) -> TFMatchLeaveReason {
        match self.leave_reason {
            Some(e) => e.enum_value_or(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            None => TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
        }
    }

    pub fn clear_leave_reason(&mut self) {
        self.leave_reason = ::std::option::Option::None;
    }

    pub fn has_leave_reason(&self) -> bool {
        self.leave_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leave_reason(&mut self, v: TFMatchLeaveReason) {
        self.leave_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool was_abandon = 3;

    pub fn was_abandon(&self) -> bool {
        self.was_abandon.unwrap_or(false)
    }

    pub fn clear_was_abandon(&mut self) {
        self.was_abandon = ::std::option::Option::None;
    }

    pub fn has_was_abandon(&self) -> bool {
        self.was_abandon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_was_abandon(&mut self, v: bool) {
        self.was_abandon = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 4;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerLeftMatch {
    const NAME: &'static str = "CMsgPlayerLeftMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.leave_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.was_abandon = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                50 => {
                    self.xp_breakdown.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.leave_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.was_abandon {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        for value in &self.xp_breakdown {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leave_reason {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.was_abandon {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        for v in &self.xp_breakdown {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerLeftMatch {
        CMsgPlayerLeftMatch::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.leave_reason = ::std::option::Option::None;
        self.was_abandon = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.xp_breakdown.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatch {
        static instance: CMsgPlayerLeftMatch = CMsgPlayerLeftMatch {
            steam_id: ::std::option::Option::None,
            leave_reason: ::std::option::Option::None,
            was_abandon: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            xp_breakdown: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerLeftMatchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerLeftMatchResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerLeftMatchResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerLeftMatchResponse {
    fn default() -> &'a CMsgPlayerLeftMatchResponse {
        <CMsgPlayerLeftMatchResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerLeftMatchResponse {
    pub fn new() -> CMsgPlayerLeftMatchResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerLeftMatchResponse {
    const NAME: &'static str = "CMsgPlayerLeftMatchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerLeftMatchResponse {
        CMsgPlayerLeftMatchResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerLeftMatchResponse {
        static instance: CMsgPlayerLeftMatchResponse = CMsgPlayerLeftMatchResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProcessMatchVoteKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessMatchVoteKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.initiator_steam_id)
    pub initiator_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.target_steam_id)
    pub target_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TFVoteKickReason>>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.votes)
    pub votes: ::std::vec::Vec<cmsg_process_match_vote_kick::Vote>,
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.default_pass)
    pub default_pass: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKick {
    fn default() -> &'a CMsgProcessMatchVoteKick {
        <CMsgProcessMatchVoteKick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKick {
    pub fn new() -> CMsgProcessMatchVoteKick {
        ::std::default::Default::default()
    }

    // optional fixed64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 initiator_steam_id = 2;

    pub fn initiator_steam_id(&self) -> u64 {
        self.initiator_steam_id.unwrap_or(0)
    }

    pub fn clear_initiator_steam_id(&mut self) {
        self.initiator_steam_id = ::std::option::Option::None;
    }

    pub fn has_initiator_steam_id(&self) -> bool {
        self.initiator_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_steam_id(&mut self, v: u64) {
        self.initiator_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 target_steam_id = 3;

    pub fn target_steam_id(&self) -> u64 {
        self.target_steam_id.unwrap_or(0)
    }

    pub fn clear_target_steam_id(&mut self) {
        self.target_steam_id = ::std::option::Option::None;
    }

    pub fn has_target_steam_id(&self) -> bool {
        self.target_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_steam_id(&mut self, v: u64) {
        self.target_steam_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;

    pub fn reason(&self) -> TFVoteKickReason {
        match self.reason {
            Some(e) => e.enum_value_or(TFVoteKickReason::TFVoteKickReason_Invalid),
            None => TFVoteKickReason::TFVoteKickReason_Invalid,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool default_pass = 6;

    pub fn default_pass(&self) -> bool {
        self.default_pass.unwrap_or(false)
    }

    pub fn clear_default_pass(&mut self) {
        self.default_pass = ::std::option::Option::None;
    }

    pub fn has_default_pass(&self) -> bool {
        self.default_pass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_pass(&mut self, v: bool) {
        self.default_pass = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProcessMatchVoteKick {
    const NAME: &'static str = "CMsgProcessMatchVoteKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.match_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                17 => {
                    self.initiator_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                25 => {
                    self.target_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                32 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.votes.push(is.read_message()?);
                },
                48 => {
                    self.default_pass = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.initiator_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.default_pass {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.initiator_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.target_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.votes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.default_pass {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessMatchVoteKick {
        CMsgProcessMatchVoteKick::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.initiator_steam_id = ::std::option::Option::None;
        self.target_steam_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.votes.clear();
        self.default_pass = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKick {
        static instance: CMsgProcessMatchVoteKick = CMsgProcessMatchVoteKick {
            match_id: ::std::option::Option::None,
            initiator_steam_id: ::std::option::Option::None,
            target_steam_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            votes: ::std::vec::Vec::new(),
            default_pass: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProcessMatchVoteKick`
pub mod cmsg_process_match_vote_kick {
    // @@protoc_insertion_point(message:CMsgProcessMatchVoteKick.Vote)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Vote {
        // message fields
        // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.Vote.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgProcessMatchVoteKick.Vote.vote_yay)
        pub vote_yay: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKick.Vote.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Vote {
        fn default() -> &'a Vote {
            <Vote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Vote {
        pub fn new() -> Vote {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool vote_yay = 2;

        pub fn vote_yay(&self) -> bool {
            self.vote_yay.unwrap_or(false)
        }

        pub fn clear_vote_yay(&mut self) {
            self.vote_yay = ::std::option::Option::None;
        }

        pub fn has_vote_yay(&self) -> bool {
            self.vote_yay.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_yay(&mut self, v: bool) {
            self.vote_yay = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Vote {
        const NAME: &'static str = "Vote";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.vote_yay = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.vote_yay {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.vote_yay {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Vote {
            Vote::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.vote_yay = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Vote {
            static instance: Vote = Vote {
                steam_id: ::std::option::Option::None,
                vote_yay: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgProcessMatchVoteKickResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProcessMatchVoteKickResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgProcessMatchVoteKickResponse.rip)
    pub rip: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProcessMatchVoteKickResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProcessMatchVoteKickResponse {
    fn default() -> &'a CMsgProcessMatchVoteKickResponse {
        <CMsgProcessMatchVoteKickResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProcessMatchVoteKickResponse {
    pub fn new() -> CMsgProcessMatchVoteKickResponse {
        ::std::default::Default::default()
    }

    // optional bool rip = 1;

    pub fn rip(&self) -> bool {
        self.rip.unwrap_or(false)
    }

    pub fn clear_rip(&mut self) {
        self.rip = ::std::option::Option::None;
    }

    pub fn has_rip(&self) -> bool {
        self.rip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rip(&mut self, v: bool) {
        self.rip = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProcessMatchVoteKickResponse {
    const NAME: &'static str = "CMsgProcessMatchVoteKickResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rip = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rip {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rip {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProcessMatchVoteKickResponse {
        CMsgProcessMatchVoteKickResponse::new()
    }

    fn clear(&mut self) {
        self.rip = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProcessMatchVoteKickResponse {
        static instance: CMsgProcessMatchVoteKickResponse = CMsgProcessMatchVoteKickResponse {
            rip: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHalloween_ServerBossEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHalloween_ServerBossEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.event_counter)
    pub event_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.boss_type)
    pub boss_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.boss_level)
    pub boss_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.event_type)
    pub event_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.players_involved)
    pub players_involved: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_ServerBossEvent.elapsed_time)
    pub elapsed_time: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHalloween_ServerBossEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_ServerBossEvent {
    fn default() -> &'a CMsgHalloween_ServerBossEvent {
        <CMsgHalloween_ServerBossEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_ServerBossEvent {
    pub fn new() -> CMsgHalloween_ServerBossEvent {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;

    pub fn event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }

    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 2;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_type = 3;

    pub fn boss_type(&self) -> u32 {
        self.boss_type.unwrap_or(0)
    }

    pub fn clear_boss_type(&mut self) {
        self.boss_type = ::std::option::Option::None;
    }

    pub fn has_boss_type(&self) -> bool {
        self.boss_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_type(&mut self, v: u32) {
        self.boss_type = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;

    pub fn boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }

    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 5;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 players_involved = 6;

    pub fn players_involved(&self) -> u32 {
        self.players_involved.unwrap_or(0)
    }

    pub fn clear_players_involved(&mut self) {
        self.players_involved = ::std::option::Option::None;
    }

    pub fn has_players_involved(&self) -> bool {
        self.players_involved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_involved(&mut self, v: u32) {
        self.players_involved = ::std::option::Option::Some(v);
    }

    // optional float elapsed_time = 7;

    pub fn elapsed_time(&self) -> f32 {
        self.elapsed_time.unwrap_or(0.)
    }

    pub fn clear_elapsed_time(&mut self) {
        self.elapsed_time = ::std::option::Option::None;
    }

    pub fn has_elapsed_time(&self) -> bool {
        self.elapsed_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_elapsed_time(&mut self, v: f32) {
        self.elapsed_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHalloween_ServerBossEvent {
    const NAME: &'static str = "CMsgHalloween_ServerBossEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.boss_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.boss_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.players_involved = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.elapsed_time = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.boss_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.boss_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.players_involved {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.elapsed_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.boss_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.players_involved {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.elapsed_time {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHalloween_ServerBossEvent {
        CMsgHalloween_ServerBossEvent::new()
    }

    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.boss_type = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.players_involved = ::std::option::Option::None;
        self.elapsed_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHalloween_ServerBossEvent {
        static instance: CMsgHalloween_ServerBossEvent = CMsgHalloween_ServerBossEvent {
            event_counter: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            boss_type: ::std::option::Option::None,
            boss_level: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            players_involved: ::std::option::Option::None,
            elapsed_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHalloween_Merasmus2012)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHalloween_Merasmus2012 {
    // message fields
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.event_counter)
    pub event_counter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.time_submitted)
    pub time_submitted: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.is_valve_server)
    pub is_valve_server: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.boss_level)
    pub boss_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.spawned_health)
    pub spawned_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.remaining_health)
    pub remaining_health: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.life_time)
    pub life_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.bomb_kills)
    pub bomb_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.staff_kills)
    pub staff_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.pvp_kills)
    pub pvp_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.prophunt_time1)
    pub prophunt_time1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.prophunt_time2)
    pub prophunt_time2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_scout)
    pub dmg_scout: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_sniper)
    pub dmg_sniper: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_soldier)
    pub dmg_soldier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_demo)
    pub dmg_demo: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_medic)
    pub dmg_medic: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_heavy)
    pub dmg_heavy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_pyro)
    pub dmg_pyro: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_spy)
    pub dmg_spy: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.dmg_engineer)
    pub dmg_engineer: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.scout_count)
    pub scout_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.sniper_count)
    pub sniper_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.solider_count)
    pub solider_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.demo_count)
    pub demo_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.medic_count)
    pub medic_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.heavy_count)
    pub heavy_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.pyro_count)
    pub pyro_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.spy_count)
    pub spy_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgHalloween_Merasmus2012.engineer_count)
    pub engineer_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHalloween_Merasmus2012.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHalloween_Merasmus2012 {
    fn default() -> &'a CMsgHalloween_Merasmus2012 {
        <CMsgHalloween_Merasmus2012 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHalloween_Merasmus2012 {
    pub fn new() -> CMsgHalloween_Merasmus2012 {
        ::std::default::Default::default()
    }

    // optional uint32 event_counter = 1;

    pub fn event_counter(&self) -> u32 {
        self.event_counter.unwrap_or(0)
    }

    pub fn clear_event_counter(&mut self) {
        self.event_counter = ::std::option::Option::None;
    }

    pub fn has_event_counter(&self) -> bool {
        self.event_counter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_counter(&mut self, v: u32) {
        self.event_counter = ::std::option::Option::Some(v);
    }

    // optional fixed32 time_submitted = 2;

    pub fn time_submitted(&self) -> u32 {
        self.time_submitted.unwrap_or(0)
    }

    pub fn clear_time_submitted(&mut self) {
        self.time_submitted = ::std::option::Option::None;
    }

    pub fn has_time_submitted(&self) -> bool {
        self.time_submitted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_submitted(&mut self, v: u32) {
        self.time_submitted = ::std::option::Option::Some(v);
    }

    // optional bool is_valve_server = 3;

    pub fn is_valve_server(&self) -> bool {
        self.is_valve_server.unwrap_or(false)
    }

    pub fn clear_is_valve_server(&mut self) {
        self.is_valve_server = ::std::option::Option::None;
    }

    pub fn has_is_valve_server(&self) -> bool {
        self.is_valve_server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valve_server(&mut self, v: bool) {
        self.is_valve_server = ::std::option::Option::Some(v);
    }

    // optional uint32 boss_level = 4;

    pub fn boss_level(&self) -> u32 {
        self.boss_level.unwrap_or(0)
    }

    pub fn clear_boss_level(&mut self) {
        self.boss_level = ::std::option::Option::None;
    }

    pub fn has_boss_level(&self) -> bool {
        self.boss_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_boss_level(&mut self, v: u32) {
        self.boss_level = ::std::option::Option::Some(v);
    }

    // optional uint32 spawned_health = 5;

    pub fn spawned_health(&self) -> u32 {
        self.spawned_health.unwrap_or(0)
    }

    pub fn clear_spawned_health(&mut self) {
        self.spawned_health = ::std::option::Option::None;
    }

    pub fn has_spawned_health(&self) -> bool {
        self.spawned_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spawned_health(&mut self, v: u32) {
        self.spawned_health = ::std::option::Option::Some(v);
    }

    // optional uint32 remaining_health = 6;

    pub fn remaining_health(&self) -> u32 {
        self.remaining_health.unwrap_or(0)
    }

    pub fn clear_remaining_health(&mut self) {
        self.remaining_health = ::std::option::Option::None;
    }

    pub fn has_remaining_health(&self) -> bool {
        self.remaining_health.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining_health(&mut self, v: u32) {
        self.remaining_health = ::std::option::Option::Some(v);
    }

    // optional uint32 life_time = 7;

    pub fn life_time(&self) -> u32 {
        self.life_time.unwrap_or(0)
    }

    pub fn clear_life_time(&mut self) {
        self.life_time = ::std::option::Option::None;
    }

    pub fn has_life_time(&self) -> bool {
        self.life_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_life_time(&mut self, v: u32) {
        self.life_time = ::std::option::Option::Some(v);
    }

    // optional uint32 bomb_kills = 8;

    pub fn bomb_kills(&self) -> u32 {
        self.bomb_kills.unwrap_or(0)
    }

    pub fn clear_bomb_kills(&mut self) {
        self.bomb_kills = ::std::option::Option::None;
    }

    pub fn has_bomb_kills(&self) -> bool {
        self.bomb_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bomb_kills(&mut self, v: u32) {
        self.bomb_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 staff_kills = 9;

    pub fn staff_kills(&self) -> u32 {
        self.staff_kills.unwrap_or(0)
    }

    pub fn clear_staff_kills(&mut self) {
        self.staff_kills = ::std::option::Option::None;
    }

    pub fn has_staff_kills(&self) -> bool {
        self.staff_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_staff_kills(&mut self, v: u32) {
        self.staff_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 pvp_kills = 10;

    pub fn pvp_kills(&self) -> u32 {
        self.pvp_kills.unwrap_or(0)
    }

    pub fn clear_pvp_kills(&mut self) {
        self.pvp_kills = ::std::option::Option::None;
    }

    pub fn has_pvp_kills(&self) -> bool {
        self.pvp_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pvp_kills(&mut self, v: u32) {
        self.pvp_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time1 = 11;

    pub fn prophunt_time1(&self) -> u32 {
        self.prophunt_time1.unwrap_or(0)
    }

    pub fn clear_prophunt_time1(&mut self) {
        self.prophunt_time1 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time1(&self) -> bool {
        self.prophunt_time1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time1(&mut self, v: u32) {
        self.prophunt_time1 = ::std::option::Option::Some(v);
    }

    // optional uint32 prophunt_time2 = 12;

    pub fn prophunt_time2(&self) -> u32 {
        self.prophunt_time2.unwrap_or(0)
    }

    pub fn clear_prophunt_time2(&mut self) {
        self.prophunt_time2 = ::std::option::Option::None;
    }

    pub fn has_prophunt_time2(&self) -> bool {
        self.prophunt_time2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prophunt_time2(&mut self, v: u32) {
        self.prophunt_time2 = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_scout = 13;

    pub fn dmg_scout(&self) -> u32 {
        self.dmg_scout.unwrap_or(0)
    }

    pub fn clear_dmg_scout(&mut self) {
        self.dmg_scout = ::std::option::Option::None;
    }

    pub fn has_dmg_scout(&self) -> bool {
        self.dmg_scout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_scout(&mut self, v: u32) {
        self.dmg_scout = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_sniper = 14;

    pub fn dmg_sniper(&self) -> u32 {
        self.dmg_sniper.unwrap_or(0)
    }

    pub fn clear_dmg_sniper(&mut self) {
        self.dmg_sniper = ::std::option::Option::None;
    }

    pub fn has_dmg_sniper(&self) -> bool {
        self.dmg_sniper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_sniper(&mut self, v: u32) {
        self.dmg_sniper = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_soldier = 15;

    pub fn dmg_soldier(&self) -> u32 {
        self.dmg_soldier.unwrap_or(0)
    }

    pub fn clear_dmg_soldier(&mut self) {
        self.dmg_soldier = ::std::option::Option::None;
    }

    pub fn has_dmg_soldier(&self) -> bool {
        self.dmg_soldier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_soldier(&mut self, v: u32) {
        self.dmg_soldier = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_demo = 16;

    pub fn dmg_demo(&self) -> u32 {
        self.dmg_demo.unwrap_or(0)
    }

    pub fn clear_dmg_demo(&mut self) {
        self.dmg_demo = ::std::option::Option::None;
    }

    pub fn has_dmg_demo(&self) -> bool {
        self.dmg_demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_demo(&mut self, v: u32) {
        self.dmg_demo = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_medic = 17;

    pub fn dmg_medic(&self) -> u32 {
        self.dmg_medic.unwrap_or(0)
    }

    pub fn clear_dmg_medic(&mut self) {
        self.dmg_medic = ::std::option::Option::None;
    }

    pub fn has_dmg_medic(&self) -> bool {
        self.dmg_medic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_medic(&mut self, v: u32) {
        self.dmg_medic = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_heavy = 18;

    pub fn dmg_heavy(&self) -> u32 {
        self.dmg_heavy.unwrap_or(0)
    }

    pub fn clear_dmg_heavy(&mut self) {
        self.dmg_heavy = ::std::option::Option::None;
    }

    pub fn has_dmg_heavy(&self) -> bool {
        self.dmg_heavy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_heavy(&mut self, v: u32) {
        self.dmg_heavy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_pyro = 19;

    pub fn dmg_pyro(&self) -> u32 {
        self.dmg_pyro.unwrap_or(0)
    }

    pub fn clear_dmg_pyro(&mut self) {
        self.dmg_pyro = ::std::option::Option::None;
    }

    pub fn has_dmg_pyro(&self) -> bool {
        self.dmg_pyro.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_pyro(&mut self, v: u32) {
        self.dmg_pyro = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_spy = 20;

    pub fn dmg_spy(&self) -> u32 {
        self.dmg_spy.unwrap_or(0)
    }

    pub fn clear_dmg_spy(&mut self) {
        self.dmg_spy = ::std::option::Option::None;
    }

    pub fn has_dmg_spy(&self) -> bool {
        self.dmg_spy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_spy(&mut self, v: u32) {
        self.dmg_spy = ::std::option::Option::Some(v);
    }

    // optional uint32 dmg_engineer = 21;

    pub fn dmg_engineer(&self) -> u32 {
        self.dmg_engineer.unwrap_or(0)
    }

    pub fn clear_dmg_engineer(&mut self) {
        self.dmg_engineer = ::std::option::Option::None;
    }

    pub fn has_dmg_engineer(&self) -> bool {
        self.dmg_engineer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dmg_engineer(&mut self, v: u32) {
        self.dmg_engineer = ::std::option::Option::Some(v);
    }

    // optional uint32 scout_count = 22;

    pub fn scout_count(&self) -> u32 {
        self.scout_count.unwrap_or(0)
    }

    pub fn clear_scout_count(&mut self) {
        self.scout_count = ::std::option::Option::None;
    }

    pub fn has_scout_count(&self) -> bool {
        self.scout_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scout_count(&mut self, v: u32) {
        self.scout_count = ::std::option::Option::Some(v);
    }

    // optional uint32 sniper_count = 23;

    pub fn sniper_count(&self) -> u32 {
        self.sniper_count.unwrap_or(0)
    }

    pub fn clear_sniper_count(&mut self) {
        self.sniper_count = ::std::option::Option::None;
    }

    pub fn has_sniper_count(&self) -> bool {
        self.sniper_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sniper_count(&mut self, v: u32) {
        self.sniper_count = ::std::option::Option::Some(v);
    }

    // optional uint32 solider_count = 24;

    pub fn solider_count(&self) -> u32 {
        self.solider_count.unwrap_or(0)
    }

    pub fn clear_solider_count(&mut self) {
        self.solider_count = ::std::option::Option::None;
    }

    pub fn has_solider_count(&self) -> bool {
        self.solider_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solider_count(&mut self, v: u32) {
        self.solider_count = ::std::option::Option::Some(v);
    }

    // optional uint32 demo_count = 25;

    pub fn demo_count(&self) -> u32 {
        self.demo_count.unwrap_or(0)
    }

    pub fn clear_demo_count(&mut self) {
        self.demo_count = ::std::option::Option::None;
    }

    pub fn has_demo_count(&self) -> bool {
        self.demo_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo_count(&mut self, v: u32) {
        self.demo_count = ::std::option::Option::Some(v);
    }

    // optional uint32 medic_count = 26;

    pub fn medic_count(&self) -> u32 {
        self.medic_count.unwrap_or(0)
    }

    pub fn clear_medic_count(&mut self) {
        self.medic_count = ::std::option::Option::None;
    }

    pub fn has_medic_count(&self) -> bool {
        self.medic_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medic_count(&mut self, v: u32) {
        self.medic_count = ::std::option::Option::Some(v);
    }

    // optional uint32 heavy_count = 27;

    pub fn heavy_count(&self) -> u32 {
        self.heavy_count.unwrap_or(0)
    }

    pub fn clear_heavy_count(&mut self) {
        self.heavy_count = ::std::option::Option::None;
    }

    pub fn has_heavy_count(&self) -> bool {
        self.heavy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heavy_count(&mut self, v: u32) {
        self.heavy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 pyro_count = 28;

    pub fn pyro_count(&self) -> u32 {
        self.pyro_count.unwrap_or(0)
    }

    pub fn clear_pyro_count(&mut self) {
        self.pyro_count = ::std::option::Option::None;
    }

    pub fn has_pyro_count(&self) -> bool {
        self.pyro_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pyro_count(&mut self, v: u32) {
        self.pyro_count = ::std::option::Option::Some(v);
    }

    // optional uint32 spy_count = 29;

    pub fn spy_count(&self) -> u32 {
        self.spy_count.unwrap_or(0)
    }

    pub fn clear_spy_count(&mut self) {
        self.spy_count = ::std::option::Option::None;
    }

    pub fn has_spy_count(&self) -> bool {
        self.spy_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spy_count(&mut self, v: u32) {
        self.spy_count = ::std::option::Option::Some(v);
    }

    // optional uint32 engineer_count = 30;

    pub fn engineer_count(&self) -> u32 {
        self.engineer_count.unwrap_or(0)
    }

    pub fn clear_engineer_count(&mut self) {
        self.engineer_count = ::std::option::Option::None;
    }

    pub fn has_engineer_count(&self) -> bool {
        self.engineer_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engineer_count(&mut self, v: u32) {
        self.engineer_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHalloween_Merasmus2012 {
    const NAME: &'static str = "CMsgHalloween_Merasmus2012";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_counter = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.time_submitted = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.is_valve_server = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.boss_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.spawned_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.remaining_health = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.life_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.bomb_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.staff_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.pvp_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.prophunt_time1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.prophunt_time2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.dmg_scout = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.dmg_sniper = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.dmg_soldier = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.dmg_demo = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.dmg_medic = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.dmg_heavy = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.dmg_pyro = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.dmg_spy = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.dmg_engineer = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.scout_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.sniper_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.solider_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.demo_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.medic_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.heavy_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.pyro_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.spy_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.engineer_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_counter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.time_submitted {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_valve_server {
            my_size += 1 + 1;
        }
        if let Some(v) = self.boss_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.spawned_health {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.remaining_health {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.life_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.bomb_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.staff_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.pvp_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.prophunt_time1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.prophunt_time2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.dmg_scout {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.dmg_sniper {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.dmg_soldier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.dmg_demo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.dmg_medic {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.dmg_heavy {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.dmg_pyro {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.dmg_spy {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.dmg_engineer {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.scout_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.sniper_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.solider_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.demo_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.medic_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.heavy_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.pyro_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.spy_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.engineer_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_counter {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.time_submitted {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.is_valve_server {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.boss_level {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.spawned_health {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.remaining_health {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.life_time {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.bomb_kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.staff_kills {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.pvp_kills {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.prophunt_time1 {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.prophunt_time2 {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.dmg_scout {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.dmg_sniper {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.dmg_soldier {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.dmg_demo {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.dmg_medic {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.dmg_heavy {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.dmg_pyro {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.dmg_spy {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.dmg_engineer {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.scout_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.sniper_count {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.solider_count {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.demo_count {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.medic_count {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.heavy_count {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.pyro_count {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.spy_count {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.engineer_count {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHalloween_Merasmus2012 {
        CMsgHalloween_Merasmus2012::new()
    }

    fn clear(&mut self) {
        self.event_counter = ::std::option::Option::None;
        self.time_submitted = ::std::option::Option::None;
        self.is_valve_server = ::std::option::Option::None;
        self.boss_level = ::std::option::Option::None;
        self.spawned_health = ::std::option::Option::None;
        self.remaining_health = ::std::option::Option::None;
        self.life_time = ::std::option::Option::None;
        self.bomb_kills = ::std::option::Option::None;
        self.staff_kills = ::std::option::Option::None;
        self.pvp_kills = ::std::option::Option::None;
        self.prophunt_time1 = ::std::option::Option::None;
        self.prophunt_time2 = ::std::option::Option::None;
        self.dmg_scout = ::std::option::Option::None;
        self.dmg_sniper = ::std::option::Option::None;
        self.dmg_soldier = ::std::option::Option::None;
        self.dmg_demo = ::std::option::Option::None;
        self.dmg_medic = ::std::option::Option::None;
        self.dmg_heavy = ::std::option::Option::None;
        self.dmg_pyro = ::std::option::Option::None;
        self.dmg_spy = ::std::option::Option::None;
        self.dmg_engineer = ::std::option::Option::None;
        self.scout_count = ::std::option::Option::None;
        self.sniper_count = ::std::option::Option::None;
        self.solider_count = ::std::option::Option::None;
        self.demo_count = ::std::option::Option::None;
        self.medic_count = ::std::option::Option::None;
        self.heavy_count = ::std::option::Option::None;
        self.pyro_count = ::std::option::Option::None;
        self.spy_count = ::std::option::Option::None;
        self.engineer_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHalloween_Merasmus2012 {
        static instance: CMsgHalloween_Merasmus2012 = CMsgHalloween_Merasmus2012 {
            event_counter: ::std::option::Option::None,
            time_submitted: ::std::option::Option::None,
            is_valve_server: ::std::option::Option::None,
            boss_level: ::std::option::Option::None,
            spawned_health: ::std::option::Option::None,
            remaining_health: ::std::option::Option::None,
            life_time: ::std::option::Option::None,
            bomb_kills: ::std::option::Option::None,
            staff_kills: ::std::option::Option::None,
            pvp_kills: ::std::option::Option::None,
            prophunt_time1: ::std::option::Option::None,
            prophunt_time2: ::std::option::Option::None,
            dmg_scout: ::std::option::Option::None,
            dmg_sniper: ::std::option::Option::None,
            dmg_soldier: ::std::option::Option::None,
            dmg_demo: ::std::option::Option::None,
            dmg_medic: ::std::option::Option::None,
            dmg_heavy: ::std::option::Option::None,
            dmg_pyro: ::std::option::Option::None,
            dmg_spy: ::std::option::Option::None,
            dmg_engineer: ::std::option::Option::None,
            scout_count: ::std::option::Option::None,
            sniper_count: ::std::option::Option::None,
            solider_count: ::std::option::Option::None,
            demo_count: ::std::option::Option::None,
            medic_count: ::std::option::Option::None,
            heavy_count: ::std::option::Option::None,
            pyro_count: ::std::option::Option::None,
            spy_count: ::std::option::Option::None,
            engineer_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpdateHalloweenMerasmusLootLevel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpdateHalloweenMerasmusLootLevel {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.players)
    pub players: ::std::vec::Vec<cmsg_update_halloween_merasmus_loot_level::Player>,
    // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.merasmus_level)
    pub merasmus_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpdateHalloweenMerasmusLootLevel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpdateHalloweenMerasmusLootLevel {
    fn default() -> &'a CMsgUpdateHalloweenMerasmusLootLevel {
        <CMsgUpdateHalloweenMerasmusLootLevel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUpdateHalloweenMerasmusLootLevel {
    pub fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        ::std::default::Default::default()
    }

    // optional uint32 merasmus_level = 2;

    pub fn merasmus_level(&self) -> u32 {
        self.merasmus_level.unwrap_or(0)
    }

    pub fn clear_merasmus_level(&mut self) {
        self.merasmus_level = ::std::option::Option::None;
    }

    pub fn has_merasmus_level(&self) -> bool {
        self.merasmus_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_merasmus_level(&mut self, v: u32) {
        self.merasmus_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUpdateHalloweenMerasmusLootLevel {
    const NAME: &'static str = "CMsgUpdateHalloweenMerasmusLootLevel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.merasmus_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.merasmus_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.merasmus_level {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpdateHalloweenMerasmusLootLevel {
        CMsgUpdateHalloweenMerasmusLootLevel::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.merasmus_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpdateHalloweenMerasmusLootLevel {
        static instance: CMsgUpdateHalloweenMerasmusLootLevel = CMsgUpdateHalloweenMerasmusLootLevel {
            players: ::std::vec::Vec::new(),
            merasmus_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgUpdateHalloweenMerasmusLootLevel`
pub mod cmsg_update_halloween_merasmus_loot_level {
    // @@protoc_insertion_point(message:CMsgUpdateHalloweenMerasmusLootLevel.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgUpdateHalloweenMerasmusLootLevel.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgUpdateHalloweenMerasmusLootLevel.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CAttribute_String)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_String {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_String.value)
    pub value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_String.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_String {
    fn default() -> &'a CAttribute_String {
        <CAttribute_String as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_String {
    pub fn new() -> CAttribute_String {
        ::std::default::Default::default()
    }

    // optional string value = 1;

    pub fn value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_String {
    const NAME: &'static str = "CAttribute_String";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.value.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.value.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_String {
        CAttribute_String::new()
    }

    fn clear(&mut self) {
        self.value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_String {
        static instance: CAttribute_String = CAttribute_String {
            value: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_DynamicRecipeComponent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_DynamicRecipeComponent {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.component_flags)
    pub component_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.num_required)
    pub num_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent.num_fulfilled)
    pub num_fulfilled: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_DynamicRecipeComponent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent {
    fn default() -> &'a CAttribute_DynamicRecipeComponent {
        <CAttribute_DynamicRecipeComponent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent {
    pub fn new() -> CAttribute_DynamicRecipeComponent {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 2;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 3;

    pub fn component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }

    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 4;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 5;

    pub fn num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }

    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 6;

    pub fn num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }

    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_DynamicRecipeComponent {
    const NAME: &'static str = "CAttribute_DynamicRecipeComponent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.component_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.num_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.component_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_DynamicRecipeComponent {
        CAttribute_DynamicRecipeComponent::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.num_required = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent {
        static instance: CAttribute_DynamicRecipeComponent = CAttribute_DynamicRecipeComponent {
            def_index: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            component_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            num_required: ::std::option::Option::None,
            num_fulfilled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_quality)
    pub item_quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.component_flags)
    pub component_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_flags)
    pub item_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.attributes_string)
    pub attributes_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.num_required)
    pub num_required: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.item_count)
    pub item_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.num_fulfilled)
    pub num_fulfilled: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.items_fulfilled)
    pub items_fulfilled: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn default() -> &'a CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        <CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    pub fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 item_def = 2;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 item_quality = 3;

    pub fn item_quality(&self) -> u32 {
        self.item_quality.unwrap_or(0)
    }

    pub fn clear_item_quality(&mut self) {
        self.item_quality = ::std::option::Option::None;
    }

    pub fn has_item_quality(&self) -> bool {
        self.item_quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_quality(&mut self, v: u32) {
        self.item_quality = ::std::option::Option::Some(v);
    }

    // optional uint32 component_flags = 4;

    pub fn component_flags(&self) -> u32 {
        self.component_flags.unwrap_or(0)
    }

    pub fn clear_component_flags(&mut self) {
        self.component_flags = ::std::option::Option::None;
    }

    pub fn has_component_flags(&self) -> bool {
        self.component_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component_flags(&mut self, v: u32) {
        self.component_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 item_flags = 5;

    pub fn item_flags(&self) -> u32 {
        self.item_flags.unwrap_or(0)
    }

    pub fn clear_item_flags(&mut self) {
        self.item_flags = ::std::option::Option::None;
    }

    pub fn has_item_flags(&self) -> bool {
        self.item_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_flags(&mut self, v: u32) {
        self.item_flags = ::std::option::Option::Some(v);
    }

    // optional string attributes_string = 6;

    pub fn attributes_string(&self) -> &str {
        match self.attributes_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attributes_string(&mut self) {
        self.attributes_string = ::std::option::Option::None;
    }

    pub fn has_attributes_string(&self) -> bool {
        self.attributes_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes_string(&mut self, v: ::std::string::String) {
        self.attributes_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes_string(&mut self) -> &mut ::std::string::String {
        if self.attributes_string.is_none() {
            self.attributes_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attributes_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes_string(&mut self) -> ::std::string::String {
        self.attributes_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 num_required = 7;

    pub fn num_required(&self) -> u32 {
        self.num_required.unwrap_or(0)
    }

    pub fn clear_num_required(&mut self) {
        self.num_required = ::std::option::Option::None;
    }

    pub fn has_num_required(&self) -> bool {
        self.num_required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_required(&mut self, v: u32) {
        self.num_required = ::std::option::Option::Some(v);
    }

    // optional uint32 item_count = 8;

    pub fn item_count(&self) -> u32 {
        self.item_count.unwrap_or(0)
    }

    pub fn clear_item_count(&mut self) {
        self.item_count = ::std::option::Option::None;
    }

    pub fn has_item_count(&self) -> bool {
        self.item_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_count(&mut self, v: u32) {
        self.item_count = ::std::option::Option::Some(v);
    }

    // optional uint32 num_fulfilled = 9;

    pub fn num_fulfilled(&self) -> u32 {
        self.num_fulfilled.unwrap_or(0)
    }

    pub fn clear_num_fulfilled(&mut self) {
        self.num_fulfilled = ::std::option::Option::None;
    }

    pub fn has_num_fulfilled(&self) -> bool {
        self.num_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_fulfilled(&mut self, v: u32) {
        self.num_fulfilled = ::std::option::Option::Some(v);
    }

    // optional uint32 items_fulfilled = 10;

    pub fn items_fulfilled(&self) -> u32 {
        self.items_fulfilled.unwrap_or(0)
    }

    pub fn clear_items_fulfilled(&mut self) {
        self.items_fulfilled = ::std::option::Option::None;
    }

    pub fn has_items_fulfilled(&self) -> bool {
        self.items_fulfilled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_items_fulfilled(&mut self, v: u32) {
        self.items_fulfilled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    const NAME: &'static str = "CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.component_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.item_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.attributes_string = ::std::option::Option::Some(is.read_string()?);
                },
                56 => {
                    self.num_required = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.item_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.num_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.items_fulfilled = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.component_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.item_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.attributes_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.num_required {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.item_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.num_fulfilled {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.items_fulfilled {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_def {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_quality {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.component_flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.item_flags {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.attributes_string.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.num_required {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.item_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.num_fulfilled {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.items_fulfilled {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.item_def = ::std::option::Option::None;
        self.item_quality = ::std::option::Option::None;
        self.component_flags = ::std::option::Option::None;
        self.item_flags = ::std::option::Option::None;
        self.attributes_string = ::std::option::Option::None;
        self.num_required = ::std::option::Option::None;
        self.item_count = ::std::option::Option::None;
        self.num_fulfilled = ::std::option::Option::None;
        self.items_fulfilled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
        static instance: CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT = CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
            def_index: ::std::option::Option::None,
            item_def: ::std::option::Option::None,
            item_quality: ::std::option::Option::None,
            component_flags: ::std::option::Option::None,
            item_flags: ::std::option::Option::None,
            attributes_string: ::std::option::Option::None,
            num_required: ::std::option::Option::None,
            item_count: ::std::option::Option::None,
            num_fulfilled: ::std::option::Option::None,
            items_fulfilled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_ItemSlotCriteria)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_ItemSlotCriteria {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_ItemSlotCriteria.tags)
    pub tags: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_ItemSlotCriteria.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_ItemSlotCriteria {
    fn default() -> &'a CAttribute_ItemSlotCriteria {
        <CAttribute_ItemSlotCriteria as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_ItemSlotCriteria {
    pub fn new() -> CAttribute_ItemSlotCriteria {
        ::std::default::Default::default()
    }

    // optional string tags = 1;

    pub fn tags(&self) -> &str {
        match self.tags.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_tags(&mut self) {
        self.tags = ::std::option::Option::None;
    }

    pub fn has_tags(&self) -> bool {
        self.tags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::std::string::String) {
        self.tags = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tags(&mut self) -> &mut ::std::string::String {
        if self.tags.is_none() {
            self.tags = ::std::option::Option::Some(::std::string::String::new());
        }
        self.tags.as_mut().unwrap()
    }

    // Take field
    pub fn take_tags(&mut self) -> ::std::string::String {
        self.tags.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_ItemSlotCriteria {
    const NAME: &'static str = "CAttribute_ItemSlotCriteria";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tags = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tags.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tags.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_ItemSlotCriteria {
        CAttribute_ItemSlotCriteria::new()
    }

    fn clear(&mut self) {
        self.tags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_ItemSlotCriteria {
        static instance: CAttribute_ItemSlotCriteria = CAttribute_ItemSlotCriteria {
            tags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetItemSlotAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemSlotAttribute {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.slot_item_original_id)
    pub slot_item_original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetItemSlotAttribute.slot_index)
    pub slot_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemSlotAttribute.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemSlotAttribute {
    fn default() -> &'a CMsgSetItemSlotAttribute {
        <CMsgSetItemSlotAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemSlotAttribute {
    pub fn new() -> CMsgSetItemSlotAttribute {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 slot_item_original_id = 2;

    pub fn slot_item_original_id(&self) -> u64 {
        self.slot_item_original_id.unwrap_or(0)
    }

    pub fn clear_slot_item_original_id(&mut self) {
        self.slot_item_original_id = ::std::option::Option::None;
    }

    pub fn has_slot_item_original_id(&self) -> bool {
        self.slot_item_original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_item_original_id(&mut self, v: u64) {
        self.slot_item_original_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_index = 3;

    pub fn slot_index(&self) -> u32 {
        self.slot_index.unwrap_or(0)
    }

    pub fn clear_slot_index(&mut self) {
        self.slot_index = ::std::option::Option::None;
    }

    pub fn has_slot_index(&self) -> bool {
        self.slot_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_index(&mut self, v: u32) {
        self.slot_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetItemSlotAttribute {
    const NAME: &'static str = "CMsgSetItemSlotAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.slot_item_original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.slot_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.slot_item_original_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.slot_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.slot_item_original_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.slot_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemSlotAttribute {
        CMsgSetItemSlotAttribute::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.slot_item_original_id = ::std::option::Option::None;
        self.slot_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemSlotAttribute {
        static instance: CMsgSetItemSlotAttribute = CMsgSetItemSlotAttribute {
            item_id: ::std::option::Option::None,
            slot_item_original_id: ::std::option::Option::None,
            slot_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOWarData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOWarData {
    // message fields
    // @@protoc_insertion_point(field:CSOWarData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.war_id)
    pub war_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.affiliation)
    pub affiliation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOWarData.points_scored)
    pub points_scored: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOWarData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOWarData {
    fn default() -> &'a CSOWarData {
        <CSOWarData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOWarData {
    pub fn new() -> CSOWarData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 affiliation = 3;

    pub fn affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }

    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 points_scored = 4;

    pub fn points_scored(&self) -> u32 {
        self.points_scored.unwrap_or(0)
    }

    pub fn clear_points_scored(&mut self) {
        self.points_scored = ::std::option::Option::None;
    }

    pub fn has_points_scored(&self) -> bool {
        self.points_scored.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_scored(&mut self, v: u32) {
        self.points_scored = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOWarData {
    const NAME: &'static str = "CSOWarData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.affiliation = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.points_scored = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.war_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.affiliation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.points_scored {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.affiliation {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.points_scored {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOWarData {
        CSOWarData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.affiliation = ::std::option::Option::None;
        self.points_scored = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOWarData {
        static instance: CSOWarData = CSOWarData {
            account_id: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            affiliation: ::std::option::Option::None,
            points_scored: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_War_IndividualUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_IndividualUpdate {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.war_id)
    pub war_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_IndividualUpdate.score)
    pub score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_IndividualUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_War_IndividualUpdate {
        <CGCMsgGC_War_IndividualUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_IndividualUpdate {
    pub fn new() -> CGCMsgGC_War_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 3;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgGC_War_IndividualUpdate {
    const NAME: &'static str = "CGCMsgGC_War_IndividualUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.war_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_IndividualUpdate {
        CGCMsgGC_War_IndividualUpdate::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_IndividualUpdate {
        static instance: CGCMsgGC_War_IndividualUpdate = CGCMsgGC_War_IndividualUpdate {
            steam_id: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_War_JoinWar)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_JoinWar {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_JoinWar.affiliation)
    pub affiliation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_JoinWar.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_JoinWar.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_JoinWar {
    fn default() -> &'a CGCMsgGC_War_JoinWar {
        <CGCMsgGC_War_JoinWar as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_JoinWar {
    pub fn new() -> CGCMsgGC_War_JoinWar {
        ::std::default::Default::default()
    }

    // optional uint32 affiliation = 1;

    pub fn affiliation(&self) -> u32 {
        self.affiliation.unwrap_or(0)
    }

    pub fn clear_affiliation(&mut self) {
        self.affiliation = ::std::option::Option::None;
    }

    pub fn has_affiliation(&self) -> bool {
        self.affiliation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affiliation(&mut self, v: u32) {
        self.affiliation = ::std::option::Option::Some(v);
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgGC_War_JoinWar {
    const NAME: &'static str = "CGCMsgGC_War_JoinWar";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.affiliation = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.affiliation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.war_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.affiliation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_JoinWar {
        CGCMsgGC_War_JoinWar::new()
    }

    fn clear(&mut self) {
        self.affiliation = ::std::option::Option::None;
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_JoinWar {
        static instance: CGCMsgGC_War_JoinWar = CGCMsgGC_War_JoinWar {
            affiliation: ::std::option::Option::None,
            war_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_War_RequestGlobalStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_RequestGlobalStats {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_RequestGlobalStats.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_RequestGlobalStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_RequestGlobalStats {
    fn default() -> &'a CGCMsgGC_War_RequestGlobalStats {
        <CGCMsgGC_War_RequestGlobalStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_RequestGlobalStats {
    pub fn new() -> CGCMsgGC_War_RequestGlobalStats {
        ::std::default::Default::default()
    }

    // optional uint32 war_id = 1;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgGC_War_RequestGlobalStats {
    const NAME: &'static str = "CGCMsgGC_War_RequestGlobalStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.war_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.war_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_RequestGlobalStats {
        CGCMsgGC_War_RequestGlobalStats::new()
    }

    fn clear(&mut self) {
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_RequestGlobalStats {
        static instance: CGCMsgGC_War_RequestGlobalStats = CGCMsgGC_War_RequestGlobalStats {
            war_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_War_GlobalStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_War_GlobalStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.side_scores)
    pub side_scores: ::std::vec::Vec<cgcmsg_gc_war_global_stats_response::SideScore>,
    // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.war_id)
    pub war_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_War_GlobalStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_War_GlobalStatsResponse {
    fn default() -> &'a CGCMsgGC_War_GlobalStatsResponse {
        <CGCMsgGC_War_GlobalStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_War_GlobalStatsResponse {
    pub fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 war_id = 2;

    pub fn war_id(&self) -> u32 {
        self.war_id.unwrap_or(0)
    }

    pub fn clear_war_id(&mut self) {
        self.war_id = ::std::option::Option::None;
    }

    pub fn has_war_id(&self) -> bool {
        self.war_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_war_id(&mut self, v: u32) {
        self.war_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgGC_War_GlobalStatsResponse {
    const NAME: &'static str = "CGCMsgGC_War_GlobalStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.side_scores.push(is.read_message()?);
                },
                16 => {
                    self.war_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.side_scores {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.war_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.side_scores {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.war_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_War_GlobalStatsResponse {
        CGCMsgGC_War_GlobalStatsResponse::new()
    }

    fn clear(&mut self) {
        self.side_scores.clear();
        self.war_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_War_GlobalStatsResponse {
        static instance: CGCMsgGC_War_GlobalStatsResponse = CGCMsgGC_War_GlobalStatsResponse {
            side_scores: ::std::vec::Vec::new(),
            war_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CGCMsgGC_War_GlobalStatsResponse`
pub mod cgcmsg_gc_war_global_stats_response {
    // @@protoc_insertion_point(message:CGCMsgGC_War_GlobalStatsResponse.SideScore)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SideScore {
        // message fields
        // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.SideScore.side)
        pub side: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CGCMsgGC_War_GlobalStatsResponse.SideScore.score)
        pub score: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CGCMsgGC_War_GlobalStatsResponse.SideScore.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SideScore {
        fn default() -> &'a SideScore {
            <SideScore as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SideScore {
        pub fn new() -> SideScore {
            ::std::default::Default::default()
        }

        // optional uint32 side = 1;

        pub fn side(&self) -> u32 {
            self.side.unwrap_or(0)
        }

        pub fn clear_side(&mut self) {
            self.side = ::std::option::Option::None;
        }

        pub fn has_side(&self) -> bool {
            self.side.is_some()
        }

        // Param is passed by value, moved
        pub fn set_side(&mut self, v: u32) {
            self.side = ::std::option::Option::Some(v);
        }

        // optional uint64 score = 2;

        pub fn score(&self) -> u64 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u64) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SideScore {
        const NAME: &'static str = "SideScore";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.side = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.side {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.side {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint64(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SideScore {
            SideScore::new()
        }

        fn clear(&mut self) {
            self.side = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SideScore {
            static instance: SideScore = SideScore {
                side: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    // message fields
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score_id)
    pub score_id: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.score_check)
    pub score_check: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn default() -> &'a CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        <CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    pub fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 score = 2;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 3;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional bytes score_id = 4;

    pub fn score_id(&self) -> &[u8] {
        match self.score_id.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_score_id(&mut self) {
        self.score_id = ::std::option::Option::None;
    }

    pub fn has_score_id(&self) -> bool {
        self.score_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_id(&mut self, v: ::std::vec::Vec<u8>) {
        self.score_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_score_id(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.score_id.is_none() {
            self.score_id = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.score_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_score_id(&mut self) -> ::std::vec::Vec<u8> {
        self.score_id.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 score_check = 5;

    pub fn score_check(&self) -> u32 {
        self.score_check.unwrap_or(0)
    }

    pub fn clear_score_check(&mut self) {
        self.score_check = ::std::option::Option::None;
    }

    pub fn has_score_check(&self) -> bool {
        self.score_check.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_check(&mut self, v: u32) {
        self.score_check = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    const NAME: &'static str = "CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.score_id = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.score_check = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.score_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.score_check {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.score_id.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.score_check {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate::new()
    }

    fn clear(&mut self) {
        self.score = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.score_id = ::std::option::Option::None;
        self.score_check = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
        static instance: CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate = CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
            score: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            score_id: ::std::option::Option::None,
            score_check: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CAttribute_WorldItemPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CAttribute_WorldItemPlacement {
    // message fields
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.original_item_id)
    pub original_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_x)
    pub ang_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_y)
    pub ang_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CAttribute_WorldItemPlacement.ang_z)
    pub ang_z: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CAttribute_WorldItemPlacement.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CAttribute_WorldItemPlacement {
    fn default() -> &'a CAttribute_WorldItemPlacement {
        <CAttribute_WorldItemPlacement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CAttribute_WorldItemPlacement {
    pub fn new() -> CAttribute_WorldItemPlacement {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;

    pub fn original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }

    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;

    pub fn ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }

    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;

    pub fn ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }

    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;

    pub fn ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }

    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CAttribute_WorldItemPlacement {
    const NAME: &'static str = "CAttribute_WorldItemPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.original_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.ang_x = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.ang_y = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ang_z = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_z {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CAttribute_WorldItemPlacement {
        CAttribute_WorldItemPlacement::new()
    }

    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CAttribute_WorldItemPlacement {
        static instance: CAttribute_WorldItemPlacement = CAttribute_WorldItemPlacement {
            original_item_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            ang_x: ::std::option::Option::None,
            ang_y: ::std::option::Option::None,
            ang_z: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CGCMsg_WorldItemPlacement_Update)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCMsg_WorldItemPlacement_Update {
    // message fields
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.original_item_id)
    pub original_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_x)
    pub pos_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_y)
    pub pos_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.pos_z)
    pub pos_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_x)
    pub ang_x: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_y)
    pub ang_y: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.ang_z)
    pub ang_z: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.force_remove_all)
    pub force_remove_all: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CGCMsg_WorldItemPlacement_Update.attrib_name)
    pub attrib_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCMsg_WorldItemPlacement_Update.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCMsg_WorldItemPlacement_Update {
    fn default() -> &'a CGCMsg_WorldItemPlacement_Update {
        <CGCMsg_WorldItemPlacement_Update as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCMsg_WorldItemPlacement_Update {
    pub fn new() -> CGCMsg_WorldItemPlacement_Update {
        ::std::default::Default::default()
    }

    // optional uint64 original_item_id = 1;

    pub fn original_item_id(&self) -> u64 {
        self.original_item_id.unwrap_or(0)
    }

    pub fn clear_original_item_id(&mut self) {
        self.original_item_id = ::std::option::Option::None;
    }

    pub fn has_original_item_id(&self) -> bool {
        self.original_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_item_id(&mut self, v: u64) {
        self.original_item_id = ::std::option::Option::Some(v);
    }

    // optional float pos_x = 2;

    pub fn pos_x(&self) -> f32 {
        self.pos_x.unwrap_or(0.)
    }

    pub fn clear_pos_x(&mut self) {
        self.pos_x = ::std::option::Option::None;
    }

    pub fn has_pos_x(&self) -> bool {
        self.pos_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_x(&mut self, v: f32) {
        self.pos_x = ::std::option::Option::Some(v);
    }

    // optional float pos_y = 3;

    pub fn pos_y(&self) -> f32 {
        self.pos_y.unwrap_or(0.)
    }

    pub fn clear_pos_y(&mut self) {
        self.pos_y = ::std::option::Option::None;
    }

    pub fn has_pos_y(&self) -> bool {
        self.pos_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_y(&mut self, v: f32) {
        self.pos_y = ::std::option::Option::Some(v);
    }

    // optional float pos_z = 4;

    pub fn pos_z(&self) -> f32 {
        self.pos_z.unwrap_or(0.)
    }

    pub fn clear_pos_z(&mut self) {
        self.pos_z = ::std::option::Option::None;
    }

    pub fn has_pos_z(&self) -> bool {
        self.pos_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pos_z(&mut self, v: f32) {
        self.pos_z = ::std::option::Option::Some(v);
    }

    // optional float ang_x = 5;

    pub fn ang_x(&self) -> f32 {
        self.ang_x.unwrap_or(0.)
    }

    pub fn clear_ang_x(&mut self) {
        self.ang_x = ::std::option::Option::None;
    }

    pub fn has_ang_x(&self) -> bool {
        self.ang_x.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_x(&mut self, v: f32) {
        self.ang_x = ::std::option::Option::Some(v);
    }

    // optional float ang_y = 6;

    pub fn ang_y(&self) -> f32 {
        self.ang_y.unwrap_or(0.)
    }

    pub fn clear_ang_y(&mut self) {
        self.ang_y = ::std::option::Option::None;
    }

    pub fn has_ang_y(&self) -> bool {
        self.ang_y.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_y(&mut self, v: f32) {
        self.ang_y = ::std::option::Option::Some(v);
    }

    // optional float ang_z = 7;

    pub fn ang_z(&self) -> f32 {
        self.ang_z.unwrap_or(0.)
    }

    pub fn clear_ang_z(&mut self) {
        self.ang_z = ::std::option::Option::None;
    }

    pub fn has_ang_z(&self) -> bool {
        self.ang_z.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ang_z(&mut self, v: f32) {
        self.ang_z = ::std::option::Option::Some(v);
    }

    // optional bool force_remove_all = 8;

    pub fn force_remove_all(&self) -> bool {
        self.force_remove_all.unwrap_or(false)
    }

    pub fn clear_force_remove_all(&mut self) {
        self.force_remove_all = ::std::option::Option::None;
    }

    pub fn has_force_remove_all(&self) -> bool {
        self.force_remove_all.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_remove_all(&mut self, v: bool) {
        self.force_remove_all = ::std::option::Option::Some(v);
    }

    // optional string attrib_name = 9;

    pub fn attrib_name(&self) -> &str {
        match self.attrib_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_attrib_name(&mut self) {
        self.attrib_name = ::std::option::Option::None;
    }

    pub fn has_attrib_name(&self) -> bool {
        self.attrib_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attrib_name(&mut self, v: ::std::string::String) {
        self.attrib_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attrib_name(&mut self) -> &mut ::std::string::String {
        if self.attrib_name.is_none() {
            self.attrib_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.attrib_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_attrib_name(&mut self) -> ::std::string::String {
        self.attrib_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCMsg_WorldItemPlacement_Update {
    const NAME: &'static str = "CGCMsg_WorldItemPlacement_Update";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.original_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.pos_x = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.pos_y = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.pos_z = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.ang_x = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.ang_y = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.ang_z = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.force_remove_all = ::std::option::Option::Some(is.read_bool()?);
                },
                74 => {
                    self.attrib_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pos_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pos_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_x {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_y {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ang_z {
            my_size += 1 + 4;
        }
        if let Some(v) = self.force_remove_all {
            my_size += 1 + 1;
        }
        if let Some(v) = self.attrib_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.original_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pos_x {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.pos_y {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.pos_z {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.ang_x {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.ang_y {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.ang_z {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.force_remove_all {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.attrib_name.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCMsg_WorldItemPlacement_Update {
        CGCMsg_WorldItemPlacement_Update::new()
    }

    fn clear(&mut self) {
        self.original_item_id = ::std::option::Option::None;
        self.pos_x = ::std::option::Option::None;
        self.pos_y = ::std::option::Option::None;
        self.pos_z = ::std::option::Option::None;
        self.ang_x = ::std::option::Option::None;
        self.ang_y = ::std::option::Option::None;
        self.ang_z = ::std::option::Option::None;
        self.force_remove_all = ::std::option::Option::None;
        self.attrib_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCMsg_WorldItemPlacement_Update {
        static instance: CGCMsg_WorldItemPlacement_Update = CGCMsg_WorldItemPlacement_Update {
            original_item_id: ::std::option::Option::None,
            pos_x: ::std::option::Option::None,
            pos_y: ::std::option::Option::None,
            pos_z: ::std::option::Option::None,
            ang_x: ::std::option::Option::None,
            ang_y: ::std::option::Option::None,
            ang_z: ::std::option::Option::None,
            force_remove_all: ::std::option::Option::None,
            attrib_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAcknowledgeXP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAcknowledgeXP {
    // message fields
    // @@protoc_insertion_point(field:CMsgAcknowledgeXP.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAcknowledgeXP.predicted_experience)
    pub predicted_experience: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAcknowledgeXP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAcknowledgeXP {
    fn default() -> &'a CMsgAcknowledgeXP {
        <CMsgAcknowledgeXP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAcknowledgeXP {
    pub fn new() -> CMsgAcknowledgeXP {
        ::std::default::Default::default()
    }

    // optional int32 match_group = 1;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 predicted_experience = 2;

    pub fn predicted_experience(&self) -> u32 {
        self.predicted_experience.unwrap_or(0)
    }

    pub fn clear_predicted_experience(&mut self) {
        self.predicted_experience = ::std::option::Option::None;
    }

    pub fn has_predicted_experience(&self) -> bool {
        self.predicted_experience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_predicted_experience(&mut self, v: u32) {
        self.predicted_experience = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAcknowledgeXP {
    const NAME: &'static str = "CMsgAcknowledgeXP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.predicted_experience = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.predicted_experience {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_group {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.predicted_experience {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAcknowledgeXP {
        CMsgAcknowledgeXP::new()
    }

    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.predicted_experience = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAcknowledgeXP {
        static instance: CMsgAcknowledgeXP = CMsgAcknowledgeXP {
            match_group: ::std::option::Option::None,
            predicted_experience: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFXPSource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFXPSource {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFXPSource.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_tfxpsource::XPSourceType>>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.amount)
    pub amount: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFXPSource.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFXPSource.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSource {
    fn default() -> &'a CMsgTFXPSource {
        <CMsgTFXPSource as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSource {
    pub fn new() -> CMsgTFXPSource {
        ::std::default::Default::default()
    }

    // optional .CMsgTFXPSource.XPSourceType type = 1;

    pub fn type_(&self) -> cmsg_tfxpsource::XPSourceType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_tfxpsource::XPSourceType::SOURCE_SCORE),
            None => cmsg_tfxpsource::XPSourceType::SOURCE_SCORE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_tfxpsource::XPSourceType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 amount = 2;

    pub fn amount(&self) -> i32 {
        self.amount.unwrap_or(0)
    }

    pub fn clear_amount(&mut self) {
        self.amount = ::std::option::Option::None;
    }

    pub fn has_amount(&self) -> bool {
        self.amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: i32) {
        self.amount = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 4;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFXPSource {
    const NAME: &'static str = "CMsgTFXPSource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.amount = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.type_ {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.amount {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFXPSource {
        CMsgTFXPSource::new()
    }

    fn clear(&mut self) {
        self.type_ = ::std::option::Option::None;
        self.amount = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFXPSource {
        static instance: CMsgTFXPSource = CMsgTFXPSource {
            type_: ::std::option::Option::None,
            amount: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgTFXPSource`
pub mod cmsg_tfxpsource {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgTFXPSource.XPSourceType)
    pub enum XPSourceType {
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_SCORE)
        SOURCE_SCORE = 0,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_OBJECTIVE_BONUS)
        SOURCE_OBJECTIVE_BONUS = 1,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPLETED_MATCH)
        SOURCE_COMPLETED_MATCH = 2,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_ABANDON)
        SOURCE_COMPETITIVE_ABANDON = 3,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_WIN)
        SOURCE_COMPETITIVE_WIN = 4,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_COMPETITIVE_LOSS)
        SOURCE_COMPETITIVE_LOSS = 5,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_AUTOBALANCE_BONUS)
        SOURCE_AUTOBALANCE_BONUS = 6,
        // @@protoc_insertion_point(enum_value:CMsgTFXPSource.XPSourceType.SOURCE_PRESTIGE_BONUS)
        SOURCE_PRESTIGE_BONUS = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for XPSourceType {
        const NAME: &'static str = "XPSourceType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<XPSourceType> {
            match value {
                0 => ::std::option::Option::Some(XPSourceType::SOURCE_SCORE),
                1 => ::std::option::Option::Some(XPSourceType::SOURCE_OBJECTIVE_BONUS),
                2 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPLETED_MATCH),
                3 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_ABANDON),
                4 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_WIN),
                5 => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_LOSS),
                6 => ::std::option::Option::Some(XPSourceType::SOURCE_AUTOBALANCE_BONUS),
                7 => ::std::option::Option::Some(XPSourceType::SOURCE_PRESTIGE_BONUS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<XPSourceType> {
            match str {
                "SOURCE_SCORE" => ::std::option::Option::Some(XPSourceType::SOURCE_SCORE),
                "SOURCE_OBJECTIVE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_OBJECTIVE_BONUS),
                "SOURCE_COMPLETED_MATCH" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPLETED_MATCH),
                "SOURCE_COMPETITIVE_ABANDON" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_ABANDON),
                "SOURCE_COMPETITIVE_WIN" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_WIN),
                "SOURCE_COMPETITIVE_LOSS" => ::std::option::Option::Some(XPSourceType::SOURCE_COMPETITIVE_LOSS),
                "SOURCE_AUTOBALANCE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_AUTOBALANCE_BONUS),
                "SOURCE_PRESTIGE_BONUS" => ::std::option::Option::Some(XPSourceType::SOURCE_PRESTIGE_BONUS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [XPSourceType] = &[
            XPSourceType::SOURCE_SCORE,
            XPSourceType::SOURCE_OBJECTIVE_BONUS,
            XPSourceType::SOURCE_COMPLETED_MATCH,
            XPSourceType::SOURCE_COMPETITIVE_ABANDON,
            XPSourceType::SOURCE_COMPETITIVE_WIN,
            XPSourceType::SOURCE_COMPETITIVE_LOSS,
            XPSourceType::SOURCE_AUTOBALANCE_BONUS,
            XPSourceType::SOURCE_PRESTIGE_BONUS,
        ];
    }

    impl ::std::default::Default for XPSourceType {
        fn default() -> Self {
            XPSourceType::SOURCE_SCORE
        }
    }

}

// @@protoc_insertion_point(message:CMsgTFXPSourceBreakdown)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFXPSourceBreakdown {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFXPSourceBreakdown.sources)
    pub sources: ::std::vec::Vec<CMsgTFXPSource>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFXPSourceBreakdown.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFXPSourceBreakdown {
    fn default() -> &'a CMsgTFXPSourceBreakdown {
        <CMsgTFXPSourceBreakdown as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFXPSourceBreakdown {
    pub fn new() -> CMsgTFXPSourceBreakdown {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFXPSourceBreakdown {
    const NAME: &'static str = "CMsgTFXPSourceBreakdown";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sources.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.sources {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFXPSourceBreakdown {
        CMsgTFXPSourceBreakdown::new()
    }

    fn clear(&mut self) {
        self.sources.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFXPSourceBreakdown {
        static instance: CMsgTFXPSourceBreakdown = CMsgTFXPSourceBreakdown {
            sources: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTFClientInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTFClientInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgTFClientInit.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTFClientInit.language)
    pub language: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTFClientInit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTFClientInit {
    fn default() -> &'a CMsgTFClientInit {
        <CMsgTFClientInit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTFClientInit {
    pub fn new() -> CMsgTFClientInit {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTFClientInit {
    const NAME: &'static str = "CMsgTFClientInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTFClientInit {
        CMsgTFClientInit::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTFClientInit {
        static instance: CMsgTFClientInit = CMsgTFClientInit {
            client_version: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotification.notification_id)
    pub notification_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNotification.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotification.expiration_time)
    pub expiration_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotification.type)
    pub type_: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcnotification::NotificationType>>,
    // @@protoc_insertion_point(field:CMsgGCNotification.notification_string)
    pub notification_string: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotification {
    fn default() -> &'a CMsgGCNotification {
        <CMsgGCNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotification {
    pub fn new() -> CMsgGCNotification {
        ::std::default::Default::default()
    }

    // optional uint64 notification_id = 1;

    pub fn notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }

    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 expiration_time = 3;

    pub fn expiration_time(&self) -> u32 {
        self.expiration_time.unwrap_or(0)
    }

    pub fn clear_expiration_time(&mut self) {
        self.expiration_time = ::std::option::Option::None;
    }

    pub fn has_expiration_time(&self) -> bool {
        self.expiration_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expiration_time(&mut self, v: u32) {
        self.expiration_time = ::std::option::Option::Some(v);
    }

    // optional .CMsgGCNotification.NotificationType type = 4;

    pub fn type_(&self) -> cmsg_gcnotification::NotificationType {
        match self.type_ {
            Some(e) => e.enum_value_or(cmsg_gcnotification::NotificationType::NOTIFICATION_CUSTOM_STRING),
            None => cmsg_gcnotification::NotificationType::NOTIFICATION_CUSTOM_STRING,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: cmsg_gcnotification::NotificationType) {
        self.type_ = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string notification_string = 5;

    pub fn notification_string(&self) -> &str {
        match self.notification_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_notification_string(&mut self) {
        self.notification_string = ::std::option::Option::None;
    }

    pub fn has_notification_string(&self) -> bool {
        self.notification_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_string(&mut self, v: ::std::string::String) {
        self.notification_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_notification_string(&mut self) -> &mut ::std::string::String {
        if self.notification_string.is_none() {
            self.notification_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.notification_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_notification_string(&mut self) -> ::std::string::String {
        self.notification_string.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotification {
    const NAME: &'static str = "CMsgGCNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.notification_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.expiration_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                32 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                42 => {
                    self.notification_string = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.expiration_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.notification_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.notification_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.expiration_time {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.notification_string.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotification {
        CMsgGCNotification::new()
    }

    fn clear(&mut self) {
        self.notification_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.expiration_time = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.notification_string = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotification {
        static instance: CMsgGCNotification = CMsgGCNotification {
            notification_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            expiration_time: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            notification_string: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCNotification`
pub mod cmsg_gcnotification {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCNotification.NotificationType)
    pub enum NotificationType {
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_REPORTED_PLAYER_BANNED)
        NOTIFICATION_REPORTED_PLAYER_BANNED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_CUSTOM_STRING)
        NOTIFICATION_CUSTOM_STRING = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS)
        NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_REPORTED_PLAYER_WAS_BANNED)
        NOTIFICATION_REPORTED_PLAYER_WAS_BANNED = 3,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_SUPPORT_MESSAGE)
        NOTIFICATION_SUPPORT_MESSAGE = 4,
        // @@protoc_insertion_point(enum_value:CMsgGCNotification.NotificationType.NOTIFICATION_NUM_TYPES)
        NOTIFICATION_NUM_TYPES = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for NotificationType {
        const NAME: &'static str = "NotificationType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<NotificationType> {
            match value {
                0 => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED),
                1 => ::std::option::Option::Some(NotificationType::NOTIFICATION_CUSTOM_STRING),
                2 => ::std::option::Option::Some(NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS),
                3 => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED),
                4 => ::std::option::Option::Some(NotificationType::NOTIFICATION_SUPPORT_MESSAGE),
                5 => ::std::option::Option::Some(NotificationType::NOTIFICATION_NUM_TYPES),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<NotificationType> {
            match str {
                "NOTIFICATION_REPORTED_PLAYER_BANNED" => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED),
                "NOTIFICATION_CUSTOM_STRING" => ::std::option::Option::Some(NotificationType::NOTIFICATION_CUSTOM_STRING),
                "NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS" => ::std::option::Option::Some(NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS),
                "NOTIFICATION_REPORTED_PLAYER_WAS_BANNED" => ::std::option::Option::Some(NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED),
                "NOTIFICATION_SUPPORT_MESSAGE" => ::std::option::Option::Some(NotificationType::NOTIFICATION_SUPPORT_MESSAGE),
                "NOTIFICATION_NUM_TYPES" => ::std::option::Option::Some(NotificationType::NOTIFICATION_NUM_TYPES),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [NotificationType] = &[
            NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED,
            NotificationType::NOTIFICATION_CUSTOM_STRING,
            NotificationType::NOTIFICATION_MM_BAN_DUE_TO_EXCESSIVE_REPORTS,
            NotificationType::NOTIFICATION_REPORTED_PLAYER_WAS_BANNED,
            NotificationType::NOTIFICATION_SUPPORT_MESSAGE,
            NotificationType::NOTIFICATION_NUM_TYPES,
        ];
    }

    impl ::std::default::Default for NotificationType {
        fn default() -> Self {
            NotificationType::NOTIFICATION_REPORTED_PLAYER_BANNED
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCNotificationQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotificationQueue.notifications)
    pub notifications: ::std::vec::Vec<CMsgGCNotification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationQueue {
    fn default() -> &'a CMsgGCNotificationQueue {
        <CMsgGCNotificationQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationQueue {
    pub fn new() -> CMsgGCNotificationQueue {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotificationQueue {
    const NAME: &'static str = "CMsgGCNotificationQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.notifications {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationQueue {
        CMsgGCNotificationQueue::new()
    }

    fn clear(&mut self) {
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationQueue {
        static instance: CMsgGCNotificationQueue = CMsgGCNotificationQueue {
            notifications: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNotificationAcknowledge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotificationAcknowledge {
    // message fields
    // @@protoc_insertion_point(field:CMsgNotificationAcknowledge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgNotificationAcknowledge.notification_id)
    pub notification_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotificationAcknowledge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledge {
    fn default() -> &'a CMsgNotificationAcknowledge {
        <CMsgNotificationAcknowledge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledge {
    pub fn new() -> CMsgNotificationAcknowledge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 notification_id = 2;

    pub fn notification_id(&self) -> u64 {
        self.notification_id.unwrap_or(0)
    }

    pub fn clear_notification_id(&mut self) {
        self.notification_id = ::std::option::Option::None;
    }

    pub fn has_notification_id(&self) -> bool {
        self.notification_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_notification_id(&mut self, v: u64) {
        self.notification_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgNotificationAcknowledge {
    const NAME: &'static str = "CMsgNotificationAcknowledge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.notification_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.notification_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.notification_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotificationAcknowledge {
        CMsgNotificationAcknowledge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.notification_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledge {
        static instance: CMsgNotificationAcknowledge = CMsgNotificationAcknowledge {
            account_id: ::std::option::Option::None,
            notification_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgNotificationAcknowledgeReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNotificationAcknowledgeReply {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNotificationAcknowledgeReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNotificationAcknowledgeReply {
    fn default() -> &'a CMsgNotificationAcknowledgeReply {
        <CMsgNotificationAcknowledgeReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgNotificationAcknowledgeReply {
    pub fn new() -> CMsgNotificationAcknowledgeReply {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgNotificationAcknowledgeReply {
    const NAME: &'static str = "CMsgNotificationAcknowledgeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNotificationAcknowledgeReply {
        CMsgNotificationAcknowledgeReply::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNotificationAcknowledgeReply {
        static instance: CMsgNotificationAcknowledgeReply = CMsgNotificationAcknowledgeReply {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Match_Result)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Match_Result {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gc_match_result::Status>>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.red_score)
    pub red_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.blue_score)
    pub blue_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.map_index)
    pub map_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.game_type)
    pub game_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.players)
    pub players: ::std::vec::Vec<cmsg_gc_match_result::Player>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.win_reason)
    pub win_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_Match_Result.bots)
    pub bots: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Match_Result.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_Result {
    fn default() -> &'a CMsgGC_Match_Result {
        <CMsgGC_Match_Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_Result {
    pub fn new() -> CMsgGC_Match_Result {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_Match_Result.Status status = 3;

    pub fn status(&self) -> cmsg_gc_match_result::Status {
        match self.status {
            Some(e) => e.enum_value_or(cmsg_gc_match_result::Status::MATCH_SUCCEEDED),
            None => cmsg_gc_match_result::Status::MATCH_SUCCEEDED,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: cmsg_gc_match_result::Status) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 duration = 4;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 red_score = 5;

    pub fn red_score(&self) -> u32 {
        self.red_score.unwrap_or(0)
    }

    pub fn clear_red_score(&mut self) {
        self.red_score = ::std::option::Option::None;
    }

    pub fn has_red_score(&self) -> bool {
        self.red_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_red_score(&mut self, v: u32) {
        self.red_score = ::std::option::Option::Some(v);
    }

    // optional uint32 blue_score = 6;

    pub fn blue_score(&self) -> u32 {
        self.blue_score.unwrap_or(0)
    }

    pub fn clear_blue_score(&mut self) {
        self.blue_score = ::std::option::Option::None;
    }

    pub fn has_blue_score(&self) -> bool {
        self.blue_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blue_score(&mut self, v: u32) {
        self.blue_score = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 7;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 8;

    pub fn map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }

    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 game_type = 9;

    pub fn game_type(&self) -> u32 {
        self.game_type.unwrap_or(0u32)
    }

    pub fn clear_game_type(&mut self) {
        self.game_type = ::std::option::Option::None;
    }

    pub fn has_game_type(&self) -> bool {
        self.game_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_type(&mut self, v: u32) {
        self.game_type = ::std::option::Option::Some(v);
    }

    // optional uint32 win_reason = 13;

    pub fn win_reason(&self) -> u32 {
        self.win_reason.unwrap_or(0)
    }

    pub fn clear_win_reason(&mut self) {
        self.win_reason = ::std::option::Option::None;
    }

    pub fn has_win_reason(&self) -> bool {
        self.win_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_reason(&mut self, v: u32) {
        self.win_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 14;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 bots = 16;

    pub fn bots(&self) -> u32 {
        self.bots.unwrap_or(0)
    }

    pub fn clear_bots(&mut self) {
        self.bots = ::std::option::Option::None;
    }

    pub fn has_bots(&self) -> bool {
        self.bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bots(&mut self, v: u32) {
        self.bots = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Match_Result {
    const NAME: &'static str = "CMsgGC_Match_Result";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.red_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.blue_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.map_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.game_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.players.push(is.read_message()?);
                },
                104 => {
                    self.win_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.bots = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.red_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.blue_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.map_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.win_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.bots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.red_score {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.blue_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_type {
            os.write_uint32(9, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        };
        if let Some(v) = self.win_reason {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.bots {
            os.write_uint32(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Match_Result {
        CMsgGC_Match_Result::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.red_score = ::std::option::Option::None;
        self.blue_score = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.game_type = ::std::option::Option::None;
        self.players.clear();
        self.win_reason = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.bots = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Match_Result {
        static instance: CMsgGC_Match_Result = CMsgGC_Match_Result {
            match_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            status: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            red_score: ::std::option::Option::None,
            blue_score: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            map_index: ::std::option::Option::None,
            game_type: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            win_reason: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            bots: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_Match_Result`
pub mod cmsg_gc_match_result {
    // @@protoc_insertion_point(message:CMsgGC_Match_Result.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.original_party_id)
        pub original_party_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.flags)
        pub flags: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.classes_played)
        pub classes_played: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.damage)
        pub damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.healing)
        pub healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.support)
        pub support: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.score_medal)
        pub score_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.kills_medal)
        pub kills_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.damage_medal)
        pub damage_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.healing_medal)
        pub healing_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.support_medal)
        pub support_medal: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.xp_breakdown)
        pub xp_breakdown: ::std::vec::Vec<super::CMsgTFXPSource>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.leave_time)
        pub leave_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.leave_reason)
        pub leave_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::TFMatchLeaveReason>>,
        // @@protoc_insertion_point(field:CMsgGC_Match_Result.Player.connect_time)
        pub connect_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_Match_Result.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint64 original_party_id = 2;

        pub fn original_party_id(&self) -> u64 {
            self.original_party_id.unwrap_or(0)
        }

        pub fn clear_original_party_id(&mut self) {
            self.original_party_id = ::std::option::Option::None;
        }

        pub fn has_original_party_id(&self) -> bool {
            self.original_party_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_original_party_id(&mut self, v: u64) {
            self.original_party_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 3;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 4;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 ping = 5;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional uint32 flags = 6;

        pub fn flags(&self) -> u32 {
            self.flags.unwrap_or(0)
        }

        pub fn clear_flags(&mut self) {
            self.flags = ::std::option::Option::None;
        }

        pub fn has_flags(&self) -> bool {
            self.flags.is_some()
        }

        // Param is passed by value, moved
        pub fn set_flags(&mut self, v: u32) {
            self.flags = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 9;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 classes_played = 10;

        pub fn classes_played(&self) -> u32 {
            self.classes_played.unwrap_or(0)
        }

        pub fn clear_classes_played(&mut self) {
            self.classes_played = ::std::option::Option::None;
        }

        pub fn has_classes_played(&self) -> bool {
            self.classes_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_classes_played(&mut self, v: u32) {
            self.classes_played = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 11;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 12;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 damage = 13;

        pub fn damage(&self) -> u32 {
            self.damage.unwrap_or(0)
        }

        pub fn clear_damage(&mut self) {
            self.damage = ::std::option::Option::None;
        }

        pub fn has_damage(&self) -> bool {
            self.damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage(&mut self, v: u32) {
            self.damage = ::std::option::Option::Some(v);
        }

        // optional uint32 healing = 14;

        pub fn healing(&self) -> u32 {
            self.healing.unwrap_or(0)
        }

        pub fn clear_healing(&mut self) {
            self.healing = ::std::option::Option::None;
        }

        pub fn has_healing(&self) -> bool {
            self.healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing(&mut self, v: u32) {
            self.healing = ::std::option::Option::Some(v);
        }

        // optional uint32 support = 15;

        pub fn support(&self) -> u32 {
            self.support.unwrap_or(0)
        }

        pub fn clear_support(&mut self) {
            self.support = ::std::option::Option::None;
        }

        pub fn has_support(&self) -> bool {
            self.support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support(&mut self, v: u32) {
            self.support = ::std::option::Option::Some(v);
        }

        // optional uint32 score_medal = 16;

        pub fn score_medal(&self) -> u32 {
            self.score_medal.unwrap_or(0)
        }

        pub fn clear_score_medal(&mut self) {
            self.score_medal = ::std::option::Option::None;
        }

        pub fn has_score_medal(&self) -> bool {
            self.score_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score_medal(&mut self, v: u32) {
            self.score_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 kills_medal = 17;

        pub fn kills_medal(&self) -> u32 {
            self.kills_medal.unwrap_or(0)
        }

        pub fn clear_kills_medal(&mut self) {
            self.kills_medal = ::std::option::Option::None;
        }

        pub fn has_kills_medal(&self) -> bool {
            self.kills_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills_medal(&mut self, v: u32) {
            self.kills_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 damage_medal = 18;

        pub fn damage_medal(&self) -> u32 {
            self.damage_medal.unwrap_or(0)
        }

        pub fn clear_damage_medal(&mut self) {
            self.damage_medal = ::std::option::Option::None;
        }

        pub fn has_damage_medal(&self) -> bool {
            self.damage_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage_medal(&mut self, v: u32) {
            self.damage_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 healing_medal = 19;

        pub fn healing_medal(&self) -> u32 {
            self.healing_medal.unwrap_or(0)
        }

        pub fn clear_healing_medal(&mut self) {
            self.healing_medal = ::std::option::Option::None;
        }

        pub fn has_healing_medal(&self) -> bool {
            self.healing_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing_medal(&mut self, v: u32) {
            self.healing_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 support_medal = 20;

        pub fn support_medal(&self) -> u32 {
            self.support_medal.unwrap_or(0)
        }

        pub fn clear_support_medal(&mut self) {
            self.support_medal = ::std::option::Option::None;
        }

        pub fn has_support_medal(&self) -> bool {
            self.support_medal.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_medal(&mut self, v: u32) {
            self.support_medal = ::std::option::Option::Some(v);
        }

        // optional uint32 leave_time = 22;

        pub fn leave_time(&self) -> u32 {
            self.leave_time.unwrap_or(0)
        }

        pub fn clear_leave_time(&mut self) {
            self.leave_time = ::std::option::Option::None;
        }

        pub fn has_leave_time(&self) -> bool {
            self.leave_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leave_time(&mut self, v: u32) {
            self.leave_time = ::std::option::Option::Some(v);
        }

        // optional .TFMatchLeaveReason leave_reason = 23;

        pub fn leave_reason(&self) -> super::TFMatchLeaveReason {
            match self.leave_reason {
                Some(e) => e.enum_value_or(super::TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
                None => super::TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
            }
        }

        pub fn clear_leave_reason(&mut self) {
            self.leave_reason = ::std::option::Option::None;
        }

        pub fn has_leave_reason(&self) -> bool {
            self.leave_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leave_reason(&mut self, v: super::TFMatchLeaveReason) {
            self.leave_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 connect_time = 24;

        pub fn connect_time(&self) -> u32 {
            self.connect_time.unwrap_or(0)
        }

        pub fn clear_connect_time(&mut self) {
            self.connect_time = ::std::option::Option::None;
        }

        pub fn has_connect_time(&self) -> bool {
            self.connect_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_connect_time(&mut self, v: u32) {
            self.connect_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.original_party_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    24 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.flags = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.classes_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    120 => {
                        self.support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.score_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.kills_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.damage_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.healing_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.support_medal = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    170 => {
                        self.xp_breakdown.push(is.read_message()?);
                    },
                    176 => {
                        self.leave_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.leave_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    192 => {
                        self.connect_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.original_party_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.ping {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.flags {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.classes_played {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.support {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.score_medal {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.kills_medal {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.damage_medal {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.healing_medal {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.support_medal {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
            }
            for value in &self.xp_breakdown {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.leave_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.leave_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(23, v.value());
            }
            if let Some(v) = self.connect_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.original_party_id {
                os.write_uint64(2, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.flags {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.classes_played {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.damage {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.healing {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.support {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.score_medal {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.kills_medal {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.damage_medal {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.healing_medal {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.support_medal {
                os.write_uint32(20, v)?;
            }
            for v in &self.xp_breakdown {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
            };
            if let Some(v) = self.leave_time {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.leave_reason {
                os.write_enum(23, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.connect_time {
                os.write_uint32(24, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.original_party_id = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.flags = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.classes_played = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.damage = ::std::option::Option::None;
            self.healing = ::std::option::Option::None;
            self.support = ::std::option::Option::None;
            self.score_medal = ::std::option::Option::None;
            self.kills_medal = ::std::option::Option::None;
            self.damage_medal = ::std::option::Option::None;
            self.healing_medal = ::std::option::Option::None;
            self.support_medal = ::std::option::Option::None;
            self.xp_breakdown.clear();
            self.leave_time = ::std::option::Option::None;
            self.leave_reason = ::std::option::Option::None;
            self.connect_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                original_party_id: ::std::option::Option::None,
                team: ::std::option::Option::None,
                score: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                flags: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                classes_played: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                damage: ::std::option::Option::None,
                healing: ::std::option::Option::None,
                support: ::std::option::Option::None,
                score_medal: ::std::option::Option::None,
                kills_medal: ::std::option::Option::None,
                damage_medal: ::std::option::Option::None,
                healing_medal: ::std::option::Option::None,
                support_medal: ::std::option::Option::None,
                xp_breakdown: ::std::vec::Vec::new(),
                leave_time: ::std::option::Option::None,
                leave_reason: ::std::option::Option::None,
                connect_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_Match_Result.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_SUCCEEDED)
        MATCH_SUCCEEDED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_GC)
        MATCH_FAILED_GC = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_TRUSTED)
        MATCH_FAILED_TRUSTED = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_ABANDON)
        MATCH_FAILED_ABANDON = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_UNKNOWN)
        MATCH_FAILED_UNKNOWN = 5,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FAILED_TIMEOUT)
        MATCH_FAILED_TIMEOUT = 6,
        // @@protoc_insertion_point(enum_value:CMsgGC_Match_Result.Status.MATCH_FINISHED_ABANDON)
        MATCH_FINISHED_ABANDON = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::MATCH_SUCCEEDED),
                1 => ::std::option::Option::Some(Status::MATCH_FAILED_GC),
                2 => ::std::option::Option::Some(Status::MATCH_FAILED_TRUSTED),
                3 => ::std::option::Option::Some(Status::MATCH_FAILED_ABANDON),
                5 => ::std::option::Option::Some(Status::MATCH_FAILED_UNKNOWN),
                6 => ::std::option::Option::Some(Status::MATCH_FAILED_TIMEOUT),
                7 => ::std::option::Option::Some(Status::MATCH_FINISHED_ABANDON),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "MATCH_SUCCEEDED" => ::std::option::Option::Some(Status::MATCH_SUCCEEDED),
                "MATCH_FAILED_GC" => ::std::option::Option::Some(Status::MATCH_FAILED_GC),
                "MATCH_FAILED_TRUSTED" => ::std::option::Option::Some(Status::MATCH_FAILED_TRUSTED),
                "MATCH_FAILED_ABANDON" => ::std::option::Option::Some(Status::MATCH_FAILED_ABANDON),
                "MATCH_FAILED_UNKNOWN" => ::std::option::Option::Some(Status::MATCH_FAILED_UNKNOWN),
                "MATCH_FAILED_TIMEOUT" => ::std::option::Option::Some(Status::MATCH_FAILED_TIMEOUT),
                "MATCH_FINISHED_ABANDON" => ::std::option::Option::Some(Status::MATCH_FINISHED_ABANDON),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::MATCH_SUCCEEDED,
            Status::MATCH_FAILED_GC,
            Status::MATCH_FAILED_TRUSTED,
            Status::MATCH_FAILED_ABANDON,
            Status::MATCH_FAILED_UNKNOWN,
            Status::MATCH_FAILED_TIMEOUT,
            Status::MATCH_FINISHED_ABANDON,
        ];
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::MATCH_SUCCEEDED
        }
    }

}

// @@protoc_insertion_point(message:CMsgGC_Match_ResultResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Match_ResultResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Match_ResultResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Match_ResultResponse {
    fn default() -> &'a CMsgGC_Match_ResultResponse {
        <CMsgGC_Match_ResultResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Match_ResultResponse {
    pub fn new() -> CMsgGC_Match_ResultResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Match_ResultResponse {
    const NAME: &'static str = "CMsgGC_Match_ResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Match_ResultResponse {
        CMsgGC_Match_ResultResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Match_ResultResponse {
        static instance: CMsgGC_Match_ResultResponse = CMsgGC_Match_ResultResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CEconItemPreviewDataBlock)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CEconItemPreviewDataBlock {
    // message fields
    // @@protoc_insertion_point(field:CEconItemPreviewDataBlock.econitem)
    pub econitem: ::steam_vent_proto_common::protobuf::MessageField<super::base_gcmessages::CSOEconItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CEconItemPreviewDataBlock.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CEconItemPreviewDataBlock {
    fn default() -> &'a CEconItemPreviewDataBlock {
        <CEconItemPreviewDataBlock as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CEconItemPreviewDataBlock {
    pub fn new() -> CEconItemPreviewDataBlock {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CEconItemPreviewDataBlock {
    const NAME: &'static str = "CEconItemPreviewDataBlock";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.econitem)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.econitem.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.econitem.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CEconItemPreviewDataBlock {
        CEconItemPreviewDataBlock::new()
    }

    fn clear(&mut self) {
        self.econitem.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CEconItemPreviewDataBlock {
        static instance: CEconItemPreviewDataBlock = CEconItemPreviewDataBlock {
            econitem: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Client2GCEconPreviewDataBlockRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_s)
    pub param_s: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_a)
    pub param_a: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_d)
    pub param_d: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockRequest.param_m)
    pub param_m: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client2GCEconPreviewDataBlockRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockRequest {
        <CMsgGC_Client2GCEconPreviewDataBlockRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockRequest {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        ::std::default::Default::default()
    }

    // optional uint64 param_s = 1;

    pub fn param_s(&self) -> u64 {
        self.param_s.unwrap_or(0)
    }

    pub fn clear_param_s(&mut self) {
        self.param_s = ::std::option::Option::None;
    }

    pub fn has_param_s(&self) -> bool {
        self.param_s.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_s(&mut self, v: u64) {
        self.param_s = ::std::option::Option::Some(v);
    }

    // optional uint64 param_a = 2;

    pub fn param_a(&self) -> u64 {
        self.param_a.unwrap_or(0)
    }

    pub fn clear_param_a(&mut self) {
        self.param_a = ::std::option::Option::None;
    }

    pub fn has_param_a(&self) -> bool {
        self.param_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_a(&mut self, v: u64) {
        self.param_a = ::std::option::Option::Some(v);
    }

    // optional uint64 param_d = 3;

    pub fn param_d(&self) -> u64 {
        self.param_d.unwrap_or(0)
    }

    pub fn clear_param_d(&mut self) {
        self.param_d = ::std::option::Option::None;
    }

    pub fn has_param_d(&self) -> bool {
        self.param_d.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_d(&mut self, v: u64) {
        self.param_d = ::std::option::Option::Some(v);
    }

    // optional uint64 param_m = 4;

    pub fn param_m(&self) -> u64 {
        self.param_m.unwrap_or(0)
    }

    pub fn clear_param_m(&mut self) {
        self.param_m = ::std::option::Option::None;
    }

    pub fn has_param_m(&self) -> bool {
        self.param_m.is_some()
    }

    // Param is passed by value, moved
    pub fn set_param_m(&mut self, v: u64) {
        self.param_m = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    const NAME: &'static str = "CMsgGC_Client2GCEconPreviewDataBlockRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.param_s = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.param_a = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.param_d = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.param_m = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.param_s {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.param_a {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.param_d {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.param_m {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.param_s {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.param_a {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.param_d {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.param_m {
            os.write_uint64(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockRequest {
        CMsgGC_Client2GCEconPreviewDataBlockRequest::new()
    }

    fn clear(&mut self) {
        self.param_s = ::std::option::Option::None;
        self.param_a = ::std::option::Option::None;
        self.param_d = ::std::option::Option::None;
        self.param_m = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockRequest {
        static instance: CMsgGC_Client2GCEconPreviewDataBlockRequest = CMsgGC_Client2GCEconPreviewDataBlockRequest {
            param_s: ::std::option::Option::None,
            param_a: ::std::option::Option::None,
            param_d: ::std::option::Option::None,
            param_m: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_Client2GCEconPreviewDataBlockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_Client2GCEconPreviewDataBlockResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_Client2GCEconPreviewDataBlockResponse.iteminfo)
    pub iteminfo: ::steam_vent_proto_common::protobuf::MessageField<CEconItemPreviewDataBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_Client2GCEconPreviewDataBlockResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn default() -> &'a CMsgGC_Client2GCEconPreviewDataBlockResponse {
        <CMsgGC_Client2GCEconPreviewDataBlockResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_Client2GCEconPreviewDataBlockResponse {
    pub fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    const NAME: &'static str = "CMsgGC_Client2GCEconPreviewDataBlockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.iteminfo)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.iteminfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.iteminfo.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_Client2GCEconPreviewDataBlockResponse {
        CMsgGC_Client2GCEconPreviewDataBlockResponse::new()
    }

    fn clear(&mut self) {
        self.iteminfo.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_Client2GCEconPreviewDataBlockResponse {
        static instance: CMsgGC_Client2GCEconPreviewDataBlockResponse = CMsgGC_Client2GCEconPreviewDataBlockResponse {
            iteminfo: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFLadderPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFLadderPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.season_id)
    pub season_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.games)
    pub games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing)
    pub healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support)
    pub support: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_bronze)
    pub score_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_silver)
    pub score_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.score_gold)
    pub score_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_bronze)
    pub kills_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_silver)
    pub kills_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.kills_gold)
    pub kills_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_bronze)
    pub damage_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_silver)
    pub damage_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.damage_gold)
    pub damage_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_bronze)
    pub healing_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_silver)
    pub healing_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.healing_gold)
    pub healing_gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_bronze)
    pub support_bronze: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_silver)
    pub support_silver: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFLadderPlayerStats.support_gold)
    pub support_gold: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFLadderPlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFLadderPlayerStats {
    fn default() -> &'a CSOTFLadderPlayerStats {
        <CSOTFLadderPlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFLadderPlayerStats {
    pub fn new() -> CSOTFLadderPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 2;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 3;

    pub fn season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }

    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 games = 9;

    pub fn games(&self) -> u32 {
        self.games.unwrap_or(0)
    }

    pub fn clear_games(&mut self) {
        self.games = ::std::option::Option::None;
    }

    pub fn has_games(&self) -> bool {
        self.games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_games(&mut self, v: u32) {
        self.games = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 10;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 11;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 12;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 13;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 14;

    pub fn healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 15;

    pub fn support(&self) -> u32 {
        self.support.unwrap_or(0)
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_bronze = 16;

    pub fn score_bronze(&self) -> u32 {
        self.score_bronze.unwrap_or(0)
    }

    pub fn clear_score_bronze(&mut self) {
        self.score_bronze = ::std::option::Option::None;
    }

    pub fn has_score_bronze(&self) -> bool {
        self.score_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_bronze(&mut self, v: u32) {
        self.score_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 score_silver = 17;

    pub fn score_silver(&self) -> u32 {
        self.score_silver.unwrap_or(0)
    }

    pub fn clear_score_silver(&mut self) {
        self.score_silver = ::std::option::Option::None;
    }

    pub fn has_score_silver(&self) -> bool {
        self.score_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_silver(&mut self, v: u32) {
        self.score_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 score_gold = 18;

    pub fn score_gold(&self) -> u32 {
        self.score_gold.unwrap_or(0)
    }

    pub fn clear_score_gold(&mut self) {
        self.score_gold = ::std::option::Option::None;
    }

    pub fn has_score_gold(&self) -> bool {
        self.score_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_gold(&mut self, v: u32) {
        self.score_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_bronze = 19;

    pub fn kills_bronze(&self) -> u32 {
        self.kills_bronze.unwrap_or(0)
    }

    pub fn clear_kills_bronze(&mut self) {
        self.kills_bronze = ::std::option::Option::None;
    }

    pub fn has_kills_bronze(&self) -> bool {
        self.kills_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_bronze(&mut self, v: u32) {
        self.kills_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_silver = 20;

    pub fn kills_silver(&self) -> u32 {
        self.kills_silver.unwrap_or(0)
    }

    pub fn clear_kills_silver(&mut self) {
        self.kills_silver = ::std::option::Option::None;
    }

    pub fn has_kills_silver(&self) -> bool {
        self.kills_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_silver(&mut self, v: u32) {
        self.kills_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_gold = 21;

    pub fn kills_gold(&self) -> u32 {
        self.kills_gold.unwrap_or(0)
    }

    pub fn clear_kills_gold(&mut self) {
        self.kills_gold = ::std::option::Option::None;
    }

    pub fn has_kills_gold(&self) -> bool {
        self.kills_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_gold(&mut self, v: u32) {
        self.kills_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_bronze = 22;

    pub fn damage_bronze(&self) -> u32 {
        self.damage_bronze.unwrap_or(0)
    }

    pub fn clear_damage_bronze(&mut self) {
        self.damage_bronze = ::std::option::Option::None;
    }

    pub fn has_damage_bronze(&self) -> bool {
        self.damage_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_bronze(&mut self, v: u32) {
        self.damage_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_silver = 23;

    pub fn damage_silver(&self) -> u32 {
        self.damage_silver.unwrap_or(0)
    }

    pub fn clear_damage_silver(&mut self) {
        self.damage_silver = ::std::option::Option::None;
    }

    pub fn has_damage_silver(&self) -> bool {
        self.damage_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_silver(&mut self, v: u32) {
        self.damage_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_gold = 24;

    pub fn damage_gold(&self) -> u32 {
        self.damage_gold.unwrap_or(0)
    }

    pub fn clear_damage_gold(&mut self) {
        self.damage_gold = ::std::option::Option::None;
    }

    pub fn has_damage_gold(&self) -> bool {
        self.damage_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_gold(&mut self, v: u32) {
        self.damage_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_bronze = 25;

    pub fn healing_bronze(&self) -> u32 {
        self.healing_bronze.unwrap_or(0)
    }

    pub fn clear_healing_bronze(&mut self) {
        self.healing_bronze = ::std::option::Option::None;
    }

    pub fn has_healing_bronze(&self) -> bool {
        self.healing_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_bronze(&mut self, v: u32) {
        self.healing_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_silver = 26;

    pub fn healing_silver(&self) -> u32 {
        self.healing_silver.unwrap_or(0)
    }

    pub fn clear_healing_silver(&mut self) {
        self.healing_silver = ::std::option::Option::None;
    }

    pub fn has_healing_silver(&self) -> bool {
        self.healing_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_silver(&mut self, v: u32) {
        self.healing_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_gold = 27;

    pub fn healing_gold(&self) -> u32 {
        self.healing_gold.unwrap_or(0)
    }

    pub fn clear_healing_gold(&mut self) {
        self.healing_gold = ::std::option::Option::None;
    }

    pub fn has_healing_gold(&self) -> bool {
        self.healing_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_gold(&mut self, v: u32) {
        self.healing_gold = ::std::option::Option::Some(v);
    }

    // optional uint32 support_bronze = 28;

    pub fn support_bronze(&self) -> u32 {
        self.support_bronze.unwrap_or(0)
    }

    pub fn clear_support_bronze(&mut self) {
        self.support_bronze = ::std::option::Option::None;
    }

    pub fn has_support_bronze(&self) -> bool {
        self.support_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_bronze(&mut self, v: u32) {
        self.support_bronze = ::std::option::Option::Some(v);
    }

    // optional uint32 support_silver = 29;

    pub fn support_silver(&self) -> u32 {
        self.support_silver.unwrap_or(0)
    }

    pub fn clear_support_silver(&mut self) {
        self.support_silver = ::std::option::Option::None;
    }

    pub fn has_support_silver(&self) -> bool {
        self.support_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_silver(&mut self, v: u32) {
        self.support_silver = ::std::option::Option::Some(v);
    }

    // optional uint32 support_gold = 30;

    pub fn support_gold(&self) -> u32 {
        self.support_gold.unwrap_or(0)
    }

    pub fn clear_support_gold(&mut self) {
        self.support_gold = ::std::option::Option::None;
    }

    pub fn has_support_gold(&self) -> bool {
        self.support_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold(&mut self, v: u32) {
        self.support_gold = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFLadderPlayerStats {
    const NAME: &'static str = "CSOTFLadderPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.games = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.support = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.score_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.score_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.score_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.kills_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.kills_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.kills_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.damage_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.damage_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.damage_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.healing_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.healing_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.healing_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.support_bronze = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.support_silver = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.season_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.healing {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.support {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.score_bronze {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.score_silver {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.score_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.kills_bronze {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.kills_silver {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.kills_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.damage_bronze {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.damage_silver {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.damage_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.healing_bronze {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.healing_silver {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.healing_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.support_bronze {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.support_silver {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.support_gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.games {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.score_bronze {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.score_silver {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.score_gold {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.kills_bronze {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.kills_silver {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.kills_gold {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.damage_bronze {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_silver {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.damage_gold {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.healing_bronze {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.healing_silver {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.healing_gold {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.support_bronze {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.support_silver {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.support_gold {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFLadderPlayerStats {
        CSOTFLadderPlayerStats::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.games = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_bronze = ::std::option::Option::None;
        self.score_silver = ::std::option::Option::None;
        self.score_gold = ::std::option::Option::None;
        self.kills_bronze = ::std::option::Option::None;
        self.kills_silver = ::std::option::Option::None;
        self.kills_gold = ::std::option::Option::None;
        self.damage_bronze = ::std::option::Option::None;
        self.damage_silver = ::std::option::Option::None;
        self.damage_gold = ::std::option::Option::None;
        self.healing_bronze = ::std::option::Option::None;
        self.healing_silver = ::std::option::Option::None;
        self.healing_gold = ::std::option::Option::None;
        self.support_bronze = ::std::option::Option::None;
        self.support_silver = ::std::option::Option::None;
        self.support_gold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFLadderPlayerStats {
        static instance: CSOTFLadderPlayerStats = CSOTFLadderPlayerStats {
            account_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            season_id: ::std::option::Option::None,
            games: ::std::option::Option::None,
            score: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            healing: ::std::option::Option::None,
            support: ::std::option::Option::None,
            score_bronze: ::std::option::Option::None,
            score_silver: ::std::option::Option::None,
            score_gold: ::std::option::Option::None,
            kills_bronze: ::std::option::Option::None,
            kills_silver: ::std::option::Option::None,
            kills_gold: ::std::option::Option::None,
            damage_bronze: ::std::option::Option::None,
            damage_silver: ::std::option::Option::None,
            damage_gold: ::std::option::Option::None,
            healing_bronze: ::std::option::Option::None,
            healing_silver: ::std::option::Option::None,
            healing_gold: ::std::option::Option::None,
            support_bronze: ::std::option::Option::None,
            support_silver: ::std::option::Option::None,
            support_gold: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOTFRatingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFRatingData {
    // message fields
    // @@protoc_insertion_point(field:CSOTFRatingData.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_type)
    pub rating_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_primary)
    pub rating_primary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_secondary)
    pub rating_secondary: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFRatingData.rating_tertiary)
    pub rating_tertiary: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFRatingData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFRatingData {
    fn default() -> &'a CSOTFRatingData {
        <CSOTFRatingData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFRatingData {
    pub fn new() -> CSOTFRatingData {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 rating_type = 2;

    pub fn rating_type(&self) -> i32 {
        self.rating_type.unwrap_or(0)
    }

    pub fn clear_rating_type(&mut self) {
        self.rating_type = ::std::option::Option::None;
    }

    pub fn has_rating_type(&self) -> bool {
        self.rating_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_type(&mut self, v: i32) {
        self.rating_type = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_primary = 3;

    pub fn rating_primary(&self) -> u32 {
        self.rating_primary.unwrap_or(0)
    }

    pub fn clear_rating_primary(&mut self) {
        self.rating_primary = ::std::option::Option::None;
    }

    pub fn has_rating_primary(&self) -> bool {
        self.rating_primary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_primary(&mut self, v: u32) {
        self.rating_primary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_secondary = 4;

    pub fn rating_secondary(&self) -> u32 {
        self.rating_secondary.unwrap_or(0)
    }

    pub fn clear_rating_secondary(&mut self) {
        self.rating_secondary = ::std::option::Option::None;
    }

    pub fn has_rating_secondary(&self) -> bool {
        self.rating_secondary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_secondary(&mut self, v: u32) {
        self.rating_secondary = ::std::option::Option::Some(v);
    }

    // optional uint32 rating_tertiary = 5;

    pub fn rating_tertiary(&self) -> u32 {
        self.rating_tertiary.unwrap_or(0)
    }

    pub fn clear_rating_tertiary(&mut self) {
        self.rating_tertiary = ::std::option::Option::None;
    }

    pub fn has_rating_tertiary(&self) -> bool {
        self.rating_tertiary.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating_tertiary(&mut self, v: u32) {
        self.rating_tertiary = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFRatingData {
    const NAME: &'static str = "CSOTFRatingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.rating_type = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.rating_primary = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rating_secondary = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rating_tertiary = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.rating_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.rating_primary {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rating_secondary {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rating_tertiary {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rating_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.rating_primary {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rating_secondary {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rating_tertiary {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFRatingData {
        CSOTFRatingData::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.rating_type = ::std::option::Option::None;
        self.rating_primary = ::std::option::Option::None;
        self.rating_secondary = ::std::option::Option::None;
        self.rating_tertiary = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFRatingData {
        static instance: CSOTFRatingData = CSOTFRatingData {
            account_id: ::std::option::Option::None,
            rating_type: ::std::option::Option::None,
            rating_primary: ::std::option::Option::None,
            rating_secondary: ::std::option::Option::None,
            rating_tertiary: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_TFVoteKickPlayerRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_TFVoteKickPlayerRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.target_id)
    pub target_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.voter_id)
    pub voter_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<TFVoteKickReason>>,
    // @@protoc_insertion_point(field:CMsgGC_TFVoteKickPlayerRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_TFVoteKickPlayerRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_TFVoteKickPlayerRequest {
    fn default() -> &'a CMsgGC_TFVoteKickPlayerRequest {
        <CMsgGC_TFVoteKickPlayerRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_TFVoteKickPlayerRequest {
    pub fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        ::std::default::Default::default()
    }

    // optional uint64 target_id = 2;

    pub fn target_id(&self) -> u64 {
        self.target_id.unwrap_or(0)
    }

    pub fn clear_target_id(&mut self) {
        self.target_id = ::std::option::Option::None;
    }

    pub fn has_target_id(&self) -> bool {
        self.target_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_id(&mut self, v: u64) {
        self.target_id = ::std::option::Option::Some(v);
    }

    // optional uint64 voter_id = 3;

    pub fn voter_id(&self) -> u64 {
        self.voter_id.unwrap_or(0)
    }

    pub fn clear_voter_id(&mut self) {
        self.voter_id = ::std::option::Option::None;
    }

    pub fn has_voter_id(&self) -> bool {
        self.voter_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_id(&mut self, v: u64) {
        self.voter_id = ::std::option::Option::Some(v);
    }

    // optional .TFVoteKickReason reason = 4;

    pub fn reason(&self) -> TFVoteKickReason {
        match self.reason {
            Some(e) => e.enum_value_or(TFVoteKickReason::TFVoteKickReason_Invalid),
            None => TFVoteKickReason::TFVoteKickReason_Invalid,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: TFVoteKickReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 5;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_TFVoteKickPlayerRequest {
    const NAME: &'static str = "CMsgGC_TFVoteKickPlayerRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.target_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.voter_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.voter_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.voter_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_TFVoteKickPlayerRequest {
        CMsgGC_TFVoteKickPlayerRequest::new()
    }

    fn clear(&mut self) {
        self.target_id = ::std::option::Option::None;
        self.voter_id = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_TFVoteKickPlayerRequest {
        static instance: CMsgGC_TFVoteKickPlayerRequest = CMsgGC_TFVoteKickPlayerRequest {
            target_id: ::std::option::Option::None,
            voter_id: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_VoteKickPlayerRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_VoteKickPlayerRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.allowed)
    pub allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.voter_inhibit)
    pub voter_inhibit: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGC_VoteKickPlayerRequestResponse.target_inhibit)
    pub target_inhibit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_VoteKickPlayerRequestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_VoteKickPlayerRequestResponse {
    fn default() -> &'a CMsgGC_VoteKickPlayerRequestResponse {
        <CMsgGC_VoteKickPlayerRequestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_VoteKickPlayerRequestResponse {
    pub fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        ::std::default::Default::default()
    }

    // optional bool allowed = 1;

    pub fn allowed(&self) -> bool {
        self.allowed.unwrap_or(false)
    }

    pub fn clear_allowed(&mut self) {
        self.allowed = ::std::option::Option::None;
    }

    pub fn has_allowed(&self) -> bool {
        self.allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowed(&mut self, v: bool) {
        self.allowed = ::std::option::Option::Some(v);
    }

    // optional bool voter_inhibit = 3;

    pub fn voter_inhibit(&self) -> bool {
        self.voter_inhibit.unwrap_or(false)
    }

    pub fn clear_voter_inhibit(&mut self) {
        self.voter_inhibit = ::std::option::Option::None;
    }

    pub fn has_voter_inhibit(&self) -> bool {
        self.voter_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voter_inhibit(&mut self, v: bool) {
        self.voter_inhibit = ::std::option::Option::Some(v);
    }

    // optional bool target_inhibit = 4;

    pub fn target_inhibit(&self) -> bool {
        self.target_inhibit.unwrap_or(false)
    }

    pub fn clear_target_inhibit(&mut self) {
        self.target_inhibit = ::std::option::Option::None;
    }

    pub fn has_target_inhibit(&self) -> bool {
        self.target_inhibit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_inhibit(&mut self, v: bool) {
        self.target_inhibit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_VoteKickPlayerRequestResponse {
    const NAME: &'static str = "CMsgGC_VoteKickPlayerRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.voter_inhibit = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.target_inhibit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allowed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.voter_inhibit {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_inhibit {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.allowed {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.voter_inhibit {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.target_inhibit {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_VoteKickPlayerRequestResponse {
        CMsgGC_VoteKickPlayerRequestResponse::new()
    }

    fn clear(&mut self) {
        self.allowed = ::std::option::Option::None;
        self.voter_inhibit = ::std::option::Option::None;
        self.target_inhibit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_VoteKickPlayerRequestResponse {
        static instance: CMsgGC_VoteKickPlayerRequestResponse = CMsgGC_VoteKickPlayerRequestResponse {
            allowed: ::std::option::Option::None,
            voter_inhibit: ::std::option::Option::None,
            target_inhibit: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_DailyCompetitiveStatsRollup {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup {
        <CMsgGC_DailyCompetitiveStatsRollup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup {
    const NAME: &'static str = "CMsgGC_DailyCompetitiveStatsRollup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup {
        CMsgGC_DailyCompetitiveStatsRollup::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup {
        static instance: CMsgGC_DailyCompetitiveStatsRollup = CMsgGC_DailyCompetitiveStatsRollup {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_DailyCompetitiveStatsRollup_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.rankdata)
    pub rankdata: ::std::vec::Vec<cmsg_gc_daily_competitive_stats_rollup_response::RankBucketEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn default() -> &'a CMsgGC_DailyCompetitiveStatsRollup_Response {
        <CMsgGC_DailyCompetitiveStatsRollup_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_DailyCompetitiveStatsRollup_Response {
    pub fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_DailyCompetitiveStatsRollup_Response {
    const NAME: &'static str = "CMsgGC_DailyCompetitiveStatsRollup_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.rankdata.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.rankdata {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.rankdata {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_DailyCompetitiveStatsRollup_Response {
        CMsgGC_DailyCompetitiveStatsRollup_Response::new()
    }

    fn clear(&mut self) {
        self.rankdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_DailyCompetitiveStatsRollup_Response {
        static instance: CMsgGC_DailyCompetitiveStatsRollup_Response = CMsgGC_DailyCompetitiveStatsRollup_Response {
            rankdata: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_DailyCompetitiveStatsRollup_Response`
pub mod cmsg_gc_daily_competitive_stats_rollup_response {
    // @@protoc_insertion_point(message:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankBucketEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.records)
        pub records: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_score)
        pub avg_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_score)
        pub stdev_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_kills)
        pub avg_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_kills)
        pub stdev_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_damage)
        pub avg_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_damage)
        pub stdev_damage: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_healing)
        pub avg_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_healing)
        pub stdev_healing: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.avg_support)
        pub avg_support: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.stdev_support)
        pub stdev_support: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGC_DailyCompetitiveStatsRollup_Response.RankBucketEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankBucketEntry {
        fn default() -> &'a RankBucketEntry {
            <RankBucketEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RankBucketEntry {
        pub fn new() -> RankBucketEntry {
            ::std::default::Default::default()
        }

        // optional uint32 rank = 1;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional uint32 records = 2;

        pub fn records(&self) -> u32 {
            self.records.unwrap_or(0)
        }

        pub fn clear_records(&mut self) {
            self.records = ::std::option::Option::None;
        }

        pub fn has_records(&self) -> bool {
            self.records.is_some()
        }

        // Param is passed by value, moved
        pub fn set_records(&mut self, v: u32) {
            self.records = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_score = 3;

        pub fn avg_score(&self) -> u32 {
            self.avg_score.unwrap_or(0)
        }

        pub fn clear_avg_score(&mut self) {
            self.avg_score = ::std::option::Option::None;
        }

        pub fn has_avg_score(&self) -> bool {
            self.avg_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_score(&mut self, v: u32) {
            self.avg_score = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_score = 4;

        pub fn stdev_score(&self) -> u32 {
            self.stdev_score.unwrap_or(0)
        }

        pub fn clear_stdev_score(&mut self) {
            self.stdev_score = ::std::option::Option::None;
        }

        pub fn has_stdev_score(&self) -> bool {
            self.stdev_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_score(&mut self, v: u32) {
            self.stdev_score = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_kills = 5;

        pub fn avg_kills(&self) -> u32 {
            self.avg_kills.unwrap_or(0)
        }

        pub fn clear_avg_kills(&mut self) {
            self.avg_kills = ::std::option::Option::None;
        }

        pub fn has_avg_kills(&self) -> bool {
            self.avg_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_kills(&mut self, v: u32) {
            self.avg_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_kills = 6;

        pub fn stdev_kills(&self) -> u32 {
            self.stdev_kills.unwrap_or(0)
        }

        pub fn clear_stdev_kills(&mut self) {
            self.stdev_kills = ::std::option::Option::None;
        }

        pub fn has_stdev_kills(&self) -> bool {
            self.stdev_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_kills(&mut self, v: u32) {
            self.stdev_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_damage = 7;

        pub fn avg_damage(&self) -> u32 {
            self.avg_damage.unwrap_or(0)
        }

        pub fn clear_avg_damage(&mut self) {
            self.avg_damage = ::std::option::Option::None;
        }

        pub fn has_avg_damage(&self) -> bool {
            self.avg_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_damage(&mut self, v: u32) {
            self.avg_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_damage = 8;

        pub fn stdev_damage(&self) -> u32 {
            self.stdev_damage.unwrap_or(0)
        }

        pub fn clear_stdev_damage(&mut self) {
            self.stdev_damage = ::std::option::Option::None;
        }

        pub fn has_stdev_damage(&self) -> bool {
            self.stdev_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_damage(&mut self, v: u32) {
            self.stdev_damage = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_healing = 9;

        pub fn avg_healing(&self) -> u32 {
            self.avg_healing.unwrap_or(0)
        }

        pub fn clear_avg_healing(&mut self) {
            self.avg_healing = ::std::option::Option::None;
        }

        pub fn has_avg_healing(&self) -> bool {
            self.avg_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_healing(&mut self, v: u32) {
            self.avg_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_healing = 10;

        pub fn stdev_healing(&self) -> u32 {
            self.stdev_healing.unwrap_or(0)
        }

        pub fn clear_stdev_healing(&mut self) {
            self.stdev_healing = ::std::option::Option::None;
        }

        pub fn has_stdev_healing(&self) -> bool {
            self.stdev_healing.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_healing(&mut self, v: u32) {
            self.stdev_healing = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_support = 11;

        pub fn avg_support(&self) -> u32 {
            self.avg_support.unwrap_or(0)
        }

        pub fn clear_avg_support(&mut self) {
            self.avg_support = ::std::option::Option::None;
        }

        pub fn has_avg_support(&self) -> bool {
            self.avg_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_support(&mut self, v: u32) {
            self.avg_support = ::std::option::Option::Some(v);
        }

        // optional uint32 stdev_support = 12;

        pub fn stdev_support(&self) -> u32 {
            self.stdev_support.unwrap_or(0)
        }

        pub fn clear_stdev_support(&mut self) {
            self.stdev_support = ::std::option::Option::None;
        }

        pub fn has_stdev_support(&self) -> bool {
            self.stdev_support.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stdev_support(&mut self, v: u32) {
            self.stdev_support = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RankBucketEntry {
        const NAME: &'static str = "RankBucketEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.records = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.avg_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.stdev_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.avg_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.stdev_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.avg_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.stdev_damage = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.avg_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.stdev_healing = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.avg_support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.stdev_support = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.records {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.avg_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.stdev_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.avg_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.stdev_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.avg_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.stdev_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.avg_healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.stdev_healing {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.avg_support {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.stdev_support {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.rank {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.records {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.avg_score {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.stdev_score {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.avg_kills {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.stdev_kills {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.avg_damage {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.stdev_damage {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.avg_healing {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.stdev_healing {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.avg_support {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.stdev_support {
                os.write_uint32(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankBucketEntry {
            RankBucketEntry::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.records = ::std::option::Option::None;
            self.avg_score = ::std::option::Option::None;
            self.stdev_score = ::std::option::Option::None;
            self.avg_kills = ::std::option::Option::None;
            self.stdev_kills = ::std::option::Option::None;
            self.avg_damage = ::std::option::Option::None;
            self.stdev_damage = ::std::option::Option::None;
            self.avg_healing = ::std::option::Option::None;
            self.stdev_healing = ::std::option::Option::None;
            self.avg_support = ::std::option::Option::None;
            self.stdev_support = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankBucketEntry {
            static instance: RankBucketEntry = RankBucketEntry {
                rank: ::std::option::Option::None,
                records: ::std::option::Option::None,
                avg_score: ::std::option::Option::None,
                stdev_score: ::std::option::Option::None,
                avg_kills: ::std::option::Option::None,
                stdev_kills: ::std::option::Option::None,
                avg_damage: ::std::option::Option::None,
                stdev_damage: ::std::option::Option::None,
                avg_healing: ::std::option::Option::None,
                stdev_healing: ::std::option::Option::None,
                avg_support: ::std::option::Option::None,
                stdev_support: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGC_ReportPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_ReportPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_ReportPlayer.account_id_target)
    pub account_id_target: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGC_ReportPlayer.reason)
    pub reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gc_report_player::EReason>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_ReportPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_ReportPlayer {
    fn default() -> &'a CMsgGC_ReportPlayer {
        <CMsgGC_ReportPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_ReportPlayer {
    pub fn new() -> CMsgGC_ReportPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 account_id_target = 1;

    pub fn account_id_target(&self) -> u32 {
        self.account_id_target.unwrap_or(0)
    }

    pub fn clear_account_id_target(&mut self) {
        self.account_id_target = ::std::option::Option::None;
    }

    pub fn has_account_id_target(&self) -> bool {
        self.account_id_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_target(&mut self, v: u32) {
        self.account_id_target = ::std::option::Option::Some(v);
    }

    // optional .CMsgGC_ReportPlayer.EReason reason = 2;

    pub fn reason(&self) -> cmsg_gc_report_player::EReason {
        match self.reason {
            Some(e) => e.enum_value_or(cmsg_gc_report_player::EReason::kReason_INVALID),
            None => cmsg_gc_report_player::EReason::kReason_INVALID,
        }
    }

    pub fn clear_reason(&mut self) {
        self.reason = ::std::option::Option::None;
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: cmsg_gc_report_player::EReason) {
        self.reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_ReportPlayer {
    const NAME: &'static str = "CMsgGC_ReportPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id_target = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_target {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_target {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reason {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_ReportPlayer {
        CMsgGC_ReportPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id_target = ::std::option::Option::None;
        self.reason = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_ReportPlayer {
        static instance: CMsgGC_ReportPlayer = CMsgGC_ReportPlayer {
            account_id_target: ::std::option::Option::None,
            reason: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGC_ReportPlayer`
pub mod cmsg_gc_report_player {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGC_ReportPlayer.EReason)
    pub enum EReason {
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_INVALID)
        kReason_INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_CHEATING)
        kReason_CHEATING = 1,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_IDLE)
        kReason_IDLE = 2,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_HARASSMENT)
        kReason_HARASSMENT = 3,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_GRIEFING)
        kReason_GRIEFING = 4,
        // @@protoc_insertion_point(enum_value:CMsgGC_ReportPlayer.EReason.kReason_COUNT)
        kReason_COUNT = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EReason {
        const NAME: &'static str = "EReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EReason> {
            match value {
                0 => ::std::option::Option::Some(EReason::kReason_INVALID),
                1 => ::std::option::Option::Some(EReason::kReason_CHEATING),
                2 => ::std::option::Option::Some(EReason::kReason_IDLE),
                3 => ::std::option::Option::Some(EReason::kReason_HARASSMENT),
                4 => ::std::option::Option::Some(EReason::kReason_GRIEFING),
                5 => ::std::option::Option::Some(EReason::kReason_COUNT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EReason> {
            match str {
                "kReason_INVALID" => ::std::option::Option::Some(EReason::kReason_INVALID),
                "kReason_CHEATING" => ::std::option::Option::Some(EReason::kReason_CHEATING),
                "kReason_IDLE" => ::std::option::Option::Some(EReason::kReason_IDLE),
                "kReason_HARASSMENT" => ::std::option::Option::Some(EReason::kReason_HARASSMENT),
                "kReason_GRIEFING" => ::std::option::Option::Some(EReason::kReason_GRIEFING),
                "kReason_COUNT" => ::std::option::Option::Some(EReason::kReason_COUNT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EReason] = &[
            EReason::kReason_INVALID,
            EReason::kReason_CHEATING,
            EReason::kReason_IDLE,
            EReason::kReason_HARASSMENT,
            EReason::kReason_GRIEFING,
            EReason::kReason_COUNT,
        ];
    }

    impl ::std::default::Default for EReason {
        fn default() -> Self {
            EReason::kReason_INVALID
        }
    }

}

// @@protoc_insertion_point(message:CSOTFMatchResultPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOTFMatchResultPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.match_group)
    pub match_group: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.endtime)
    pub endtime: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.season_id)
    pub season_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.status)
    pub status: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.original_party_id)
    pub original_party_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.team)
    pub team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.score)
    pub score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.ping)
    pub ping: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.display_rating)
    pub display_rating: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.display_rating_change)
    pub display_rating_change: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.classes_played)
    pub classes_played: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.damage)
    pub damage: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.healing)
    pub healing: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.support)
    pub support: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.score_medal)
    pub score_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.kills_medal)
    pub kills_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.damage_medal)
    pub damage_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.healing_medal)
    pub healing_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.support_medal)
    pub support_medal: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.map_index)
    pub map_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOTFMatchResultPlayerStats.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOTFMatchResultPlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOTFMatchResultPlayerStats {
    fn default() -> &'a CSOTFMatchResultPlayerStats {
        <CSOTFMatchResultPlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOTFMatchResultPlayerStats {
    pub fn new() -> CSOTFMatchResultPlayerStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 match_group = 3;

    pub fn match_group(&self) -> i32 {
        self.match_group.unwrap_or(0)
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: i32) {
        self.match_group = ::std::option::Option::Some(v);
    }

    // optional uint32 endtime = 4;

    pub fn endtime(&self) -> u32 {
        self.endtime.unwrap_or(0)
    }

    pub fn clear_endtime(&mut self) {
        self.endtime = ::std::option::Option::None;
    }

    pub fn has_endtime(&self) -> bool {
        self.endtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endtime(&mut self, v: u32) {
        self.endtime = ::std::option::Option::Some(v);
    }

    // optional uint32 season_id = 5;

    pub fn season_id(&self) -> u32 {
        self.season_id.unwrap_or(0)
    }

    pub fn clear_season_id(&mut self) {
        self.season_id = ::std::option::Option::None;
    }

    pub fn has_season_id(&self) -> bool {
        self.season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_season_id(&mut self, v: u32) {
        self.season_id = ::std::option::Option::Some(v);
    }

    // optional uint32 status = 6;

    pub fn status(&self) -> u32 {
        self.status.unwrap_or(0)
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: u32) {
        self.status = ::std::option::Option::Some(v);
    }

    // optional uint32 original_party_id = 7;

    pub fn original_party_id(&self) -> u32 {
        self.original_party_id.unwrap_or(0)
    }

    pub fn clear_original_party_id(&mut self) {
        self.original_party_id = ::std::option::Option::None;
    }

    pub fn has_original_party_id(&self) -> bool {
        self.original_party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_party_id(&mut self, v: u32) {
        self.original_party_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team = 8;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 9;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }

    // optional uint32 ping = 10;

    pub fn ping(&self) -> u32 {
        self.ping.unwrap_or(0)
    }

    pub fn clear_ping(&mut self) {
        self.ping = ::std::option::Option::None;
    }

    pub fn has_ping(&self) -> bool {
        self.ping.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ping(&mut self, v: u32) {
        self.ping = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 11;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 display_rating = 12;

    pub fn display_rating(&self) -> u32 {
        self.display_rating.unwrap_or(0)
    }

    pub fn clear_display_rating(&mut self) {
        self.display_rating = ::std::option::Option::None;
    }

    pub fn has_display_rating(&self) -> bool {
        self.display_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating(&mut self, v: u32) {
        self.display_rating = ::std::option::Option::Some(v);
    }

    // optional int32 display_rating_change = 13;

    pub fn display_rating_change(&self) -> i32 {
        self.display_rating_change.unwrap_or(0)
    }

    pub fn clear_display_rating_change(&mut self) {
        self.display_rating_change = ::std::option::Option::None;
    }

    pub fn has_display_rating_change(&self) -> bool {
        self.display_rating_change.is_some()
    }

    // Param is passed by value, moved
    pub fn set_display_rating_change(&mut self, v: i32) {
        self.display_rating_change = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 14;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional uint32 classes_played = 15;

    pub fn classes_played(&self) -> u32 {
        self.classes_played.unwrap_or(0)
    }

    pub fn clear_classes_played(&mut self) {
        self.classes_played = ::std::option::Option::None;
    }

    pub fn has_classes_played(&self) -> bool {
        self.classes_played.is_some()
    }

    // Param is passed by value, moved
    pub fn set_classes_played(&mut self, v: u32) {
        self.classes_played = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 16;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 17;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 damage = 18;

    pub fn damage(&self) -> u32 {
        self.damage.unwrap_or(0)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: u32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional uint32 healing = 19;

    pub fn healing(&self) -> u32 {
        self.healing.unwrap_or(0)
    }

    pub fn clear_healing(&mut self) {
        self.healing = ::std::option::Option::None;
    }

    pub fn has_healing(&self) -> bool {
        self.healing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing(&mut self, v: u32) {
        self.healing = ::std::option::Option::Some(v);
    }

    // optional uint32 support = 20;

    pub fn support(&self) -> u32 {
        self.support.unwrap_or(0)
    }

    pub fn clear_support(&mut self) {
        self.support = ::std::option::Option::None;
    }

    pub fn has_support(&self) -> bool {
        self.support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support(&mut self, v: u32) {
        self.support = ::std::option::Option::Some(v);
    }

    // optional uint32 score_medal = 21;

    pub fn score_medal(&self) -> u32 {
        self.score_medal.unwrap_or(0)
    }

    pub fn clear_score_medal(&mut self) {
        self.score_medal = ::std::option::Option::None;
    }

    pub fn has_score_medal(&self) -> bool {
        self.score_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score_medal(&mut self, v: u32) {
        self.score_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 kills_medal = 22;

    pub fn kills_medal(&self) -> u32 {
        self.kills_medal.unwrap_or(0)
    }

    pub fn clear_kills_medal(&mut self) {
        self.kills_medal = ::std::option::Option::None;
    }

    pub fn has_kills_medal(&self) -> bool {
        self.kills_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills_medal(&mut self, v: u32) {
        self.kills_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 damage_medal = 23;

    pub fn damage_medal(&self) -> u32 {
        self.damage_medal.unwrap_or(0)
    }

    pub fn clear_damage_medal(&mut self) {
        self.damage_medal = ::std::option::Option::None;
    }

    pub fn has_damage_medal(&self) -> bool {
        self.damage_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage_medal(&mut self, v: u32) {
        self.damage_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 healing_medal = 24;

    pub fn healing_medal(&self) -> u32 {
        self.healing_medal.unwrap_or(0)
    }

    pub fn clear_healing_medal(&mut self) {
        self.healing_medal = ::std::option::Option::None;
    }

    pub fn has_healing_medal(&self) -> bool {
        self.healing_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healing_medal(&mut self, v: u32) {
        self.healing_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 support_medal = 25;

    pub fn support_medal(&self) -> u32 {
        self.support_medal.unwrap_or(0)
    }

    pub fn clear_support_medal(&mut self) {
        self.support_medal = ::std::option::Option::None;
    }

    pub fn has_support_medal(&self) -> bool {
        self.support_medal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_medal(&mut self, v: u32) {
        self.support_medal = ::std::option::Option::Some(v);
    }

    // optional uint32 map_index = 26;

    pub fn map_index(&self) -> u32 {
        self.map_index.unwrap_or(0)
    }

    pub fn clear_map_index(&mut self) {
        self.map_index = ::std::option::Option::None;
    }

    pub fn has_map_index(&self) -> bool {
        self.map_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_index(&mut self, v: u32) {
        self.map_index = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 27;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOTFMatchResultPlayerStats {
    const NAME: &'static str = "CSOTFMatchResultPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.match_group = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.endtime = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.status = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.original_party_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.ping = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.display_rating = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.display_rating_change = ::std::option::Option::Some(is.read_int32()?);
                },
                112 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.classes_played = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.damage = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.healing = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.support = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.score_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.kills_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.damage_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.healing_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                200 => {
                    self.support_medal = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.map_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                216 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.endtime {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.season_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.original_party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.ping {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.display_rating {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.display_rating_change {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
        }
        if let Some(v) = self.rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.classes_played {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.damage {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.healing {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.support {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.score_medal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.kills_medal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.damage_medal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        if let Some(v) = self.healing_medal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.support_medal {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
        }
        if let Some(v) = self.map_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_group {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.endtime {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.season_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.status {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.original_party_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.ping {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.display_rating {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.display_rating_change {
            os.write_int32(13, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.classes_played {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.damage {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.healing {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.support {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.score_medal {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.kills_medal {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.damage_medal {
            os.write_uint32(23, v)?;
        }
        if let Some(v) = self.healing_medal {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.support_medal {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.map_index {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(27, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOTFMatchResultPlayerStats {
        CSOTFMatchResultPlayerStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.match_group = ::std::option::Option::None;
        self.endtime = ::std::option::Option::None;
        self.season_id = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.original_party_id = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.ping = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.display_rating = ::std::option::Option::None;
        self.display_rating_change = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.classes_played = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.healing = ::std::option::Option::None;
        self.support = ::std::option::Option::None;
        self.score_medal = ::std::option::Option::None;
        self.kills_medal = ::std::option::Option::None;
        self.damage_medal = ::std::option::Option::None;
        self.healing_medal = ::std::option::Option::None;
        self.support_medal = ::std::option::Option::None;
        self.map_index = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOTFMatchResultPlayerStats {
        static instance: CSOTFMatchResultPlayerStats = CSOTFMatchResultPlayerStats {
            match_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            match_group: ::std::option::Option::None,
            endtime: ::std::option::Option::None,
            season_id: ::std::option::Option::None,
            status: ::std::option::Option::None,
            original_party_id: ::std::option::Option::None,
            team: ::std::option::Option::None,
            score: ::std::option::Option::None,
            ping: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            display_rating: ::std::option::Option::None,
            display_rating_change: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            classes_played: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            healing: ::std::option::Option::None,
            support: ::std::option::Option::None,
            score_medal: ::std::option::Option::None,
            kills_medal: ::std::option::Option::None,
            damage_medal: ::std::option::Option::None,
            healing_medal: ::std::option::Option::None,
            support_medal: ::std::option::Option::None,
            map_index: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCRequestMatchMakerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCRequestMatchMakerStats {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCRequestMatchMakerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCRequestMatchMakerStats {
    fn default() -> &'a CMsgGCRequestMatchMakerStats {
        <CMsgGCRequestMatchMakerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCRequestMatchMakerStats {
    pub fn new() -> CMsgGCRequestMatchMakerStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCRequestMatchMakerStats {
    const NAME: &'static str = "CMsgGCRequestMatchMakerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCRequestMatchMakerStats {
        CMsgGCRequestMatchMakerStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCRequestMatchMakerStats {
        static instance: CMsgGCRequestMatchMakerStats = CMsgGCRequestMatchMakerStats {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCDataCenterPopulation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCDataCenterPopulation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCDataCenterPopulation.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCDataCenterPopulation.health_ratio)
    pub health_ratio: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCDataCenterPopulation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPopulation {
    fn default() -> &'a CMsgGCDataCenterPopulation {
        <CMsgGCDataCenterPopulation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPopulation {
    pub fn new() -> CMsgGCDataCenterPopulation {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float health_ratio = 2;

    pub fn health_ratio(&self) -> f32 {
        self.health_ratio.unwrap_or(0.)
    }

    pub fn clear_health_ratio(&mut self) {
        self.health_ratio = ::std::option::Option::None;
    }

    pub fn has_health_ratio(&self) -> bool {
        self.health_ratio.is_some()
    }

    // Param is passed by value, moved
    pub fn set_health_ratio(&mut self, v: f32) {
        self.health_ratio = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCDataCenterPopulation {
    const NAME: &'static str = "CMsgGCDataCenterPopulation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                21 => {
                    self.health_ratio = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.health_ratio {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.health_ratio {
            os.write_float(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCDataCenterPopulation {
        CMsgGCDataCenterPopulation::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.health_ratio = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCDataCenterPopulation {
        static instance: CMsgGCDataCenterPopulation = CMsgGCDataCenterPopulation {
            name: ::std::option::Option::None,
            health_ratio: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMatchGroupDataCenterPopulation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchGroupDataCenterPopulation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchGroupDataCenterPopulation.data_center_population)
    pub data_center_population: ::std::vec::Vec<CMsgGCDataCenterPopulation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchGroupDataCenterPopulation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchGroupDataCenterPopulation {
    fn default() -> &'a CMsgGCMatchGroupDataCenterPopulation {
        <CMsgGCMatchGroupDataCenterPopulation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchGroupDataCenterPopulation {
    pub fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMatchGroupDataCenterPopulation {
    const NAME: &'static str = "CMsgGCMatchGroupDataCenterPopulation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data_center_population.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.data_center_population {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchGroupDataCenterPopulation {
        CMsgGCMatchGroupDataCenterPopulation::new()
    }

    fn clear(&mut self) {
        self.data_center_population.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchGroupDataCenterPopulation {
        static instance: CMsgGCMatchGroupDataCenterPopulation = CMsgGCMatchGroupDataCenterPopulation {
            data_center_population: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMatchMakerStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchMakerStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchMakerStatsResponse.map_count)
    pub map_count: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGCMatchMakerStatsResponse.matchgroup_data_center_population)
    pub matchgroup_data_center_population: ::std::vec::Vec<CMsgGCMatchGroupDataCenterPopulation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchMakerStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchMakerStatsResponse {
    fn default() -> &'a CMsgGCMatchMakerStatsResponse {
        <CMsgGCMatchMakerStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchMakerStatsResponse {
    pub fn new() -> CMsgGCMatchMakerStatsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMatchMakerStatsResponse {
    const NAME: &'static str = "CMsgGCMatchMakerStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.map_count)?;
                },
                8 => {
                    self.map_count.push(is.read_uint32()?);
                },
                18 => {
                    self.matchgroup_data_center_population.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.map_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        for value in &self.matchgroup_data_center_population {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.map_count {
            os.write_uint32(1, *v)?;
        };
        for v in &self.matchgroup_data_center_population {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchMakerStatsResponse {
        CMsgGCMatchMakerStatsResponse::new()
    }

    fn clear(&mut self) {
        self.map_count.clear();
        self.matchgroup_data_center_population.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchMakerStatsResponse {
        static instance: CMsgGCMatchMakerStatsResponse = CMsgGCMatchMakerStatsResponse {
            map_count: ::std::vec::Vec::new(),
            matchgroup_data_center_population: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMatchHistoryLoad)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchHistoryLoad {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchHistoryLoad.match_group)
    pub match_group: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ETFMatchGroup>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchHistoryLoad.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchHistoryLoad {
    fn default() -> &'a CMsgGCMatchHistoryLoad {
        <CMsgGCMatchHistoryLoad as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchHistoryLoad {
    pub fn new() -> CMsgGCMatchHistoryLoad {
        ::std::default::Default::default()
    }

    // optional .ETFMatchGroup match_group = 1;

    pub fn match_group(&self) -> ETFMatchGroup {
        match self.match_group {
            Some(e) => e.enum_value_or(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            None => ETFMatchGroup::k_eTFMatchGroup_Invalid,
        }
    }

    pub fn clear_match_group(&mut self) {
        self.match_group = ::std::option::Option::None;
    }

    pub fn has_match_group(&self) -> bool {
        self.match_group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_group(&mut self, v: ETFMatchGroup) {
        self.match_group = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMatchHistoryLoad {
    const NAME: &'static str = "CMsgGCMatchHistoryLoad";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_group = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_group {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_group {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchHistoryLoad {
        CMsgGCMatchHistoryLoad::new()
    }

    fn clear(&mut self) {
        self.match_group = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchHistoryLoad {
        static instance: CMsgGCMatchHistoryLoad = CMsgGCMatchHistoryLoad {
            match_group: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCDataCenterPing_Update)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCDataCenterPing_Update {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.pingdata)
    pub pingdata: ::std::vec::Vec<cmsg_gcdata_center_ping_update::PingEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCDataCenterPing_Update.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCDataCenterPing_Update {
    fn default() -> &'a CMsgGCDataCenterPing_Update {
        <CMsgGCDataCenterPing_Update as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCDataCenterPing_Update {
    pub fn new() -> CMsgGCDataCenterPing_Update {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCDataCenterPing_Update {
    const NAME: &'static str = "CMsgGCDataCenterPing_Update";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pingdata.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pingdata {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.pingdata {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCDataCenterPing_Update {
        CMsgGCDataCenterPing_Update::new()
    }

    fn clear(&mut self) {
        self.pingdata.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCDataCenterPing_Update {
        static instance: CMsgGCDataCenterPing_Update = CMsgGCDataCenterPing_Update {
            pingdata: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCDataCenterPing_Update`
pub mod cmsg_gcdata_center_ping_update {
    // @@protoc_insertion_point(message:CMsgGCDataCenterPing_Update.PingEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PingEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCDataCenterPing_Update.PingEntry.ping_status)
        pub ping_status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<Status>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCDataCenterPing_Update.PingEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PingEntry {
        fn default() -> &'a PingEntry {
            <PingEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PingEntry {
        pub fn new() -> PingEntry {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 ping = 2;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional .CMsgGCDataCenterPing_Update.Status ping_status = 3;

        pub fn ping_status(&self) -> Status {
            match self.ping_status {
                Some(e) => e.enum_value_or(Status::Normal),
                None => Status::Normal,
            }
        }

        pub fn clear_ping_status(&mut self) {
            self.ping_status = ::std::option::Option::None;
        }

        pub fn has_ping_status(&self) -> bool {
            self.ping_status.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_status(&mut self, v: Status) {
            self.ping_status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PingEntry {
        const NAME: &'static str = "PingEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.ping_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.ping {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.ping_status {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.ping_status {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PingEntry {
            PingEntry::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.ping_status = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PingEntry {
            static instance: PingEntry = PingEntry {
                name: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                ping_status: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCDataCenterPing_Update.Status)
    pub enum Status {
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Invalid)
        Invalid = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Normal)
        Normal = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.Unreachable)
        Unreachable = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCDataCenterPing_Update.Status.FallbackToDCPing)
        FallbackToDCPing = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Status {
        const NAME: &'static str = "Status";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Status> {
            match value {
                0 => ::std::option::Option::Some(Status::Invalid),
                1 => ::std::option::Option::Some(Status::Normal),
                2 => ::std::option::Option::Some(Status::Unreachable),
                3 => ::std::option::Option::Some(Status::FallbackToDCPing),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Status> {
            match str {
                "Invalid" => ::std::option::Option::Some(Status::Invalid),
                "Normal" => ::std::option::Option::Some(Status::Normal),
                "Unreachable" => ::std::option::Option::Some(Status::Unreachable),
                "FallbackToDCPing" => ::std::option::Option::Some(Status::FallbackToDCPing),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Status] = &[
            Status::Invalid,
            Status::Normal,
            Status::Unreachable,
            Status::FallbackToDCPing,
        ];
    }

    impl ::std::default::Default for Status {
        fn default() -> Self {
            Status::Invalid
        }
    }

}

// @@protoc_insertion_point(message:CMsgGC_KickPlayerFromLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGC_KickPlayerFromLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgGC_KickPlayerFromLobby.targetID)
    pub targetID: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGC_KickPlayerFromLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGC_KickPlayerFromLobby {
    fn default() -> &'a CMsgGC_KickPlayerFromLobby {
        <CMsgGC_KickPlayerFromLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGC_KickPlayerFromLobby {
    pub fn new() -> CMsgGC_KickPlayerFromLobby {
        ::std::default::Default::default()
    }

    // optional uint64 targetID = 1;

    pub fn targetID(&self) -> u64 {
        self.targetID.unwrap_or(0)
    }

    pub fn clear_targetID(&mut self) {
        self.targetID = ::std::option::Option::None;
    }

    pub fn has_targetID(&self) -> bool {
        self.targetID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetID(&mut self, v: u64) {
        self.targetID = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGC_KickPlayerFromLobby {
    const NAME: &'static str = "CMsgGC_KickPlayerFromLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.targetID = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.targetID {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.targetID {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGC_KickPlayerFromLobby {
        CMsgGC_KickPlayerFromLobby::new()
    }

    fn clear(&mut self) {
        self.targetID = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGC_KickPlayerFromLobby {
        static instance: CMsgGC_KickPlayerFromLobby = CMsgGC_KickPlayerFromLobby {
            targetID: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCSurveyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSurveyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSurveyRequest.question_type)
    pub question_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<SurveyQuestionType>>,
    // @@protoc_insertion_point(field:CMsgGCSurveyRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSurveyRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyRequest {
    fn default() -> &'a CMsgGCSurveyRequest {
        <CMsgGCSurveyRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyRequest {
    pub fn new() -> CMsgGCSurveyRequest {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;

    pub fn question_type(&self) -> SurveyQuestionType {
        match self.question_type {
            Some(e) => e.enum_value_or(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            None => SurveyQuestionType::QUESTION_MATCH_QUALITY,
        }
    }

    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCSurveyRequest {
    const NAME: &'static str = "CMsgGCSurveyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSurveyRequest {
        CMsgGCSurveyRequest::new()
    }

    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSurveyRequest {
        static instance: CMsgGCSurveyRequest = CMsgGCSurveyRequest {
            question_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.question_type)
    pub question_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<SurveyQuestionType>>,
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCSurveyResponse.response)
    pub response: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSurveyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSurveyResponse {
    fn default() -> &'a CMsgGCSurveyResponse {
        <CMsgGCSurveyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSurveyResponse {
    pub fn new() -> CMsgGCSurveyResponse {
        ::std::default::Default::default()
    }

    // optional .SurveyQuestionType question_type = 1;

    pub fn question_type(&self) -> SurveyQuestionType {
        match self.question_type {
            Some(e) => e.enum_value_or(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            None => SurveyQuestionType::QUESTION_MATCH_QUALITY,
        }
    }

    pub fn clear_question_type(&mut self) {
        self.question_type = ::std::option::Option::None;
    }

    pub fn has_question_type(&self) -> bool {
        self.question_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_type(&mut self, v: SurveyQuestionType) {
        self.question_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 response = 3;

    pub fn response(&self) -> i32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: i32) {
        self.response = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCSurveyResponse {
    const NAME: &'static str = "CMsgGCSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.question_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.response {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSurveyResponse {
        CMsgGCSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.question_type = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSurveyResponse {
        static instance: CMsgGCSurveyResponse = CMsgGCSurveyResponse {
            question_type: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOQuestMapNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuestMapNode {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestMapNode.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.node_id)
    pub node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_0_earned)
    pub star_0_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_1_earned)
    pub star_1_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.star_2_earned)
    pub star_2_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.loot_claimed)
    pub loot_claimed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.selected_quest_def)
    pub selected_quest_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapNode.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestMapNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapNode {
    fn default() -> &'a CSOQuestMapNode {
        <CSOQuestMapNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapNode {
    pub fn new() -> CSOQuestMapNode {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 node_id = 4;

    pub fn node_id(&self) -> u32 {
        self.node_id.unwrap_or(0)
    }

    pub fn clear_node_id(&mut self) {
        self.node_id = ::std::option::Option::None;
    }

    pub fn has_node_id(&self) -> bool {
        self.node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_id(&mut self, v: u32) {
        self.node_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 6;

    pub fn star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }

    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 7;

    pub fn star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }

    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 8;

    pub fn star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }

    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // optional bool loot_claimed = 9;

    pub fn loot_claimed(&self) -> bool {
        self.loot_claimed.unwrap_or(false)
    }

    pub fn clear_loot_claimed(&mut self) {
        self.loot_claimed = ::std::option::Option::None;
    }

    pub fn has_loot_claimed(&self) -> bool {
        self.loot_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_claimed(&mut self, v: bool) {
        self.loot_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 selected_quest_def = 10;

    pub fn selected_quest_def(&self) -> u32 {
        self.selected_quest_def.unwrap_or(0u32)
    }

    pub fn clear_selected_quest_def(&mut self) {
        self.selected_quest_def = ::std::option::Option::None;
    }

    pub fn has_selected_quest_def(&self) -> bool {
        self.selected_quest_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_quest_def(&mut self, v: u32) {
        self.selected_quest_def = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 11;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOQuestMapNode {
    const NAME: &'static str = "CSOQuestMapNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.star_0_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.star_1_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.star_2_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.loot_claimed = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.selected_quest_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.loot_claimed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.selected_quest_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.node_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.loot_claimed {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.selected_quest_def {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestMapNode {
        CSOQuestMapNode::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.node_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.loot_claimed = ::std::option::Option::None;
        self.selected_quest_def = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestMapNode {
        static instance: CSOQuestMapNode = CSOQuestMapNode {
            account_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            node_id: ::std::option::Option::None,
            star_0_earned: ::std::option::Option::None,
            star_1_earned: ::std::option::Option::None,
            star_2_earned: ::std::option::Option::None,
            loot_claimed: ::std::option::Option::None,
            selected_quest_def: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOQuest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuest {
    // message fields
    // @@protoc_insertion_point(field:CSOQuest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOQuest.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.active)
    pub active: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOQuest.points_0)
    pub points_0: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.points_1)
    pub points_1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.points_2)
    pub points_2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.quest_map_node_source_id)
    pub quest_map_node_source_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuest.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuest {
    fn default() -> &'a CSOQuest {
        <CSOQuest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOQuest {
    pub fn new() -> CSOQuest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 2;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 3;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional bool active = 4;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }

    // optional uint32 points_0 = 5;

    pub fn points_0(&self) -> u32 {
        self.points_0.unwrap_or(0)
    }

    pub fn clear_points_0(&mut self) {
        self.points_0 = ::std::option::Option::None;
    }

    pub fn has_points_0(&self) -> bool {
        self.points_0.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_0(&mut self, v: u32) {
        self.points_0 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_1 = 6;

    pub fn points_1(&self) -> u32 {
        self.points_1.unwrap_or(0)
    }

    pub fn clear_points_1(&mut self) {
        self.points_1 = ::std::option::Option::None;
    }

    pub fn has_points_1(&self) -> bool {
        self.points_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_1(&mut self, v: u32) {
        self.points_1 = ::std::option::Option::Some(v);
    }

    // optional uint32 points_2 = 7;

    pub fn points_2(&self) -> u32 {
        self.points_2.unwrap_or(0)
    }

    pub fn clear_points_2(&mut self) {
        self.points_2 = ::std::option::Option::None;
    }

    pub fn has_points_2(&self) -> bool {
        self.points_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_2(&mut self, v: u32) {
        self.points_2 = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_map_node_source_id = 8;

    pub fn quest_map_node_source_id(&self) -> u32 {
        self.quest_map_node_source_id.unwrap_or(0)
    }

    pub fn clear_quest_map_node_source_id(&mut self) {
        self.quest_map_node_source_id = ::std::option::Option::None;
    }

    pub fn has_quest_map_node_source_id(&self) -> bool {
        self.quest_map_node_source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_map_node_source_id(&mut self, v: u32) {
        self.quest_map_node_source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 9;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOQuest {
    const NAME: &'static str = "CSOQuest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.points_0 = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.points_1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.points_2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.quest_map_node_source_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        if let Some(v) = self.points_0 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.points_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.points_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.quest_map_node_source_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.active {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.points_0 {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.points_1 {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.points_2 {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.quest_map_node_source_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuest {
        CSOQuest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.active = ::std::option::Option::None;
        self.points_0 = ::std::option::Option::None;
        self.points_1 = ::std::option::Option::None;
        self.points_2 = ::std::option::Option::None;
        self.quest_map_node_source_id = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuest {
        static instance: CSOQuest = CSOQuest {
            account_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            active: ::std::option::Option::None,
            points_0: ::std::option::Option::None,
            points_1: ::std::option::Option::None,
            points_2: ::std::option::Option::None,
            quest_map_node_source_id: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOQuestMapRewardPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOQuestMapRewardPurchase {
    // message fields
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.count)
    pub count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.map_cycle)
    pub map_cycle: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOQuestMapRewardPurchase.purchase_id)
    pub purchase_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOQuestMapRewardPurchase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOQuestMapRewardPurchase {
    fn default() -> &'a CSOQuestMapRewardPurchase {
        <CSOQuestMapRewardPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOQuestMapRewardPurchase {
    pub fn new() -> CSOQuestMapRewardPurchase {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 defindex = 2;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 count = 3;

    pub fn count(&self) -> u32 {
        self.count.unwrap_or(0)
    }

    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: u32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional uint32 map_cycle = 4;

    pub fn map_cycle(&self) -> u32 {
        self.map_cycle.unwrap_or(0)
    }

    pub fn clear_map_cycle(&mut self) {
        self.map_cycle = ::std::option::Option::None;
    }

    pub fn has_map_cycle(&self) -> bool {
        self.map_cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_cycle(&mut self, v: u32) {
        self.map_cycle = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_id = 5;

    pub fn purchase_id(&self) -> u32 {
        self.purchase_id.unwrap_or(0)
    }

    pub fn clear_purchase_id(&mut self) {
        self.purchase_id = ::std::option::Option::None;
    }

    pub fn has_purchase_id(&self) -> bool {
        self.purchase_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_id(&mut self, v: u32) {
        self.purchase_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOQuestMapRewardPurchase {
    const NAME: &'static str = "CSOQuestMapRewardPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.map_cycle = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.purchase_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.map_cycle {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.purchase_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.defindex {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.map_cycle {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.purchase_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOQuestMapRewardPurchase {
        CSOQuestMapRewardPurchase::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.defindex = ::std::option::Option::None;
        self.count = ::std::option::Option::None;
        self.map_cycle = ::std::option::Option::None;
        self.purchase_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOQuestMapRewardPurchase {
        static instance: CSOQuestMapRewardPurchase = CSOQuestMapRewardPurchase {
            account_id: ::std::option::Option::None,
            defindex: ::std::option::Option::None,
            count: ::std::option::Option::None,
            map_cycle: ::std::option::Option::None,
            purchase_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestIdentify)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestIdentify {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestIdentify.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestIdentify.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestIdentify {
    fn default() -> &'a CMsgGCQuestIdentify {
        <CMsgGCQuestIdentify as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestIdentify {
    pub fn new() -> CMsgGCQuestIdentify {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestIdentify {
    const NAME: &'static str = "CMsgGCQuestIdentify";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestIdentify {
        CMsgGCQuestIdentify::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestIdentify {
        static instance: CMsgGCQuestIdentify = CMsgGCQuestIdentify {
            quest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestDevGive)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestDevGive {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestDevGive.quest_def_index)
    pub quest_def_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestDevGive.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestDevGive {
    fn default() -> &'a CMsgGCQuestDevGive {
        <CMsgGCQuestDevGive as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestDevGive {
    pub fn new() -> CMsgGCQuestDevGive {
        ::std::default::Default::default()
    }

    // optional uint32 quest_def_index = 1;

    pub fn quest_def_index(&self) -> u32 {
        self.quest_def_index.unwrap_or(0)
    }

    pub fn clear_quest_def_index(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
    }

    pub fn has_quest_def_index(&self) -> bool {
        self.quest_def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_def_index(&mut self, v: u32) {
        self.quest_def_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestDevGive {
    const NAME: &'static str = "CMsgGCQuestDevGive";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_def_index {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestDevGive {
        CMsgGCQuestDevGive::new()
    }

    fn clear(&mut self) {
        self.quest_def_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestDevGive {
        static instance: CMsgGCQuestDevGive = CMsgGCQuestDevGive {
            quest_def_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestNodeTurnIn)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestNodeTurnIn {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestNodeTurnIn.node_defindex)
    pub node_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestNodeTurnIn.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestNodeTurnIn {
    fn default() -> &'a CMsgGCQuestNodeTurnIn {
        <CMsgGCQuestNodeTurnIn as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestNodeTurnIn {
    pub fn new() -> CMsgGCQuestNodeTurnIn {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;

    pub fn node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }

    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestNodeTurnIn {
    const NAME: &'static str = "CMsgGCQuestNodeTurnIn";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestNodeTurnIn {
        CMsgGCQuestNodeTurnIn::new()
    }

    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestNodeTurnIn {
        static instance: CMsgGCQuestNodeTurnIn = CMsgGCQuestNodeTurnIn {
            node_defindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestMapUnlockNode)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMapUnlockNode {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMapUnlockNode.node_defindex)
    pub node_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMapUnlockNode.quest_defindex)
    pub quest_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMapUnlockNode.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapUnlockNode {
    fn default() -> &'a CMsgGCQuestMapUnlockNode {
        <CMsgGCQuestMapUnlockNode as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapUnlockNode {
    pub fn new() -> CMsgGCQuestMapUnlockNode {
        ::std::default::Default::default()
    }

    // optional uint32 node_defindex = 1;

    pub fn node_defindex(&self) -> u32 {
        self.node_defindex.unwrap_or(0)
    }

    pub fn clear_node_defindex(&mut self) {
        self.node_defindex = ::std::option::Option::None;
    }

    pub fn has_node_defindex(&self) -> bool {
        self.node_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_defindex(&mut self, v: u32) {
        self.node_defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_defindex = 2;

    pub fn quest_defindex(&self) -> u32 {
        self.quest_defindex.unwrap_or(0)
    }

    pub fn clear_quest_defindex(&mut self) {
        self.quest_defindex = ::std::option::Option::None;
    }

    pub fn has_quest_defindex(&self) -> bool {
        self.quest_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_defindex(&mut self, v: u32) {
        self.quest_defindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestMapUnlockNode {
    const NAME: &'static str = "CMsgGCQuestMapUnlockNode";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.node_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quest_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.node_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quest_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.node_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMapUnlockNode {
        CMsgGCQuestMapUnlockNode::new()
    }

    fn clear(&mut self) {
        self.node_defindex = ::std::option::Option::None;
        self.quest_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMapUnlockNode {
        static instance: CMsgGCQuestMapUnlockNode = CMsgGCQuestMapUnlockNode {
            node_defindex: ::std::option::Option::None,
            quest_defindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNewMatchForLobbyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNewMatchForLobbyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.current_match_id)
    pub current_match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.next_map_id)
    pub next_map_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyRequest.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNewMatchForLobbyRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyRequest {
    fn default() -> &'a CMsgGCNewMatchForLobbyRequest {
        <CMsgGCNewMatchForLobbyRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyRequest {
    pub fn new() -> CMsgGCNewMatchForLobbyRequest {
        ::std::default::Default::default()
    }

    // optional uint64 current_match_id = 1;

    pub fn current_match_id(&self) -> u64 {
        self.current_match_id.unwrap_or(0)
    }

    pub fn clear_current_match_id(&mut self) {
        self.current_match_id = ::std::option::Option::None;
    }

    pub fn has_current_match_id(&self) -> bool {
        self.current_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_match_id(&mut self, v: u64) {
        self.current_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 next_map_id = 2;

    pub fn next_map_id(&self) -> u32 {
        self.next_map_id.unwrap_or(0)
    }

    pub fn clear_next_map_id(&mut self) {
        self.next_map_id = ::std::option::Option::None;
    }

    pub fn has_next_map_id(&self) -> bool {
        self.next_map_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_map_id(&mut self, v: u32) {
        self.next_map_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNewMatchForLobbyRequest {
    const NAME: &'static str = "CMsgGCNewMatchForLobbyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.current_match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.next_map_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.current_match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.next_map_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.current_match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.next_map_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNewMatchForLobbyRequest {
        CMsgGCNewMatchForLobbyRequest::new()
    }

    fn clear(&mut self) {
        self.current_match_id = ::std::option::Option::None;
        self.next_map_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyRequest {
        static instance: CMsgGCNewMatchForLobbyRequest = CMsgGCNewMatchForLobbyRequest {
            current_match_id: ::std::option::Option::None,
            next_map_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNewMatchForLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNewMatchForLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNewMatchForLobbyResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNewMatchForLobbyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNewMatchForLobbyResponse {
    fn default() -> &'a CMsgGCNewMatchForLobbyResponse {
        <CMsgGCNewMatchForLobbyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNewMatchForLobbyResponse {
    pub fn new() -> CMsgGCNewMatchForLobbyResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNewMatchForLobbyResponse {
    const NAME: &'static str = "CMsgGCNewMatchForLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNewMatchForLobbyResponse {
        CMsgGCNewMatchForLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNewMatchForLobbyResponse {
        static instance: CMsgGCNewMatchForLobbyResponse = CMsgGCNewMatchForLobbyResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCChangeMatchPlayerTeamsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.member)
    pub member: ::std::vec::Vec<cmsg_gcchange_match_player_teams_request::Member>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsRequest {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsRequest {
        <CMsgGCChangeMatchPlayerTeamsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsRequest {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCChangeMatchPlayerTeamsRequest {
    const NAME: &'static str = "CMsgGCChangeMatchPlayerTeamsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.member.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.member {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.member {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsRequest {
        CMsgGCChangeMatchPlayerTeamsRequest::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.member.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsRequest {
        static instance: CMsgGCChangeMatchPlayerTeamsRequest = CMsgGCChangeMatchPlayerTeamsRequest {
            match_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            member: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCChangeMatchPlayerTeamsRequest`
pub mod cmsg_gcchange_match_player_teams_request {
    // @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsRequest.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.Member.member_id)
        pub member_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsRequest.Member.new_team)
        pub new_team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::TF_GC_TEAM>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsRequest.Member.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional uint64 member_id = 1;

        pub fn member_id(&self) -> u64 {
            self.member_id.unwrap_or(0)
        }

        pub fn clear_member_id(&mut self) {
            self.member_id = ::std::option::Option::None;
        }

        pub fn has_member_id(&self) -> bool {
            self.member_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_id(&mut self, v: u64) {
            self.member_id = ::std::option::Option::Some(v);
        }

        // optional .TF_GC_TEAM new_team = 2;

        pub fn new_team(&self) -> super::TF_GC_TEAM {
            match self.new_team {
                Some(e) => e.enum_value_or(super::TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
                None => super::TF_GC_TEAM::TF_GC_TEAM_NOTEAM,
            }
        }

        pub fn clear_new_team(&mut self) {
            self.new_team = ::std::option::Option::None;
        }

        pub fn has_new_team(&self) -> bool {
            self.new_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_new_team(&mut self, v: super::TF_GC_TEAM) {
            self.new_team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.member_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.new_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.member_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.new_team {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.member_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.new_team {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.member_id = ::std::option::Option::None;
            self.new_team = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                member_id: ::std::option::Option::None,
                new_team: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCChangeMatchPlayerTeamsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCChangeMatchPlayerTeamsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCChangeMatchPlayerTeamsResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCChangeMatchPlayerTeamsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCChangeMatchPlayerTeamsResponse {
    fn default() -> &'a CMsgGCChangeMatchPlayerTeamsResponse {
        <CMsgGCChangeMatchPlayerTeamsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCChangeMatchPlayerTeamsResponse {
    pub fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCChangeMatchPlayerTeamsResponse {
    const NAME: &'static str = "CMsgGCChangeMatchPlayerTeamsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCChangeMatchPlayerTeamsResponse {
        CMsgGCChangeMatchPlayerTeamsResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCChangeMatchPlayerTeamsResponse {
        static instance: CMsgGCChangeMatchPlayerTeamsResponse = CMsgGCChangeMatchPlayerTeamsResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestComplete_Debug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestComplete_Debug {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Debug.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCQuestComplete_Debug.points_type)
    pub points_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestComplete_Debug.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestComplete_Debug {
    fn default() -> &'a CMsgGCQuestComplete_Debug {
        <CMsgGCQuestComplete_Debug as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestComplete_Debug {
    pub fn new() -> CMsgGCQuestComplete_Debug {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 points_type = 2;

    pub fn points_type(&self) -> u32 {
        self.points_type.unwrap_or(0)
    }

    pub fn clear_points_type(&mut self) {
        self.points_type = ::std::option::Option::None;
    }

    pub fn has_points_type(&self) -> bool {
        self.points_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_type(&mut self, v: u32) {
        self.points_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestComplete_Debug {
    const NAME: &'static str = "CMsgGCQuestComplete_Debug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.points_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.points_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.points_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestComplete_Debug {
        CMsgGCQuestComplete_Debug::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.points_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestComplete_Debug {
        static instance: CMsgGCQuestComplete_Debug = CMsgGCQuestComplete_Debug {
            quest_id: ::std::option::Option::None,
            points_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestMap_Debug)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMap_Debug {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.reset_operation)
    pub reset_operation: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.give_credit)
    pub give_credit: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCQuestMap_Debug.unlock_node)
    pub unlock_node: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCQuestMapUnlockNode>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMap_Debug.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMap_Debug {
    fn default() -> &'a CMsgGCQuestMap_Debug {
        <CMsgGCQuestMap_Debug as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMap_Debug {
    pub fn new() -> CMsgGCQuestMap_Debug {
        ::std::default::Default::default()
    }

    // optional uint32 reset_operation = 1;

    pub fn reset_operation(&self) -> u32 {
        self.reset_operation.unwrap_or(0)
    }

    pub fn clear_reset_operation(&mut self) {
        self.reset_operation = ::std::option::Option::None;
    }

    pub fn has_reset_operation(&self) -> bool {
        self.reset_operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reset_operation(&mut self, v: u32) {
        self.reset_operation = ::std::option::Option::Some(v);
    }

    // optional uint32 give_credit = 2;

    pub fn give_credit(&self) -> u32 {
        self.give_credit.unwrap_or(0)
    }

    pub fn clear_give_credit(&mut self) {
        self.give_credit = ::std::option::Option::None;
    }

    pub fn has_give_credit(&self) -> bool {
        self.give_credit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_give_credit(&mut self, v: u32) {
        self.give_credit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestMap_Debug {
    const NAME: &'static str = "CMsgGCQuestMap_Debug";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.reset_operation = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.give_credit = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.unlock_node)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.reset_operation {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.give_credit {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.unlock_node.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.reset_operation {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.give_credit {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.unlock_node.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMap_Debug {
        CMsgGCQuestMap_Debug::new()
    }

    fn clear(&mut self) {
        self.reset_operation = ::std::option::Option::None;
        self.give_credit = ::std::option::Option::None;
        self.unlock_node.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMap_Debug {
        static instance: CMsgGCQuestMap_Debug = CMsgGCQuestMap_Debug {
            reset_operation: ::std::option::Option::None,
            give_credit: ::std::option::Option::None,
            unlock_node: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestMapPurchaseReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestMapPurchaseReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestMapPurchaseReward.store_item_defindex)
    pub store_item_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestMapPurchaseReward.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestMapPurchaseReward {
    fn default() -> &'a CMsgGCQuestMapPurchaseReward {
        <CMsgGCQuestMapPurchaseReward as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestMapPurchaseReward {
    pub fn new() -> CMsgGCQuestMapPurchaseReward {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_defindex = 1;

    pub fn store_item_defindex(&self) -> u32 {
        self.store_item_defindex.unwrap_or(0)
    }

    pub fn clear_store_item_defindex(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
    }

    pub fn has_store_item_defindex(&self) -> bool {
        self.store_item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_defindex(&mut self, v: u32) {
        self.store_item_defindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestMapPurchaseReward {
    const NAME: &'static str = "CMsgGCQuestMapPurchaseReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.store_item_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.store_item_defindex {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestMapPurchaseReward {
        CMsgGCQuestMapPurchaseReward::new()
    }

    fn clear(&mut self) {
        self.store_item_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestMapPurchaseReward {
        static instance: CMsgGCQuestMapPurchaseReward = CMsgGCQuestMapPurchaseReward {
            store_item_defindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCQuestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCQuestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCQuestResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCQuestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCQuestResponse {
    fn default() -> &'a CMsgGCQuestResponse {
        <CMsgGCQuestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCQuestResponse {
    pub fn new() -> CMsgGCQuestResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCQuestResponse {
    const NAME: &'static str = "CMsgGCQuestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCQuestResponse {
        CMsgGCQuestResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCQuestResponse {
        static instance: CMsgGCQuestResponse = CMsgGCQuestResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCSetDisablePartyQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCSetDisablePartyQuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCSetDisablePartyQuestProgress.state)
    pub state: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCSetDisablePartyQuestProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCSetDisablePartyQuestProgress {
    fn default() -> &'a CMsgGCSetDisablePartyQuestProgress {
        <CMsgGCSetDisablePartyQuestProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCSetDisablePartyQuestProgress {
    pub fn new() -> CMsgGCSetDisablePartyQuestProgress {
        ::std::default::Default::default()
    }

    // optional bool state = 1;

    pub fn state(&self) -> bool {
        self.state.unwrap_or(false)
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: bool) {
        self.state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCSetDisablePartyQuestProgress {
    const NAME: &'static str = "CMsgGCSetDisablePartyQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCSetDisablePartyQuestProgress {
        CMsgGCSetDisablePartyQuestProgress::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCSetDisablePartyQuestProgress {
        static instance: CMsgGCSetDisablePartyQuestProgress = CMsgGCSetDisablePartyQuestProgress {
            state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuestProgressReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuestProgressReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_0_earned)
    pub star_0_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_1_earned)
    pub star_1_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.star_2_earned)
    pub star_2_earned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.items_earned)
    pub items_earned: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.reward_credits_earned)
    pub reward_credits_earned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuestProgressReport.contract_completed)
    pub contract_completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuestProgressReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuestProgressReport {
    fn default() -> &'a CMsgQuestProgressReport {
        <CMsgQuestProgressReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuestProgressReport {
    pub fn new() -> CMsgQuestProgressReport {
        ::std::default::Default::default()
    }

    // optional uint64 quest_id = 1;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional bool star_0_earned = 2;

    pub fn star_0_earned(&self) -> bool {
        self.star_0_earned.unwrap_or(false)
    }

    pub fn clear_star_0_earned(&mut self) {
        self.star_0_earned = ::std::option::Option::None;
    }

    pub fn has_star_0_earned(&self) -> bool {
        self.star_0_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_0_earned(&mut self, v: bool) {
        self.star_0_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_1_earned = 3;

    pub fn star_1_earned(&self) -> bool {
        self.star_1_earned.unwrap_or(false)
    }

    pub fn clear_star_1_earned(&mut self) {
        self.star_1_earned = ::std::option::Option::None;
    }

    pub fn has_star_1_earned(&self) -> bool {
        self.star_1_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_1_earned(&mut self, v: bool) {
        self.star_1_earned = ::std::option::Option::Some(v);
    }

    // optional bool star_2_earned = 4;

    pub fn star_2_earned(&self) -> bool {
        self.star_2_earned.unwrap_or(false)
    }

    pub fn clear_star_2_earned(&mut self) {
        self.star_2_earned = ::std::option::Option::None;
    }

    pub fn has_star_2_earned(&self) -> bool {
        self.star_2_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_star_2_earned(&mut self, v: bool) {
        self.star_2_earned = ::std::option::Option::Some(v);
    }

    // optional uint32 reward_credits_earned = 6;

    pub fn reward_credits_earned(&self) -> u32 {
        self.reward_credits_earned.unwrap_or(0)
    }

    pub fn clear_reward_credits_earned(&mut self) {
        self.reward_credits_earned = ::std::option::Option::None;
    }

    pub fn has_reward_credits_earned(&self) -> bool {
        self.reward_credits_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reward_credits_earned(&mut self, v: u32) {
        self.reward_credits_earned = ::std::option::Option::Some(v);
    }

    // optional bool contract_completed = 7;

    pub fn contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }

    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuestProgressReport {
    const NAME: &'static str = "CMsgQuestProgressReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.star_0_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.star_1_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.star_2_earned = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    is.read_repeated_packed_uint64_into(&mut self.items_earned)?;
                },
                40 => {
                    self.items_earned.push(is.read_uint64()?);
                },
                48 => {
                    self.reward_credits_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.contract_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.star_0_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_1_earned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.star_2_earned {
            my_size += 1 + 1;
        }
        for value in &self.items_earned {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, *value);
        };
        if let Some(v) = self.reward_credits_earned {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.contract_completed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.star_0_earned {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.star_1_earned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.star_2_earned {
            os.write_bool(4, v)?;
        }
        for v in &self.items_earned {
            os.write_uint64(5, *v)?;
        };
        if let Some(v) = self.reward_credits_earned {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuestProgressReport {
        CMsgQuestProgressReport::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.star_0_earned = ::std::option::Option::None;
        self.star_1_earned = ::std::option::Option::None;
        self.star_2_earned = ::std::option::Option::None;
        self.items_earned.clear();
        self.reward_credits_earned = ::std::option::Option::None;
        self.contract_completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuestProgressReport {
        static instance: CMsgQuestProgressReport = CMsgQuestProgressReport {
            quest_id: ::std::option::Option::None,
            star_0_earned: ::std::option::Option::None,
            star_1_earned: ::std::option::Option::None,
            star_2_earned: ::std::option::Option::None,
            items_earned: ::std::vec::Vec::new(),
            reward_credits_earned: ::std::option::Option::None,
            contract_completed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConsumePaintkit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumePaintkit {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumePaintkit.source_id)
    pub source_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgConsumePaintkit.target_defindex)
    pub target_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumePaintkit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumePaintkit {
    fn default() -> &'a CMsgConsumePaintkit {
        <CMsgConsumePaintkit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumePaintkit {
    pub fn new() -> CMsgConsumePaintkit {
        ::std::default::Default::default()
    }

    // optional fixed64 source_id = 1;

    pub fn source_id(&self) -> u64 {
        self.source_id.unwrap_or(0)
    }

    pub fn clear_source_id(&mut self) {
        self.source_id = ::std::option::Option::None;
    }

    pub fn has_source_id(&self) -> bool {
        self.source_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_id(&mut self, v: u64) {
        self.source_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_defindex = 2;

    pub fn target_defindex(&self) -> u32 {
        self.target_defindex.unwrap_or(0)
    }

    pub fn clear_target_defindex(&mut self) {
        self.target_defindex = ::std::option::Option::None;
    }

    pub fn has_target_defindex(&self) -> bool {
        self.target_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_defindex(&mut self, v: u32) {
        self.target_defindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConsumePaintkit {
    const NAME: &'static str = "CMsgConsumePaintkit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.source_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.target_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.target_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.target_defindex {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumePaintkit {
        CMsgConsumePaintkit::new()
    }

    fn clear(&mut self) {
        self.source_id = ::std::option::Option::None;
        self.target_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumePaintkit {
        static instance: CMsgConsumePaintkit = CMsgConsumePaintkit {
            source_id: ::std::option::Option::None,
            target_defindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPainkitDevGrant)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPainkitDevGrant {
    // message fields
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.paintkit_defindex)
    pub paintkit_defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.wear)
    pub wear: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgPainkitDevGrant.item_defindex)
    pub item_defindex: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPainkitDevGrant.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPainkitDevGrant {
    fn default() -> &'a CMsgPainkitDevGrant {
        <CMsgPainkitDevGrant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPainkitDevGrant {
    pub fn new() -> CMsgPainkitDevGrant {
        ::std::default::Default::default()
    }

    // optional uint32 paintkit_defindex = 1;

    pub fn paintkit_defindex(&self) -> u32 {
        self.paintkit_defindex.unwrap_or(0)
    }

    pub fn clear_paintkit_defindex(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
    }

    pub fn has_paintkit_defindex(&self) -> bool {
        self.paintkit_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_paintkit_defindex(&mut self, v: u32) {
        self.paintkit_defindex = ::std::option::Option::Some(v);
    }

    // optional float wear = 2;

    pub fn wear(&self) -> f32 {
        self.wear.unwrap_or(0.)
    }

    pub fn clear_wear(&mut self) {
        self.wear = ::std::option::Option::None;
    }

    pub fn has_wear(&self) -> bool {
        self.wear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wear(&mut self, v: f32) {
        self.wear = ::std::option::Option::Some(v);
    }

    // optional uint32 item_defindex = 3;

    pub fn item_defindex(&self) -> u32 {
        self.item_defindex.unwrap_or(0)
    }

    pub fn clear_item_defindex(&mut self) {
        self.item_defindex = ::std::option::Option::None;
    }

    pub fn has_item_defindex(&self) -> bool {
        self.item_defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_defindex(&mut self, v: u32) {
        self.item_defindex = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPainkitDevGrant {
    const NAME: &'static str = "CMsgPainkitDevGrant";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.paintkit_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                21 => {
                    self.wear = ::std::option::Option::Some(is.read_float()?);
                },
                24 => {
                    self.item_defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.paintkit_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wear {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.paintkit_defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wear {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.item_defindex {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPainkitDevGrant {
        CMsgPainkitDevGrant::new()
    }

    fn clear(&mut self) {
        self.paintkit_defindex = ::std::option::Option::None;
        self.wear = ::std::option::Option::None;
        self.item_defindex = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPainkitDevGrant {
        static instance: CMsgPainkitDevGrant = CMsgPainkitDevGrant {
            paintkit_defindex: ::std::option::Option::None,
            wear: ::std::option::Option::None,
            item_defindex: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:GCQuestStrangeEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GCQuestStrangeEvent {
    // message fields
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.owner_account_id)
    pub owner_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.scorer_account_id)
    pub scorer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.quest_id)
    pub quest_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.strange_event_id)
    pub strange_event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:GCQuestStrangeEvent.score)
    pub score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:GCQuestStrangeEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GCQuestStrangeEvent {
    fn default() -> &'a GCQuestStrangeEvent {
        <GCQuestStrangeEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl GCQuestStrangeEvent {
    pub fn new() -> GCQuestStrangeEvent {
        ::std::default::Default::default()
    }

    // optional uint32 owner_account_id = 1;

    pub fn owner_account_id(&self) -> u32 {
        self.owner_account_id.unwrap_or(0)
    }

    pub fn clear_owner_account_id(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
    }

    pub fn has_owner_account_id(&self) -> bool {
        self.owner_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owner_account_id(&mut self, v: u32) {
        self.owner_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 scorer_account_id = 2;

    pub fn scorer_account_id(&self) -> u32 {
        self.scorer_account_id.unwrap_or(0)
    }

    pub fn clear_scorer_account_id(&mut self) {
        self.scorer_account_id = ::std::option::Option::None;
    }

    pub fn has_scorer_account_id(&self) -> bool {
        self.scorer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scorer_account_id(&mut self, v: u32) {
        self.scorer_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 quest_id = 3;

    pub fn quest_id(&self) -> u64 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u64) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 strange_event_id = 4;

    pub fn strange_event_id(&self) -> u32 {
        self.strange_event_id.unwrap_or(0)
    }

    pub fn clear_strange_event_id(&mut self) {
        self.strange_event_id = ::std::option::Option::None;
    }

    pub fn has_strange_event_id(&self) -> bool {
        self.strange_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_event_id(&mut self, v: u32) {
        self.strange_event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 score = 5;

    pub fn score(&self) -> u32 {
        self.score.unwrap_or(0)
    }

    pub fn clear_score(&mut self) {
        self.score = ::std::option::Option::None;
    }

    pub fn has_score(&self) -> bool {
        self.score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_score(&mut self, v: u32) {
        self.score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for GCQuestStrangeEvent {
    const NAME: &'static str = "GCQuestStrangeEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.owner_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.scorer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.strange_event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.owner_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.scorer_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.strange_event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.owner_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.scorer_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quest_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.strange_event_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.score {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GCQuestStrangeEvent {
        GCQuestStrangeEvent::new()
    }

    fn clear(&mut self) {
        self.owner_account_id = ::std::option::Option::None;
        self.scorer_account_id = ::std::option::Option::None;
        self.quest_id = ::std::option::Option::None;
        self.strange_event_id = ::std::option::Option::None;
        self.score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GCQuestStrangeEvent {
        static instance: GCQuestStrangeEvent = GCQuestStrangeEvent {
            owner_account_id: ::std::option::Option::None,
            scorer_account_id: ::std::option::Option::None,
            quest_id: ::std::option::Option::None,
            strange_event_id: ::std::option::Option::None,
            score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSDRTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDRTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgSDRTicket.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSDRTicket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDRTicket {
    fn default() -> &'a CMsgSDRTicket {
        <CMsgSDRTicket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSDRTicket {
    pub fn new() -> CMsgSDRTicket {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 1;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSDRTicket {
    const NAME: &'static str = "CMsgSDRTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDRTicket {
        CMsgSDRTicket::new()
    }

    fn clear(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDRTicket {
        static instance: CMsgSDRTicket = CMsgSDRTicket {
            serialized_ticket: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAuthorizeServerItemRetrieval)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAuthorizeServerItemRetrieval {
    // message fields
    // @@protoc_insertion_point(field:CMsgAuthorizeServerItemRetrieval.item_id)
    pub item_id: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAuthorizeServerItemRetrieval.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAuthorizeServerItemRetrieval {
    fn default() -> &'a CMsgAuthorizeServerItemRetrieval {
        <CMsgAuthorizeServerItemRetrieval as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthorizeServerItemRetrieval {
    pub fn new() -> CMsgAuthorizeServerItemRetrieval {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAuthorizeServerItemRetrieval {
    const NAME: &'static str = "CMsgAuthorizeServerItemRetrieval";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_id)?;
                },
                8 => {
                    self.item_id.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_id {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAuthorizeServerItemRetrieval {
        CMsgAuthorizeServerItemRetrieval::new()
    }

    fn clear(&mut self) {
        self.item_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAuthorizeServerItemRetrieval {
        static instance: CMsgAuthorizeServerItemRetrieval = CMsgAuthorizeServerItemRetrieval {
            item_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSendAccountBannedNotifications)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSendAccountBannedNotifications {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSendAccountBannedNotifications.banned_accountid)
    pub banned_accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCSendAccountBannedNotifications.report_period_begin)
    pub report_period_begin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCSendAccountBannedNotifications.report_period_end)
    pub report_period_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSendAccountBannedNotifications.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSendAccountBannedNotifications {
    fn default() -> &'a CMsgGCToGCSendAccountBannedNotifications {
        <CMsgGCToGCSendAccountBannedNotifications as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSendAccountBannedNotifications {
    pub fn new() -> CMsgGCToGCSendAccountBannedNotifications {
        ::std::default::Default::default()
    }

    // optional uint32 banned_accountid = 1;

    pub fn banned_accountid(&self) -> u32 {
        self.banned_accountid.unwrap_or(0)
    }

    pub fn clear_banned_accountid(&mut self) {
        self.banned_accountid = ::std::option::Option::None;
    }

    pub fn has_banned_accountid(&self) -> bool {
        self.banned_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_banned_accountid(&mut self, v: u32) {
        self.banned_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 report_period_begin = 2;

    pub fn report_period_begin(&self) -> u32 {
        self.report_period_begin.unwrap_or(0)
    }

    pub fn clear_report_period_begin(&mut self) {
        self.report_period_begin = ::std::option::Option::None;
    }

    pub fn has_report_period_begin(&self) -> bool {
        self.report_period_begin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_period_begin(&mut self, v: u32) {
        self.report_period_begin = ::std::option::Option::Some(v);
    }

    // optional uint32 report_period_end = 3;

    pub fn report_period_end(&self) -> u32 {
        self.report_period_end.unwrap_or(0)
    }

    pub fn clear_report_period_end(&mut self) {
        self.report_period_end = ::std::option::Option::None;
    }

    pub fn has_report_period_end(&self) -> bool {
        self.report_period_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_period_end(&mut self, v: u32) {
        self.report_period_end = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSendAccountBannedNotifications {
    const NAME: &'static str = "CMsgGCToGCSendAccountBannedNotifications";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.banned_accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.report_period_begin = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.report_period_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.banned_accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.report_period_begin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.report_period_end {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.banned_accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_period_begin {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.report_period_end {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSendAccountBannedNotifications {
        CMsgGCToGCSendAccountBannedNotifications::new()
    }

    fn clear(&mut self) {
        self.banned_accountid = ::std::option::Option::None;
        self.report_period_begin = ::std::option::Option::None;
        self.report_period_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSendAccountBannedNotifications {
        static instance: CMsgGCToGCSendAccountBannedNotifications = CMsgGCToGCSendAccountBannedNotifications {
            banned_accountid: ::std::option::Option::None,
            report_period_begin: ::std::option::Option::None,
            report_period_end: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCSendNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCSendNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCSendNotification.notification)
    pub notification: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCNotification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCSendNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCSendNotification {
    fn default() -> &'a CMsgGCToGCSendNotification {
        <CMsgGCToGCSendNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCSendNotification {
    pub fn new() -> CMsgGCToGCSendNotification {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCSendNotification {
    const NAME: &'static str = "CMsgGCToGCSendNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.notification)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.notification.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.notification.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCSendNotification {
        CMsgGCToGCSendNotification::new()
    }

    fn clear(&mut self) {
        self.notification.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCSendNotification {
        static instance: CMsgGCToGCSendNotification = CMsgGCToGCSendNotification {
            notification: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFGCMsg)
pub enum ETFGCMsg {
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReportWarKill)
    k_EMsgGCReportWarKill = 5001,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCKickPlayer_DEPRECATED)
    k_EMsgGCKickPlayer_DEPRECATED = 5020,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCStartedTraining_DEPRECATED)
    k_EMsgGCStartedTraining_DEPRECATED = 5021,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ChooseMostHelpfulFriend)
    k_EMsgGCFreeTrial_ChooseMostHelpfulFriend = 5022,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestTF2Friends)
    k_EMsgGCRequestTF2Friends = 5023,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestTF2FriendsResponse)
    k_EMsgGCRequestTF2FriendsResponse = 5024,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReplay_SubmitContestEntry)
    k_EMsgGCReplay_SubmitContestEntry = 5026,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReplay_SubmitContestEntryResponse)
    k_EMsgGCReplay_SubmitContestEntryResponse = 5027,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCSaxxy_Awarded)
    k_EMsgGCSaxxy_Awarded = 5029,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ThankedBySomeone)
    k_EMsgGCFreeTrial_ThankedBySomeone = 5028,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ThankedSomeone)
    k_EMsgGCFreeTrial_ThankedSomeone = 5030,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCFreeTrial_ConvertedToPremium)
    k_EMsgGCFreeTrial_ConvertedToPremium = 5031,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED)
    k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED = 5032,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED)
    k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED = 5033,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED)
    k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED = 5034,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AddToCoaches)
    k_EMsgGCCoaching_AddToCoaches = 5200,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AddToCoachesResponse)
    k_EMsgGCCoaching_AddToCoachesResponse = 5201,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveFromCoaches)
    k_EMsgGCCoaching_RemoveFromCoaches = 5202,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveFromCoachesResponse)
    k_EMsgGCCoaching_RemoveFromCoachesResponse = 5203,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_FindCoach)
    k_EMsgGCCoaching_FindCoach = 5204,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_FindCoachResponse)
    k_EMsgGCCoaching_FindCoachResponse = 5205,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AskCoach)
    k_EMsgGCCoaching_AskCoach = 5206,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AskCoachResponse)
    k_EMsgGCCoaching_AskCoachResponse = 5207,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoinGame)
    k_EMsgGCCoaching_CoachJoinGame = 5208,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoining)
    k_EMsgGCCoaching_CoachJoining = 5209,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_CoachJoined)
    k_EMsgGCCoaching_CoachJoined = 5210,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_LikeCurrentCoach)
    k_EMsgGCCoaching_LikeCurrentCoach = 5211,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_RemoveCurrentCoach)
    k_EMsgGCCoaching_RemoveCurrentCoach = 5212,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCCoaching_AlreadyRatedCoach)
    k_EMsgGCCoaching_AlreadyRatedCoach = 5213,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Request)
    k_EMsgGC_Duel_Request = 5500,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Response)
    k_EMsgGC_Duel_Response = 5501,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Results)
    k_EMsgGC_Duel_Results = 5502,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Duel_Status)
    k_EMsgGC_Duel_Status = 5503,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ReservedItem_DEPRECATED)
    k_EMsgGC_Halloween_ReservedItem_DEPRECATED = 5600,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItem_DEPRECATED)
    k_EMsgGC_Halloween_GrantItem_DEPRECATED = 5601,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED)
    k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED = 5604,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED)
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED = 5605,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ItemClaimed_DEPRECATED)
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED = 5606,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ReservedItem)
    k_EMsgGC_Halloween_ReservedItem = 5607,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItem)
    k_EMsgGC_Halloween_GrantItem = 5608,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_GrantItemResponse)
    k_EMsgGC_Halloween_GrantItemResponse = 5609,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2)
    k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2 = 5610,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2)
    k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2 = 5611,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_ServerBossEvent)
    k_EMsgGC_Halloween_ServerBossEvent = 5612,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_Merasmus2012)
    k_EMsgGC_Halloween_Merasmus2012 = 5613,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Halloween_UpdateMerasmusLootLevel)
    k_EMsgGC_Halloween_UpdateMerasmusLootLevel = 5614,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_LevelInfo)
    k_EMsgGC_GameServer_LevelInfo = 5700,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthChallenge)
    k_EMsgGC_GameServer_AuthChallenge = 5701,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthChallengeResponse)
    k_EMsgGC_GameServer_AuthChallengeResponse = 5702,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_CreateIdentity)
    k_EMsgGC_GameServer_CreateIdentity = 5703,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_CreateIdentityResponse)
    k_EMsgGC_GameServer_CreateIdentityResponse = 5704,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_List)
    k_EMsgGC_GameServer_List = 5705,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ListResponse)
    k_EMsgGC_GameServer_ListResponse = 5706,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AuthResult)
    k_EMsgGC_GameServer_AuthResult = 5707,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ResetIdentity)
    k_EMsgGC_GameServer_ResetIdentity = 5708,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ResetIdentityResponse)
    k_EMsgGC_GameServer_ResetIdentityResponse = 5709,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client_UseServerModificationItem)
    k_EMsgGC_Client_UseServerModificationItem = 5710,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client_UseServerModificationItem_Response)
    k_EMsgGC_Client_UseServerModificationItem_Response = 5711,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_UseServerModificationItem)
    k_EMsgGC_GameServer_UseServerModificationItem = 5712,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_UseServerModificationItem_Response)
    k_EMsgGC_GameServer_UseServerModificationItem_Response = 5713,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ServerModificationItemExpired)
    k_EMsgGC_GameServer_ServerModificationItemExpired = 5714,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_ModificationItemState)
    k_EMsgGC_GameServer_ModificationItemState = 5715,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AckPolicy)
    k_EMsgGC_GameServer_AckPolicy = 5716,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_GameServer_AckPolicyResponse)
    k_EMsgGC_GameServer_AckPolicyResponse = 5717,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_ScoreServers)
    k_EMsgGC_QP_ScoreServers = 5800,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_ScoreServersResponse)
    k_EMsgGC_QP_ScoreServersResponse = 5801,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QP_PlayerJoining)
    k_EMsgGC_QP_PlayerJoining = 5802,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_PickupItemEligibility_Query_DEPRECATED)
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED = 6000,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2)
    k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2 = 6001,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_IncrementKillCountAttribute_DEPRECATED)
    k_EMsgGC_IncrementKillCountAttribute_DEPRECATED = 6100,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_IncrementKillCountResponse_DEPRECATED)
    k_EMsgGC_IncrementKillCountResponse_DEPRECATED = 6101,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCAbandonCurrentGame)
    k_EMsgGCAbandonCurrentGame = 6235,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgForceSOCacheResend)
    k_EMsgForceSOCacheResend = 6237,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestChatChannelList)
    k_EMsgGCRequestChatChannelList = 6260,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestChatChannelListResponse)
    k_EMsgGCRequestChatChannelListResponse = 6261,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCReadyUp)
    k_EMsgGCReadyUp = 6270,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCKickedFromMatchmakingQueue)
    k_EMsgGCKickedFromMatchmakingQueue = 6271,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaverDetected)
    k_EMsgGCLeaverDetected = 6272,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaverDetectedResponse)
    k_EMsgGCLeaverDetectedResponse = 6287,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCExitMatchmaking)
    k_EMsgGCExitMatchmaking = 6289,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchmakingProgress)
    k_EMsgGCMatchmakingProgress = 6293,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictoryInfo)
    k_EMsgGCMvMVictoryInfo = 6294,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerMatchmakingStatus)
    k_EMsgGCGameServerMatchmakingStatus = 6295,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictory)
    k_EMsgGCMvMVictory = 6297,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMvMVictoryReply)
    k_EMsgGCMvMVictoryReply = 6298,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerKickingLobby)
    k_EMsgGCGameServerKickingLobby = 6299,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCLeaveGameAndPrepareToJoinParty)
    k_EMsgGCLeaveGameAndPrepareToJoinParty = 6300,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_UpdatePeriodicEvent)
    k_EMsgGC_UpdatePeriodicEvent = 6400,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DuckLeaderboard_IndividualUpdate)
    k_EMsgGC_DuckLeaderboard_IndividualUpdate = 6401,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client2GCEconPreviewDataBlockRequest)
    k_EMsgGC_Client2GCEconPreviewDataBlockRequest = 6402,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Client2GCEconPreviewDataBlockResponse)
    k_EMsgGC_Client2GCEconPreviewDataBlockResponse = 6403,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationChallenge)
    k_EMsgGC_ClientVerificationChallenge = 6500,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationChallengeResponse)
    k_EMsgGC_ClientVerificationChallengeResponse = 6501,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientVerificationVerboseResponse)
    k_EMsgGC_ClientVerificationVerboseResponse = 6502,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ClientSetItemSlotAttribute)
    k_EMsgGC_ClientSetItemSlotAttribute = 6503,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_IndividualUpdate)
    k_EMsgGC_War_IndividualUpdate = 6505,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_JoinWar)
    k_EMsgGC_War_JoinWar = 6506,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_RequestGlobalStats)
    k_EMsgGC_War_RequestGlobalStats = 6507,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_War_GlobalStatsResponse)
    k_EMsgGC_War_GlobalStatsResponse = 6508,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldItemPlacement_Attribute)
    k_EMsgGC_WorldItemPlacement_Attribute = 6510,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldItemPlacement_Update)
    k_EMsgGC_WorldItemPlacement_Update = 6511,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Match_Result)
    k_EMsgGC_Match_Result = 6512,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCVoteKickPlayerRequest)
    k_EMsgGCVoteKickPlayerRequest = 6513,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCVoteKickPlayerRequestResponse)
    k_EMsgGCVoteKickPlayerRequestResponse = 6514,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DailyCompetitiveStatsRollup)
    k_EMsgGC_DailyCompetitiveStatsRollup = 6516,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_DailyCompetitiveStatsRollup_Response)
    k_EMsgGC_DailyCompetitiveStatsRollup_Response = 6517,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_WorldStatusBroadcast)
    k_EMsgGC_WorldStatusBroadcast = 6518,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ReportPlayer)
    k_EMsgGC_ReportPlayer = 6519,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Match_ResultResponse)
    k_EMsgGC_Match_ResultResponse = 6520,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCGameServerKickingLobbyResponse)
    k_EMsgGCGameServerKickingLobbyResponse = 6521,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCPlayerLeftMatch)
    k_EMsgGCPlayerLeftMatch = 6522,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCPlayerLeftMatchResponse)
    k_EMsgGCPlayerLeftMatchResponse = 6523,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCRequestMatchMakerStats)
    k_EMsgGCRequestMatchMakerStats = 6524,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchMakerStatsResponse)
    k_EMsgGCMatchMakerStatsResponse = 6525,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCMatchHistoryLoad)
    k_EMsgGCMatchHistoryLoad = 6526,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcknowledgeXP)
    k_EMsgGC_AcknowledgeXP = 6527,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCDataCenterPing_Update)
    k_EMsgGCDataCenterPing_Update = 6528,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NotificationAcknowledge)
    k_EMsgGC_NotificationAcknowledge = 6529,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NotificationAcknowledgeReply)
    k_EMsgGC_NotificationAcknowledgeReply = 6530,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_KickPlayerFromLobby)
    k_EMsgGC_KickPlayerFromLobby = 6531,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SurveyQuestionRequest)
    k_EMsgGC_SurveyQuestionRequest = 6534,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SurveyQuestionResponse)
    k_EMsgGC_SurveyQuestionResponse = 6535,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_TFClientInit)
    k_EMsgGC_TFClientInit = 6536,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NewMatchForLobbyRequest)
    k_EMsgGC_NewMatchForLobbyRequest = 6537,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_NewMatchForLobbyResponse)
    k_EMsgGC_NewMatchForLobbyResponse = 6538,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ChangeMatchPlayerTeamsRequest)
    k_EMsgGC_ChangeMatchPlayerTeamsRequest = 6539,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ChangeMatchPlayerTeamsResponse)
    k_EMsgGC_ChangeMatchPlayerTeamsResponse = 6540,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestIdentify)
    k_EMsgGC_QuestIdentify = 6541,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestDevGive)
    k_EMsgGC_QuestDevGive = 6542,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestComplete_Debug)
    k_EMsgGCQuestComplete_Debug = 6544,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapDebug)
    k_EMsgGC_QuestMapDebug = 6545,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapUnlockNode)
    k_EMsgGC_QuestMapUnlockNode = 6547,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_QuestMapPurchaseReward)
    k_EMsgGC_QuestMapPurchaseReward = 6549,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SetDisablePartyQuestProgress)
    k_EMsgGC_SetDisablePartyQuestProgress = 6550,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestProgressReport)
    k_EMsgGCQuestProgressReport = 6553,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SetOptions)
    k_EMsgGCParty_SetOptions = 6554,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SetOptionsResponse)
    k_EMsgGCParty_SetOptionsResponse = 6555,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForMatch)
    k_EMsgGCParty_QueueForMatch = 6556,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForMatchResponse)
    k_EMsgGCParty_QueueForMatchResponse = 6557,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromQueue)
    k_EMsgGCParty_RemoveFromQueue = 6558,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromQueueResponse)
    k_EMsgGCParty_RemoveFromQueueResponse = 6559,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_InvitePlayer)
    k_EMsgGCParty_InvitePlayer = 6560,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RequestJoinPlayer)
    k_EMsgGCParty_RequestJoinPlayer = 6561,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_SendChat)
    k_EMsgGCParty_SendChat = 6562,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ChatMsg)
    k_EMsgGCParty_ChatMsg = 6563,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestNodeTurnIn)
    k_EMsgGCQuestNodeTurnIn = 6564,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCConsumePaintKit)
    k_EMsgGCConsumePaintKit = 6565,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_Painkit_DevGrant)
    k_EMsgGC_Painkit_DevGrant = 6566,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForStandby)
    k_EMsgGCParty_QueueForStandby = 6567,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_QueueForStandbyResponse)
    k_EMsgGCParty_QueueForStandbyResponse = 6568,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromStandbyQueue)
    k_EMsgGCParty_RemoveFromStandbyQueue = 6569,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_RemoveFromStandbyQueueResponse)
    k_EMsgGCParty_RemoveFromStandbyQueueResponse = 6570,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearPendingPlayer)
    k_EMsgGCParty_ClearPendingPlayer = 6571,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearPendingPlayerResponse)
    k_EMsgGCParty_ClearPendingPlayerResponse = 6572,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearOtherPartyRequest)
    k_EMsgGCParty_ClearOtherPartyRequest = 6573,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_ClearOtherPartyRequestResponse)
    k_EMsgGCParty_ClearOtherPartyRequestResponse = 6574,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_PromoteToLeader)
    k_EMsgGCParty_PromoteToLeader = 6575,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCParty_KickMember)
    k_EMsgGCParty_KickMember = 6576,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCQuestStrangeEvent)
    k_EMsgGCQuestStrangeEvent = 6577,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcceptLobbyInvite)
    k_EMsgGC_AcceptLobbyInvite = 6578,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_AcceptLobbyInviteReply)
    k_EMsgGC_AcceptLobbyInviteReply = 6579,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_SDRTicket)
    k_EMsgGC_SDRTicket = 6580,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ProcessMatchVoteKick)
    k_EMsgGC_ProcessMatchVoteKick = 6581,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGC_ProcessMatchVoteKickResponse)
    k_EMsgGC_ProcessMatchVoteKickResponse = 6582,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCToGC_SendAccountBannedNotifications)
    k_EMsgGCToGC_SendAccountBannedNotifications = 6584,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCToGC_SendNotification)
    k_EMsgGCToGC_SendNotification = 6585,
    // @@protoc_insertion_point(enum_value:ETFGCMsg.k_EMsgGCDev_GrantWarKill)
    k_EMsgGCDev_GrantWarKill = 10001,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETFGCMsg {
    const NAME: &'static str = "ETFGCMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFGCMsg> {
        match value {
            5001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReportWarKill),
            5020 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED),
            5021 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED),
            5022 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend),
            5023 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2Friends),
            5024 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse),
            5026 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry),
            5027 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse),
            5029 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCSaxxy_Awarded),
            5028 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone),
            5030 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone),
            5031 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium),
            5032 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED),
            5033 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED),
            5034 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED),
            5200 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoaches),
            5201 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse),
            5202 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches),
            5203 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse),
            5204 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoach),
            5205 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse),
            5206 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoach),
            5207 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse),
            5208 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame),
            5209 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoining),
            5210 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoined),
            5211 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach),
            5212 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach),
            5213 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach),
            5500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Request),
            5501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Response),
            5502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Results),
            5503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Status),
            5600 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED),
            5601 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED),
            5604 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED),
            5605 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED),
            5606 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED),
            5607 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem),
            5608 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem),
            5609 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse),
            5610 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2),
            5611 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2),
            5612 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent),
            5613 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012),
            5614 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel),
            5700 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_LevelInfo),
            5701 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge),
            5702 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse),
            5703 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity),
            5704 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse),
            5705 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_List),
            5706 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ListResponse),
            5707 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthResult),
            5708 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity),
            5709 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse),
            5710 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem),
            5711 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response),
            5712 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem),
            5713 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response),
            5714 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired),
            5715 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState),
            5716 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicy),
            5717 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse),
            5800 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServers),
            5801 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse),
            5802 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_PlayerJoining),
            6000 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED),
            6001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2),
            6100 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED),
            6101 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED),
            6235 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCAbandonCurrentGame),
            6237 => ::std::option::Option::Some(ETFGCMsg::k_EMsgForceSOCacheResend),
            6260 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelList),
            6261 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelListResponse),
            6270 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReadyUp),
            6271 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue),
            6272 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetected),
            6287 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetectedResponse),
            6289 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCExitMatchmaking),
            6293 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchmakingProgress),
            6294 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryInfo),
            6295 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus),
            6297 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictory),
            6298 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryReply),
            6299 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobby),
            6300 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty),
            6400 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent),
            6401 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate),
            6402 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest),
            6403 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse),
            6500 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallenge),
            6501 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse),
            6502 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse),
            6503 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute),
            6505 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_IndividualUpdate),
            6506 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_JoinWar),
            6507 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_RequestGlobalStats),
            6508 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse),
            6510 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute),
            6511 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update),
            6512 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_Result),
            6513 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequest),
            6514 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse),
            6516 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup),
            6517 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response),
            6518 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldStatusBroadcast),
            6519 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ReportPlayer),
            6520 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_ResultResponse),
            6521 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse),
            6522 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatch),
            6523 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse),
            6524 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestMatchMakerStats),
            6525 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchMakerStatsResponse),
            6526 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchHistoryLoad),
            6527 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcknowledgeXP),
            6528 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDataCenterPing_Update),
            6529 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledge),
            6530 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply),
            6531 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_KickPlayerFromLobby),
            6534 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionRequest),
            6535 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionResponse),
            6536 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_TFClientInit),
            6537 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest),
            6538 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse),
            6539 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest),
            6540 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse),
            6541 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestIdentify),
            6542 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestDevGive),
            6544 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestComplete_Debug),
            6545 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapDebug),
            6547 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapUnlockNode),
            6549 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward),
            6550 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress),
            6553 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestProgressReport),
            6554 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptions),
            6555 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptionsResponse),
            6556 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatch),
            6557 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse),
            6558 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueue),
            6559 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse),
            6560 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_InvitePlayer),
            6561 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer),
            6562 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SendChat),
            6563 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ChatMsg),
            6564 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestNodeTurnIn),
            6565 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCConsumePaintKit),
            6566 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Painkit_DevGrant),
            6567 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandby),
            6568 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse),
            6569 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue),
            6570 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse),
            6571 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer),
            6572 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse),
            6573 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest),
            6574 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse),
            6575 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_PromoteToLeader),
            6576 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_KickMember),
            6577 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestStrangeEvent),
            6578 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInvite),
            6579 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply),
            6580 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SDRTicket),
            6581 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick),
            6582 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse),
            6584 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCToGC_SendAccountBannedNotifications),
            6585 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCToGC_SendNotification),
            10001 => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDev_GrantWarKill),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFGCMsg> {
        match str {
            "k_EMsgGCReportWarKill" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReportWarKill),
            "k_EMsgGCKickPlayer_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED),
            "k_EMsgGCStartedTraining_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED),
            "k_EMsgGCFreeTrial_ChooseMostHelpfulFriend" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend),
            "k_EMsgGCRequestTF2Friends" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2Friends),
            "k_EMsgGCRequestTF2FriendsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse),
            "k_EMsgGCReplay_SubmitContestEntry" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry),
            "k_EMsgGCReplay_SubmitContestEntryResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse),
            "k_EMsgGCSaxxy_Awarded" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCSaxxy_Awarded),
            "k_EMsgGCFreeTrial_ThankedBySomeone" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone),
            "k_EMsgGCFreeTrial_ThankedSomeone" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone),
            "k_EMsgGCFreeTrial_ConvertedToPremium" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium),
            "k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED),
            "k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED),
            "k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED),
            "k_EMsgGCCoaching_AddToCoaches" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoaches),
            "k_EMsgGCCoaching_AddToCoachesResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse),
            "k_EMsgGCCoaching_RemoveFromCoaches" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches),
            "k_EMsgGCCoaching_RemoveFromCoachesResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse),
            "k_EMsgGCCoaching_FindCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoach),
            "k_EMsgGCCoaching_FindCoachResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse),
            "k_EMsgGCCoaching_AskCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoach),
            "k_EMsgGCCoaching_AskCoachResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse),
            "k_EMsgGCCoaching_CoachJoinGame" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame),
            "k_EMsgGCCoaching_CoachJoining" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoining),
            "k_EMsgGCCoaching_CoachJoined" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_CoachJoined),
            "k_EMsgGCCoaching_LikeCurrentCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach),
            "k_EMsgGCCoaching_RemoveCurrentCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach),
            "k_EMsgGCCoaching_AlreadyRatedCoach" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach),
            "k_EMsgGC_Duel_Request" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Request),
            "k_EMsgGC_Duel_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Response),
            "k_EMsgGC_Duel_Results" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Results),
            "k_EMsgGC_Duel_Status" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Duel_Status),
            "k_EMsgGC_Halloween_ReservedItem_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED),
            "k_EMsgGC_Halloween_GrantItem_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED),
            "k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED),
            "k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED),
            "k_EMsgGC_Halloween_ItemClaimed_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED),
            "k_EMsgGC_Halloween_ReservedItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ReservedItem),
            "k_EMsgGC_Halloween_GrantItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItem),
            "k_EMsgGC_Halloween_GrantItemResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse),
            "k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2),
            "k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2),
            "k_EMsgGC_Halloween_ServerBossEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent),
            "k_EMsgGC_Halloween_Merasmus2012" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012),
            "k_EMsgGC_Halloween_UpdateMerasmusLootLevel" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel),
            "k_EMsgGC_GameServer_LevelInfo" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_LevelInfo),
            "k_EMsgGC_GameServer_AuthChallenge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge),
            "k_EMsgGC_GameServer_AuthChallengeResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse),
            "k_EMsgGC_GameServer_CreateIdentity" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity),
            "k_EMsgGC_GameServer_CreateIdentityResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse),
            "k_EMsgGC_GameServer_List" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_List),
            "k_EMsgGC_GameServer_ListResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ListResponse),
            "k_EMsgGC_GameServer_AuthResult" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AuthResult),
            "k_EMsgGC_GameServer_ResetIdentity" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity),
            "k_EMsgGC_GameServer_ResetIdentityResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse),
            "k_EMsgGC_Client_UseServerModificationItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem),
            "k_EMsgGC_Client_UseServerModificationItem_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response),
            "k_EMsgGC_GameServer_UseServerModificationItem" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem),
            "k_EMsgGC_GameServer_UseServerModificationItem_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response),
            "k_EMsgGC_GameServer_ServerModificationItemExpired" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired),
            "k_EMsgGC_GameServer_ModificationItemState" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState),
            "k_EMsgGC_GameServer_AckPolicy" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicy),
            "k_EMsgGC_GameServer_AckPolicyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse),
            "k_EMsgGC_QP_ScoreServers" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServers),
            "k_EMsgGC_QP_ScoreServersResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse),
            "k_EMsgGC_QP_PlayerJoining" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QP_PlayerJoining),
            "k_EMsgGC_PickupItemEligibility_Query_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED),
            "k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2),
            "k_EMsgGC_IncrementKillCountAttribute_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED),
            "k_EMsgGC_IncrementKillCountResponse_DEPRECATED" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED),
            "k_EMsgGCAbandonCurrentGame" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCAbandonCurrentGame),
            "k_EMsgForceSOCacheResend" => ::std::option::Option::Some(ETFGCMsg::k_EMsgForceSOCacheResend),
            "k_EMsgGCRequestChatChannelList" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelList),
            "k_EMsgGCRequestChatChannelListResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestChatChannelListResponse),
            "k_EMsgGCReadyUp" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCReadyUp),
            "k_EMsgGCKickedFromMatchmakingQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue),
            "k_EMsgGCLeaverDetected" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetected),
            "k_EMsgGCLeaverDetectedResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaverDetectedResponse),
            "k_EMsgGCExitMatchmaking" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCExitMatchmaking),
            "k_EMsgGCMatchmakingProgress" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchmakingProgress),
            "k_EMsgGCMvMVictoryInfo" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryInfo),
            "k_EMsgGCGameServerMatchmakingStatus" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus),
            "k_EMsgGCMvMVictory" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictory),
            "k_EMsgGCMvMVictoryReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMvMVictoryReply),
            "k_EMsgGCGameServerKickingLobby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobby),
            "k_EMsgGCLeaveGameAndPrepareToJoinParty" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty),
            "k_EMsgGC_UpdatePeriodicEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent),
            "k_EMsgGC_DuckLeaderboard_IndividualUpdate" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate),
            "k_EMsgGC_Client2GCEconPreviewDataBlockRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest),
            "k_EMsgGC_Client2GCEconPreviewDataBlockResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse),
            "k_EMsgGC_ClientVerificationChallenge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallenge),
            "k_EMsgGC_ClientVerificationChallengeResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse),
            "k_EMsgGC_ClientVerificationVerboseResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse),
            "k_EMsgGC_ClientSetItemSlotAttribute" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute),
            "k_EMsgGC_War_IndividualUpdate" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_IndividualUpdate),
            "k_EMsgGC_War_JoinWar" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_JoinWar),
            "k_EMsgGC_War_RequestGlobalStats" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_RequestGlobalStats),
            "k_EMsgGC_War_GlobalStatsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse),
            "k_EMsgGC_WorldItemPlacement_Attribute" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute),
            "k_EMsgGC_WorldItemPlacement_Update" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update),
            "k_EMsgGC_Match_Result" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_Result),
            "k_EMsgGCVoteKickPlayerRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequest),
            "k_EMsgGCVoteKickPlayerRequestResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse),
            "k_EMsgGC_DailyCompetitiveStatsRollup" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup),
            "k_EMsgGC_DailyCompetitiveStatsRollup_Response" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response),
            "k_EMsgGC_WorldStatusBroadcast" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_WorldStatusBroadcast),
            "k_EMsgGC_ReportPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ReportPlayer),
            "k_EMsgGC_Match_ResultResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Match_ResultResponse),
            "k_EMsgGCGameServerKickingLobbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse),
            "k_EMsgGCPlayerLeftMatch" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatch),
            "k_EMsgGCPlayerLeftMatchResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse),
            "k_EMsgGCRequestMatchMakerStats" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCRequestMatchMakerStats),
            "k_EMsgGCMatchMakerStatsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchMakerStatsResponse),
            "k_EMsgGCMatchHistoryLoad" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCMatchHistoryLoad),
            "k_EMsgGC_AcknowledgeXP" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcknowledgeXP),
            "k_EMsgGCDataCenterPing_Update" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDataCenterPing_Update),
            "k_EMsgGC_NotificationAcknowledge" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledge),
            "k_EMsgGC_NotificationAcknowledgeReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply),
            "k_EMsgGC_KickPlayerFromLobby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_KickPlayerFromLobby),
            "k_EMsgGC_SurveyQuestionRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionRequest),
            "k_EMsgGC_SurveyQuestionResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SurveyQuestionResponse),
            "k_EMsgGC_TFClientInit" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_TFClientInit),
            "k_EMsgGC_NewMatchForLobbyRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest),
            "k_EMsgGC_NewMatchForLobbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse),
            "k_EMsgGC_ChangeMatchPlayerTeamsRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest),
            "k_EMsgGC_ChangeMatchPlayerTeamsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse),
            "k_EMsgGC_QuestIdentify" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestIdentify),
            "k_EMsgGC_QuestDevGive" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestDevGive),
            "k_EMsgGCQuestComplete_Debug" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestComplete_Debug),
            "k_EMsgGC_QuestMapDebug" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapDebug),
            "k_EMsgGC_QuestMapUnlockNode" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapUnlockNode),
            "k_EMsgGC_QuestMapPurchaseReward" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward),
            "k_EMsgGC_SetDisablePartyQuestProgress" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress),
            "k_EMsgGCQuestProgressReport" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestProgressReport),
            "k_EMsgGCParty_SetOptions" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptions),
            "k_EMsgGCParty_SetOptionsResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SetOptionsResponse),
            "k_EMsgGCParty_QueueForMatch" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatch),
            "k_EMsgGCParty_QueueForMatchResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse),
            "k_EMsgGCParty_RemoveFromQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueue),
            "k_EMsgGCParty_RemoveFromQueueResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse),
            "k_EMsgGCParty_InvitePlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_InvitePlayer),
            "k_EMsgGCParty_RequestJoinPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer),
            "k_EMsgGCParty_SendChat" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_SendChat),
            "k_EMsgGCParty_ChatMsg" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ChatMsg),
            "k_EMsgGCQuestNodeTurnIn" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestNodeTurnIn),
            "k_EMsgGCConsumePaintKit" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCConsumePaintKit),
            "k_EMsgGC_Painkit_DevGrant" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_Painkit_DevGrant),
            "k_EMsgGCParty_QueueForStandby" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandby),
            "k_EMsgGCParty_QueueForStandbyResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse),
            "k_EMsgGCParty_RemoveFromStandbyQueue" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue),
            "k_EMsgGCParty_RemoveFromStandbyQueueResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse),
            "k_EMsgGCParty_ClearPendingPlayer" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer),
            "k_EMsgGCParty_ClearPendingPlayerResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse),
            "k_EMsgGCParty_ClearOtherPartyRequest" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest),
            "k_EMsgGCParty_ClearOtherPartyRequestResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse),
            "k_EMsgGCParty_PromoteToLeader" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_PromoteToLeader),
            "k_EMsgGCParty_KickMember" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCParty_KickMember),
            "k_EMsgGCQuestStrangeEvent" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCQuestStrangeEvent),
            "k_EMsgGC_AcceptLobbyInvite" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInvite),
            "k_EMsgGC_AcceptLobbyInviteReply" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply),
            "k_EMsgGC_SDRTicket" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_SDRTicket),
            "k_EMsgGC_ProcessMatchVoteKick" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick),
            "k_EMsgGC_ProcessMatchVoteKickResponse" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse),
            "k_EMsgGCToGC_SendAccountBannedNotifications" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCToGC_SendAccountBannedNotifications),
            "k_EMsgGCToGC_SendNotification" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCToGC_SendNotification),
            "k_EMsgGCDev_GrantWarKill" => ::std::option::Option::Some(ETFGCMsg::k_EMsgGCDev_GrantWarKill),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFGCMsg] = &[
        ETFGCMsg::k_EMsgGCReportWarKill,
        ETFGCMsg::k_EMsgGCKickPlayer_DEPRECATED,
        ETFGCMsg::k_EMsgGCStartedTraining_DEPRECATED,
        ETFGCMsg::k_EMsgGCFreeTrial_ChooseMostHelpfulFriend,
        ETFGCMsg::k_EMsgGCRequestTF2Friends,
        ETFGCMsg::k_EMsgGCRequestTF2FriendsResponse,
        ETFGCMsg::k_EMsgGCReplay_SubmitContestEntry,
        ETFGCMsg::k_EMsgGCReplay_SubmitContestEntryResponse,
        ETFGCMsg::k_EMsgGCSaxxy_Awarded,
        ETFGCMsg::k_EMsgGCFreeTrial_ThankedBySomeone,
        ETFGCMsg::k_EMsgGCFreeTrial_ThankedSomeone,
        ETFGCMsg::k_EMsgGCFreeTrial_ConvertedToPremium,
        ETFGCMsg::k_EMsgGCMeetThePyroSilliness_BananaCraft_DEPRECATED,
        ETFGCMsg::k_EMsgGCMVMARG_HighFiveSuccessResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGCMVMARG_HighFiveOnClient_DEPRECATED,
        ETFGCMsg::k_EMsgGCCoaching_AddToCoaches,
        ETFGCMsg::k_EMsgGCCoaching_AddToCoachesResponse,
        ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoaches,
        ETFGCMsg::k_EMsgGCCoaching_RemoveFromCoachesResponse,
        ETFGCMsg::k_EMsgGCCoaching_FindCoach,
        ETFGCMsg::k_EMsgGCCoaching_FindCoachResponse,
        ETFGCMsg::k_EMsgGCCoaching_AskCoach,
        ETFGCMsg::k_EMsgGCCoaching_AskCoachResponse,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoinGame,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoining,
        ETFGCMsg::k_EMsgGCCoaching_CoachJoined,
        ETFGCMsg::k_EMsgGCCoaching_LikeCurrentCoach,
        ETFGCMsg::k_EMsgGCCoaching_RemoveCurrentCoach,
        ETFGCMsg::k_EMsgGCCoaching_AlreadyRatedCoach,
        ETFGCMsg::k_EMsgGC_Duel_Request,
        ETFGCMsg::k_EMsgGC_Duel_Response,
        ETFGCMsg::k_EMsgGC_Duel_Results,
        ETFGCMsg::k_EMsgGC_Duel_Status,
        ETFGCMsg::k_EMsgGC_Halloween_ReservedItem_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItem_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED,
        ETFGCMsg::k_EMsgGC_Halloween_ReservedItem,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItem,
        ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse,
        ETFGCMsg::k_EMsgGC_Halloween_Cheat_QueryResponse_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_Halloween_ItemClaimed_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_Halloween_ServerBossEvent,
        ETFGCMsg::k_EMsgGC_Halloween_Merasmus2012,
        ETFGCMsg::k_EMsgGC_Halloween_UpdateMerasmusLootLevel,
        ETFGCMsg::k_EMsgGC_GameServer_LevelInfo,
        ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge,
        ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse,
        ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity,
        ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse,
        ETFGCMsg::k_EMsgGC_GameServer_List,
        ETFGCMsg::k_EMsgGC_GameServer_ListResponse,
        ETFGCMsg::k_EMsgGC_GameServer_AuthResult,
        ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity,
        ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse,
        ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem,
        ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response,
        ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem,
        ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response,
        ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired,
        ETFGCMsg::k_EMsgGC_GameServer_ModificationItemState,
        ETFGCMsg::k_EMsgGC_GameServer_AckPolicy,
        ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse,
        ETFGCMsg::k_EMsgGC_QP_ScoreServers,
        ETFGCMsg::k_EMsgGC_QP_ScoreServersResponse,
        ETFGCMsg::k_EMsgGC_QP_PlayerJoining,
        ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED,
        ETFGCMsg::k_EMsgGC_PickupItemEligibility_Query_DEPRECATED_2,
        ETFGCMsg::k_EMsgGC_IncrementKillCountAttribute_DEPRECATED,
        ETFGCMsg::k_EMsgGC_IncrementKillCountResponse_DEPRECATED,
        ETFGCMsg::k_EMsgGCAbandonCurrentGame,
        ETFGCMsg::k_EMsgForceSOCacheResend,
        ETFGCMsg::k_EMsgGCRequestChatChannelList,
        ETFGCMsg::k_EMsgGCRequestChatChannelListResponse,
        ETFGCMsg::k_EMsgGCReadyUp,
        ETFGCMsg::k_EMsgGCKickedFromMatchmakingQueue,
        ETFGCMsg::k_EMsgGCLeaverDetected,
        ETFGCMsg::k_EMsgGCLeaverDetectedResponse,
        ETFGCMsg::k_EMsgGCExitMatchmaking,
        ETFGCMsg::k_EMsgGCMatchmakingProgress,
        ETFGCMsg::k_EMsgGCMvMVictoryInfo,
        ETFGCMsg::k_EMsgGCGameServerMatchmakingStatus,
        ETFGCMsg::k_EMsgGCMvMVictory,
        ETFGCMsg::k_EMsgGCMvMVictoryReply,
        ETFGCMsg::k_EMsgGCGameServerKickingLobby,
        ETFGCMsg::k_EMsgGCLeaveGameAndPrepareToJoinParty,
        ETFGCMsg::k_EMsgGC_UpdatePeriodicEvent,
        ETFGCMsg::k_EMsgGC_DuckLeaderboard_IndividualUpdate,
        ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest,
        ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse,
        ETFGCMsg::k_EMsgGC_ClientVerificationChallenge,
        ETFGCMsg::k_EMsgGC_ClientVerificationChallengeResponse,
        ETFGCMsg::k_EMsgGC_ClientVerificationVerboseResponse,
        ETFGCMsg::k_EMsgGC_ClientSetItemSlotAttribute,
        ETFGCMsg::k_EMsgGC_War_IndividualUpdate,
        ETFGCMsg::k_EMsgGC_War_JoinWar,
        ETFGCMsg::k_EMsgGC_War_RequestGlobalStats,
        ETFGCMsg::k_EMsgGC_War_GlobalStatsResponse,
        ETFGCMsg::k_EMsgGC_WorldItemPlacement_Attribute,
        ETFGCMsg::k_EMsgGC_WorldItemPlacement_Update,
        ETFGCMsg::k_EMsgGC_Match_Result,
        ETFGCMsg::k_EMsgGCVoteKickPlayerRequest,
        ETFGCMsg::k_EMsgGCVoteKickPlayerRequestResponse,
        ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup,
        ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response,
        ETFGCMsg::k_EMsgGC_WorldStatusBroadcast,
        ETFGCMsg::k_EMsgGC_ReportPlayer,
        ETFGCMsg::k_EMsgGC_Match_ResultResponse,
        ETFGCMsg::k_EMsgGCGameServerKickingLobbyResponse,
        ETFGCMsg::k_EMsgGCPlayerLeftMatch,
        ETFGCMsg::k_EMsgGCPlayerLeftMatchResponse,
        ETFGCMsg::k_EMsgGCRequestMatchMakerStats,
        ETFGCMsg::k_EMsgGCMatchMakerStatsResponse,
        ETFGCMsg::k_EMsgGCMatchHistoryLoad,
        ETFGCMsg::k_EMsgGC_AcknowledgeXP,
        ETFGCMsg::k_EMsgGCDataCenterPing_Update,
        ETFGCMsg::k_EMsgGC_NotificationAcknowledge,
        ETFGCMsg::k_EMsgGC_NotificationAcknowledgeReply,
        ETFGCMsg::k_EMsgGC_KickPlayerFromLobby,
        ETFGCMsg::k_EMsgGC_SurveyQuestionRequest,
        ETFGCMsg::k_EMsgGC_SurveyQuestionResponse,
        ETFGCMsg::k_EMsgGC_TFClientInit,
        ETFGCMsg::k_EMsgGC_NewMatchForLobbyRequest,
        ETFGCMsg::k_EMsgGC_NewMatchForLobbyResponse,
        ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsRequest,
        ETFGCMsg::k_EMsgGC_ChangeMatchPlayerTeamsResponse,
        ETFGCMsg::k_EMsgGC_QuestIdentify,
        ETFGCMsg::k_EMsgGC_QuestDevGive,
        ETFGCMsg::k_EMsgGCQuestComplete_Debug,
        ETFGCMsg::k_EMsgGC_QuestMapDebug,
        ETFGCMsg::k_EMsgGC_QuestMapUnlockNode,
        ETFGCMsg::k_EMsgGC_QuestMapPurchaseReward,
        ETFGCMsg::k_EMsgGC_SetDisablePartyQuestProgress,
        ETFGCMsg::k_EMsgGCQuestProgressReport,
        ETFGCMsg::k_EMsgGCParty_SetOptions,
        ETFGCMsg::k_EMsgGCParty_SetOptionsResponse,
        ETFGCMsg::k_EMsgGCParty_QueueForMatch,
        ETFGCMsg::k_EMsgGCParty_QueueForMatchResponse,
        ETFGCMsg::k_EMsgGCParty_RemoveFromQueue,
        ETFGCMsg::k_EMsgGCParty_RemoveFromQueueResponse,
        ETFGCMsg::k_EMsgGCParty_InvitePlayer,
        ETFGCMsg::k_EMsgGCParty_RequestJoinPlayer,
        ETFGCMsg::k_EMsgGCParty_SendChat,
        ETFGCMsg::k_EMsgGCParty_ChatMsg,
        ETFGCMsg::k_EMsgGCQuestNodeTurnIn,
        ETFGCMsg::k_EMsgGCConsumePaintKit,
        ETFGCMsg::k_EMsgGC_Painkit_DevGrant,
        ETFGCMsg::k_EMsgGCParty_QueueForStandby,
        ETFGCMsg::k_EMsgGCParty_QueueForStandbyResponse,
        ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueue,
        ETFGCMsg::k_EMsgGCParty_RemoveFromStandbyQueueResponse,
        ETFGCMsg::k_EMsgGCParty_ClearPendingPlayer,
        ETFGCMsg::k_EMsgGCParty_ClearPendingPlayerResponse,
        ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequest,
        ETFGCMsg::k_EMsgGCParty_ClearOtherPartyRequestResponse,
        ETFGCMsg::k_EMsgGCParty_PromoteToLeader,
        ETFGCMsg::k_EMsgGCParty_KickMember,
        ETFGCMsg::k_EMsgGCQuestStrangeEvent,
        ETFGCMsg::k_EMsgGC_AcceptLobbyInvite,
        ETFGCMsg::k_EMsgGC_AcceptLobbyInviteReply,
        ETFGCMsg::k_EMsgGC_SDRTicket,
        ETFGCMsg::k_EMsgGC_ProcessMatchVoteKick,
        ETFGCMsg::k_EMsgGC_ProcessMatchVoteKickResponse,
        ETFGCMsg::k_EMsgGCToGC_SendAccountBannedNotifications,
        ETFGCMsg::k_EMsgGCToGC_SendNotification,
        ETFGCMsg::k_EMsgGCDev_GrantWarKill,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFGCMsg {
    fn default() -> Self {
        ETFGCMsg::k_EMsgGCReportWarKill
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EServerModificationItemType)
pub enum EServerModificationItemType {
    // @@protoc_insertion_point(enum_value:EServerModificationItemType.kGameServerModificationItem_Halloween)
    kGameServerModificationItem_Halloween = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for EServerModificationItemType {
    const NAME: &'static str = "EServerModificationItemType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EServerModificationItemType> {
        match value {
            1 => ::std::option::Option::Some(EServerModificationItemType::kGameServerModificationItem_Halloween),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EServerModificationItemType> {
        match str {
            "kGameServerModificationItem_Halloween" => ::std::option::Option::Some(EServerModificationItemType::kGameServerModificationItem_Halloween),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EServerModificationItemType] = &[
        EServerModificationItemType::kGameServerModificationItem_Halloween,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EServerModificationItemType {
    fn default() -> Self {
        EServerModificationItemType::kGameServerModificationItem_Halloween
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFSyncedMMMenuStep)
pub enum ETFSyncedMMMenuStep {
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_Invalid)
    k_eTFSyncedMMMenuStep_Invalid = -1,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_None)
    k_eTFSyncedMMMenuStep_None = 0,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_Configuring_Mode)
    k_eTFSyncedMMMenuStep_Configuring_Mode = 1,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Mode)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Mode = 2,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Tour)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Tour = 3,
    // @@protoc_insertion_point(enum_value:ETFSyncedMMMenuStep.k_eTFSyncedMMMenuStep_MvM_Selecting_Missions)
    k_eTFSyncedMMMenuStep_MvM_Selecting_Missions = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETFSyncedMMMenuStep {
    const NAME: &'static str = "ETFSyncedMMMenuStep";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFSyncedMMMenuStep> {
        match value {
            -1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid),
            0 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            1 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode),
            2 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode),
            3 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour),
            4 => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFSyncedMMMenuStep> {
        match str {
            "k_eTFSyncedMMMenuStep_Invalid" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid),
            "k_eTFSyncedMMMenuStep_None" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None),
            "k_eTFSyncedMMMenuStep_Configuring_Mode" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Mode" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Tour" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour),
            "k_eTFSyncedMMMenuStep_MvM_Selecting_Missions" => ::std::option::Option::Some(ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFSyncedMMMenuStep] = &[
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_None,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Configuring_Mode,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Mode,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Tour,
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_MvM_Selecting_Missions,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFSyncedMMMenuStep {
    fn default() -> Self {
        ETFSyncedMMMenuStep::k_eTFSyncedMMMenuStep_Invalid
    }
}


// Note: you cannot use pattern matching for enums with allow_alias option
#[derive(Clone,Copy,Eq,Debug)]
// @@protoc_insertion_point(enum:ETFMatchGroup)
pub enum ETFMatchGroup {
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Invalid)
    k_eTFMatchGroup_Invalid, // -1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Practice)
    k_eTFMatchGroup_MvM_Practice, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_MannUp)
    k_eTFMatchGroup_MvM_MannUp, // 1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_First)
    k_eTFMatchGroup_First, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Default)
    k_eTFMatchGroup_MvM_Default, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_First)
    k_eTFMatchGroup_MvM_First, // 0
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_MvM_Last)
    k_eTFMatchGroup_MvM_Last, // 1
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_6v6)
    k_eTFMatchGroup_Ladder_6v6, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_9v9)
    k_eTFMatchGroup_Ladder_9v9, // 3
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_12v12)
    k_eTFMatchGroup_Ladder_12v12, // 4
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_Default)
    k_eTFMatchGroup_Ladder_Default, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_First)
    k_eTFMatchGroup_Ladder_First, // 2
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Ladder_Last)
    k_eTFMatchGroup_Ladder_Last, // 4
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_6v6)
    k_eTFMatchGroup_Casual_6v6, // 5
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_9v9)
    k_eTFMatchGroup_Casual_9v9, // 6
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_12v12)
    k_eTFMatchGroup_Casual_12v12, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_Default)
    k_eTFMatchGroup_Casual_Default, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_First)
    k_eTFMatchGroup_Casual_First, // 5
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Casual_Last)
    k_eTFMatchGroup_Casual_Last, // 7
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Placeholder)
    k_eTFMatchGroup_Event_Placeholder, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Default)
    k_eTFMatchGroup_Event_Default, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_First)
    k_eTFMatchGroup_Event_First, // 8
    // @@protoc_insertion_point(enum_value:ETFMatchGroup.k_eTFMatchGroup_Event_Last)
    k_eTFMatchGroup_Event_Last, // 8
}

impl ::std::cmp::PartialEq for ETFMatchGroup {
    fn eq(&self, other: &Self) -> bool {
        ::steam_vent_proto_common::protobuf::Enum::value(self) == ::steam_vent_proto_common::protobuf::Enum::value(other)
    }
}

impl ::std::hash::Hash for ETFMatchGroup {
    fn hash<H : ::std::hash::Hasher>(&self, state: &mut H) {
        state.write_i32(::steam_vent_proto_common::protobuf::Enum::value(self))
    }
}

impl ::steam_vent_proto_common::protobuf::Enum for ETFMatchGroup {
    const NAME: &'static str = "ETFMatchGroup";

    fn value(&self) -> i32 {
        match *self {
            ETFMatchGroup::k_eTFMatchGroup_Invalid => -1,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Practice => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp => 1,
            ETFMatchGroup::k_eTFMatchGroup_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Default => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_First => 0,
            ETFMatchGroup::k_eTFMatchGroup_MvM_Last => 1,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6 => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9 => 3,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12 => 4,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Default => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_First => 2,
            ETFMatchGroup::k_eTFMatchGroup_Ladder_Last => 4,
            ETFMatchGroup::k_eTFMatchGroup_Casual_6v6 => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_9v9 => 6,
            ETFMatchGroup::k_eTFMatchGroup_Casual_12v12 => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Default => 7,
            ETFMatchGroup::k_eTFMatchGroup_Casual_First => 5,
            ETFMatchGroup::k_eTFMatchGroup_Casual_Last => 7,
            ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Default => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_First => 8,
            ETFMatchGroup::k_eTFMatchGroup_Event_Last => 8,
        }
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFMatchGroup> {
        match value {
            -1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            0 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_Practice),
            1 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp),
            2 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6),
            3 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9),
            4 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12),
            5 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_6v6),
            6 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_9v9),
            7 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_12v12),
            8 => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFMatchGroup> {
        match str {
            "k_eTFMatchGroup_Invalid" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Invalid),
            "k_eTFMatchGroup_MvM_Practice" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_Practice),
            "k_eTFMatchGroup_MvM_MannUp" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp),
            "k_eTFMatchGroup_Ladder_6v6" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6),
            "k_eTFMatchGroup_Ladder_9v9" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9),
            "k_eTFMatchGroup_Ladder_12v12" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12),
            "k_eTFMatchGroup_Casual_6v6" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_6v6),
            "k_eTFMatchGroup_Casual_9v9" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_9v9),
            "k_eTFMatchGroup_Casual_12v12" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Casual_12v12),
            "k_eTFMatchGroup_Event_Placeholder" => ::std::option::Option::Some(ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFMatchGroup] = &[
        ETFMatchGroup::k_eTFMatchGroup_Invalid,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Practice,
        ETFMatchGroup::k_eTFMatchGroup_MvM_MannUp,
        ETFMatchGroup::k_eTFMatchGroup_First,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Default,
        ETFMatchGroup::k_eTFMatchGroup_MvM_First,
        ETFMatchGroup::k_eTFMatchGroup_MvM_Last,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_6v6,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_9v9,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_12v12,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_Default,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_First,
        ETFMatchGroup::k_eTFMatchGroup_Ladder_Last,
        ETFMatchGroup::k_eTFMatchGroup_Casual_6v6,
        ETFMatchGroup::k_eTFMatchGroup_Casual_9v9,
        ETFMatchGroup::k_eTFMatchGroup_Casual_12v12,
        ETFMatchGroup::k_eTFMatchGroup_Casual_Default,
        ETFMatchGroup::k_eTFMatchGroup_Casual_First,
        ETFMatchGroup::k_eTFMatchGroup_Casual_Last,
        ETFMatchGroup::k_eTFMatchGroup_Event_Placeholder,
        ETFMatchGroup::k_eTFMatchGroup_Event_Default,
        ETFMatchGroup::k_eTFMatchGroup_Event_First,
        ETFMatchGroup::k_eTFMatchGroup_Event_Last,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for ETFMatchGroup {
    fn default() -> Self {
        ETFMatchGroup::k_eTFMatchGroup_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ETFPartyChatType)
pub enum ETFPartyChatType {
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Invalid)
    k_eTFPartyChatType_Invalid = 0,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_MemberChat)
    k_eTFPartyChatType_MemberChat = 1,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberJoin)
    k_eTFPartyChatType_Synthetic_MemberJoin = 1000,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberLeave)
    k_eTFPartyChatType_Synthetic_MemberLeave = 1001,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_SendFailed)
    k_eTFPartyChatType_Synthetic_SendFailed = 1002,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberOnline)
    k_eTFPartyChatType_Synthetic_MemberOnline = 1003,
    // @@protoc_insertion_point(enum_value:ETFPartyChatType.k_eTFPartyChatType_Synthetic_MemberOffline)
    k_eTFPartyChatType_Synthetic_MemberOffline = 1004,
}

impl ::steam_vent_proto_common::protobuf::Enum for ETFPartyChatType {
    const NAME: &'static str = "ETFPartyChatType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ETFPartyChatType> {
        match value {
            0 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            1 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_MemberChat),
            1000 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin),
            1001 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave),
            1002 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed),
            1003 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline),
            1004 => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ETFPartyChatType> {
        match str {
            "k_eTFPartyChatType_Invalid" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Invalid),
            "k_eTFPartyChatType_MemberChat" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_MemberChat),
            "k_eTFPartyChatType_Synthetic_MemberJoin" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin),
            "k_eTFPartyChatType_Synthetic_MemberLeave" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave),
            "k_eTFPartyChatType_Synthetic_SendFailed" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed),
            "k_eTFPartyChatType_Synthetic_MemberOnline" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline),
            "k_eTFPartyChatType_Synthetic_MemberOffline" => ::std::option::Option::Some(ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ETFPartyChatType] = &[
        ETFPartyChatType::k_eTFPartyChatType_Invalid,
        ETFPartyChatType::k_eTFPartyChatType_MemberChat,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberJoin,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberLeave,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_SendFailed,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOnline,
        ETFPartyChatType::k_eTFPartyChatType_Synthetic_MemberOffline,
    ];
}

impl ::std::default::Default for ETFPartyChatType {
    fn default() -> Self {
        ETFPartyChatType::k_eTFPartyChatType_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TF_GC_GameState)
pub enum TF_GC_GameState {
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_STATE_INIT)
    TF_GC_GAMESTATE_STATE_INIT = 0,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD)
    TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD = 1,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_STRATEGY_TIME)
    TF_GC_GAMESTATE_STRATEGY_TIME = 3,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_GAME_IN_PROGRESS)
    TF_GC_GAMESTATE_GAME_IN_PROGRESS = 5,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_POST_GAME)
    TF_GC_GAMESTATE_POST_GAME = 6,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_DISCONNECT)
    TF_GC_GAMESTATE_DISCONNECT = 7,
    // @@protoc_insertion_point(enum_value:TF_GC_GameState.TF_GC_GAMESTATE_LAST)
    TF_GC_GAMESTATE_LAST = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for TF_GC_GameState {
    const NAME: &'static str = "TF_GC_GameState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_GameState> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            1 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD),
            3 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME),
            5 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS),
            6 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME),
            7 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT),
            8 => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TF_GC_GameState> {
        match str {
            "TF_GC_GAMESTATE_STATE_INIT" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT),
            "TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD),
            "TF_GC_GAMESTATE_STRATEGY_TIME" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME),
            "TF_GC_GAMESTATE_GAME_IN_PROGRESS" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS),
            "TF_GC_GAMESTATE_POST_GAME" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME),
            "TF_GC_GAMESTATE_DISCONNECT" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT),
            "TF_GC_GAMESTATE_LAST" => ::std::option::Option::Some(TF_GC_GameState::TF_GC_GAMESTATE_LAST),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TF_GC_GameState] = &[
        TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT,
        TF_GC_GameState::TF_GC_GAMESTATE_WAIT_FOR_PLAYERS_TO_LOAD,
        TF_GC_GameState::TF_GC_GAMESTATE_STRATEGY_TIME,
        TF_GC_GameState::TF_GC_GAMESTATE_GAME_IN_PROGRESS,
        TF_GC_GameState::TF_GC_GAMESTATE_POST_GAME,
        TF_GC_GameState::TF_GC_GAMESTATE_DISCONNECT,
        TF_GC_GameState::TF_GC_GAMESTATE_LAST,
    ];
}

impl ::std::default::Default for TF_GC_GameState {
    fn default() -> Self {
        TF_GC_GameState::TF_GC_GAMESTATE_STATE_INIT
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TF_GC_TEAM)
pub enum TF_GC_TEAM {
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_DEFENDERS)
    TF_GC_TEAM_DEFENDERS = 0,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_INVADERS)
    TF_GC_TEAM_INVADERS = 1,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_BROADCASTER)
    TF_GC_TEAM_BROADCASTER = 2,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_SPECTATOR)
    TF_GC_TEAM_SPECTATOR = 3,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_PLAYER_POOL)
    TF_GC_TEAM_PLAYER_POOL = 4,
    // @@protoc_insertion_point(enum_value:TF_GC_TEAM.TF_GC_TEAM_NOTEAM)
    TF_GC_TEAM_NOTEAM = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for TF_GC_TEAM {
    const NAME: &'static str = "TF_GC_TEAM";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TF_GC_TEAM> {
        match value {
            0 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            1 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_INVADERS),
            2 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_BROADCASTER),
            3 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_SPECTATOR),
            4 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL),
            5 => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TF_GC_TEAM> {
        match str {
            "TF_GC_TEAM_DEFENDERS" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_DEFENDERS),
            "TF_GC_TEAM_INVADERS" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_INVADERS),
            "TF_GC_TEAM_BROADCASTER" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_BROADCASTER),
            "TF_GC_TEAM_SPECTATOR" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_SPECTATOR),
            "TF_GC_TEAM_PLAYER_POOL" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL),
            "TF_GC_TEAM_NOTEAM" => ::std::option::Option::Some(TF_GC_TEAM::TF_GC_TEAM_NOTEAM),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TF_GC_TEAM] = &[
        TF_GC_TEAM::TF_GC_TEAM_DEFENDERS,
        TF_GC_TEAM::TF_GC_TEAM_INVADERS,
        TF_GC_TEAM::TF_GC_TEAM_BROADCASTER,
        TF_GC_TEAM::TF_GC_TEAM_SPECTATOR,
        TF_GC_TEAM::TF_GC_TEAM_PLAYER_POOL,
        TF_GC_TEAM::TF_GC_TEAM_NOTEAM,
    ];
}

impl ::std::default::Default for TF_GC_TEAM {
    fn default() -> Self {
        TF_GC_TEAM::TF_GC_TEAM_DEFENDERS
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TFMatchLeaveReason)
pub enum TFMatchLeaveReason {
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_UNSPECIFIED)
    TFMatchLeaveReason_UNSPECIFIED = 0,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_VOTE_KICK)
    TFMatchLeaveReason_VOTE_KICK = 1,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_IDLE)
    TFMatchLeaveReason_IDLE = 2,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_ADMIN_KICK)
    TFMatchLeaveReason_ADMIN_KICK = 3,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_AWOL)
    TFMatchLeaveReason_AWOL = 4,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_NO_SHOW)
    TFMatchLeaveReason_NO_SHOW = 5,
    // @@protoc_insertion_point(enum_value:TFMatchLeaveReason.TFMatchLeaveReason_GC_REMOVED)
    TFMatchLeaveReason_GC_REMOVED = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for TFMatchLeaveReason {
    const NAME: &'static str = "TFMatchLeaveReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFMatchLeaveReason> {
        match value {
            0 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            1 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK),
            2 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_IDLE),
            3 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK),
            4 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_AWOL),
            5 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW),
            6 => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TFMatchLeaveReason> {
        match str {
            "TFMatchLeaveReason_UNSPECIFIED" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED),
            "TFMatchLeaveReason_VOTE_KICK" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK),
            "TFMatchLeaveReason_IDLE" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_IDLE),
            "TFMatchLeaveReason_ADMIN_KICK" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK),
            "TFMatchLeaveReason_AWOL" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_AWOL),
            "TFMatchLeaveReason_NO_SHOW" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW),
            "TFMatchLeaveReason_GC_REMOVED" => ::std::option::Option::Some(TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TFMatchLeaveReason] = &[
        TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED,
        TFMatchLeaveReason::TFMatchLeaveReason_VOTE_KICK,
        TFMatchLeaveReason::TFMatchLeaveReason_IDLE,
        TFMatchLeaveReason::TFMatchLeaveReason_ADMIN_KICK,
        TFMatchLeaveReason::TFMatchLeaveReason_AWOL,
        TFMatchLeaveReason::TFMatchLeaveReason_NO_SHOW,
        TFMatchLeaveReason::TFMatchLeaveReason_GC_REMOVED,
    ];
}

impl ::std::default::Default for TFMatchLeaveReason {
    fn default() -> Self {
        TFMatchLeaveReason::TFMatchLeaveReason_UNSPECIFIED
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TFVoteKickReason)
pub enum TFVoteKickReason {
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Invalid)
    TFVoteKickReason_Invalid = -1,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Other)
    TFVoteKickReason_Other = 0,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Cheating)
    TFVoteKickReason_Cheating = 1,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Idle)
    TFVoteKickReason_Idle = 2,
    // @@protoc_insertion_point(enum_value:TFVoteKickReason.TFVoteKickReason_Scamming)
    TFVoteKickReason_Scamming = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for TFVoteKickReason {
    const NAME: &'static str = "TFVoteKickReason";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TFVoteKickReason> {
        match value {
            -1 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Invalid),
            0 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Other),
            1 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Cheating),
            2 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Idle),
            3 => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Scamming),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TFVoteKickReason> {
        match str {
            "TFVoteKickReason_Invalid" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Invalid),
            "TFVoteKickReason_Other" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Other),
            "TFVoteKickReason_Cheating" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Cheating),
            "TFVoteKickReason_Idle" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Idle),
            "TFVoteKickReason_Scamming" => ::std::option::Option::Some(TFVoteKickReason::TFVoteKickReason_Scamming),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TFVoteKickReason] = &[
        TFVoteKickReason::TFVoteKickReason_Invalid,
        TFVoteKickReason::TFVoteKickReason_Other,
        TFVoteKickReason::TFVoteKickReason_Cheating,
        TFVoteKickReason::TFVoteKickReason_Idle,
        TFVoteKickReason::TFVoteKickReason_Scamming,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for TFVoteKickReason {
    fn default() -> Self {
        TFVoteKickReason::TFVoteKickReason_Invalid
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ServerMatchmakingState)
pub enum ServerMatchmakingState {
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_INVALID)
    ServerMatchmakingState_INVALID = 0,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_NOT_PARTICIPATING)
    ServerMatchmakingState_NOT_PARTICIPATING = 1,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_EMPTY)
    ServerMatchmakingState_EMPTY = 2,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN)
    ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN = 3,
    // @@protoc_insertion_point(enum_value:ServerMatchmakingState.ServerMatchmakingState_ACTIVE_MATCH)
    ServerMatchmakingState_ACTIVE_MATCH = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for ServerMatchmakingState {
    const NAME: &'static str = "ServerMatchmakingState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServerMatchmakingState> {
        match value {
            0 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            1 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING),
            2 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_EMPTY),
            3 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN),
            4 => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ServerMatchmakingState> {
        match str {
            "ServerMatchmakingState_INVALID" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_INVALID),
            "ServerMatchmakingState_NOT_PARTICIPATING" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING),
            "ServerMatchmakingState_EMPTY" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_EMPTY),
            "ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN),
            "ServerMatchmakingState_ACTIVE_MATCH" => ::std::option::Option::Some(ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ServerMatchmakingState] = &[
        ServerMatchmakingState::ServerMatchmakingState_INVALID,
        ServerMatchmakingState::ServerMatchmakingState_NOT_PARTICIPATING,
        ServerMatchmakingState::ServerMatchmakingState_EMPTY,
        ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH_REQUESTING_LATE_JOIN,
        ServerMatchmakingState::ServerMatchmakingState_ACTIVE_MATCH,
    ];
}

impl ::std::default::Default for ServerMatchmakingState {
    fn default() -> Self {
        ServerMatchmakingState::ServerMatchmakingState_INVALID
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SurveyQuestionType)
pub enum SurveyQuestionType {
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_MATCH_QUALITY)
    QUESTION_MATCH_QUALITY = 0,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_MAP_QUALITY)
    QUESTION_MAP_QUALITY = 1,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_COMP_INQUIRY)
    QUESTION_COMP_INQUIRY = 2,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_CASUAL_INQUIRY)
    QUESTION_CASUAL_INQUIRY = 3,
    // @@protoc_insertion_point(enum_value:SurveyQuestionType.QUESTION_RANDOM_CRIT)
    QUESTION_RANDOM_CRIT = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for SurveyQuestionType {
    const NAME: &'static str = "SurveyQuestionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SurveyQuestionType> {
        match value {
            0 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            1 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MAP_QUALITY),
            2 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_COMP_INQUIRY),
            3 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_CASUAL_INQUIRY),
            4 => ::std::option::Option::Some(SurveyQuestionType::QUESTION_RANDOM_CRIT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SurveyQuestionType> {
        match str {
            "QUESTION_MATCH_QUALITY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MATCH_QUALITY),
            "QUESTION_MAP_QUALITY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_MAP_QUALITY),
            "QUESTION_COMP_INQUIRY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_COMP_INQUIRY),
            "QUESTION_CASUAL_INQUIRY" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_CASUAL_INQUIRY),
            "QUESTION_RANDOM_CRIT" => ::std::option::Option::Some(SurveyQuestionType::QUESTION_RANDOM_CRIT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SurveyQuestionType] = &[
        SurveyQuestionType::QUESTION_MATCH_QUALITY,
        SurveyQuestionType::QUESTION_MAP_QUALITY,
        SurveyQuestionType::QUESTION_COMP_INQUIRY,
        SurveyQuestionType::QUESTION_CASUAL_INQUIRY,
        SurveyQuestionType::QUESTION_RANDOM_CRIT,
    ];
}

impl ::std::default::Default for SurveyQuestionType {
    fn default() -> Self {
        SurveyQuestionType::QUESTION_MATCH_QUALITY
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgTFGoldenWrenchBroadcast {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgTFGoldenWrenchBroadcast {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCGoldenWrenchBroadcast;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFSaxxyBroadcast {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgTFSaxxyBroadcast {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSaxxyBroadcast;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCTFSpecificItemBroadcast {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCTFSpecificItemBroadcast {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCTFSpecificItemBroadcast;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFWorldStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFDuelSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFMapContribution {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFFreeTrialChooseMostHelpfulFriend {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFRequestTF2Friends {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFRequestTF2FriendsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFPlayerInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFThankedBySomeone {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFThankedSomeone {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFFreeTrialConvertedToPremium {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSaxxyAwarded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReplaySubmitContestEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReplaySubmitContestEntryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CReplayCachedContestData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_AddToCoaches {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_RemoveFromCoaches {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_FindCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_FindCoachResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_AskCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_AskCoachResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_CoachJoinGame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_CoachJoining {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_CoachJoined {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_LikeCurrentCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFCoaching_RemoveCurrentCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFQuickplay_ScoreServers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFQuickplay_ScoreServersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFQuickplay_PlayerJoining {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_LevelInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_LevelInfo {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_LevelInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_AuthChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_AuthChallenge {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_AuthChallenge;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_AuthResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_AuthResult {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_AuthResult;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_AuthChallengeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_AuthChallengeResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_AuthChallengeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_CreateIdentity {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_CreateIdentity {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_CreateIdentity;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_CreateIdentityResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_CreateIdentityResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_CreateIdentityResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_List {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_List {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_List;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_ListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_ListResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_ListResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_ResetIdentity {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_ResetIdentity {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_ResetIdentity;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_ResetIdentityResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_ResetIdentityResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_ResetIdentityResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_AckPolicy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_GameServer_AckPolicy {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_AckPolicy;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_AckPolicyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_AckPolicyResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_AckPolicyResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Client_UseServerModificationItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_Client_UseServerModificationItem {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_Client_UseServerModificationItem_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_Client_UseServerModificationItem_Response {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Client_UseServerModificationItem_Response;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_GameServer_UseServerModificationItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_UseServerModificationItem {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_GameServer_UseServerModificationItem_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_UseServerModificationItem_Response {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_UseServerModificationItem_Response;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_GameServer_ServerModificationItemExpired {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_GameServer_ServerModificationItemExpired {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_GameServer_ServerModificationItemExpired;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_GameServer_ServerModificationItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Halloween_ReservedItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_Halloween_ReservedItem {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Halloween_ReservedItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Halloween_GrantItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_Halloween_GrantItem {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Halloween_GrantItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Halloween_GrantItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_Halloween_GrantItemResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Halloween_GrantItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Halloween_ItemClaimed {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_PickupItemEligibility_Query {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_PickupItemEligibility_QueryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFPartyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for TFPendingPartyMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for TFSyncedMMUIState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFGroupMatchCriteriaProto {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFCasualMatchCriteria {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFPerPlayerMatchCriteriaProto {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFPartyOptions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartySetOptions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartySetOptionsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyQueueForMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyQueueForMatchResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyQueueForStandby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyQueueForStandbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyRemoveFromQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyRemoveFromQueueResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyRemoveFromStandbyQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyRemoveFromStandbyQueueResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyInvitePlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyRequestJoinPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyClearPendingPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyClearPendingPlayerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyClearOtherPartyRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyClearOtherPartyRequestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyPromoteToLeader {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyKickMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartySendChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyChatMsg {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFPartyInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFLobbyPlayerProto {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CTFLobbyInviteProto {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFGameServerLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgExitMatchmaking {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAcceptLobbyInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAcceptLobbyInviteReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchmakingSearchCountRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchmakingSearchCountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgKickedFromMatchmakingQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerMatchmakingStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchmakingProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMvMVictoryInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgTFHelloResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgTFSync {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgTFSyncEx {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMvMVictory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMvMMannUpVictoryReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerKickingLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerKickingLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeaveGameAndPrepareToJoinParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerLeftMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerLeftMatchResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProcessMatchVoteKick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProcessMatchVoteKickResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHalloween_ServerBossEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHalloween_Merasmus2012 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUpdateHalloweenMerasmusLootLevel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_String {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_DynamicRecipeComponent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CAttribute_DynamicRecipeComponent_COMPAT_NEVER_SERIALIZE_THIS_OUT {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_ItemSlotCriteria {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetItemSlotAttribute {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOWarData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgGC_War_IndividualUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgGC_War_JoinWar {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgGC_War_RequestGlobalStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsgGC_War_GlobalStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CGCMsgGC_PlayerDuckLeaderboard_IndividualUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CAttribute_WorldItemPlacement {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CGCMsg_WorldItemPlacement_Update {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAcknowledgeXP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFXPSource {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFXPSourceBreakdown {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTFClientInit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotificationQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgNotificationAcknowledge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgNotificationAcknowledgeReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Match_Result {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_Match_Result {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Match_Result;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_Match_ResultResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_Match_ResultResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Match_ResultResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CEconItemPreviewDataBlock {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_Client2GCEconPreviewDataBlockRequest {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_Client2GCEconPreviewDataBlockResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_Client2GCEconPreviewDataBlockResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFLadderPlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFRatingData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_TFVoteKickPlayerRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_VoteKickPlayerRequestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_DailyCompetitiveStatsRollup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_DailyCompetitiveStatsRollup {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGC_DailyCompetitiveStatsRollup_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGC_DailyCompetitiveStatsRollup_Response {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_DailyCompetitiveStatsRollup_Response;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_ReportPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_ReportPlayer {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_ReportPlayer;
}
impl ::steam_vent_proto_common::RpcMessage for CSOTFMatchResultPlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCRequestMatchMakerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCRequestMatchMakerStats {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCRequestMatchMakerStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCDataCenterPopulation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMatchGroupDataCenterPopulation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMatchMakerStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCMatchMakerStatsResponse {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCMatchMakerStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMatchHistoryLoad {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCMatchHistoryLoad {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCMatchHistoryLoad;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCDataCenterPing_Update {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCDataCenterPing_Update {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCDataCenterPing_Update;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGC_KickPlayerFromLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGC_KickPlayerFromLobby {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGC_KickPlayerFromLobby;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCSurveyRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCSurveyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOQuestMapNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOQuest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOQuestMapRewardPurchase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestIdentify {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestDevGive {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestNodeTurnIn {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCQuestNodeTurnIn {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCQuestNodeTurnIn;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestMapUnlockNode {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNewMatchForLobbyRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNewMatchForLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCChangeMatchPlayerTeamsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCChangeMatchPlayerTeamsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestComplete_Debug {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCQuestComplete_Debug {
    type KindEnum = crate::tf_gcmessages::ETFGCMsg;
    const KIND: Self::KindEnum = crate::tf_gcmessages::ETFGCMsg::k_EMsgGCQuestComplete_Debug;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestMap_Debug {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestMapPurchaseReward {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCQuestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCSetDisablePartyQuestProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuestProgressReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConsumePaintkit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPainkitDevGrant {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for GCQuestStrangeEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSDRTicket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAuthorizeServerItemRetrieval {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSendAccountBannedNotifications {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCSendNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::MsgKindEnum for ETFGCMsg {}
