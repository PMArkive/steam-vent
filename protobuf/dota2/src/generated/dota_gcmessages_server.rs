// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_server.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgPoorNetworkConditions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPoorNetworkConditions {
    // message fields
    // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.detection_type)
    pub detection_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EPoorNetworkConditionsType>>,
    // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.players)
    pub players: ::std::vec::Vec<cmsg_poor_network_conditions::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPoorNetworkConditions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPoorNetworkConditions {
    fn default() -> &'a CMsgPoorNetworkConditions {
        <CMsgPoorNetworkConditions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPoorNetworkConditions {
    pub fn new() -> CMsgPoorNetworkConditions {
        ::std::default::Default::default()
    }

    // optional .EPoorNetworkConditionsType detection_type = 1;

    pub fn detection_type(&self) -> EPoorNetworkConditionsType {
        match self.detection_type {
            Some(e) => e.enum_value_or(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            None => EPoorNetworkConditionsType::k_EPoorNetworkConditions_None,
        }
    }

    pub fn clear_detection_type(&mut self) {
        self.detection_type = ::std::option::Option::None;
    }

    pub fn has_detection_type(&self) -> bool {
        self.detection_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_detection_type(&mut self, v: EPoorNetworkConditionsType) {
        self.detection_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPoorNetworkConditions {
    const NAME: &'static str = "CMsgPoorNetworkConditions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.detection_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.detection_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.detection_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPoorNetworkConditions {
        CMsgPoorNetworkConditions::new()
    }

    fn clear(&mut self) {
        self.detection_type = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPoorNetworkConditions {
        static instance: CMsgPoorNetworkConditions = CMsgPoorNetworkConditions {
            detection_type: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPoorNetworkConditions`
pub mod cmsg_poor_network_conditions {
    // @@protoc_insertion_point(message:CMsgPoorNetworkConditions.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.Player.disconnect_reason)
        pub disconnect_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::network_connection::ENetworkDisconnectionReason>>,
        // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.Player.num_bad_intervals)
        pub num_bad_intervals: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPoorNetworkConditions.Player.peak_loss_pct)
        pub peak_loss_pct: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPoorNetworkConditions.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .ENetworkDisconnectionReason disconnect_reason = 2;

        pub fn disconnect_reason(&self) -> super::super::network_connection::ENetworkDisconnectionReason {
            match self.disconnect_reason {
                Some(e) => e.enum_value_or(super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
                None => super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
            }
        }

        pub fn clear_disconnect_reason(&mut self) {
            self.disconnect_reason = ::std::option::Option::None;
        }

        pub fn has_disconnect_reason(&self) -> bool {
            self.disconnect_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnect_reason(&mut self, v: super::super::network_connection::ENetworkDisconnectionReason) {
            self.disconnect_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 num_bad_intervals = 3;

        pub fn num_bad_intervals(&self) -> u32 {
            self.num_bad_intervals.unwrap_or(0)
        }

        pub fn clear_num_bad_intervals(&mut self) {
            self.num_bad_intervals = ::std::option::Option::None;
        }

        pub fn has_num_bad_intervals(&self) -> bool {
            self.num_bad_intervals.is_some()
        }

        // Param is passed by value, moved
        pub fn set_num_bad_intervals(&mut self, v: u32) {
            self.num_bad_intervals = ::std::option::Option::Some(v);
        }

        // optional uint32 peak_loss_pct = 4;

        pub fn peak_loss_pct(&self) -> u32 {
            self.peak_loss_pct.unwrap_or(0)
        }

        pub fn clear_peak_loss_pct(&mut self) {
            self.peak_loss_pct = ::std::option::Option::None;
        }

        pub fn has_peak_loss_pct(&self) -> bool {
            self.peak_loss_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_peak_loss_pct(&mut self, v: u32) {
            self.peak_loss_pct = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.num_bad_intervals = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.peak_loss_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.disconnect_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.num_bad_intervals {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.peak_loss_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.disconnect_reason {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.num_bad_intervals {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.peak_loss_pct {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.disconnect_reason = ::std::option::Option::None;
            self.num_bad_intervals = ::std::option::Option::None;
            self.peak_loss_pct = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                disconnect_reason: ::std::option::Option::None,
                num_bad_intervals: ::std::option::Option::None,
                peak_loss_pct: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameserverCrash)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameserverCrash {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameserverCrash.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.game_state)
    pub game_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.sentinel_save_time)
    pub sentinel_save_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.server_public_ip_addr)
    pub server_public_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.pid)
    pub pid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameserverCrash.engine)
    pub engine: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameserverCrash.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameserverCrash {
    fn default() -> &'a CMsgGameserverCrash {
        <CMsgGameserverCrash as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameserverCrash {
    pub fn new() -> CMsgGameserverCrash {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameState game_state = 3;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 sentinel_save_time = 4;

    pub fn sentinel_save_time(&self) -> u32 {
        self.sentinel_save_time.unwrap_or(0)
    }

    pub fn clear_sentinel_save_time(&mut self) {
        self.sentinel_save_time = ::std::option::Option::None;
    }

    pub fn has_sentinel_save_time(&self) -> bool {
        self.sentinel_save_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sentinel_save_time(&mut self, v: u32) {
        self.sentinel_save_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_id = 11;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_id = 12;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 5;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_public_ip_addr = 6;

    pub fn server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 7;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_cluster = 8;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 pid = 9;

    pub fn pid(&self) -> u32 {
        self.pid.unwrap_or(0)
    }

    pub fn clear_pid(&mut self) {
        self.pid = ::std::option::Option::None;
    }

    pub fn has_pid(&self) -> bool {
        self.pid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pid(&mut self, v: u32) {
        self.pid = ::std::option::Option::Some(v);
    }

    // optional uint32 engine = 10;

    pub fn engine(&self) -> u32 {
        self.engine.unwrap_or(0)
    }

    pub fn clear_engine(&mut self) {
        self.engine = ::std::option::Option::None;
    }

    pub fn has_engine(&self) -> bool {
        self.engine.is_some()
    }

    // Param is passed by value, moved
    pub fn set_engine(&mut self, v: u32) {
        self.engine = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameserverCrash {
    const NAME: &'static str = "CMsgGameserverCrash";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                37 => {
                    self.sentinel_save_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                89 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                96 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                41 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                53 => {
                    self.server_public_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                56 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.pid = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.engine = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.game_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.sentinel_save_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.custom_game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.tournament_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.server_public_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.pid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.engine {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.game_state {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sentinel_save_time {
            os.write_fixed32(4, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.tournament_id {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.pid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.engine {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameserverCrash {
        CMsgGameserverCrash::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.game_state = ::std::option::Option::None;
        self.sentinel_save_time = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.tournament_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_cluster = ::std::option::Option::None;
        self.pid = ::std::option::Option::None;
        self.engine = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameserverCrash {
        static instance: CMsgGameserverCrash = CMsgGameserverCrash {
            match_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            game_state: ::std::option::Option::None,
            sentinel_save_time: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            tournament_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            server_public_ip_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            server_cluster: ::std::option::Option::None,
            pid: ::std::option::Option::None,
            engine: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConnectedPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConnectedPlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.connected_players)
    pub connected_players: ::std::vec::Vec<cmsg_connected_players::Player>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.disconnected_players)
    pub disconnected_players: ::std::vec::Vec<cmsg_connected_players::Player>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.game_state)
    pub game_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameState>>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.first_blood_happened)
    pub first_blood_happened: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.poor_network_conditions)
    pub poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.send_reason)
    pub send_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_connected_players::SendReason>>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.radiant_kills)
    pub radiant_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.dire_kills)
    pub dire_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.radiant_lead)
    pub radiant_lead: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.building_state)
    pub building_state: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgConnectedPlayers.player_draft)
    pub player_draft: ::std::vec::Vec<cmsg_connected_players::PlayerDraft>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConnectedPlayers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConnectedPlayers {
    fn default() -> &'a CMsgConnectedPlayers {
        <CMsgConnectedPlayers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConnectedPlayers {
    pub fn new() -> CMsgConnectedPlayers {
        ::std::default::Default::default()
    }

    // optional .DOTA_GameState game_state = 2;

    pub fn game_state(&self) -> super::dota_shared_enums::DOTA_GameState {
        match self.game_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT),
            None => super::dota_shared_enums::DOTA_GameState::DOTA_GAMERULES_STATE_INIT,
        }
    }

    pub fn clear_game_state(&mut self) {
        self.game_state = ::std::option::Option::None;
    }

    pub fn has_game_state(&self) -> bool {
        self.game_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_state(&mut self, v: super::dota_shared_enums::DOTA_GameState) {
        self.game_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool first_blood_happened = 6;

    pub fn first_blood_happened(&self) -> bool {
        self.first_blood_happened.unwrap_or(false)
    }

    pub fn clear_first_blood_happened(&mut self) {
        self.first_blood_happened = ::std::option::Option::None;
    }

    pub fn has_first_blood_happened(&self) -> bool {
        self.first_blood_happened.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_happened(&mut self, v: bool) {
        self.first_blood_happened = ::std::option::Option::Some(v);
    }

    // optional .CMsgConnectedPlayers.SendReason send_reason = 8;

    pub fn send_reason(&self) -> cmsg_connected_players::SendReason {
        match self.send_reason {
            Some(e) => e.enum_value_or(cmsg_connected_players::SendReason::INVALID),
            None => cmsg_connected_players::SendReason::INVALID,
        }
    }

    pub fn clear_send_reason(&mut self) {
        self.send_reason = ::std::option::Option::None;
    }

    pub fn has_send_reason(&self) -> bool {
        self.send_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_send_reason(&mut self, v: cmsg_connected_players::SendReason) {
        self.send_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 radiant_kills = 11;

    pub fn radiant_kills(&self) -> u32 {
        self.radiant_kills.unwrap_or(0)
    }

    pub fn clear_radiant_kills(&mut self) {
        self.radiant_kills = ::std::option::Option::None;
    }

    pub fn has_radiant_kills(&self) -> bool {
        self.radiant_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_kills(&mut self, v: u32) {
        self.radiant_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_kills = 12;

    pub fn dire_kills(&self) -> u32 {
        self.dire_kills.unwrap_or(0)
    }

    pub fn clear_dire_kills(&mut self) {
        self.dire_kills = ::std::option::Option::None;
    }

    pub fn has_dire_kills(&self) -> bool {
        self.dire_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_kills(&mut self, v: u32) {
        self.dire_kills = ::std::option::Option::Some(v);
    }

    // optional int32 radiant_lead = 14;

    pub fn radiant_lead(&self) -> i32 {
        self.radiant_lead.unwrap_or(0)
    }

    pub fn clear_radiant_lead(&mut self) {
        self.radiant_lead = ::std::option::Option::None;
    }

    pub fn has_radiant_lead(&self) -> bool {
        self.radiant_lead.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_lead(&mut self, v: i32) {
        self.radiant_lead = ::std::option::Option::Some(v);
    }

    // optional uint32 building_state = 15;

    pub fn building_state(&self) -> u32 {
        self.building_state.unwrap_or(0)
    }

    pub fn clear_building_state(&mut self) {
        self.building_state = ::std::option::Option::None;
    }

    pub fn has_building_state(&self) -> bool {
        self.building_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_building_state(&mut self, v: u32) {
        self.building_state = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConnectedPlayers {
    const NAME: &'static str = "CMsgConnectedPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.connected_players.push(is.read_message()?);
                },
                58 => {
                    self.disconnected_players.push(is.read_message()?);
                },
                16 => {
                    self.game_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.first_blood_happened = ::std::option::Option::Some(is.read_bool()?);
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                64 => {
                    self.send_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                88 => {
                    self.radiant_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.dire_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.radiant_lead = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.building_state = ::std::option::Option::Some(is.read_uint32()?);
                },
                130 => {
                    self.player_draft.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.connected_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.disconnected_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.game_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.first_blood_happened {
            my_size += 1 + 1;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.send_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.radiant_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.dire_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.radiant_lead {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.building_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        for value in &self.player_draft {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.connected_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.disconnected_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.game_state {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.first_blood_happened {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.send_reason {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.radiant_kills {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.dire_kills {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.radiant_lead {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.building_state {
            os.write_uint32(15, v)?;
        }
        for v in &self.player_draft {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConnectedPlayers {
        CMsgConnectedPlayers::new()
    }

    fn clear(&mut self) {
        self.connected_players.clear();
        self.disconnected_players.clear();
        self.game_state = ::std::option::Option::None;
        self.first_blood_happened = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.send_reason = ::std::option::Option::None;
        self.radiant_kills = ::std::option::Option::None;
        self.dire_kills = ::std::option::Option::None;
        self.radiant_lead = ::std::option::Option::None;
        self.building_state = ::std::option::Option::None;
        self.player_draft.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConnectedPlayers {
        static instance: CMsgConnectedPlayers = CMsgConnectedPlayers {
            connected_players: ::std::vec::Vec::new(),
            disconnected_players: ::std::vec::Vec::new(),
            game_state: ::std::option::Option::None,
            first_blood_happened: ::std::option::Option::None,
            poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            send_reason: ::std::option::Option::None,
            radiant_kills: ::std::option::Option::None,
            dire_kills: ::std::option::Option::None,
            radiant_lead: ::std::option::Option::None,
            building_state: ::std::option::Option::None,
            player_draft: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgConnectedPlayers`
pub mod cmsg_connected_players {
    // @@protoc_insertion_point(message:CMsgConnectedPlayers.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.Player.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.Player.leaver_state)
        pub leaver_state: ::steam_vent_proto_common::protobuf::MessageField<super::super::dota_gcmessages_common_match_management::CMsgLeaverState>,
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.Player.disconnect_reason)
        pub disconnect_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::network_connection::ENetworkDisconnectionReason>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgConnectedPlayers.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional .ENetworkDisconnectionReason disconnect_reason = 4;

        pub fn disconnect_reason(&self) -> super::super::network_connection::ENetworkDisconnectionReason {
            match self.disconnect_reason {
                Some(e) => e.enum_value_or(super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
                None => super::super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
            }
        }

        pub fn clear_disconnect_reason(&mut self) {
            self.disconnect_reason = ::std::option::Option::None;
        }

        pub fn has_disconnect_reason(&self) -> bool {
            self.disconnect_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_disconnect_reason(&mut self, v: super::super::network_connection::ENetworkDisconnectionReason) {
            self.disconnect_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.leaver_state)?;
                    },
                    32 => {
                        self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.leaver_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.disconnect_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.leaver_state.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.disconnect_reason {
                os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.leaver_state.clear();
            self.disconnect_reason = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                steam_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                leaver_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
                disconnect_reason: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgConnectedPlayers.PlayerDraft)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerDraft {
        // message fields
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.PlayerDraft.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.PlayerDraft.team)
        pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::DOTA_GC_TEAM>>,
        // @@protoc_insertion_point(field:CMsgConnectedPlayers.PlayerDraft.team_slot)
        pub team_slot: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgConnectedPlayers.PlayerDraft.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerDraft {
        fn default() -> &'a PlayerDraft {
            <PlayerDraft as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerDraft {
        pub fn new() -> PlayerDraft {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional .DOTA_GC_TEAM team = 2;

        pub fn team(&self) -> super::super::dota_shared_enums::DOTA_GC_TEAM {
            match self.team {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                None => super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
            }
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: super::super::dota_shared_enums::DOTA_GC_TEAM) {
            self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional int32 team_slot = 3;

        pub fn team_slot(&self) -> i32 {
            self.team_slot.unwrap_or(0)
        }

        pub fn clear_team_slot(&mut self) {
            self.team_slot = ::std::option::Option::None;
        }

        pub fn has_team_slot(&self) -> bool {
            self.team_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_slot(&mut self, v: i32) {
            self.team_slot = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerDraft {
        const NAME: &'static str = "PlayerDraft";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.team_slot = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.team_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.team {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.team_slot {
                os.write_int32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerDraft {
            PlayerDraft::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.team_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerDraft {
            static instance: PlayerDraft = PlayerDraft {
                steam_id: ::std::option::Option::None,
                team: ::std::option::Option::None,
                team_slot: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgConnectedPlayers.SendReason)
    pub enum SendReason {
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.INVALID)
        INVALID = 0,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.HEARTBEAT)
        HEARTBEAT = 1,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.GAME_STATE)
        GAME_STATE = 2,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.FIRST_BLOOD)
        FIRST_BLOOD = 3,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.PLAYER_CONNECTED)
        PLAYER_CONNECTED = 4,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.PLAYER_HERO)
        PLAYER_HERO = 5,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.PLAYER_DISCONNECTED_CONSEQUENCES)
        PLAYER_DISCONNECTED_CONSEQUENCES = 6,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.PLAYER_DISCONNECTED_NOCONSEQUENCES)
        PLAYER_DISCONNECTED_NOCONSEQUENCES = 7,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.GAMESTATE_TIMEOUT)
        GAMESTATE_TIMEOUT = 10,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.MASS_DISCONNECT)
        MASS_DISCONNECT = 11,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.KILLS)
        KILLS = 13,
        // @@protoc_insertion_point(enum_value:CMsgConnectedPlayers.SendReason.BUILDING_STATE)
        BUILDING_STATE = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for SendReason {
        const NAME: &'static str = "SendReason";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<SendReason> {
            match value {
                0 => ::std::option::Option::Some(SendReason::INVALID),
                1 => ::std::option::Option::Some(SendReason::HEARTBEAT),
                2 => ::std::option::Option::Some(SendReason::GAME_STATE),
                3 => ::std::option::Option::Some(SendReason::FIRST_BLOOD),
                4 => ::std::option::Option::Some(SendReason::PLAYER_CONNECTED),
                5 => ::std::option::Option::Some(SendReason::PLAYER_HERO),
                6 => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_CONSEQUENCES),
                7 => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES),
                10 => ::std::option::Option::Some(SendReason::GAMESTATE_TIMEOUT),
                11 => ::std::option::Option::Some(SendReason::MASS_DISCONNECT),
                13 => ::std::option::Option::Some(SendReason::KILLS),
                14 => ::std::option::Option::Some(SendReason::BUILDING_STATE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<SendReason> {
            match str {
                "INVALID" => ::std::option::Option::Some(SendReason::INVALID),
                "HEARTBEAT" => ::std::option::Option::Some(SendReason::HEARTBEAT),
                "GAME_STATE" => ::std::option::Option::Some(SendReason::GAME_STATE),
                "FIRST_BLOOD" => ::std::option::Option::Some(SendReason::FIRST_BLOOD),
                "PLAYER_CONNECTED" => ::std::option::Option::Some(SendReason::PLAYER_CONNECTED),
                "PLAYER_HERO" => ::std::option::Option::Some(SendReason::PLAYER_HERO),
                "PLAYER_DISCONNECTED_CONSEQUENCES" => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_CONSEQUENCES),
                "PLAYER_DISCONNECTED_NOCONSEQUENCES" => ::std::option::Option::Some(SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES),
                "GAMESTATE_TIMEOUT" => ::std::option::Option::Some(SendReason::GAMESTATE_TIMEOUT),
                "MASS_DISCONNECT" => ::std::option::Option::Some(SendReason::MASS_DISCONNECT),
                "KILLS" => ::std::option::Option::Some(SendReason::KILLS),
                "BUILDING_STATE" => ::std::option::Option::Some(SendReason::BUILDING_STATE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [SendReason] = &[
            SendReason::INVALID,
            SendReason::HEARTBEAT,
            SendReason::GAME_STATE,
            SendReason::FIRST_BLOOD,
            SendReason::PLAYER_CONNECTED,
            SendReason::PLAYER_HERO,
            SendReason::PLAYER_DISCONNECTED_CONSEQUENCES,
            SendReason::PLAYER_DISCONNECTED_NOCONSEQUENCES,
            SendReason::GAMESTATE_TIMEOUT,
            SendReason::MASS_DISCONNECT,
            SendReason::KILLS,
            SendReason::BUILDING_STATE,
        ];
    }

    impl ::std::default::Default for SendReason {
        fn default() -> Self {
            SendReason::INVALID
        }
    }

}

// @@protoc_insertion_point(message:CMsgGameServerInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_public_ip_addr)
    pub server_public_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_private_ip_addr)
    pub server_private_ip_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_port)
    pub server_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_tv_port)
    pub server_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.assigned_server_tv_port)
    pub assigned_server_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.legacy_server_steamdatagram_address)
    pub legacy_server_steamdatagram_address: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_key)
    pub server_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_hibernation)
    pub server_hibernation: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_type)
    pub server_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_game_server_info::ServerType>>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_loadavg)
    pub server_loadavg: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_tv_broadcast_time)
    pub server_tv_broadcast_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_game_time)
    pub server_game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_relay_connected_steam_id)
    pub server_relay_connected_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relay_slots_max)
    pub relay_slots_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relays_connected)
    pub relays_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relay_clients_connected)
    pub relay_clients_connected: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.relayed_game_server_steam_id)
    pub relayed_game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.parent_relay_count)
    pub parent_relay_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.tv_secret_code)
    pub tv_secret_code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.allow_custom_games)
    pub allow_custom_games: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_game_server_info::CustomGames>>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.build_version)
    pub build_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.srcds_instance)
    pub srcds_instance: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.dev_force_server_type)
    pub dev_force_server_type: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameServerInfo.is_recording_match_training_data)
    pub is_recording_match_training_data: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerInfo {
    fn default() -> &'a CMsgGameServerInfo {
        <CMsgGameServerInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerInfo {
    pub fn new() -> CMsgGameServerInfo {
        ::std::default::Default::default()
    }

    // optional fixed32 server_public_ip_addr = 1;

    pub fn server_public_ip_addr(&self) -> u32 {
        self.server_public_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_public_ip_addr(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_public_ip_addr(&self) -> bool {
        self.server_public_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_public_ip_addr(&mut self, v: u32) {
        self.server_public_ip_addr = ::std::option::Option::Some(v);
    }

    // optional fixed32 server_private_ip_addr = 2;

    pub fn server_private_ip_addr(&self) -> u32 {
        self.server_private_ip_addr.unwrap_or(0)
    }

    pub fn clear_server_private_ip_addr(&mut self) {
        self.server_private_ip_addr = ::std::option::Option::None;
    }

    pub fn has_server_private_ip_addr(&self) -> bool {
        self.server_private_ip_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_private_ip_addr(&mut self, v: u32) {
        self.server_private_ip_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 server_port = 3;

    pub fn server_port(&self) -> u32 {
        self.server_port.unwrap_or(0)
    }

    pub fn clear_server_port(&mut self) {
        self.server_port = ::std::option::Option::None;
    }

    pub fn has_server_port(&self) -> bool {
        self.server_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_port(&mut self, v: u32) {
        self.server_port = ::std::option::Option::Some(v);
    }

    // optional uint32 server_tv_port = 4;

    pub fn server_tv_port(&self) -> u32 {
        self.server_tv_port.unwrap_or(0)
    }

    pub fn clear_server_tv_port(&mut self) {
        self.server_tv_port = ::std::option::Option::None;
    }

    pub fn has_server_tv_port(&self) -> bool {
        self.server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_port(&mut self, v: u32) {
        self.server_tv_port = ::std::option::Option::Some(v);
    }

    // optional uint32 assigned_server_tv_port = 22;

    pub fn assigned_server_tv_port(&self) -> u32 {
        self.assigned_server_tv_port.unwrap_or(0)
    }

    pub fn clear_assigned_server_tv_port(&mut self) {
        self.assigned_server_tv_port = ::std::option::Option::None;
    }

    pub fn has_assigned_server_tv_port(&self) -> bool {
        self.assigned_server_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_server_tv_port(&mut self, v: u32) {
        self.assigned_server_tv_port = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_server_steamdatagram_address = 27;

    pub fn legacy_server_steamdatagram_address(&self) -> &[u8] {
        match self.legacy_server_steamdatagram_address.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_server_steamdatagram_address(&mut self) {
        self.legacy_server_steamdatagram_address = ::std::option::Option::None;
    }

    pub fn has_legacy_server_steamdatagram_address(&self) -> bool {
        self.legacy_server_steamdatagram_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_server_steamdatagram_address(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_server_steamdatagram_address = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_server_steamdatagram_address(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_server_steamdatagram_address.is_none() {
            self.legacy_server_steamdatagram_address = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_server_steamdatagram_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_server_steamdatagram_address(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_server_steamdatagram_address.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string server_key = 5;

    pub fn server_key(&self) -> &str {
        match self.server_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_key(&mut self) {
        self.server_key = ::std::option::Option::None;
    }

    pub fn has_server_key(&self) -> bool {
        self.server_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_key(&mut self, v: ::std::string::String) {
        self.server_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_key(&mut self) -> &mut ::std::string::String {
        if self.server_key.is_none() {
            self.server_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_key(&mut self) -> ::std::string::String {
        self.server_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool server_hibernation = 6;

    pub fn server_hibernation(&self) -> bool {
        self.server_hibernation.unwrap_or(false)
    }

    pub fn clear_server_hibernation(&mut self) {
        self.server_hibernation = ::std::option::Option::None;
    }

    pub fn has_server_hibernation(&self) -> bool {
        self.server_hibernation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_hibernation(&mut self, v: bool) {
        self.server_hibernation = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerInfo.ServerType server_type = 7;

    pub fn server_type(&self) -> cmsg_game_server_info::ServerType {
        match self.server_type {
            Some(e) => e.enum_value_or(cmsg_game_server_info::ServerType::UNSPECIFIED),
            None => cmsg_game_server_info::ServerType::UNSPECIFIED,
        }
    }

    pub fn clear_server_type(&mut self) {
        self.server_type = ::std::option::Option::None;
    }

    pub fn has_server_type(&self) -> bool {
        self.server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_type(&mut self, v: cmsg_game_server_info::ServerType) {
        self.server_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 server_region = 8;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional float server_loadavg = 9;

    pub fn server_loadavg(&self) -> f32 {
        self.server_loadavg.unwrap_or(0.)
    }

    pub fn clear_server_loadavg(&mut self) {
        self.server_loadavg = ::std::option::Option::None;
    }

    pub fn has_server_loadavg(&self) -> bool {
        self.server_loadavg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_loadavg(&mut self, v: f32) {
        self.server_loadavg = ::std::option::Option::Some(v);
    }

    // optional float server_tv_broadcast_time = 10;

    pub fn server_tv_broadcast_time(&self) -> f32 {
        self.server_tv_broadcast_time.unwrap_or(0.)
    }

    pub fn clear_server_tv_broadcast_time(&mut self) {
        self.server_tv_broadcast_time = ::std::option::Option::None;
    }

    pub fn has_server_tv_broadcast_time(&self) -> bool {
        self.server_tv_broadcast_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_tv_broadcast_time(&mut self, v: f32) {
        self.server_tv_broadcast_time = ::std::option::Option::Some(v);
    }

    // optional float server_game_time = 11;

    pub fn server_game_time(&self) -> f32 {
        self.server_game_time.unwrap_or(0.)
    }

    pub fn clear_server_game_time(&mut self) {
        self.server_game_time = ::std::option::Option::None;
    }

    pub fn has_server_game_time(&self) -> bool {
        self.server_game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_game_time(&mut self, v: f32) {
        self.server_game_time = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_relay_connected_steam_id = 12;

    pub fn server_relay_connected_steam_id(&self) -> u64 {
        self.server_relay_connected_steam_id.unwrap_or(0)
    }

    pub fn clear_server_relay_connected_steam_id(&mut self) {
        self.server_relay_connected_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_relay_connected_steam_id(&self) -> bool {
        self.server_relay_connected_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_relay_connected_steam_id(&mut self, v: u64) {
        self.server_relay_connected_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 relay_slots_max = 13;

    pub fn relay_slots_max(&self) -> u32 {
        self.relay_slots_max.unwrap_or(0)
    }

    pub fn clear_relay_slots_max(&mut self) {
        self.relay_slots_max = ::std::option::Option::None;
    }

    pub fn has_relay_slots_max(&self) -> bool {
        self.relay_slots_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_slots_max(&mut self, v: u32) {
        self.relay_slots_max = ::std::option::Option::Some(v);
    }

    // optional int32 relays_connected = 14;

    pub fn relays_connected(&self) -> i32 {
        self.relays_connected.unwrap_or(0)
    }

    pub fn clear_relays_connected(&mut self) {
        self.relays_connected = ::std::option::Option::None;
    }

    pub fn has_relays_connected(&self) -> bool {
        self.relays_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relays_connected(&mut self, v: i32) {
        self.relays_connected = ::std::option::Option::Some(v);
    }

    // optional int32 relay_clients_connected = 15;

    pub fn relay_clients_connected(&self) -> i32 {
        self.relay_clients_connected.unwrap_or(0)
    }

    pub fn clear_relay_clients_connected(&mut self) {
        self.relay_clients_connected = ::std::option::Option::None;
    }

    pub fn has_relay_clients_connected(&self) -> bool {
        self.relay_clients_connected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_clients_connected(&mut self, v: i32) {
        self.relay_clients_connected = ::std::option::Option::Some(v);
    }

    // optional fixed64 relayed_game_server_steam_id = 16;

    pub fn relayed_game_server_steam_id(&self) -> u64 {
        self.relayed_game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_relayed_game_server_steam_id(&mut self) {
        self.relayed_game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_relayed_game_server_steam_id(&self) -> bool {
        self.relayed_game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relayed_game_server_steam_id(&mut self, v: u64) {
        self.relayed_game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_relay_count = 17;

    pub fn parent_relay_count(&self) -> u32 {
        self.parent_relay_count.unwrap_or(0)
    }

    pub fn clear_parent_relay_count(&mut self) {
        self.parent_relay_count = ::std::option::Option::None;
    }

    pub fn has_parent_relay_count(&self) -> bool {
        self.parent_relay_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_relay_count(&mut self, v: u32) {
        self.parent_relay_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_secret_code = 18;

    pub fn tv_secret_code(&self) -> u64 {
        self.tv_secret_code.unwrap_or(0)
    }

    pub fn clear_tv_secret_code(&mut self) {
        self.tv_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_secret_code(&self) -> bool {
        self.tv_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_secret_code(&mut self, v: u64) {
        self.tv_secret_code = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 19;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 server_cluster = 20;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional .CMsgGameServerInfo.CustomGames allow_custom_games = 23;

    pub fn allow_custom_games(&self) -> cmsg_game_server_info::CustomGames {
        match self.allow_custom_games {
            Some(e) => e.enum_value_or(cmsg_game_server_info::CustomGames::BOTH),
            None => cmsg_game_server_info::CustomGames::BOTH,
        }
    }

    pub fn clear_allow_custom_games(&mut self) {
        self.allow_custom_games = ::std::option::Option::None;
    }

    pub fn has_allow_custom_games(&self) -> bool {
        self.allow_custom_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_custom_games(&mut self, v: cmsg_game_server_info::CustomGames) {
        self.allow_custom_games = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 build_version = 24;

    pub fn build_version(&self) -> u32 {
        self.build_version.unwrap_or(0)
    }

    pub fn clear_build_version(&mut self) {
        self.build_version = ::std::option::Option::None;
    }

    pub fn has_build_version(&self) -> bool {
        self.build_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_build_version(&mut self, v: u32) {
        self.build_version = ::std::option::Option::Some(v);
    }

    // optional uint32 srcds_instance = 26;

    pub fn srcds_instance(&self) -> u32 {
        self.srcds_instance.unwrap_or(0)
    }

    pub fn clear_srcds_instance(&mut self) {
        self.srcds_instance = ::std::option::Option::None;
    }

    pub fn has_srcds_instance(&self) -> bool {
        self.srcds_instance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcds_instance(&mut self, v: u32) {
        self.srcds_instance = ::std::option::Option::Some(v);
    }

    // optional bool dev_force_server_type = 28;

    pub fn dev_force_server_type(&self) -> bool {
        self.dev_force_server_type.unwrap_or(false)
    }

    pub fn clear_dev_force_server_type(&mut self) {
        self.dev_force_server_type = ::std::option::Option::None;
    }

    pub fn has_dev_force_server_type(&self) -> bool {
        self.dev_force_server_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dev_force_server_type(&mut self, v: bool) {
        self.dev_force_server_type = ::std::option::Option::Some(v);
    }

    // optional bool is_recording_match_training_data = 29;

    pub fn is_recording_match_training_data(&self) -> bool {
        self.is_recording_match_training_data.unwrap_or(false)
    }

    pub fn clear_is_recording_match_training_data(&mut self) {
        self.is_recording_match_training_data = ::std::option::Option::None;
    }

    pub fn has_is_recording_match_training_data(&self) -> bool {
        self.is_recording_match_training_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_recording_match_training_data(&mut self, v: bool) {
        self.is_recording_match_training_data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerInfo {
    const NAME: &'static str = "CMsgGameServerInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.server_public_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.server_private_ip_addr = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.server_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.server_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.assigned_server_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                218 => {
                    self.legacy_server_steamdatagram_address = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.server_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.server_hibernation = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.server_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                64 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                77 => {
                    self.server_loadavg = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.server_tv_broadcast_time = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.server_game_time = ::std::option::Option::Some(is.read_float()?);
                },
                97 => {
                    self.server_relay_connected_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                104 => {
                    self.relay_slots_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.relays_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                120 => {
                    self.relay_clients_connected = ::std::option::Option::Some(is.read_int32()?);
                },
                129 => {
                    self.relayed_game_server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                136 => {
                    self.parent_relay_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                145 => {
                    self.tv_secret_code = ::std::option::Option::Some(is.read_fixed64()?);
                },
                152 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.allow_custom_games = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                192 => {
                    self.build_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                208 => {
                    self.srcds_instance = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.dev_force_server_type = ::std::option::Option::Some(is.read_bool()?);
                },
                232 => {
                    self.is_recording_match_training_data = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_public_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_private_ip_addr {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.server_tv_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assigned_server_tv_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.legacy_server_steamdatagram_address.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(27, &v);
        }
        if let Some(v) = self.server_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.server_hibernation {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v.value());
        }
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_loadavg {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.relay_slots_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.relays_connected {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
        }
        if let Some(v) = self.relay_clients_connected {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            my_size += 2 + 8;
        }
        if let Some(v) = self.parent_relay_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.tv_secret_code {
            my_size += 2 + 8;
        }
        if let Some(v) = self.server_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.server_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.allow_custom_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(23, v.value());
        }
        if let Some(v) = self.build_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
        }
        if let Some(v) = self.srcds_instance {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
        }
        if let Some(v) = self.dev_force_server_type {
            my_size += 2 + 1;
        }
        if let Some(v) = self.is_recording_match_training_data {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_public_ip_addr {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.server_private_ip_addr {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.server_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.server_tv_port {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assigned_server_tv_port {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.legacy_server_steamdatagram_address.as_ref() {
            os.write_bytes(27, v)?;
        }
        if let Some(v) = self.server_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.server_hibernation {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.server_type {
            os.write_enum(7, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_loadavg {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.server_tv_broadcast_time {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.server_game_time {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.server_relay_connected_steam_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.relay_slots_max {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.relays_connected {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.relay_clients_connected {
            os.write_int32(15, v)?;
        }
        if let Some(v) = self.relayed_game_server_steam_id {
            os.write_fixed64(16, v)?;
        }
        if let Some(v) = self.parent_relay_count {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.tv_secret_code {
            os.write_fixed64(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.allow_custom_games {
            os.write_enum(23, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.build_version {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.srcds_instance {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.dev_force_server_type {
            os.write_bool(28, v)?;
        }
        if let Some(v) = self.is_recording_match_training_data {
            os.write_bool(29, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerInfo {
        CMsgGameServerInfo::new()
    }

    fn clear(&mut self) {
        self.server_public_ip_addr = ::std::option::Option::None;
        self.server_private_ip_addr = ::std::option::Option::None;
        self.server_port = ::std::option::Option::None;
        self.server_tv_port = ::std::option::Option::None;
        self.assigned_server_tv_port = ::std::option::Option::None;
        self.legacy_server_steamdatagram_address = ::std::option::Option::None;
        self.server_key = ::std::option::Option::None;
        self.server_hibernation = ::std::option::Option::None;
        self.server_type = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.server_loadavg = ::std::option::Option::None;
        self.server_tv_broadcast_time = ::std::option::Option::None;
        self.server_game_time = ::std::option::Option::None;
        self.server_relay_connected_steam_id = ::std::option::Option::None;
        self.relay_slots_max = ::std::option::Option::None;
        self.relays_connected = ::std::option::Option::None;
        self.relay_clients_connected = ::std::option::Option::None;
        self.relayed_game_server_steam_id = ::std::option::Option::None;
        self.parent_relay_count = ::std::option::Option::None;
        self.tv_secret_code = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.server_cluster = ::std::option::Option::None;
        self.allow_custom_games = ::std::option::Option::None;
        self.build_version = ::std::option::Option::None;
        self.srcds_instance = ::std::option::Option::None;
        self.dev_force_server_type = ::std::option::Option::None;
        self.is_recording_match_training_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerInfo {
        static instance: CMsgGameServerInfo = CMsgGameServerInfo {
            server_public_ip_addr: ::std::option::Option::None,
            server_private_ip_addr: ::std::option::Option::None,
            server_port: ::std::option::Option::None,
            server_tv_port: ::std::option::Option::None,
            assigned_server_tv_port: ::std::option::Option::None,
            legacy_server_steamdatagram_address: ::std::option::Option::None,
            server_key: ::std::option::Option::None,
            server_hibernation: ::std::option::Option::None,
            server_type: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            server_loadavg: ::std::option::Option::None,
            server_tv_broadcast_time: ::std::option::Option::None,
            server_game_time: ::std::option::Option::None,
            server_relay_connected_steam_id: ::std::option::Option::None,
            relay_slots_max: ::std::option::Option::None,
            relays_connected: ::std::option::Option::None,
            relay_clients_connected: ::std::option::Option::None,
            relayed_game_server_steam_id: ::std::option::Option::None,
            parent_relay_count: ::std::option::Option::None,
            tv_secret_code: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            server_cluster: ::std::option::Option::None,
            allow_custom_games: ::std::option::Option::None,
            build_version: ::std::option::Option::None,
            srcds_instance: ::std::option::Option::None,
            dev_force_server_type: ::std::option::Option::None,
            is_recording_match_training_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameServerInfo`
pub mod cmsg_game_server_info {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerInfo.ServerType)
    pub enum ServerType {
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.UNSPECIFIED)
        UNSPECIFIED = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.GAME)
        GAME = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.PROXY)
        PROXY = 2,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.DOTA_ONLY)
        DOTA_ONLY = 4,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.CUSTOM_GAME_ONLY)
        CUSTOM_GAME_ONLY = 5,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.ServerType.EVENT_GAME_ONLY)
        EVENT_GAME_ONLY = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for ServerType {
        const NAME: &'static str = "ServerType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<ServerType> {
            match value {
                0 => ::std::option::Option::Some(ServerType::UNSPECIFIED),
                1 => ::std::option::Option::Some(ServerType::GAME),
                2 => ::std::option::Option::Some(ServerType::PROXY),
                4 => ::std::option::Option::Some(ServerType::DOTA_ONLY),
                5 => ::std::option::Option::Some(ServerType::CUSTOM_GAME_ONLY),
                6 => ::std::option::Option::Some(ServerType::EVENT_GAME_ONLY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<ServerType> {
            match str {
                "UNSPECIFIED" => ::std::option::Option::Some(ServerType::UNSPECIFIED),
                "GAME" => ::std::option::Option::Some(ServerType::GAME),
                "PROXY" => ::std::option::Option::Some(ServerType::PROXY),
                "DOTA_ONLY" => ::std::option::Option::Some(ServerType::DOTA_ONLY),
                "CUSTOM_GAME_ONLY" => ::std::option::Option::Some(ServerType::CUSTOM_GAME_ONLY),
                "EVENT_GAME_ONLY" => ::std::option::Option::Some(ServerType::EVENT_GAME_ONLY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [ServerType] = &[
            ServerType::UNSPECIFIED,
            ServerType::GAME,
            ServerType::PROXY,
            ServerType::DOTA_ONLY,
            ServerType::CUSTOM_GAME_ONLY,
            ServerType::EVENT_GAME_ONLY,
        ];
    }

    impl ::std::default::Default for ServerType {
        fn default() -> Self {
            ServerType::UNSPECIFIED
        }
    }


    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerInfo.CustomGames)
    pub enum CustomGames {
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.CustomGames.BOTH)
        BOTH = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.CustomGames.NONE)
        NONE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.CustomGames.ONLY)
        ONLY = 2,
        // @@protoc_insertion_point(enum_value:CMsgGameServerInfo.CustomGames.EVENT)
        EVENT = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for CustomGames {
        const NAME: &'static str = "CustomGames";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CustomGames> {
            match value {
                0 => ::std::option::Option::Some(CustomGames::BOTH),
                1 => ::std::option::Option::Some(CustomGames::NONE),
                2 => ::std::option::Option::Some(CustomGames::ONLY),
                3 => ::std::option::Option::Some(CustomGames::EVENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CustomGames> {
            match str {
                "BOTH" => ::std::option::Option::Some(CustomGames::BOTH),
                "NONE" => ::std::option::Option::Some(CustomGames::NONE),
                "ONLY" => ::std::option::Option::Some(CustomGames::ONLY),
                "EVENT" => ::std::option::Option::Some(CustomGames::EVENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CustomGames] = &[
            CustomGames::BOTH,
            CustomGames::NONE,
            CustomGames::ONLY,
            CustomGames::EVENT,
        ];
    }

    impl ::std::default::Default for CustomGames {
        fn default() -> Self {
            CustomGames::BOTH
        }
    }

}

// @@protoc_insertion_point(message:CMsgLeaverDetected)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaverDetected {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeaverDetected.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgLeaverDetected.leaver_status)
    pub leaver_status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALeaverStatus_t>>,
    // @@protoc_insertion_point(field:CMsgLeaverDetected.leaver_state)
    pub leaver_state: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMsgLeaverState>,
    // @@protoc_insertion_point(field:CMsgLeaverDetected.server_cluster)
    pub server_cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLeaverDetected.disconnect_reason)
    pub disconnect_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::network_connection::ENetworkDisconnectionReason>>,
    // @@protoc_insertion_point(field:CMsgLeaverDetected.poor_network_conditions)
    pub poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaverDetected.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaverDetected {
    fn default() -> &'a CMsgLeaverDetected {
        <CMsgLeaverDetected as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaverDetected {
    pub fn new() -> CMsgLeaverDetected {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional .DOTALeaverStatus_t leaver_status = 2;

    pub fn leaver_status(&self) -> super::dota_shared_enums::DOTALeaverStatus_t {
        match self.leaver_status {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE),
            None => super::dota_shared_enums::DOTALeaverStatus_t::DOTA_LEAVER_NONE,
        }
    }

    pub fn clear_leaver_status(&mut self) {
        self.leaver_status = ::std::option::Option::None;
    }

    pub fn has_leaver_status(&self) -> bool {
        self.leaver_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leaver_status(&mut self, v: super::dota_shared_enums::DOTALeaverStatus_t) {
        self.leaver_status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 server_cluster = 5;

    pub fn server_cluster(&self) -> u32 {
        self.server_cluster.unwrap_or(0)
    }

    pub fn clear_server_cluster(&mut self) {
        self.server_cluster = ::std::option::Option::None;
    }

    pub fn has_server_cluster(&self) -> bool {
        self.server_cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_cluster(&mut self, v: u32) {
        self.server_cluster = ::std::option::Option::Some(v);
    }

    // optional .ENetworkDisconnectionReason disconnect_reason = 6;

    pub fn disconnect_reason(&self) -> super::network_connection::ENetworkDisconnectionReason {
        match self.disconnect_reason {
            Some(e) => e.enum_value_or(super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID),
            None => super::network_connection::ENetworkDisconnectionReason::NETWORK_DISCONNECT_INVALID,
        }
    }

    pub fn clear_disconnect_reason(&mut self) {
        self.disconnect_reason = ::std::option::Option::None;
    }

    pub fn has_disconnect_reason(&self) -> bool {
        self.disconnect_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disconnect_reason(&mut self, v: super::network_connection::ENetworkDisconnectionReason) {
        self.disconnect_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeaverDetected {
    const NAME: &'static str = "CMsgLeaverDetected";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.leaver_status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.leaver_state)?;
                },
                40 => {
                    self.server_cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.disconnect_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.leaver_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.leaver_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.server_cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.disconnect_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.leaver_status {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.leaver_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.server_cluster {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.disconnect_reason {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaverDetected {
        CMsgLeaverDetected::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.leaver_status = ::std::option::Option::None;
        self.leaver_state.clear();
        self.server_cluster = ::std::option::Option::None;
        self.disconnect_reason = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaverDetected {
        static instance: CMsgLeaverDetected = CMsgLeaverDetected {
            steam_id: ::std::option::Option::None,
            leaver_status: ::std::option::Option::None,
            leaver_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            server_cluster: ::std::option::Option::None,
            disconnect_reason: ::std::option::Option::None,
            poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLeaverDetectedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaverDetectedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLeaverDetectedResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaverDetectedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaverDetectedResponse {
    fn default() -> &'a CMsgLeaverDetectedResponse {
        <CMsgLeaverDetectedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaverDetectedResponse {
    pub fn new() -> CMsgLeaverDetectedResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeaverDetectedResponse {
    const NAME: &'static str = "CMsgLeaverDetectedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaverDetectedResponse {
        CMsgLeaverDetectedResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaverDetectedResponse {
        static instance: CMsgLeaverDetectedResponse = CMsgLeaverDetectedResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyFinalPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyFinalPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyFinalPlayerStats.stats)
    pub stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyFinalPlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyFinalPlayerStats {
    fn default() -> &'a CMsgDOTAFantasyFinalPlayerStats {
        <CMsgDOTAFantasyFinalPlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyFinalPlayerStats {
    pub fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyFinalPlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyFinalPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyFinalPlayerStats {
        CMsgDOTAFantasyFinalPlayerStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyFinalPlayerStats {
        static instance: CMsgDOTAFantasyFinalPlayerStats = CMsgDOTAFantasyFinalPlayerStats {
            stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAFantasyLivePlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAFantasyLivePlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAFantasyLivePlayerStats.stats)
    pub stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAFantasyLivePlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAFantasyLivePlayerStats {
    fn default() -> &'a CMsgDOTAFantasyLivePlayerStats {
        <CMsgDOTAFantasyLivePlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAFantasyLivePlayerStats {
    pub fn new() -> CMsgDOTAFantasyLivePlayerStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAFantasyLivePlayerStats {
    const NAME: &'static str = "CMsgDOTAFantasyLivePlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAFantasyLivePlayerStats {
        CMsgDOTAFantasyLivePlayerStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAFantasyLivePlayerStats {
        static instance: CMsgDOTAFantasyLivePlayerStats = CMsgDOTAFantasyLivePlayerStats {
            stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRealtimeStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRealtimeStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRealtimeStats.delayed)
    pub delayed: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTARealtimeGameStatsTerse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRealtimeStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRealtimeStats {
    fn default() -> &'a CMsgServerToGCRealtimeStats {
        <CMsgServerToGCRealtimeStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRealtimeStats {
    pub fn new() -> CMsgServerToGCRealtimeStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRealtimeStats {
    const NAME: &'static str = "CMsgServerToGCRealtimeStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.delayed)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delayed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.delayed.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRealtimeStats {
        CMsgServerToGCRealtimeStats::new()
    }

    fn clear(&mut self) {
        self.delayed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRealtimeStats {
        static instance: CMsgServerToGCRealtimeStats = CMsgServerToGCRealtimeStats {
            delayed: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerRealtimeStatsStartStop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerRealtimeStatsStartStop {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerRealtimeStatsStartStop.delayed)
    pub delayed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerRealtimeStatsStartStop.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerRealtimeStatsStartStop {
    fn default() -> &'a CMsgGCToServerRealtimeStatsStartStop {
        <CMsgGCToServerRealtimeStatsStartStop as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerRealtimeStatsStartStop {
    pub fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        ::std::default::Default::default()
    }

    // optional bool delayed = 1;

    pub fn delayed(&self) -> bool {
        self.delayed.unwrap_or(false)
    }

    pub fn clear_delayed(&mut self) {
        self.delayed = ::std::option::Option::None;
    }

    pub fn has_delayed(&self) -> bool {
        self.delayed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_delayed(&mut self, v: bool) {
        self.delayed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerRealtimeStatsStartStop {
    const NAME: &'static str = "CMsgGCToServerRealtimeStatsStartStop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.delayed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.delayed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.delayed {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerRealtimeStatsStartStop {
        CMsgGCToServerRealtimeStatsStartStop::new()
    }

    fn clear(&mut self) {
        self.delayed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerRealtimeStatsStartStop {
        static instance: CMsgGCToServerRealtimeStatsStartStop = CMsgGCToServerRealtimeStatsStartStop {
            delayed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerUpdateSteamBroadcasting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerUpdateSteamBroadcasting {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerUpdateSteamBroadcasting.active)
    pub active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerUpdateSteamBroadcasting.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerUpdateSteamBroadcasting {
    fn default() -> &'a CMsgGCToServerUpdateSteamBroadcasting {
        <CMsgGCToServerUpdateSteamBroadcasting as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerUpdateSteamBroadcasting {
    pub fn new() -> CMsgGCToServerUpdateSteamBroadcasting {
        ::std::default::Default::default()
    }

    // optional bool active = 1;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerUpdateSteamBroadcasting {
    const NAME: &'static str = "CMsgGCToServerUpdateSteamBroadcasting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.active {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerUpdateSteamBroadcasting {
        CMsgGCToServerUpdateSteamBroadcasting::new()
    }

    fn clear(&mut self) {
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerUpdateSteamBroadcasting {
        static instance: CMsgGCToServerUpdateSteamBroadcasting = CMsgGCToServerUpdateSteamBroadcasting {
            active: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutGameplayStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGameplayStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.teams)
    pub teams: ::std::vec::Vec<cmsg_sign_out_gameplay_stats::CTeam>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutGameplayStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGameplayStats {
    fn default() -> &'a CMsgSignOutGameplayStats {
        <CMsgSignOutGameplayStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGameplayStats {
    pub fn new() -> CMsgSignOutGameplayStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutGameplayStats {
    const NAME: &'static str = "CMsgSignOutGameplayStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.teams.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGameplayStats {
        CMsgSignOutGameplayStats::new()
    }

    fn clear(&mut self) {
        self.teams.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGameplayStats {
        static instance: CMsgSignOutGameplayStats = CMsgSignOutGameplayStats {
            teams: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutGameplayStats`
pub mod cmsg_sign_out_gameplay_stats {
    // @@protoc_insertion_point(message:CMsgSignOutGameplayStats.CPlayer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CPlayer {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CPlayer.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CPlayer.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CPlayer.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CPlayer.timed_player_stats)
        pub timed_player_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMatchPlayerTimedStats>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutGameplayStats.CPlayer.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CPlayer {
        fn default() -> &'a CPlayer {
            <CPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CPlayer {
        pub fn new() -> CPlayer {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 2;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CPlayer {
        const NAME: &'static str = "CPlayer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        self.timed_player_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            for value in &self.timed_player_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            for v in &self.timed_player_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CPlayer {
            CPlayer::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.timed_player_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CPlayer {
            static instance: CPlayer = CPlayer {
                steam_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                timed_player_stats: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSignOutGameplayStats.CTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CTeam {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CTeam.is_winning_team)
        pub is_winning_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CTeam.is_radiant_team)
        pub is_radiant_team: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CTeam.timed_team_stats)
        pub timed_team_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMatchTeamTimedStats>,
        // @@protoc_insertion_point(field:CMsgSignOutGameplayStats.CTeam.players)
        pub players: ::std::vec::Vec<CPlayer>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutGameplayStats.CTeam.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CTeam {
        fn default() -> &'a CTeam {
            <CTeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CTeam {
        pub fn new() -> CTeam {
            ::std::default::Default::default()
        }

        // optional bool is_winning_team = 1;

        pub fn is_winning_team(&self) -> bool {
            self.is_winning_team.unwrap_or(false)
        }

        pub fn clear_is_winning_team(&mut self) {
            self.is_winning_team = ::std::option::Option::None;
        }

        pub fn has_is_winning_team(&self) -> bool {
            self.is_winning_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winning_team(&mut self, v: bool) {
            self.is_winning_team = ::std::option::Option::Some(v);
        }

        // optional bool is_radiant_team = 2;

        pub fn is_radiant_team(&self) -> bool {
            self.is_radiant_team.unwrap_or(false)
        }

        pub fn clear_is_radiant_team(&mut self) {
            self.is_radiant_team = ::std::option::Option::None;
        }

        pub fn has_is_radiant_team(&self) -> bool {
            self.is_radiant_team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_radiant_team(&mut self, v: bool) {
            self.is_radiant_team = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CTeam {
        const NAME: &'static str = "CTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.is_winning_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    16 => {
                        self.is_radiant_team = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.timed_team_stats.push(is.read_message()?);
                    },
                    34 => {
                        self.players.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.is_winning_team {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_radiant_team {
                my_size += 1 + 1;
            }
            for value in &self.timed_team_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.is_winning_team {
                os.write_bool(1, v)?;
            }
            if let Some(v) = self.is_radiant_team {
                os.write_bool(2, v)?;
            }
            for v in &self.timed_team_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            };
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CTeam {
            CTeam::new()
        }

        fn clear(&mut self) {
            self.is_winning_team = ::std::option::Option::None;
            self.is_radiant_team = ::std::option::Option::None;
            self.timed_team_stats.clear();
            self.players.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CTeam {
            static instance: CTeam = CTeam {
                is_winning_team: ::std::option::Option::None,
                is_radiant_team: ::std::option::Option::None,
                timed_team_stats: ::std::vec::Vec::new(),
                players: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOut)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOut {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.good_guys_win)
    pub good_guys_win: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.date)
    pub date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.teams)
    pub teams: ::std::vec::Vec<cmsg_game_match_sign_out::CTeam>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.tower_status)
    pub tower_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.barracks_status)
    pub barracks_status: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.cluster)
    pub cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.server_addr)
    pub server_addr: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.first_blood_time)
    pub first_blood_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.event_score)
    pub event_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.fantasy_stats)
    pub fantasy_stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAFantasyPlayerStats>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.player_strange_count_adjustments)
    pub player_strange_count_adjustments: ::std::vec::Vec<super::econ_gcmessages::CMsgEconPlayerStrangeCountAdjustment>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.automatic_surrender)
    pub automatic_surrender: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.poor_network_conditions)
    pub poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField<CMsgPoorNetworkConditions>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.additional_msgs)
    pub additional_msgs: ::std::vec::Vec<cmsg_game_match_sign_out::CAdditionalSignoutMsg>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.social_feed_events)
    pub social_feed_events: ::std::vec::Vec<cmsg_game_match_sign_out::CSocialFeedMatchEvent>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.average_networth_delta)
    pub average_networth_delta: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.custom_game_data)
    pub custom_game_data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_game_match_sign_out::CCustomGameData>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.match_flags)
    pub match_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.team_scores)
    pub team_scores: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.pre_game_duration)
    pub pre_game_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.event_game_leaderboard_entries)
    pub event_game_leaderboard_entries: ::std::vec::Vec<cmsg_game_match_sign_out::EventGameLeaderboardEntry>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.ward_placements)
    pub ward_placements: ::std::vec::Vec<cmsg_game_match_sign_out::WardPlacement>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.gameplay_stats)
    pub gameplay_stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgSignOutGameplayStats>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.extra_messages)
    pub extra_messages: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.training_data_recorded)
    pub training_data_recorded: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.winning_team)
    pub winning_team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.normalized_win_probability_diff)
    pub normalized_win_probability_diff: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOut.match_tracked_stats)
    pub match_tracked_stats: ::std::vec::Vec<super::dota_gcmessages_common::CMsgTrackedStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOut {
    fn default() -> &'a CMsgGameMatchSignOut {
        <CMsgGameMatchSignOut as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOut {
    pub fn new() -> CMsgGameMatchSignOut {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 2;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional bool good_guys_win = 3;

    pub fn good_guys_win(&self) -> bool {
        self.good_guys_win.unwrap_or(false)
    }

    pub fn clear_good_guys_win(&mut self) {
        self.good_guys_win = ::std::option::Option::None;
    }

    pub fn has_good_guys_win(&self) -> bool {
        self.good_guys_win.is_some()
    }

    // Param is passed by value, moved
    pub fn set_good_guys_win(&mut self, v: bool) {
        self.good_guys_win = ::std::option::Option::Some(v);
    }

    // optional fixed32 date = 4;

    pub fn date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 10;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    // optional string server_addr = 11;

    pub fn server_addr(&self) -> &str {
        match self.server_addr.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_server_addr(&mut self) {
        self.server_addr = ::std::option::Option::None;
    }

    pub fn has_server_addr(&self) -> bool {
        self.server_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_addr(&mut self, v: ::std::string::String) {
        self.server_addr = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_addr(&mut self) -> &mut ::std::string::String {
        if self.server_addr.is_none() {
            self.server_addr = ::std::option::Option::Some(::std::string::String::new());
        }
        self.server_addr.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_addr(&mut self) -> ::std::string::String {
        self.server_addr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 first_blood_time = 12;

    pub fn first_blood_time(&self) -> u32 {
        self.first_blood_time.unwrap_or(0)
    }

    pub fn clear_first_blood_time(&mut self) {
        self.first_blood_time = ::std::option::Option::None;
    }

    pub fn has_first_blood_time(&self) -> bool {
        self.first_blood_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_time(&mut self, v: u32) {
        self.first_blood_time = ::std::option::Option::Some(v);
    }

    // optional uint32 event_score = 14;

    pub fn event_score(&self) -> u32 {
        self.event_score.unwrap_or(0)
    }

    pub fn clear_event_score(&mut self) {
        self.event_score = ::std::option::Option::None;
    }

    pub fn has_event_score(&self) -> bool {
        self.event_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_score(&mut self, v: u32) {
        self.event_score = ::std::option::Option::Some(v);
    }

    // optional bool automatic_surrender = 18;

    pub fn automatic_surrender(&self) -> bool {
        self.automatic_surrender.unwrap_or(false)
    }

    pub fn clear_automatic_surrender(&mut self) {
        self.automatic_surrender = ::std::option::Option::None;
    }

    pub fn has_automatic_surrender(&self) -> bool {
        self.automatic_surrender.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automatic_surrender(&mut self, v: bool) {
        self.automatic_surrender = ::std::option::Option::Some(v);
    }

    // optional uint32 server_version = 19;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional sint32 average_networth_delta = 22;

    pub fn average_networth_delta(&self) -> i32 {
        self.average_networth_delta.unwrap_or(0)
    }

    pub fn clear_average_networth_delta(&mut self) {
        self.average_networth_delta = ::std::option::Option::None;
    }

    pub fn has_average_networth_delta(&self) -> bool {
        self.average_networth_delta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_networth_delta(&mut self, v: i32) {
        self.average_networth_delta = ::std::option::Option::Some(v);
    }

    // optional uint32 match_flags = 38;

    pub fn match_flags(&self) -> u32 {
        self.match_flags.unwrap_or(0)
    }

    pub fn clear_match_flags(&mut self) {
        self.match_flags = ::std::option::Option::None;
    }

    pub fn has_match_flags(&self) -> bool {
        self.match_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_flags(&mut self, v: u32) {
        self.match_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 pre_game_duration = 40;

    pub fn pre_game_duration(&self) -> u32 {
        self.pre_game_duration.unwrap_or(0)
    }

    pub fn clear_pre_game_duration(&mut self) {
        self.pre_game_duration = ::std::option::Option::None;
    }

    pub fn has_pre_game_duration(&self) -> bool {
        self.pre_game_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pre_game_duration(&mut self, v: u32) {
        self.pre_game_duration = ::std::option::Option::Some(v);
    }

    // optional bool training_data_recorded = 55;

    pub fn training_data_recorded(&self) -> bool {
        self.training_data_recorded.unwrap_or(false)
    }

    pub fn clear_training_data_recorded(&mut self) {
        self.training_data_recorded = ::std::option::Option::None;
    }

    pub fn has_training_data_recorded(&self) -> bool {
        self.training_data_recorded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_training_data_recorded(&mut self, v: bool) {
        self.training_data_recorded = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GC_TEAM winning_team = 56;

    pub fn winning_team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.winning_team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.winning_team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional float normalized_win_probability_diff = 57;

    pub fn normalized_win_probability_diff(&self) -> f32 {
        self.normalized_win_probability_diff.unwrap_or(0.)
    }

    pub fn clear_normalized_win_probability_diff(&mut self) {
        self.normalized_win_probability_diff = ::std::option::Option::None;
    }

    pub fn has_normalized_win_probability_diff(&self) -> bool {
        self.normalized_win_probability_diff.is_some()
    }

    // Param is passed by value, moved
    pub fn set_normalized_win_probability_diff(&mut self, v: f32) {
        self.normalized_win_probability_diff = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOut {
    const NAME: &'static str = "CMsgGameMatchSignOut";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.good_guys_win = ::std::option::Option::Some(is.read_bool()?);
                },
                37 => {
                    self.date = ::std::option::Option::Some(is.read_fixed32()?);
                },
                50 => {
                    self.teams.push(is.read_message()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.tower_status)?;
                },
                64 => {
                    self.tower_status.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.barracks_status)?;
                },
                72 => {
                    self.barracks_status.push(is.read_uint32()?);
                },
                80 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                90 => {
                    self.server_addr = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.first_blood_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.event_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                330 => {
                    self.fantasy_stats.push(is.read_message()?);
                },
                138 => {
                    self.player_strange_count_adjustments.push(is.read_message()?);
                },
                144 => {
                    self.automatic_surrender = ::std::option::Option::Some(is.read_bool()?);
                },
                152 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                282 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.poor_network_conditions)?;
                },
                162 => {
                    self.additional_msgs.push(is.read_message()?);
                },
                290 => {
                    self.social_feed_events.push(is.read_message()?);
                },
                176 => {
                    self.average_networth_delta = ::std::option::Option::Some(is.read_sint32()?);
                },
                298 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                },
                304 => {
                    self.match_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                314 => {
                    is.read_repeated_packed_uint32_into(&mut self.team_scores)?;
                },
                312 => {
                    self.team_scores.push(is.read_uint32()?);
                },
                320 => {
                    self.pre_game_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                338 => {
                    self.event_game_leaderboard_entries.push(is.read_message()?);
                },
                346 => {
                    self.ward_placements.push(is.read_message()?);
                },
                354 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.gameplay_stats)?;
                },
                434 => {
                    self.extra_messages.push(is.read_message()?);
                },
                440 => {
                    self.training_data_recorded = ::std::option::Option::Some(is.read_bool()?);
                },
                448 => {
                    self.winning_team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                461 => {
                    self.normalized_win_probability_diff = ::std::option::Option::Some(is.read_float()?);
                },
                466 => {
                    self.match_tracked_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.good_guys_win {
            my_size += 1 + 1;
        }
        if let Some(v) = self.date {
            my_size += 1 + 4;
        }
        for value in &self.teams {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.tower_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        for value in &self.barracks_status {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, *value);
        };
        if let Some(v) = self.cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.server_addr.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.first_blood_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.event_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        for value in &self.fantasy_stats {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.player_strange_count_adjustments {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.automatic_surrender {
            my_size += 2 + 1;
        }
        if let Some(v) = self.server_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.additional_msgs {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.social_feed_events {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.average_networth_delta {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(22, v);
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.match_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
        }
        for value in &self.team_scores {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, *value);
        };
        if let Some(v) = self.pre_game_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(40, v);
        }
        for value in &self.event_game_leaderboard_entries {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.ward_placements {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.gameplay_stats.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.training_data_recorded {
            my_size += 2 + 1;
        }
        if let Some(v) = self.winning_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(56, v.value());
        }
        if let Some(v) = self.normalized_win_probability_diff {
            my_size += 2 + 4;
        }
        for value in &self.match_tracked_stats {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.good_guys_win {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.date {
            os.write_fixed32(4, v)?;
        }
        for v in &self.teams {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.tower_status {
            os.write_uint32(8, *v)?;
        };
        for v in &self.barracks_status {
            os.write_uint32(9, *v)?;
        };
        if let Some(v) = self.cluster {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.server_addr.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.first_blood_time {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.event_score {
            os.write_uint32(14, v)?;
        }
        for v in &self.fantasy_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(41, v, os)?;
        };
        for v in &self.player_strange_count_adjustments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        };
        if let Some(v) = self.automatic_surrender {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.server_version {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.poor_network_conditions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
        }
        for v in &self.additional_msgs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.social_feed_events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(36, v, os)?;
        };
        if let Some(v) = self.average_networth_delta {
            os.write_sint32(22, v)?;
        }
        if let Some(v) = self.custom_game_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(37, v, os)?;
        }
        if let Some(v) = self.match_flags {
            os.write_uint32(38, v)?;
        }
        for v in &self.team_scores {
            os.write_uint32(39, *v)?;
        };
        if let Some(v) = self.pre_game_duration {
            os.write_uint32(40, v)?;
        }
        for v in &self.event_game_leaderboard_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(42, v, os)?;
        };
        for v in &self.ward_placements {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(43, v, os)?;
        };
        if let Some(v) = self.gameplay_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(44, v, os)?;
        }
        for v in &self.extra_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(54, v, os)?;
        };
        if let Some(v) = self.training_data_recorded {
            os.write_bool(55, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_enum(56, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.normalized_win_probability_diff {
            os.write_float(57, v)?;
        }
        for v in &self.match_tracked_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(58, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOut {
        CMsgGameMatchSignOut::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.good_guys_win = ::std::option::Option::None;
        self.date = ::std::option::Option::None;
        self.teams.clear();
        self.tower_status.clear();
        self.barracks_status.clear();
        self.cluster = ::std::option::Option::None;
        self.server_addr = ::std::option::Option::None;
        self.first_blood_time = ::std::option::Option::None;
        self.event_score = ::std::option::Option::None;
        self.fantasy_stats.clear();
        self.player_strange_count_adjustments.clear();
        self.automatic_surrender = ::std::option::Option::None;
        self.server_version = ::std::option::Option::None;
        self.poor_network_conditions.clear();
        self.additional_msgs.clear();
        self.social_feed_events.clear();
        self.average_networth_delta = ::std::option::Option::None;
        self.custom_game_data.clear();
        self.match_flags = ::std::option::Option::None;
        self.team_scores.clear();
        self.pre_game_duration = ::std::option::Option::None;
        self.event_game_leaderboard_entries.clear();
        self.ward_placements.clear();
        self.gameplay_stats.clear();
        self.extra_messages.clear();
        self.training_data_recorded = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.normalized_win_probability_diff = ::std::option::Option::None;
        self.match_tracked_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOut {
        static instance: CMsgGameMatchSignOut = CMsgGameMatchSignOut {
            match_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            good_guys_win: ::std::option::Option::None,
            date: ::std::option::Option::None,
            teams: ::std::vec::Vec::new(),
            tower_status: ::std::vec::Vec::new(),
            barracks_status: ::std::vec::Vec::new(),
            cluster: ::std::option::Option::None,
            server_addr: ::std::option::Option::None,
            first_blood_time: ::std::option::Option::None,
            event_score: ::std::option::Option::None,
            fantasy_stats: ::std::vec::Vec::new(),
            player_strange_count_adjustments: ::std::vec::Vec::new(),
            automatic_surrender: ::std::option::Option::None,
            server_version: ::std::option::Option::None,
            poor_network_conditions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            additional_msgs: ::std::vec::Vec::new(),
            social_feed_events: ::std::vec::Vec::new(),
            average_networth_delta: ::std::option::Option::None,
            custom_game_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            match_flags: ::std::option::Option::None,
            team_scores: ::std::vec::Vec::new(),
            pre_game_duration: ::std::option::Option::None,
            event_game_leaderboard_entries: ::std::vec::Vec::new(),
            ward_placements: ::std::vec::Vec::new(),
            gameplay_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            extra_messages: ::std::vec::Vec::new(),
            training_data_recorded: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            normalized_win_probability_diff: ::std::option::Option::None,
            match_tracked_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameMatchSignOut`
pub mod cmsg_game_match_sign_out {
    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CTeam)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CTeam {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.players)
        pub players: ::std::vec::Vec<cteam::CPlayer>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.team_tracked_stats)
        pub team_tracked_stats: ::std::vec::Vec<super::super::dota_gcmessages_common::CMsgTrackedStat>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CTeam.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CTeam {
        fn default() -> &'a CTeam {
            <CTeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CTeam {
        pub fn new() -> CTeam {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CTeam {
        const NAME: &'static str = "CTeam";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.players.push(is.read_message()?);
                    },
                    18 => {
                        self.team_tracked_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.team_tracked_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            for v in &self.team_tracked_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CTeam {
            CTeam::new()
        }

        fn clear(&mut self) {
            self.players.clear();
            self.team_tracked_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CTeam {
            static instance: CTeam = CTeam {
                players: ::std::vec::Vec::new(),
                team_tracked_stats: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `CTeam`
    pub mod cteam {
        // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CTeam.CPlayer)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct CPlayer {
            // message fields
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.steam_id)
            pub steam_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_id)
            pub hero_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.items)
            pub items: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.item_purchase_times)
            pub item_purchase_times: ::std::vec::Vec<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.gold)
            pub gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.leaver_status)
            pub leaver_status: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.last_hits)
            pub last_hits: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.denies)
            pub denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.gold_per_min)
            pub gold_per_min: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.xp_per_minute)
            pub xp_per_minute: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.gold_spent)
            pub gold_spent: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.scaled_hero_damage)
            pub scaled_hero_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.scaled_tower_damage)
            pub scaled_tower_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.scaled_hero_healing)
            pub scaled_hero_healing: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.time_last_seen)
            pub time_last_seen: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.support_ability_value)
            pub support_ability_value: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.party_id)
            pub party_id: ::std::option::Option<u64>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.claimed_farm_gold)
            pub claimed_farm_gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.support_gold)
            pub support_gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.claimed_denies)
            pub claimed_denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.claimed_misses)
            pub claimed_misses: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.misses)
            pub misses: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.net_worth)
            pub net_worth: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage)
            pub hero_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.tower_damage)
            pub tower_damage: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_healing)
            pub hero_healing: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.ability_upgrades)
            pub ability_upgrades: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchPlayerAbilityUpgrade>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.additional_units_inventory)
            pub additional_units_inventory: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchAdditionalUnitInventory>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.permanent_buffs)
            pub permanent_buffs: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMatchPlayerPermanentBuff>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.custom_game_data)
            pub custom_game_data: ::steam_vent_proto_common::protobuf::MessageField<cplayer::CCustomGameData>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.match_player_flags)
            pub match_player_flags: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.talent_ability_ids)
            pub talent_ability_ids: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_pick_order)
            pub hero_pick_order: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_was_randomed)
            pub hero_was_randomed: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_was_dota_plus_suggestion)
            pub hero_was_dota_plus_suggestion: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.lane)
            pub lane: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.is_using_plus_guide)
            pub is_using_plus_guide: ::std::option::Option<bool>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage_received)
            pub hero_damage_received: ::std::vec::Vec<cplayer::HeroDamageReceived>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.hero_damage_dealt)
            pub hero_damage_dealt: ::std::vec::Vec<cplayer::HeroDamageReceived>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.seconds_dead)
            pub seconds_dead: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.gold_lost_to_death)
            pub gold_lost_to_death: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.command_count)
            pub command_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.mouse_click_cast_command_count)
            pub mouse_click_cast_command_count: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.teleports_used)
            pub teleports_used: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.cavern_crawl_preferred_map_variant)
            pub cavern_crawl_preferred_map_variant: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.bounty_runes)
            pub bounty_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.outposts_captured)
            pub outposts_captured: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.dewards)
            pub dewards: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.wards_placed)
            pub wards_placed: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.camps_stacked)
            pub camps_stacked: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.predicted_position)
            pub predicted_position: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.lane_outcomes)
            pub lane_outcomes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.friendly_t1_destroyed_time)
            pub friendly_t1_destroyed_time: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.enemy_t1_destroyed_time)
            pub enemy_t1_destroyed_time: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.friendly_roshan_kills)
            pub friendly_roshan_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.enemy_roshan_kills)
            pub enemy_roshan_kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.power_runes)
            pub power_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.water_runes)
            pub water_runes: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.stun_duration)
            pub stun_duration: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.team_number)
            pub team_number: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::super::dota_shared_enums::DOTA_GC_TEAM>>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.team_slot)
            pub team_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.time_purchased_shard)
            pub time_purchased_shard: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.time_purchased_aghs)
            pub time_purchased_aghs: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.ability_draft_abilities)
            pub ability_draft_abilities: ::std::vec::Vec<i32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.player_tracked_stats)
            pub player_tracked_stats: ::std::vec::Vec<super::super::super::dota_gcmessages_common::CMsgTrackedStat>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.predicted_rank)
            pub predicted_rank: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.selected_facet)
            pub selected_facet: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CTeam.CPlayer.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a CPlayer {
            fn default() -> &'a CPlayer {
                <CPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl CPlayer {
            pub fn new() -> CPlayer {
                ::std::default::Default::default()
            }

            // optional fixed64 steam_id = 1;

            pub fn steam_id(&self) -> u64 {
                self.steam_id.unwrap_or(0)
            }

            pub fn clear_steam_id(&mut self) {
                self.steam_id = ::std::option::Option::None;
            }

            pub fn has_steam_id(&self) -> bool {
                self.steam_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_steam_id(&mut self, v: u64) {
                self.steam_id = ::std::option::Option::Some(v);
            }

            // optional int32 hero_id = 3;

            pub fn hero_id(&self) -> i32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: i32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 gold = 5;

            pub fn gold(&self) -> u32 {
                self.gold.unwrap_or(0)
            }

            pub fn clear_gold(&mut self) {
                self.gold = ::std::option::Option::None;
            }

            pub fn has_gold(&self) -> bool {
                self.gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold(&mut self, v: u32) {
                self.gold = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 6;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 7;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 8;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 leaver_status = 9;

            pub fn leaver_status(&self) -> u32 {
                self.leaver_status.unwrap_or(0)
            }

            pub fn clear_leaver_status(&mut self) {
                self.leaver_status = ::std::option::Option::None;
            }

            pub fn has_leaver_status(&self) -> bool {
                self.leaver_status.is_some()
            }

            // Param is passed by value, moved
            pub fn set_leaver_status(&mut self, v: u32) {
                self.leaver_status = ::std::option::Option::Some(v);
            }

            // optional uint32 last_hits = 10;

            pub fn last_hits(&self) -> u32 {
                self.last_hits.unwrap_or(0)
            }

            pub fn clear_last_hits(&mut self) {
                self.last_hits = ::std::option::Option::None;
            }

            pub fn has_last_hits(&self) -> bool {
                self.last_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_last_hits(&mut self, v: u32) {
                self.last_hits = ::std::option::Option::Some(v);
            }

            // optional uint32 denies = 11;

            pub fn denies(&self) -> u32 {
                self.denies.unwrap_or(0)
            }

            pub fn clear_denies(&mut self) {
                self.denies = ::std::option::Option::None;
            }

            pub fn has_denies(&self) -> bool {
                self.denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_denies(&mut self, v: u32) {
                self.denies = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_per_min = 12;

            pub fn gold_per_min(&self) -> u32 {
                self.gold_per_min.unwrap_or(0)
            }

            pub fn clear_gold_per_min(&mut self) {
                self.gold_per_min = ::std::option::Option::None;
            }

            pub fn has_gold_per_min(&self) -> bool {
                self.gold_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_per_min(&mut self, v: u32) {
                self.gold_per_min = ::std::option::Option::Some(v);
            }

            // optional uint32 xp_per_minute = 13;

            pub fn xp_per_minute(&self) -> u32 {
                self.xp_per_minute.unwrap_or(0)
            }

            pub fn clear_xp_per_minute(&mut self) {
                self.xp_per_minute = ::std::option::Option::None;
            }

            pub fn has_xp_per_minute(&self) -> bool {
                self.xp_per_minute.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xp_per_minute(&mut self, v: u32) {
                self.xp_per_minute = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_spent = 14;

            pub fn gold_spent(&self) -> u32 {
                self.gold_spent.unwrap_or(0)
            }

            pub fn clear_gold_spent(&mut self) {
                self.gold_spent = ::std::option::Option::None;
            }

            pub fn has_gold_spent(&self) -> bool {
                self.gold_spent.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_spent(&mut self, v: u32) {
                self.gold_spent = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 15;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_hero_damage = 16;

            pub fn scaled_hero_damage(&self) -> u32 {
                self.scaled_hero_damage.unwrap_or(0)
            }

            pub fn clear_scaled_hero_damage(&mut self) {
                self.scaled_hero_damage = ::std::option::Option::None;
            }

            pub fn has_scaled_hero_damage(&self) -> bool {
                self.scaled_hero_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_hero_damage(&mut self, v: u32) {
                self.scaled_hero_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_tower_damage = 17;

            pub fn scaled_tower_damage(&self) -> u32 {
                self.scaled_tower_damage.unwrap_or(0)
            }

            pub fn clear_scaled_tower_damage(&mut self) {
                self.scaled_tower_damage = ::std::option::Option::None;
            }

            pub fn has_scaled_tower_damage(&self) -> bool {
                self.scaled_tower_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_tower_damage(&mut self, v: u32) {
                self.scaled_tower_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 scaled_hero_healing = 18;

            pub fn scaled_hero_healing(&self) -> u32 {
                self.scaled_hero_healing.unwrap_or(0)
            }

            pub fn clear_scaled_hero_healing(&mut self) {
                self.scaled_hero_healing = ::std::option::Option::None;
            }

            pub fn has_scaled_hero_healing(&self) -> bool {
                self.scaled_hero_healing.is_some()
            }

            // Param is passed by value, moved
            pub fn set_scaled_hero_healing(&mut self, v: u32) {
                self.scaled_hero_healing = ::std::option::Option::Some(v);
            }

            // optional uint32 time_last_seen = 19;

            pub fn time_last_seen(&self) -> u32 {
                self.time_last_seen.unwrap_or(0)
            }

            pub fn clear_time_last_seen(&mut self) {
                self.time_last_seen = ::std::option::Option::None;
            }

            pub fn has_time_last_seen(&self) -> bool {
                self.time_last_seen.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_last_seen(&mut self, v: u32) {
                self.time_last_seen = ::std::option::Option::Some(v);
            }

            // optional uint32 support_ability_value = 20;

            pub fn support_ability_value(&self) -> u32 {
                self.support_ability_value.unwrap_or(0)
            }

            pub fn clear_support_ability_value(&mut self) {
                self.support_ability_value = ::std::option::Option::None;
            }

            pub fn has_support_ability_value(&self) -> bool {
                self.support_ability_value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_ability_value(&mut self, v: u32) {
                self.support_ability_value = ::std::option::Option::Some(v);
            }

            // optional uint64 party_id = 21;

            pub fn party_id(&self) -> u64 {
                self.party_id.unwrap_or(0)
            }

            pub fn clear_party_id(&mut self) {
                self.party_id = ::std::option::Option::None;
            }

            pub fn has_party_id(&self) -> bool {
                self.party_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_party_id(&mut self, v: u64) {
                self.party_id = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_farm_gold = 27;

            pub fn claimed_farm_gold(&self) -> u32 {
                self.claimed_farm_gold.unwrap_or(0)
            }

            pub fn clear_claimed_farm_gold(&mut self) {
                self.claimed_farm_gold = ::std::option::Option::None;
            }

            pub fn has_claimed_farm_gold(&self) -> bool {
                self.claimed_farm_gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_farm_gold(&mut self, v: u32) {
                self.claimed_farm_gold = ::std::option::Option::Some(v);
            }

            // optional uint32 support_gold = 28;

            pub fn support_gold(&self) -> u32 {
                self.support_gold.unwrap_or(0)
            }

            pub fn clear_support_gold(&mut self) {
                self.support_gold = ::std::option::Option::None;
            }

            pub fn has_support_gold(&self) -> bool {
                self.support_gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_support_gold(&mut self, v: u32) {
                self.support_gold = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_denies = 29;

            pub fn claimed_denies(&self) -> u32 {
                self.claimed_denies.unwrap_or(0)
            }

            pub fn clear_claimed_denies(&mut self) {
                self.claimed_denies = ::std::option::Option::None;
            }

            pub fn has_claimed_denies(&self) -> bool {
                self.claimed_denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_denies(&mut self, v: u32) {
                self.claimed_denies = ::std::option::Option::Some(v);
            }

            // optional uint32 claimed_misses = 30;

            pub fn claimed_misses(&self) -> u32 {
                self.claimed_misses.unwrap_or(0)
            }

            pub fn clear_claimed_misses(&mut self) {
                self.claimed_misses = ::std::option::Option::None;
            }

            pub fn has_claimed_misses(&self) -> bool {
                self.claimed_misses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_claimed_misses(&mut self, v: u32) {
                self.claimed_misses = ::std::option::Option::Some(v);
            }

            // optional uint32 misses = 31;

            pub fn misses(&self) -> u32 {
                self.misses.unwrap_or(0)
            }

            pub fn clear_misses(&mut self) {
                self.misses = ::std::option::Option::None;
            }

            pub fn has_misses(&self) -> bool {
                self.misses.is_some()
            }

            // Param is passed by value, moved
            pub fn set_misses(&mut self, v: u32) {
                self.misses = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth = 34;

            pub fn net_worth(&self) -> u32 {
                self.net_worth.unwrap_or(0)
            }

            pub fn clear_net_worth(&mut self) {
                self.net_worth = ::std::option::Option::None;
            }

            pub fn has_net_worth(&self) -> bool {
                self.net_worth.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth(&mut self, v: u32) {
                self.net_worth = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_damage = 37;

            pub fn hero_damage(&self) -> u32 {
                self.hero_damage.unwrap_or(0)
            }

            pub fn clear_hero_damage(&mut self) {
                self.hero_damage = ::std::option::Option::None;
            }

            pub fn has_hero_damage(&self) -> bool {
                self.hero_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_damage(&mut self, v: u32) {
                self.hero_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 tower_damage = 38;

            pub fn tower_damage(&self) -> u32 {
                self.tower_damage.unwrap_or(0)
            }

            pub fn clear_tower_damage(&mut self) {
                self.tower_damage = ::std::option::Option::None;
            }

            pub fn has_tower_damage(&self) -> bool {
                self.tower_damage.is_some()
            }

            // Param is passed by value, moved
            pub fn set_tower_damage(&mut self, v: u32) {
                self.tower_damage = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_healing = 39;

            pub fn hero_healing(&self) -> u32 {
                self.hero_healing.unwrap_or(0)
            }

            pub fn clear_hero_healing(&mut self) {
                self.hero_healing = ::std::option::Option::None;
            }

            pub fn has_hero_healing(&self) -> bool {
                self.hero_healing.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_healing(&mut self, v: u32) {
                self.hero_healing = ::std::option::Option::Some(v);
            }

            // optional uint32 match_player_flags = 36;

            pub fn match_player_flags(&self) -> u32 {
                self.match_player_flags.unwrap_or(0)
            }

            pub fn clear_match_player_flags(&mut self) {
                self.match_player_flags = ::std::option::Option::None;
            }

            pub fn has_match_player_flags(&self) -> bool {
                self.match_player_flags.is_some()
            }

            // Param is passed by value, moved
            pub fn set_match_player_flags(&mut self, v: u32) {
                self.match_player_flags = ::std::option::Option::Some(v);
            }

            // optional uint32 hero_pick_order = 42;

            pub fn hero_pick_order(&self) -> u32 {
                self.hero_pick_order.unwrap_or(0)
            }

            pub fn clear_hero_pick_order(&mut self) {
                self.hero_pick_order = ::std::option::Option::None;
            }

            pub fn has_hero_pick_order(&self) -> bool {
                self.hero_pick_order.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_pick_order(&mut self, v: u32) {
                self.hero_pick_order = ::std::option::Option::Some(v);
            }

            // optional bool hero_was_randomed = 43;

            pub fn hero_was_randomed(&self) -> bool {
                self.hero_was_randomed.unwrap_or(false)
            }

            pub fn clear_hero_was_randomed(&mut self) {
                self.hero_was_randomed = ::std::option::Option::None;
            }

            pub fn has_hero_was_randomed(&self) -> bool {
                self.hero_was_randomed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_was_randomed(&mut self, v: bool) {
                self.hero_was_randomed = ::std::option::Option::Some(v);
            }

            // optional bool hero_was_dota_plus_suggestion = 50;

            pub fn hero_was_dota_plus_suggestion(&self) -> bool {
                self.hero_was_dota_plus_suggestion.unwrap_or(false)
            }

            pub fn clear_hero_was_dota_plus_suggestion(&mut self) {
                self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
            }

            pub fn has_hero_was_dota_plus_suggestion(&self) -> bool {
                self.hero_was_dota_plus_suggestion.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_was_dota_plus_suggestion(&mut self, v: bool) {
                self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(v);
            }

            // optional uint32 lane = 45;

            pub fn lane(&self) -> u32 {
                self.lane.unwrap_or(0)
            }

            pub fn clear_lane(&mut self) {
                self.lane = ::std::option::Option::None;
            }

            pub fn has_lane(&self) -> bool {
                self.lane.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane(&mut self, v: u32) {
                self.lane = ::std::option::Option::Some(v);
            }

            // optional bool is_using_plus_guide = 47;

            pub fn is_using_plus_guide(&self) -> bool {
                self.is_using_plus_guide.unwrap_or(false)
            }

            pub fn clear_is_using_plus_guide(&mut self) {
                self.is_using_plus_guide = ::std::option::Option::None;
            }

            pub fn has_is_using_plus_guide(&self) -> bool {
                self.is_using_plus_guide.is_some()
            }

            // Param is passed by value, moved
            pub fn set_is_using_plus_guide(&mut self, v: bool) {
                self.is_using_plus_guide = ::std::option::Option::Some(v);
            }

            // optional uint32 seconds_dead = 51;

            pub fn seconds_dead(&self) -> u32 {
                self.seconds_dead.unwrap_or(0)
            }

            pub fn clear_seconds_dead(&mut self) {
                self.seconds_dead = ::std::option::Option::None;
            }

            pub fn has_seconds_dead(&self) -> bool {
                self.seconds_dead.is_some()
            }

            // Param is passed by value, moved
            pub fn set_seconds_dead(&mut self, v: u32) {
                self.seconds_dead = ::std::option::Option::Some(v);
            }

            // optional uint32 gold_lost_to_death = 52;

            pub fn gold_lost_to_death(&self) -> u32 {
                self.gold_lost_to_death.unwrap_or(0)
            }

            pub fn clear_gold_lost_to_death(&mut self) {
                self.gold_lost_to_death = ::std::option::Option::None;
            }

            pub fn has_gold_lost_to_death(&self) -> bool {
                self.gold_lost_to_death.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_lost_to_death(&mut self, v: u32) {
                self.gold_lost_to_death = ::std::option::Option::Some(v);
            }

            // optional uint32 command_count = 53;

            pub fn command_count(&self) -> u32 {
                self.command_count.unwrap_or(0)
            }

            pub fn clear_command_count(&mut self) {
                self.command_count = ::std::option::Option::None;
            }

            pub fn has_command_count(&self) -> bool {
                self.command_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_command_count(&mut self, v: u32) {
                self.command_count = ::std::option::Option::Some(v);
            }

            // optional uint32 mouse_click_cast_command_count = 54;

            pub fn mouse_click_cast_command_count(&self) -> u32 {
                self.mouse_click_cast_command_count.unwrap_or(0)
            }

            pub fn clear_mouse_click_cast_command_count(&mut self) {
                self.mouse_click_cast_command_count = ::std::option::Option::None;
            }

            pub fn has_mouse_click_cast_command_count(&self) -> bool {
                self.mouse_click_cast_command_count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_mouse_click_cast_command_count(&mut self, v: u32) {
                self.mouse_click_cast_command_count = ::std::option::Option::Some(v);
            }

            // optional uint32 teleports_used = 55;

            pub fn teleports_used(&self) -> u32 {
                self.teleports_used.unwrap_or(0)
            }

            pub fn clear_teleports_used(&mut self) {
                self.teleports_used = ::std::option::Option::None;
            }

            pub fn has_teleports_used(&self) -> bool {
                self.teleports_used.is_some()
            }

            // Param is passed by value, moved
            pub fn set_teleports_used(&mut self, v: u32) {
                self.teleports_used = ::std::option::Option::Some(v);
            }

            // optional uint32 cavern_crawl_preferred_map_variant = 56;

            pub fn cavern_crawl_preferred_map_variant(&self) -> u32 {
                self.cavern_crawl_preferred_map_variant.unwrap_or(255u32)
            }

            pub fn clear_cavern_crawl_preferred_map_variant(&mut self) {
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::None;
            }

            pub fn has_cavern_crawl_preferred_map_variant(&self) -> bool {
                self.cavern_crawl_preferred_map_variant.is_some()
            }

            // Param is passed by value, moved
            pub fn set_cavern_crawl_preferred_map_variant(&mut self, v: u32) {
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::Some(v);
            }

            // optional uint32 bounty_runes = 57;

            pub fn bounty_runes(&self) -> u32 {
                self.bounty_runes.unwrap_or(0)
            }

            pub fn clear_bounty_runes(&mut self) {
                self.bounty_runes = ::std::option::Option::None;
            }

            pub fn has_bounty_runes(&self) -> bool {
                self.bounty_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_bounty_runes(&mut self, v: u32) {
                self.bounty_runes = ::std::option::Option::Some(v);
            }

            // optional uint32 outposts_captured = 58;

            pub fn outposts_captured(&self) -> u32 {
                self.outposts_captured.unwrap_or(0)
            }

            pub fn clear_outposts_captured(&mut self) {
                self.outposts_captured = ::std::option::Option::None;
            }

            pub fn has_outposts_captured(&self) -> bool {
                self.outposts_captured.is_some()
            }

            // Param is passed by value, moved
            pub fn set_outposts_captured(&mut self, v: u32) {
                self.outposts_captured = ::std::option::Option::Some(v);
            }

            // optional uint32 dewards = 59;

            pub fn dewards(&self) -> u32 {
                self.dewards.unwrap_or(0)
            }

            pub fn clear_dewards(&mut self) {
                self.dewards = ::std::option::Option::None;
            }

            pub fn has_dewards(&self) -> bool {
                self.dewards.is_some()
            }

            // Param is passed by value, moved
            pub fn set_dewards(&mut self, v: u32) {
                self.dewards = ::std::option::Option::Some(v);
            }

            // optional uint32 wards_placed = 60;

            pub fn wards_placed(&self) -> u32 {
                self.wards_placed.unwrap_or(0)
            }

            pub fn clear_wards_placed(&mut self) {
                self.wards_placed = ::std::option::Option::None;
            }

            pub fn has_wards_placed(&self) -> bool {
                self.wards_placed.is_some()
            }

            // Param is passed by value, moved
            pub fn set_wards_placed(&mut self, v: u32) {
                self.wards_placed = ::std::option::Option::Some(v);
            }

            // optional uint32 camps_stacked = 61;

            pub fn camps_stacked(&self) -> u32 {
                self.camps_stacked.unwrap_or(0)
            }

            pub fn clear_camps_stacked(&mut self) {
                self.camps_stacked = ::std::option::Option::None;
            }

            pub fn has_camps_stacked(&self) -> bool {
                self.camps_stacked.is_some()
            }

            // Param is passed by value, moved
            pub fn set_camps_stacked(&mut self, v: u32) {
                self.camps_stacked = ::std::option::Option::Some(v);
            }

            // optional uint32 player_slot = 62;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 predicted_position = 66;

            pub fn predicted_position(&self) -> u32 {
                self.predicted_position.unwrap_or(0)
            }

            pub fn clear_predicted_position(&mut self) {
                self.predicted_position = ::std::option::Option::None;
            }

            pub fn has_predicted_position(&self) -> bool {
                self.predicted_position.is_some()
            }

            // Param is passed by value, moved
            pub fn set_predicted_position(&mut self, v: u32) {
                self.predicted_position = ::std::option::Option::Some(v);
            }

            // optional uint32 lane_outcomes = 67;

            pub fn lane_outcomes(&self) -> u32 {
                self.lane_outcomes.unwrap_or(255u32)
            }

            pub fn clear_lane_outcomes(&mut self) {
                self.lane_outcomes = ::std::option::Option::None;
            }

            pub fn has_lane_outcomes(&self) -> bool {
                self.lane_outcomes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_lane_outcomes(&mut self, v: u32) {
                self.lane_outcomes = ::std::option::Option::Some(v);
            }

            // optional uint32 friendly_t1_destroyed_time = 68;

            pub fn friendly_t1_destroyed_time(&self) -> u32 {
                self.friendly_t1_destroyed_time.unwrap_or(0)
            }

            pub fn clear_friendly_t1_destroyed_time(&mut self) {
                self.friendly_t1_destroyed_time = ::std::option::Option::None;
            }

            pub fn has_friendly_t1_destroyed_time(&self) -> bool {
                self.friendly_t1_destroyed_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_t1_destroyed_time(&mut self, v: u32) {
                self.friendly_t1_destroyed_time = ::std::option::Option::Some(v);
            }

            // optional uint32 enemy_t1_destroyed_time = 69;

            pub fn enemy_t1_destroyed_time(&self) -> u32 {
                self.enemy_t1_destroyed_time.unwrap_or(0)
            }

            pub fn clear_enemy_t1_destroyed_time(&mut self) {
                self.enemy_t1_destroyed_time = ::std::option::Option::None;
            }

            pub fn has_enemy_t1_destroyed_time(&self) -> bool {
                self.enemy_t1_destroyed_time.is_some()
            }

            // Param is passed by value, moved
            pub fn set_enemy_t1_destroyed_time(&mut self, v: u32) {
                self.enemy_t1_destroyed_time = ::std::option::Option::Some(v);
            }

            // optional uint32 friendly_roshan_kills = 70;

            pub fn friendly_roshan_kills(&self) -> u32 {
                self.friendly_roshan_kills.unwrap_or(0)
            }

            pub fn clear_friendly_roshan_kills(&mut self) {
                self.friendly_roshan_kills = ::std::option::Option::None;
            }

            pub fn has_friendly_roshan_kills(&self) -> bool {
                self.friendly_roshan_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_friendly_roshan_kills(&mut self, v: u32) {
                self.friendly_roshan_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 enemy_roshan_kills = 71;

            pub fn enemy_roshan_kills(&self) -> u32 {
                self.enemy_roshan_kills.unwrap_or(0)
            }

            pub fn clear_enemy_roshan_kills(&mut self) {
                self.enemy_roshan_kills = ::std::option::Option::None;
            }

            pub fn has_enemy_roshan_kills(&self) -> bool {
                self.enemy_roshan_kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_enemy_roshan_kills(&mut self, v: u32) {
                self.enemy_roshan_kills = ::std::option::Option::Some(v);
            }

            // optional uint32 power_runes = 72;

            pub fn power_runes(&self) -> u32 {
                self.power_runes.unwrap_or(0)
            }

            pub fn clear_power_runes(&mut self) {
                self.power_runes = ::std::option::Option::None;
            }

            pub fn has_power_runes(&self) -> bool {
                self.power_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_power_runes(&mut self, v: u32) {
                self.power_runes = ::std::option::Option::Some(v);
            }

            // optional uint32 water_runes = 73;

            pub fn water_runes(&self) -> u32 {
                self.water_runes.unwrap_or(0)
            }

            pub fn clear_water_runes(&mut self) {
                self.water_runes = ::std::option::Option::None;
            }

            pub fn has_water_runes(&self) -> bool {
                self.water_runes.is_some()
            }

            // Param is passed by value, moved
            pub fn set_water_runes(&mut self, v: u32) {
                self.water_runes = ::std::option::Option::Some(v);
            }

            // optional float stun_duration = 74;

            pub fn stun_duration(&self) -> f32 {
                self.stun_duration.unwrap_or(0.)
            }

            pub fn clear_stun_duration(&mut self) {
                self.stun_duration = ::std::option::Option::None;
            }

            pub fn has_stun_duration(&self) -> bool {
                self.stun_duration.is_some()
            }

            // Param is passed by value, moved
            pub fn set_stun_duration(&mut self, v: f32) {
                self.stun_duration = ::std::option::Option::Some(v);
            }

            // optional .DOTA_GC_TEAM team_number = 75;

            pub fn team_number(&self) -> super::super::super::dota_shared_enums::DOTA_GC_TEAM {
                match self.team_number {
                    Some(e) => e.enum_value_or(super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
                    None => super::super::super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
                }
            }

            pub fn clear_team_number(&mut self) {
                self.team_number = ::std::option::Option::None;
            }

            pub fn has_team_number(&self) -> bool {
                self.team_number.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_number(&mut self, v: super::super::super::dota_shared_enums::DOTA_GC_TEAM) {
                self.team_number = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional uint32 team_slot = 76;

            pub fn team_slot(&self) -> u32 {
                self.team_slot.unwrap_or(0)
            }

            pub fn clear_team_slot(&mut self) {
                self.team_slot = ::std::option::Option::None;
            }

            pub fn has_team_slot(&self) -> bool {
                self.team_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_team_slot(&mut self, v: u32) {
                self.team_slot = ::std::option::Option::Some(v);
            }

            // optional uint32 time_purchased_shard = 77;

            pub fn time_purchased_shard(&self) -> u32 {
                self.time_purchased_shard.unwrap_or(0)
            }

            pub fn clear_time_purchased_shard(&mut self) {
                self.time_purchased_shard = ::std::option::Option::None;
            }

            pub fn has_time_purchased_shard(&self) -> bool {
                self.time_purchased_shard.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_purchased_shard(&mut self, v: u32) {
                self.time_purchased_shard = ::std::option::Option::Some(v);
            }

            // optional uint32 time_purchased_aghs = 78;

            pub fn time_purchased_aghs(&self) -> u32 {
                self.time_purchased_aghs.unwrap_or(0)
            }

            pub fn clear_time_purchased_aghs(&mut self) {
                self.time_purchased_aghs = ::std::option::Option::None;
            }

            pub fn has_time_purchased_aghs(&self) -> bool {
                self.time_purchased_aghs.is_some()
            }

            // Param is passed by value, moved
            pub fn set_time_purchased_aghs(&mut self, v: u32) {
                self.time_purchased_aghs = ::std::option::Option::Some(v);
            }

            // optional uint32 predicted_rank = 81;

            pub fn predicted_rank(&self) -> u32 {
                self.predicted_rank.unwrap_or(0)
            }

            pub fn clear_predicted_rank(&mut self) {
                self.predicted_rank = ::std::option::Option::None;
            }

            pub fn has_predicted_rank(&self) -> bool {
                self.predicted_rank.is_some()
            }

            // Param is passed by value, moved
            pub fn set_predicted_rank(&mut self, v: u32) {
                self.predicted_rank = ::std::option::Option::Some(v);
            }

            // optional uint32 selected_facet = 82;

            pub fn selected_facet(&self) -> u32 {
                self.selected_facet.unwrap_or(0)
            }

            pub fn clear_selected_facet(&mut self) {
                self.selected_facet = ::std::option::Option::None;
            }

            pub fn has_selected_facet(&self) -> bool {
                self.selected_facet.is_some()
            }

            // Param is passed by value, moved
            pub fn set_selected_facet(&mut self, v: u32) {
                self.selected_facet = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for CPlayer {
            const NAME: &'static str = "CPlayer";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        9 => {
                            self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                        },
                        24 => {
                            self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        34 => {
                            is.read_repeated_packed_int32_into(&mut self.items)?;
                        },
                        32 => {
                            self.items.push(is.read_int32()?);
                        },
                        506 => {
                            is.read_repeated_packed_uint32_into(&mut self.item_purchase_times)?;
                        },
                        504 => {
                            self.item_purchase_times.push(is.read_uint32()?);
                        },
                        40 => {
                            self.gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.leaver_status = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        96 => {
                            self.gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        104 => {
                            self.xp_per_minute = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        112 => {
                            self.gold_spent = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        120 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        128 => {
                            self.scaled_hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        136 => {
                            self.scaled_tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        144 => {
                            self.scaled_hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        152 => {
                            self.time_last_seen = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        160 => {
                            self.support_ability_value = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        168 => {
                            self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                        },
                        216 => {
                            self.claimed_farm_gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        224 => {
                            self.support_gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        232 => {
                            self.claimed_denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        240 => {
                            self.claimed_misses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        248 => {
                            self.misses = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        272 => {
                            self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        296 => {
                            self.hero_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        304 => {
                            self.tower_damage = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        312 => {
                            self.hero_healing = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        258 => {
                            self.ability_upgrades.push(is.read_message()?);
                        },
                        266 => {
                            self.additional_units_inventory.push(is.read_message()?);
                        },
                        322 => {
                            self.permanent_buffs.push(is.read_message()?);
                        },
                        282 => {
                            ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_data)?;
                        },
                        288 => {
                            self.match_player_flags = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        330 => {
                            is.read_repeated_packed_int32_into(&mut self.talent_ability_ids)?;
                        },
                        328 => {
                            self.talent_ability_ids.push(is.read_int32()?);
                        },
                        336 => {
                            self.hero_pick_order = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        344 => {
                            self.hero_was_randomed = ::std::option::Option::Some(is.read_bool()?);
                        },
                        400 => {
                            self.hero_was_dota_plus_suggestion = ::std::option::Option::Some(is.read_bool()?);
                        },
                        360 => {
                            self.lane = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        376 => {
                            self.is_using_plus_guide = ::std::option::Option::Some(is.read_bool()?);
                        },
                        386 => {
                            self.hero_damage_received.push(is.read_message()?);
                        },
                        514 => {
                            self.hero_damage_dealt.push(is.read_message()?);
                        },
                        408 => {
                            self.seconds_dead = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        416 => {
                            self.gold_lost_to_death = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        424 => {
                            self.command_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        432 => {
                            self.mouse_click_cast_command_count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        440 => {
                            self.teleports_used = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        448 => {
                            self.cavern_crawl_preferred_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        456 => {
                            self.bounty_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        464 => {
                            self.outposts_captured = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        472 => {
                            self.dewards = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        480 => {
                            self.wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        488 => {
                            self.camps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        496 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        528 => {
                            self.predicted_position = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        536 => {
                            self.lane_outcomes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        544 => {
                            self.friendly_t1_destroyed_time = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        552 => {
                            self.enemy_t1_destroyed_time = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        560 => {
                            self.friendly_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        568 => {
                            self.enemy_roshan_kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        576 => {
                            self.power_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        584 => {
                            self.water_runes = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        597 => {
                            self.stun_duration = ::std::option::Option::Some(is.read_float()?);
                        },
                        600 => {
                            self.team_number = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        608 => {
                            self.team_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        616 => {
                            self.time_purchased_shard = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        624 => {
                            self.time_purchased_aghs = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        634 => {
                            is.read_repeated_packed_int32_into(&mut self.ability_draft_abilities)?;
                        },
                        632 => {
                            self.ability_draft_abilities.push(is.read_int32()?);
                        },
                        642 => {
                            self.player_tracked_stats.push(is.read_message()?);
                        },
                        648 => {
                            self.predicted_rank = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        656 => {
                            self.selected_facet = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.steam_id {
                    my_size += 1 + 8;
                }
                if let Some(v) = self.hero_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
                }
                for value in &self.items {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
                };
                for value in &self.item_purchase_times {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(63, *value);
                };
                if let Some(v) = self.gold {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.leaver_status {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.last_hits {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.denies {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.gold_per_min {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
                }
                if let Some(v) = self.xp_per_minute {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
                }
                if let Some(v) = self.gold_spent {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
                }
                if let Some(v) = self.level {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
                }
                if let Some(v) = self.scaled_hero_damage {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
                }
                if let Some(v) = self.scaled_tower_damage {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
                }
                if let Some(v) = self.scaled_hero_healing {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
                }
                if let Some(v) = self.time_last_seen {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
                }
                if let Some(v) = self.support_ability_value {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
                }
                if let Some(v) = self.party_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(21, v);
                }
                if let Some(v) = self.claimed_farm_gold {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
                }
                if let Some(v) = self.support_gold {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
                }
                if let Some(v) = self.claimed_denies {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
                }
                if let Some(v) = self.claimed_misses {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
                }
                if let Some(v) = self.misses {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
                }
                if let Some(v) = self.net_worth {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(34, v);
                }
                if let Some(v) = self.hero_damage {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(37, v);
                }
                if let Some(v) = self.tower_damage {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(38, v);
                }
                if let Some(v) = self.hero_healing {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(39, v);
                }
                for value in &self.ability_upgrades {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.additional_units_inventory {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.permanent_buffs {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.custom_game_data.as_ref() {
                    let len = v.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                }
                if let Some(v) = self.match_player_flags {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(36, v);
                }
                for value in &self.talent_ability_ids {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(41, *value);
                };
                if let Some(v) = self.hero_pick_order {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(42, v);
                }
                if let Some(v) = self.hero_was_randomed {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.hero_was_dota_plus_suggestion {
                    my_size += 2 + 1;
                }
                if let Some(v) = self.lane {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(45, v);
                }
                if let Some(v) = self.is_using_plus_guide {
                    my_size += 2 + 1;
                }
                for value in &self.hero_damage_received {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                for value in &self.hero_damage_dealt {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.seconds_dead {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(51, v);
                }
                if let Some(v) = self.gold_lost_to_death {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(52, v);
                }
                if let Some(v) = self.command_count {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(53, v);
                }
                if let Some(v) = self.mouse_click_cast_command_count {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(54, v);
                }
                if let Some(v) = self.teleports_used {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(55, v);
                }
                if let Some(v) = self.cavern_crawl_preferred_map_variant {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(56, v);
                }
                if let Some(v) = self.bounty_runes {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(57, v);
                }
                if let Some(v) = self.outposts_captured {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(58, v);
                }
                if let Some(v) = self.dewards {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(59, v);
                }
                if let Some(v) = self.wards_placed {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(60, v);
                }
                if let Some(v) = self.camps_stacked {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(61, v);
                }
                if let Some(v) = self.player_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(62, v);
                }
                if let Some(v) = self.predicted_position {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(66, v);
                }
                if let Some(v) = self.lane_outcomes {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(67, v);
                }
                if let Some(v) = self.friendly_t1_destroyed_time {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(68, v);
                }
                if let Some(v) = self.enemy_t1_destroyed_time {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(69, v);
                }
                if let Some(v) = self.friendly_roshan_kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(70, v);
                }
                if let Some(v) = self.enemy_roshan_kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(71, v);
                }
                if let Some(v) = self.power_runes {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(72, v);
                }
                if let Some(v) = self.water_runes {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(73, v);
                }
                if let Some(v) = self.stun_duration {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.team_number {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(75, v.value());
                }
                if let Some(v) = self.team_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(76, v);
                }
                if let Some(v) = self.time_purchased_shard {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(77, v);
                }
                if let Some(v) = self.time_purchased_aghs {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(78, v);
                }
                for value in &self.ability_draft_abilities {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(79, *value);
                };
                for value in &self.player_tracked_stats {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                if let Some(v) = self.predicted_rank {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(81, v);
                }
                if let Some(v) = self.selected_facet {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(82, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.steam_id {
                    os.write_fixed64(1, v)?;
                }
                if let Some(v) = self.hero_id {
                    os.write_int32(3, v)?;
                }
                for v in &self.items {
                    os.write_int32(4, *v)?;
                };
                for v in &self.item_purchase_times {
                    os.write_uint32(63, *v)?;
                };
                if let Some(v) = self.gold {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.leaver_status {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.last_hits {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.denies {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.gold_per_min {
                    os.write_uint32(12, v)?;
                }
                if let Some(v) = self.xp_per_minute {
                    os.write_uint32(13, v)?;
                }
                if let Some(v) = self.gold_spent {
                    os.write_uint32(14, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(15, v)?;
                }
                if let Some(v) = self.scaled_hero_damage {
                    os.write_uint32(16, v)?;
                }
                if let Some(v) = self.scaled_tower_damage {
                    os.write_uint32(17, v)?;
                }
                if let Some(v) = self.scaled_hero_healing {
                    os.write_uint32(18, v)?;
                }
                if let Some(v) = self.time_last_seen {
                    os.write_uint32(19, v)?;
                }
                if let Some(v) = self.support_ability_value {
                    os.write_uint32(20, v)?;
                }
                if let Some(v) = self.party_id {
                    os.write_uint64(21, v)?;
                }
                if let Some(v) = self.claimed_farm_gold {
                    os.write_uint32(27, v)?;
                }
                if let Some(v) = self.support_gold {
                    os.write_uint32(28, v)?;
                }
                if let Some(v) = self.claimed_denies {
                    os.write_uint32(29, v)?;
                }
                if let Some(v) = self.claimed_misses {
                    os.write_uint32(30, v)?;
                }
                if let Some(v) = self.misses {
                    os.write_uint32(31, v)?;
                }
                if let Some(v) = self.net_worth {
                    os.write_uint32(34, v)?;
                }
                if let Some(v) = self.hero_damage {
                    os.write_uint32(37, v)?;
                }
                if let Some(v) = self.tower_damage {
                    os.write_uint32(38, v)?;
                }
                if let Some(v) = self.hero_healing {
                    os.write_uint32(39, v)?;
                }
                for v in &self.ability_upgrades {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(32, v, os)?;
                };
                for v in &self.additional_units_inventory {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(33, v, os)?;
                };
                for v in &self.permanent_buffs {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(40, v, os)?;
                };
                if let Some(v) = self.custom_game_data.as_ref() {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(35, v, os)?;
                }
                if let Some(v) = self.match_player_flags {
                    os.write_uint32(36, v)?;
                }
                for v in &self.talent_ability_ids {
                    os.write_int32(41, *v)?;
                };
                if let Some(v) = self.hero_pick_order {
                    os.write_uint32(42, v)?;
                }
                if let Some(v) = self.hero_was_randomed {
                    os.write_bool(43, v)?;
                }
                if let Some(v) = self.hero_was_dota_plus_suggestion {
                    os.write_bool(50, v)?;
                }
                if let Some(v) = self.lane {
                    os.write_uint32(45, v)?;
                }
                if let Some(v) = self.is_using_plus_guide {
                    os.write_bool(47, v)?;
                }
                for v in &self.hero_damage_received {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(48, v, os)?;
                };
                for v in &self.hero_damage_dealt {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(64, v, os)?;
                };
                if let Some(v) = self.seconds_dead {
                    os.write_uint32(51, v)?;
                }
                if let Some(v) = self.gold_lost_to_death {
                    os.write_uint32(52, v)?;
                }
                if let Some(v) = self.command_count {
                    os.write_uint32(53, v)?;
                }
                if let Some(v) = self.mouse_click_cast_command_count {
                    os.write_uint32(54, v)?;
                }
                if let Some(v) = self.teleports_used {
                    os.write_uint32(55, v)?;
                }
                if let Some(v) = self.cavern_crawl_preferred_map_variant {
                    os.write_uint32(56, v)?;
                }
                if let Some(v) = self.bounty_runes {
                    os.write_uint32(57, v)?;
                }
                if let Some(v) = self.outposts_captured {
                    os.write_uint32(58, v)?;
                }
                if let Some(v) = self.dewards {
                    os.write_uint32(59, v)?;
                }
                if let Some(v) = self.wards_placed {
                    os.write_uint32(60, v)?;
                }
                if let Some(v) = self.camps_stacked {
                    os.write_uint32(61, v)?;
                }
                if let Some(v) = self.player_slot {
                    os.write_uint32(62, v)?;
                }
                if let Some(v) = self.predicted_position {
                    os.write_uint32(66, v)?;
                }
                if let Some(v) = self.lane_outcomes {
                    os.write_uint32(67, v)?;
                }
                if let Some(v) = self.friendly_t1_destroyed_time {
                    os.write_uint32(68, v)?;
                }
                if let Some(v) = self.enemy_t1_destroyed_time {
                    os.write_uint32(69, v)?;
                }
                if let Some(v) = self.friendly_roshan_kills {
                    os.write_uint32(70, v)?;
                }
                if let Some(v) = self.enemy_roshan_kills {
                    os.write_uint32(71, v)?;
                }
                if let Some(v) = self.power_runes {
                    os.write_uint32(72, v)?;
                }
                if let Some(v) = self.water_runes {
                    os.write_uint32(73, v)?;
                }
                if let Some(v) = self.stun_duration {
                    os.write_float(74, v)?;
                }
                if let Some(v) = self.team_number {
                    os.write_enum(75, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.team_slot {
                    os.write_uint32(76, v)?;
                }
                if let Some(v) = self.time_purchased_shard {
                    os.write_uint32(77, v)?;
                }
                if let Some(v) = self.time_purchased_aghs {
                    os.write_uint32(78, v)?;
                }
                for v in &self.ability_draft_abilities {
                    os.write_int32(79, *v)?;
                };
                for v in &self.player_tracked_stats {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(80, v, os)?;
                };
                if let Some(v) = self.predicted_rank {
                    os.write_uint32(81, v)?;
                }
                if let Some(v) = self.selected_facet {
                    os.write_uint32(82, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> CPlayer {
                CPlayer::new()
            }

            fn clear(&mut self) {
                self.steam_id = ::std::option::Option::None;
                self.hero_id = ::std::option::Option::None;
                self.items.clear();
                self.item_purchase_times.clear();
                self.gold = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.leaver_status = ::std::option::Option::None;
                self.last_hits = ::std::option::Option::None;
                self.denies = ::std::option::Option::None;
                self.gold_per_min = ::std::option::Option::None;
                self.xp_per_minute = ::std::option::Option::None;
                self.gold_spent = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.scaled_hero_damage = ::std::option::Option::None;
                self.scaled_tower_damage = ::std::option::Option::None;
                self.scaled_hero_healing = ::std::option::Option::None;
                self.time_last_seen = ::std::option::Option::None;
                self.support_ability_value = ::std::option::Option::None;
                self.party_id = ::std::option::Option::None;
                self.claimed_farm_gold = ::std::option::Option::None;
                self.support_gold = ::std::option::Option::None;
                self.claimed_denies = ::std::option::Option::None;
                self.claimed_misses = ::std::option::Option::None;
                self.misses = ::std::option::Option::None;
                self.net_worth = ::std::option::Option::None;
                self.hero_damage = ::std::option::Option::None;
                self.tower_damage = ::std::option::Option::None;
                self.hero_healing = ::std::option::Option::None;
                self.ability_upgrades.clear();
                self.additional_units_inventory.clear();
                self.permanent_buffs.clear();
                self.custom_game_data.clear();
                self.match_player_flags = ::std::option::Option::None;
                self.talent_ability_ids.clear();
                self.hero_pick_order = ::std::option::Option::None;
                self.hero_was_randomed = ::std::option::Option::None;
                self.hero_was_dota_plus_suggestion = ::std::option::Option::None;
                self.lane = ::std::option::Option::None;
                self.is_using_plus_guide = ::std::option::Option::None;
                self.hero_damage_received.clear();
                self.hero_damage_dealt.clear();
                self.seconds_dead = ::std::option::Option::None;
                self.gold_lost_to_death = ::std::option::Option::None;
                self.command_count = ::std::option::Option::None;
                self.mouse_click_cast_command_count = ::std::option::Option::None;
                self.teleports_used = ::std::option::Option::None;
                self.cavern_crawl_preferred_map_variant = ::std::option::Option::None;
                self.bounty_runes = ::std::option::Option::None;
                self.outposts_captured = ::std::option::Option::None;
                self.dewards = ::std::option::Option::None;
                self.wards_placed = ::std::option::Option::None;
                self.camps_stacked = ::std::option::Option::None;
                self.player_slot = ::std::option::Option::None;
                self.predicted_position = ::std::option::Option::None;
                self.lane_outcomes = ::std::option::Option::None;
                self.friendly_t1_destroyed_time = ::std::option::Option::None;
                self.enemy_t1_destroyed_time = ::std::option::Option::None;
                self.friendly_roshan_kills = ::std::option::Option::None;
                self.enemy_roshan_kills = ::std::option::Option::None;
                self.power_runes = ::std::option::Option::None;
                self.water_runes = ::std::option::Option::None;
                self.stun_duration = ::std::option::Option::None;
                self.team_number = ::std::option::Option::None;
                self.team_slot = ::std::option::Option::None;
                self.time_purchased_shard = ::std::option::Option::None;
                self.time_purchased_aghs = ::std::option::Option::None;
                self.ability_draft_abilities.clear();
                self.player_tracked_stats.clear();
                self.predicted_rank = ::std::option::Option::None;
                self.selected_facet = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static CPlayer {
                static instance: CPlayer = CPlayer {
                    steam_id: ::std::option::Option::None,
                    hero_id: ::std::option::Option::None,
                    items: ::std::vec::Vec::new(),
                    item_purchase_times: ::std::vec::Vec::new(),
                    gold: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    leaver_status: ::std::option::Option::None,
                    last_hits: ::std::option::Option::None,
                    denies: ::std::option::Option::None,
                    gold_per_min: ::std::option::Option::None,
                    xp_per_minute: ::std::option::Option::None,
                    gold_spent: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    scaled_hero_damage: ::std::option::Option::None,
                    scaled_tower_damage: ::std::option::Option::None,
                    scaled_hero_healing: ::std::option::Option::None,
                    time_last_seen: ::std::option::Option::None,
                    support_ability_value: ::std::option::Option::None,
                    party_id: ::std::option::Option::None,
                    claimed_farm_gold: ::std::option::Option::None,
                    support_gold: ::std::option::Option::None,
                    claimed_denies: ::std::option::Option::None,
                    claimed_misses: ::std::option::Option::None,
                    misses: ::std::option::Option::None,
                    net_worth: ::std::option::Option::None,
                    hero_damage: ::std::option::Option::None,
                    tower_damage: ::std::option::Option::None,
                    hero_healing: ::std::option::Option::None,
                    ability_upgrades: ::std::vec::Vec::new(),
                    additional_units_inventory: ::std::vec::Vec::new(),
                    permanent_buffs: ::std::vec::Vec::new(),
                    custom_game_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
                    match_player_flags: ::std::option::Option::None,
                    talent_ability_ids: ::std::vec::Vec::new(),
                    hero_pick_order: ::std::option::Option::None,
                    hero_was_randomed: ::std::option::Option::None,
                    hero_was_dota_plus_suggestion: ::std::option::Option::None,
                    lane: ::std::option::Option::None,
                    is_using_plus_guide: ::std::option::Option::None,
                    hero_damage_received: ::std::vec::Vec::new(),
                    hero_damage_dealt: ::std::vec::Vec::new(),
                    seconds_dead: ::std::option::Option::None,
                    gold_lost_to_death: ::std::option::Option::None,
                    command_count: ::std::option::Option::None,
                    mouse_click_cast_command_count: ::std::option::Option::None,
                    teleports_used: ::std::option::Option::None,
                    cavern_crawl_preferred_map_variant: ::std::option::Option::None,
                    bounty_runes: ::std::option::Option::None,
                    outposts_captured: ::std::option::Option::None,
                    dewards: ::std::option::Option::None,
                    wards_placed: ::std::option::Option::None,
                    camps_stacked: ::std::option::Option::None,
                    player_slot: ::std::option::Option::None,
                    predicted_position: ::std::option::Option::None,
                    lane_outcomes: ::std::option::Option::None,
                    friendly_t1_destroyed_time: ::std::option::Option::None,
                    enemy_t1_destroyed_time: ::std::option::Option::None,
                    friendly_roshan_kills: ::std::option::Option::None,
                    enemy_roshan_kills: ::std::option::Option::None,
                    power_runes: ::std::option::Option::None,
                    water_runes: ::std::option::Option::None,
                    stun_duration: ::std::option::Option::None,
                    team_number: ::std::option::Option::None,
                    team_slot: ::std::option::Option::None,
                    time_purchased_shard: ::std::option::Option::None,
                    time_purchased_aghs: ::std::option::Option::None,
                    ability_draft_abilities: ::std::vec::Vec::new(),
                    player_tracked_stats: ::std::vec::Vec::new(),
                    predicted_rank: ::std::option::Option::None,
                    selected_facet: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `CPlayer`
        pub mod cplayer {
            // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct CCustomGameData {
                // message fields
                // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.dota_team)
                pub dota_team: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.winner)
                pub winner: ::std::option::Option<bool>,
                // special fields
                // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CTeam.CPlayer.CCustomGameData.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a CCustomGameData {
                fn default() -> &'a CCustomGameData {
                    <CCustomGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl CCustomGameData {
                pub fn new() -> CCustomGameData {
                    ::std::default::Default::default()
                }

                // optional uint32 dota_team = 1;

                pub fn dota_team(&self) -> u32 {
                    self.dota_team.unwrap_or(0)
                }

                pub fn clear_dota_team(&mut self) {
                    self.dota_team = ::std::option::Option::None;
                }

                pub fn has_dota_team(&self) -> bool {
                    self.dota_team.is_some()
                }

                // Param is passed by value, moved
                pub fn set_dota_team(&mut self, v: u32) {
                    self.dota_team = ::std::option::Option::Some(v);
                }

                // optional bool winner = 2;

                pub fn winner(&self) -> bool {
                    self.winner.unwrap_or(false)
                }

                pub fn clear_winner(&mut self) {
                    self.winner = ::std::option::Option::None;
                }

                pub fn has_winner(&self) -> bool {
                    self.winner.is_some()
                }

                // Param is passed by value, moved
                pub fn set_winner(&mut self, v: bool) {
                    self.winner = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for CCustomGameData {
                const NAME: &'static str = "CCustomGameData";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.dota_team = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.winner = ::std::option::Option::Some(is.read_bool()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.dota_team {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.winner {
                        my_size += 1 + 1;
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.dota_team {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.winner {
                        os.write_bool(2, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> CCustomGameData {
                    CCustomGameData::new()
                }

                fn clear(&mut self) {
                    self.dota_team = ::std::option::Option::None;
                    self.winner = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static CCustomGameData {
                    static instance: CCustomGameData = CCustomGameData {
                        dota_team: ::std::option::Option::None,
                        winner: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct HeroDamageReceived {
                // message fields
                // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.pre_reduction)
                pub pre_reduction: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.post_reduction)
                pub post_reduction: ::std::option::Option<u32>,
                // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.damage_type)
                pub damage_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<HeroDamageType>>,
                // special fields
                // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageReceived.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HeroDamageReceived {
                fn default() -> &'a HeroDamageReceived {
                    <HeroDamageReceived as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl HeroDamageReceived {
                pub fn new() -> HeroDamageReceived {
                    ::std::default::Default::default()
                }

                // optional uint32 pre_reduction = 1;

                pub fn pre_reduction(&self) -> u32 {
                    self.pre_reduction.unwrap_or(0)
                }

                pub fn clear_pre_reduction(&mut self) {
                    self.pre_reduction = ::std::option::Option::None;
                }

                pub fn has_pre_reduction(&self) -> bool {
                    self.pre_reduction.is_some()
                }

                // Param is passed by value, moved
                pub fn set_pre_reduction(&mut self, v: u32) {
                    self.pre_reduction = ::std::option::Option::Some(v);
                }

                // optional uint32 post_reduction = 2;

                pub fn post_reduction(&self) -> u32 {
                    self.post_reduction.unwrap_or(0)
                }

                pub fn clear_post_reduction(&mut self) {
                    self.post_reduction = ::std::option::Option::None;
                }

                pub fn has_post_reduction(&self) -> bool {
                    self.post_reduction.is_some()
                }

                // Param is passed by value, moved
                pub fn set_post_reduction(&mut self, v: u32) {
                    self.post_reduction = ::std::option::Option::Some(v);
                }

                // optional .CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType damage_type = 3;

                pub fn damage_type(&self) -> HeroDamageType {
                    match self.damage_type {
                        Some(e) => e.enum_value_or(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        None => HeroDamageType::HERO_DAMAGE_PHYSICAL,
                    }
                }

                pub fn clear_damage_type(&mut self) {
                    self.damage_type = ::std::option::Option::None;
                }

                pub fn has_damage_type(&self) -> bool {
                    self.damage_type.is_some()
                }

                // Param is passed by value, moved
                pub fn set_damage_type(&mut self, v: HeroDamageType) {
                    self.damage_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for HeroDamageReceived {
                const NAME: &'static str = "HeroDamageReceived";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.pre_reduction = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            16 => {
                                self.post_reduction = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            24 => {
                                self.damage_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.pre_reduction {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                    }
                    if let Some(v) = self.post_reduction {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                    }
                    if let Some(v) = self.damage_type {
                        my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.pre_reduction {
                        os.write_uint32(1, v)?;
                    }
                    if let Some(v) = self.post_reduction {
                        os.write_uint32(2, v)?;
                    }
                    if let Some(v) = self.damage_type {
                        os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HeroDamageReceived {
                    HeroDamageReceived::new()
                }

                fn clear(&mut self) {
                    self.pre_reduction = ::std::option::Option::None;
                    self.post_reduction = ::std::option::Option::None;
                    self.damage_type = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HeroDamageReceived {
                    static instance: HeroDamageReceived = HeroDamageReceived {
                        pre_reduction: ::std::option::Option::None,
                        post_reduction: ::std::option::Option::None,
                        damage_type: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType)
            pub enum HeroDamageType {
                // @@protoc_insertion_point(enum_value:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_PHYSICAL)
                HERO_DAMAGE_PHYSICAL = 0,
                // @@protoc_insertion_point(enum_value:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_MAGICAL)
                HERO_DAMAGE_MAGICAL = 1,
                // @@protoc_insertion_point(enum_value:CMsgGameMatchSignOut.CTeam.CPlayer.HeroDamageType.HERO_DAMAGE_PURE)
                HERO_DAMAGE_PURE = 2,
            }

            impl ::steam_vent_proto_common::protobuf::Enum for HeroDamageType {
                const NAME: &'static str = "HeroDamageType";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<HeroDamageType> {
                    match value {
                        0 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        1 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                        2 => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<HeroDamageType> {
                    match str {
                        "HERO_DAMAGE_PHYSICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PHYSICAL),
                        "HERO_DAMAGE_MAGICAL" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_MAGICAL),
                        "HERO_DAMAGE_PURE" => ::std::option::Option::Some(HeroDamageType::HERO_DAMAGE_PURE),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [HeroDamageType] = &[
                    HeroDamageType::HERO_DAMAGE_PHYSICAL,
                    HeroDamageType::HERO_DAMAGE_MAGICAL,
                    HeroDamageType::HERO_DAMAGE_PURE,
                ];
            }

            impl ::std::default::Default for HeroDamageType {
                fn default() -> Self {
                    HeroDamageType::HERO_DAMAGE_PHYSICAL
                }
            }

        }
    }

    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CAdditionalSignoutMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CAdditionalSignoutMsg {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CAdditionalSignoutMsg.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CAdditionalSignoutMsg.contents)
        pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CAdditionalSignoutMsg.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CAdditionalSignoutMsg {
        fn default() -> &'a CAdditionalSignoutMsg {
            <CAdditionalSignoutMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CAdditionalSignoutMsg {
        pub fn new() -> CAdditionalSignoutMsg {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional bytes contents = 2;

        pub fn contents(&self) -> &[u8] {
            match self.contents.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_contents(&mut self) {
            self.contents = ::std::option::Option::None;
        }

        pub fn has_contents(&self) -> bool {
            self.contents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
            self.contents = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.contents.is_none() {
                self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.contents.as_mut().unwrap()
        }

        // Take field
        pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
            self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CAdditionalSignoutMsg {
        const NAME: &'static str = "CAdditionalSignoutMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.contents = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.contents.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.contents.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CAdditionalSignoutMsg {
            CAdditionalSignoutMsg::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.contents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CAdditionalSignoutMsg {
            static instance: CAdditionalSignoutMsg = CAdditionalSignoutMsg {
                id: ::std::option::Option::None,
                contents: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CSocialFeedMatchEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CSocialFeedMatchEvent {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.game_time)
        pub game_time: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.replay_time)
        pub replay_time: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CSocialFeedMatchEvent.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CSocialFeedMatchEvent {
        fn default() -> &'a CSocialFeedMatchEvent {
            <CSocialFeedMatchEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CSocialFeedMatchEvent {
        pub fn new() -> CSocialFeedMatchEvent {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 event_type = 3;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional int32 game_time = 4;

        pub fn game_time(&self) -> i32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: i32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 replay_time = 5;

        pub fn replay_time(&self) -> u32 {
            self.replay_time.unwrap_or(0)
        }

        pub fn clear_replay_time(&mut self) {
            self.replay_time = ::std::option::Option::None;
        }

        pub fn has_replay_time(&self) -> bool {
            self.replay_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_replay_time(&mut self, v: u32) {
            self.replay_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CSocialFeedMatchEvent {
        const NAME: &'static str = "CSocialFeedMatchEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.replay_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.event_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.replay_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.event_type {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.replay_time {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CSocialFeedMatchEvent {
            CSocialFeedMatchEvent::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.event_type = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.replay_time = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CSocialFeedMatchEvent {
            static instance: CSocialFeedMatchEvent = CSocialFeedMatchEvent {
                account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                event_type: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                replay_time: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.CCustomGameData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CCustomGameData {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.CCustomGameData.publish_timestamp)
        pub publish_timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.CCustomGameData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CCustomGameData {
        fn default() -> &'a CCustomGameData {
            <CCustomGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CCustomGameData {
        pub fn new() -> CCustomGameData {
            ::std::default::Default::default()
        }

        // optional uint32 publish_timestamp = 1;

        pub fn publish_timestamp(&self) -> u32 {
            self.publish_timestamp.unwrap_or(0)
        }

        pub fn clear_publish_timestamp(&mut self) {
            self.publish_timestamp = ::std::option::Option::None;
        }

        pub fn has_publish_timestamp(&self) -> bool {
            self.publish_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_publish_timestamp(&mut self, v: u32) {
            self.publish_timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CCustomGameData {
        const NAME: &'static str = "CCustomGameData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.publish_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.publish_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.publish_timestamp {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CCustomGameData {
            CCustomGameData::new()
        }

        fn clear(&mut self) {
            self.publish_timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CCustomGameData {
            static instance: CCustomGameData = CCustomGameData {
                publish_timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.EventGameLeaderboardEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventGameLeaderboardEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.name_suffix)
        pub name_suffix: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.score)
        pub score: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_1)
        pub extra_data_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_2)
        pub extra_data_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_3)
        pub extra_data_3: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_4)
        pub extra_data_4: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.extra_data_5)
        pub extra_data_5: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.EventGameLeaderboardEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventGameLeaderboardEntry {
        fn default() -> &'a EventGameLeaderboardEntry {
            <EventGameLeaderboardEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EventGameLeaderboardEntry {
        pub fn new() -> EventGameLeaderboardEntry {
            ::std::default::Default::default()
        }

        // optional string name_suffix = 1;

        pub fn name_suffix(&self) -> &str {
            match self.name_suffix.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_suffix(&mut self) {
            self.name_suffix = ::std::option::Option::None;
        }

        pub fn has_name_suffix(&self) -> bool {
            self.name_suffix.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_suffix(&mut self, v: ::std::string::String) {
            self.name_suffix = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_suffix(&mut self) -> &mut ::std::string::String {
            if self.name_suffix.is_none() {
                self.name_suffix = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_suffix.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_suffix(&mut self) -> ::std::string::String {
            self.name_suffix.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 score = 2;

        pub fn score(&self) -> i32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: i32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_1 = 3;

        pub fn extra_data_1(&self) -> u32 {
            self.extra_data_1.unwrap_or(0)
        }

        pub fn clear_extra_data_1(&mut self) {
            self.extra_data_1 = ::std::option::Option::None;
        }

        pub fn has_extra_data_1(&self) -> bool {
            self.extra_data_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_1(&mut self, v: u32) {
            self.extra_data_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_2 = 4;

        pub fn extra_data_2(&self) -> u32 {
            self.extra_data_2.unwrap_or(0)
        }

        pub fn clear_extra_data_2(&mut self) {
            self.extra_data_2 = ::std::option::Option::None;
        }

        pub fn has_extra_data_2(&self) -> bool {
            self.extra_data_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_2(&mut self, v: u32) {
            self.extra_data_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_3 = 5;

        pub fn extra_data_3(&self) -> u32 {
            self.extra_data_3.unwrap_or(0)
        }

        pub fn clear_extra_data_3(&mut self) {
            self.extra_data_3 = ::std::option::Option::None;
        }

        pub fn has_extra_data_3(&self) -> bool {
            self.extra_data_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_3(&mut self, v: u32) {
            self.extra_data_3 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_4 = 6;

        pub fn extra_data_4(&self) -> u32 {
            self.extra_data_4.unwrap_or(0)
        }

        pub fn clear_extra_data_4(&mut self) {
            self.extra_data_4 = ::std::option::Option::None;
        }

        pub fn has_extra_data_4(&self) -> bool {
            self.extra_data_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_4(&mut self, v: u32) {
            self.extra_data_4 = ::std::option::Option::Some(v);
        }

        // optional uint32 extra_data_5 = 7;

        pub fn extra_data_5(&self) -> u32 {
            self.extra_data_5.unwrap_or(0)
        }

        pub fn clear_extra_data_5(&mut self) {
            self.extra_data_5 = ::std::option::Option::None;
        }

        pub fn has_extra_data_5(&self) -> bool {
            self.extra_data_5.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extra_data_5(&mut self, v: u32) {
            self.extra_data_5 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EventGameLeaderboardEntry {
        const NAME: &'static str = "EventGameLeaderboardEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_suffix = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.extra_data_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.extra_data_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.extra_data_3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.extra_data_4 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.extra_data_5 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_suffix.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.extra_data_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.extra_data_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.extra_data_3 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.extra_data_4 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.extra_data_5 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name_suffix.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.extra_data_1 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.extra_data_2 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.extra_data_3 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.extra_data_4 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.extra_data_5 {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventGameLeaderboardEntry {
            EventGameLeaderboardEntry::new()
        }

        fn clear(&mut self) {
            self.name_suffix = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.extra_data_1 = ::std::option::Option::None;
            self.extra_data_2 = ::std::option::Option::None;
            self.extra_data_3 = ::std::option::Option::None;
            self.extra_data_4 = ::std::option::Option::None;
            self.extra_data_5 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventGameLeaderboardEntry {
            static instance: EventGameLeaderboardEntry = EventGameLeaderboardEntry {
                name_suffix: ::std::option::Option::None,
                score: ::std::option::Option::None,
                extra_data_1: ::std::option::Option::None,
                extra_data_2: ::std::option::Option::None,
                extra_data_3: ::std::option::Option::None,
                extra_data_4: ::std::option::Option::None,
                extra_data_5: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGameMatchSignOut.WardPlacement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WardPlacement {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.player_id)
        pub player_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.placed_time)
        pub placed_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.building_state)
        pub building_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.creep_state)
        pub creep_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.roshan_alive)
        pub roshan_alive: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.position_x)
        pub position_x: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignOut.WardPlacement.position_y)
        pub position_y: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignOut.WardPlacement.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WardPlacement {
        fn default() -> &'a WardPlacement {
            <WardPlacement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WardPlacement {
        pub fn new() -> WardPlacement {
            ::std::default::Default::default()
        }

        // optional int32 player_id = 1;

        pub fn player_id(&self) -> i32 {
            self.player_id.unwrap_or(-1i32)
        }

        pub fn clear_player_id(&mut self) {
            self.player_id = ::std::option::Option::None;
        }

        pub fn has_player_id(&self) -> bool {
            self.player_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_id(&mut self, v: i32) {
            self.player_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 2;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 placed_time = 3;

        pub fn placed_time(&self) -> u32 {
            self.placed_time.unwrap_or(0)
        }

        pub fn clear_placed_time(&mut self) {
            self.placed_time = ::std::option::Option::None;
        }

        pub fn has_placed_time(&self) -> bool {
            self.placed_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_placed_time(&mut self, v: u32) {
            self.placed_time = ::std::option::Option::Some(v);
        }

        // optional uint32 building_state = 4;

        pub fn building_state(&self) -> u32 {
            self.building_state.unwrap_or(0)
        }

        pub fn clear_building_state(&mut self) {
            self.building_state = ::std::option::Option::None;
        }

        pub fn has_building_state(&self) -> bool {
            self.building_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_state(&mut self, v: u32) {
            self.building_state = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_state = 5;

        pub fn creep_state(&self) -> u32 {
            self.creep_state.unwrap_or(0)
        }

        pub fn clear_creep_state(&mut self) {
            self.creep_state = ::std::option::Option::None;
        }

        pub fn has_creep_state(&self) -> bool {
            self.creep_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_state(&mut self, v: u32) {
            self.creep_state = ::std::option::Option::Some(v);
        }

        // optional bool roshan_alive = 6;

        pub fn roshan_alive(&self) -> bool {
            self.roshan_alive.unwrap_or(false)
        }

        pub fn clear_roshan_alive(&mut self) {
            self.roshan_alive = ::std::option::Option::None;
        }

        pub fn has_roshan_alive(&self) -> bool {
            self.roshan_alive.is_some()
        }

        // Param is passed by value, moved
        pub fn set_roshan_alive(&mut self, v: bool) {
            self.roshan_alive = ::std::option::Option::Some(v);
        }

        // optional uint32 position_x = 7;

        pub fn position_x(&self) -> u32 {
            self.position_x.unwrap_or(0)
        }

        pub fn clear_position_x(&mut self) {
            self.position_x = ::std::option::Option::None;
        }

        pub fn has_position_x(&self) -> bool {
            self.position_x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_x(&mut self, v: u32) {
            self.position_x = ::std::option::Option::Some(v);
        }

        // optional uint32 position_y = 8;

        pub fn position_y(&self) -> u32 {
            self.position_y.unwrap_or(0)
        }

        pub fn clear_position_y(&mut self) {
            self.position_y = ::std::option::Option::None;
        }

        pub fn has_position_y(&self) -> bool {
            self.position_y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position_y(&mut self, v: u32) {
            self.position_y = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WardPlacement {
        const NAME: &'static str = "WardPlacement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.placed_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.building_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.creep_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.roshan_alive = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.position_x = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.position_y = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.placed_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.building_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.creep_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.roshan_alive {
                my_size += 1 + 1;
            }
            if let Some(v) = self.position_x {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.position_y {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.placed_time {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.building_state {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.creep_state {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.roshan_alive {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.position_x {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.position_y {
                os.write_uint32(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WardPlacement {
            WardPlacement::new()
        }

        fn clear(&mut self) {
            self.player_id = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.placed_time = ::std::option::Option::None;
            self.building_state = ::std::option::Option::None;
            self.creep_state = ::std::option::Option::None;
            self.roshan_alive = ::std::option::Option::None;
            self.position_x = ::std::option::Option::None;
            self.position_y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WardPlacement {
            static instance: WardPlacement = WardPlacement {
                player_id: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                placed_time: ::std::option::Option::None,
                building_state: ::std::option::Option::None,
                creep_state: ::std::option::Option::None,
                roshan_alive: ::std::option::Option::None,
                position_x: ::std::option::Option::None,
                position_y: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutDraftInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutDraftInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutDraftInfo.radiant_captain_account_id)
    pub radiant_captain_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutDraftInfo.dire_captain_account_id)
    pub dire_captain_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutDraftInfo.picks_bans)
    pub picks_bans: ::std::vec::Vec<super::dota_gcmessages_common::CMatchHeroSelectEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutDraftInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutDraftInfo {
    fn default() -> &'a CMsgSignOutDraftInfo {
        <CMsgSignOutDraftInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutDraftInfo {
    pub fn new() -> CMsgSignOutDraftInfo {
        ::std::default::Default::default()
    }

    // optional uint32 radiant_captain_account_id = 1;

    pub fn radiant_captain_account_id(&self) -> u32 {
        self.radiant_captain_account_id.unwrap_or(0)
    }

    pub fn clear_radiant_captain_account_id(&mut self) {
        self.radiant_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_radiant_captain_account_id(&self) -> bool {
        self.radiant_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_captain_account_id(&mut self, v: u32) {
        self.radiant_captain_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_captain_account_id = 2;

    pub fn dire_captain_account_id(&self) -> u32 {
        self.dire_captain_account_id.unwrap_or(0)
    }

    pub fn clear_dire_captain_account_id(&mut self) {
        self.dire_captain_account_id = ::std::option::Option::None;
    }

    pub fn has_dire_captain_account_id(&self) -> bool {
        self.dire_captain_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_captain_account_id(&mut self, v: u32) {
        self.dire_captain_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutDraftInfo {
    const NAME: &'static str = "CMsgSignOutDraftInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.radiant_captain_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.dire_captain_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.picks_bans.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.radiant_captain_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dire_captain_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.picks_bans {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.radiant_captain_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dire_captain_account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.picks_bans {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutDraftInfo {
        CMsgSignOutDraftInfo::new()
    }

    fn clear(&mut self) {
        self.radiant_captain_account_id = ::std::option::Option::None;
        self.dire_captain_account_id = ::std::option::Option::None;
        self.picks_bans.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutDraftInfo {
        static instance: CMsgSignOutDraftInfo = CMsgSignOutDraftInfo {
            radiant_captain_account_id: ::std::option::Option::None,
            dire_captain_account_id: ::std::option::Option::None,
            picks_bans: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutBotInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutBotInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutBotInfo.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSignOutBotInfo.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CMsgSignOutBotInfo.created_lobby)
    pub created_lobby: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSignOutBotInfo.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutBotInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutBotInfo {
    fn default() -> &'a CMsgSignOutBotInfo {
        <CMsgSignOutBotInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutBotInfo {
    pub fn new() -> CMsgSignOutBotInfo {
        ::std::default::Default::default()
    }

    // optional bool allow_cheats = 1;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty bot_difficulty_radiant = 2;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool created_lobby = 3;

    pub fn created_lobby(&self) -> bool {
        self.created_lobby.unwrap_or(false)
    }

    pub fn clear_created_lobby(&mut self) {
        self.created_lobby = ::std::option::Option::None;
    }

    pub fn has_created_lobby(&self) -> bool {
        self.created_lobby.is_some()
    }

    // Param is passed by value, moved
    pub fn set_created_lobby(&mut self, v: bool) {
        self.created_lobby = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty bot_difficulty_dire = 5;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutBotInfo {
    const NAME: &'static str = "CMsgSignOutBotInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.created_lobby = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.created_lobby {
            my_size += 1 + 1;
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.allow_cheats {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.created_lobby {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutBotInfo {
        CMsgSignOutBotInfo::new()
    }

    fn clear(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.created_lobby = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutBotInfo {
        static instance: CMsgSignOutBotInfo = CMsgSignOutBotInfo {
            allow_cheats: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            created_lobby: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutTextMuteInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutTextMuteInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutTextMuteInfo.text_mute_messages)
    pub text_mute_messages: ::std::vec::Vec<cmsg_sign_out_text_mute_info::TextMuteMessage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutTextMuteInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutTextMuteInfo {
    fn default() -> &'a CMsgSignOutTextMuteInfo {
        <CMsgSignOutTextMuteInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutTextMuteInfo {
    pub fn new() -> CMsgSignOutTextMuteInfo {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutTextMuteInfo {
    const NAME: &'static str = "CMsgSignOutTextMuteInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.text_mute_messages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.text_mute_messages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.text_mute_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutTextMuteInfo {
        CMsgSignOutTextMuteInfo::new()
    }

    fn clear(&mut self) {
        self.text_mute_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutTextMuteInfo {
        static instance: CMsgSignOutTextMuteInfo = CMsgSignOutTextMuteInfo {
            text_mute_messages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutTextMuteInfo`
pub mod cmsg_sign_out_text_mute_info {
    // @@protoc_insertion_point(message:CMsgSignOutTextMuteInfo.TextMuteMessage)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TextMuteMessage {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutTextMuteInfo.TextMuteMessage.region)
        pub region: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutTextMuteInfo.TextMuteMessage.caused_text_mute)
        pub caused_text_mute: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSignOutTextMuteInfo.TextMuteMessage.chat_message)
        pub chat_message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutTextMuteInfo.TextMuteMessage.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TextMuteMessage {
        fn default() -> &'a TextMuteMessage {
            <TextMuteMessage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TextMuteMessage {
        pub fn new() -> TextMuteMessage {
            ::std::default::Default::default()
        }

        // optional uint32 region = 1;

        pub fn region(&self) -> u32 {
            self.region.unwrap_or(0)
        }

        pub fn clear_region(&mut self) {
            self.region = ::std::option::Option::None;
        }

        pub fn has_region(&self) -> bool {
            self.region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region(&mut self, v: u32) {
            self.region = ::std::option::Option::Some(v);
        }

        // optional bool caused_text_mute = 2;

        pub fn caused_text_mute(&self) -> bool {
            self.caused_text_mute.unwrap_or(false)
        }

        pub fn clear_caused_text_mute(&mut self) {
            self.caused_text_mute = ::std::option::Option::None;
        }

        pub fn has_caused_text_mute(&self) -> bool {
            self.caused_text_mute.is_some()
        }

        // Param is passed by value, moved
        pub fn set_caused_text_mute(&mut self, v: bool) {
            self.caused_text_mute = ::std::option::Option::Some(v);
        }

        // optional string chat_message = 3;

        pub fn chat_message(&self) -> &str {
            match self.chat_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_chat_message(&mut self) {
            self.chat_message = ::std::option::Option::None;
        }

        pub fn has_chat_message(&self) -> bool {
            self.chat_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_message(&mut self, v: ::std::string::String) {
            self.chat_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_chat_message(&mut self) -> &mut ::std::string::String {
            if self.chat_message.is_none() {
                self.chat_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.chat_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_chat_message(&mut self) -> ::std::string::String {
            self.chat_message.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TextMuteMessage {
        const NAME: &'static str = "TextMuteMessage";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.region = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.caused_text_mute = ::std::option::Option::Some(is.read_bool()?);
                    },
                    26 => {
                        self.chat_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.region {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.caused_text_mute {
                my_size += 1 + 1;
            }
            if let Some(v) = self.chat_message.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.region {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.caused_text_mute {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.chat_message.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TextMuteMessage {
            TextMuteMessage::new()
        }

        fn clear(&mut self) {
            self.region = ::std::option::Option::None;
            self.caused_text_mute = ::std::option::Option::None;
            self.chat_message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TextMuteMessage {
            static instance: TextMuteMessage = TextMuteMessage {
                region: ::std::option::Option::None,
                caused_text_mute: ::std::option::Option::None,
                chat_message: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutPlayerStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutPlayerStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.account_id)
    pub account_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.rank)
    pub rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.rampages)
    pub rampages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.triple_kills)
    pub triple_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.first_blood_claimed)
    pub first_blood_claimed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.first_blood_given)
    pub first_blood_given: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.couriers_killed)
    pub couriers_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.aegises_snatched)
    pub aegises_snatched: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.cheeses_eaten)
    pub cheeses_eaten: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.creeps_stacked)
    pub creeps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.fight_score)
    pub fight_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.farm_score)
    pub farm_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.support_score)
    pub support_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.push_score)
    pub push_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.kills)
    pub kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.deaths)
    pub deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.assists)
    pub assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.last_hits)
    pub last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.denies)
    pub denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.gpm)
    pub gpm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.xppm)
    pub xppm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.net_worth)
    pub net_worth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.damage)
    pub damage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.heals)
    pub heals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.rapiers_purchased)
    pub rapiers_purchased: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.observer_wards_placed)
    pub observer_wards_placed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.wards_destroyed)
    pub wards_destroyed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutPlayerStats.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutPlayerStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutPlayerStats {
    fn default() -> &'a CMsgSignOutPlayerStats {
        <CMsgSignOutPlayerStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutPlayerStats {
    pub fn new() -> CMsgSignOutPlayerStats {
        ::std::default::Default::default()
    }

    // optional int32 account_id = 1;

    pub fn account_id(&self) -> i32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: i32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank = 3;

    pub fn rank(&self) -> u32 {
        self.rank.unwrap_or(0)
    }

    pub fn clear_rank(&mut self) {
        self.rank = ::std::option::Option::None;
    }

    pub fn has_rank(&self) -> bool {
        self.rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank(&mut self, v: u32) {
        self.rank = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rampages = 5;

    pub fn rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    // optional uint32 triple_kills = 6;

    pub fn triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_claimed = 7;

    pub fn first_blood_claimed(&self) -> u32 {
        self.first_blood_claimed.unwrap_or(0)
    }

    pub fn clear_first_blood_claimed(&mut self) {
        self.first_blood_claimed = ::std::option::Option::None;
    }

    pub fn has_first_blood_claimed(&self) -> bool {
        self.first_blood_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_claimed(&mut self, v: u32) {
        self.first_blood_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_given = 8;

    pub fn first_blood_given(&self) -> u32 {
        self.first_blood_given.unwrap_or(0)
    }

    pub fn clear_first_blood_given(&mut self) {
        self.first_blood_given = ::std::option::Option::None;
    }

    pub fn has_first_blood_given(&self) -> bool {
        self.first_blood_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_given(&mut self, v: u32) {
        self.first_blood_given = ::std::option::Option::Some(v);
    }

    // optional uint32 couriers_killed = 9;

    pub fn couriers_killed(&self) -> u32 {
        self.couriers_killed.unwrap_or(0)
    }

    pub fn clear_couriers_killed(&mut self) {
        self.couriers_killed = ::std::option::Option::None;
    }

    pub fn has_couriers_killed(&self) -> bool {
        self.couriers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_couriers_killed(&mut self, v: u32) {
        self.couriers_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 aegises_snatched = 10;

    pub fn aegises_snatched(&self) -> u32 {
        self.aegises_snatched.unwrap_or(0)
    }

    pub fn clear_aegises_snatched(&mut self) {
        self.aegises_snatched = ::std::option::Option::None;
    }

    pub fn has_aegises_snatched(&self) -> bool {
        self.aegises_snatched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aegises_snatched(&mut self, v: u32) {
        self.aegises_snatched = ::std::option::Option::Some(v);
    }

    // optional uint32 cheeses_eaten = 11;

    pub fn cheeses_eaten(&self) -> u32 {
        self.cheeses_eaten.unwrap_or(0)
    }

    pub fn clear_cheeses_eaten(&mut self) {
        self.cheeses_eaten = ::std::option::Option::None;
    }

    pub fn has_cheeses_eaten(&self) -> bool {
        self.cheeses_eaten.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheeses_eaten(&mut self, v: u32) {
        self.cheeses_eaten = ::std::option::Option::Some(v);
    }

    // optional uint32 creeps_stacked = 12;

    pub fn creeps_stacked(&self) -> u32 {
        self.creeps_stacked.unwrap_or(0)
    }

    pub fn clear_creeps_stacked(&mut self) {
        self.creeps_stacked = ::std::option::Option::None;
    }

    pub fn has_creeps_stacked(&self) -> bool {
        self.creeps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creeps_stacked(&mut self, v: u32) {
        self.creeps_stacked = ::std::option::Option::Some(v);
    }

    // optional float fight_score = 13;

    pub fn fight_score(&self) -> f32 {
        self.fight_score.unwrap_or(0.)
    }

    pub fn clear_fight_score(&mut self) {
        self.fight_score = ::std::option::Option::None;
    }

    pub fn has_fight_score(&self) -> bool {
        self.fight_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight_score(&mut self, v: f32) {
        self.fight_score = ::std::option::Option::Some(v);
    }

    // optional float farm_score = 14;

    pub fn farm_score(&self) -> f32 {
        self.farm_score.unwrap_or(0.)
    }

    pub fn clear_farm_score(&mut self) {
        self.farm_score = ::std::option::Option::None;
    }

    pub fn has_farm_score(&self) -> bool {
        self.farm_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_farm_score(&mut self, v: f32) {
        self.farm_score = ::std::option::Option::Some(v);
    }

    // optional float support_score = 15;

    pub fn support_score(&self) -> f32 {
        self.support_score.unwrap_or(0.)
    }

    pub fn clear_support_score(&mut self) {
        self.support_score = ::std::option::Option::None;
    }

    pub fn has_support_score(&self) -> bool {
        self.support_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_score(&mut self, v: f32) {
        self.support_score = ::std::option::Option::Some(v);
    }

    // optional float push_score = 16;

    pub fn push_score(&self) -> f32 {
        self.push_score.unwrap_or(0.)
    }

    pub fn clear_push_score(&mut self) {
        self.push_score = ::std::option::Option::None;
    }

    pub fn has_push_score(&self) -> bool {
        self.push_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_score(&mut self, v: f32) {
        self.push_score = ::std::option::Option::Some(v);
    }

    // optional uint32 kills = 17;

    pub fn kills(&self) -> u32 {
        self.kills.unwrap_or(0)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: u32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional uint32 deaths = 18;

    pub fn deaths(&self) -> u32 {
        self.deaths.unwrap_or(0)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: u32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 assists = 19;

    pub fn assists(&self) -> u32 {
        self.assists.unwrap_or(0)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: u32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional uint32 last_hits = 20;

    pub fn last_hits(&self) -> u32 {
        self.last_hits.unwrap_or(0)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: u32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 denies = 21;

    pub fn denies(&self) -> u32 {
        self.denies.unwrap_or(0)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: u32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional float gpm = 22;

    pub fn gpm(&self) -> f32 {
        self.gpm.unwrap_or(0.)
    }

    pub fn clear_gpm(&mut self) {
        self.gpm = ::std::option::Option::None;
    }

    pub fn has_gpm(&self) -> bool {
        self.gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gpm(&mut self, v: f32) {
        self.gpm = ::std::option::Option::Some(v);
    }

    // optional float xppm = 23;

    pub fn xppm(&self) -> f32 {
        self.xppm.unwrap_or(0.)
    }

    pub fn clear_xppm(&mut self) {
        self.xppm = ::std::option::Option::None;
    }

    pub fn has_xppm(&self) -> bool {
        self.xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xppm(&mut self, v: f32) {
        self.xppm = ::std::option::Option::Some(v);
    }

    // optional float net_worth = 24;

    pub fn net_worth(&self) -> f32 {
        self.net_worth.unwrap_or(0.)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: f32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional float damage = 25;

    pub fn damage(&self) -> f32 {
        self.damage.unwrap_or(0.)
    }

    pub fn clear_damage(&mut self) {
        self.damage = ::std::option::Option::None;
    }

    pub fn has_damage(&self) -> bool {
        self.damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_damage(&mut self, v: f32) {
        self.damage = ::std::option::Option::Some(v);
    }

    // optional float heals = 26;

    pub fn heals(&self) -> f32 {
        self.heals.unwrap_or(0.)
    }

    pub fn clear_heals(&mut self) {
        self.heals = ::std::option::Option::None;
    }

    pub fn has_heals(&self) -> bool {
        self.heals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_heals(&mut self, v: f32) {
        self.heals = ::std::option::Option::Some(v);
    }

    // optional uint32 rapiers_purchased = 27;

    pub fn rapiers_purchased(&self) -> u32 {
        self.rapiers_purchased.unwrap_or(0)
    }

    pub fn clear_rapiers_purchased(&mut self) {
        self.rapiers_purchased = ::std::option::Option::None;
    }

    pub fn has_rapiers_purchased(&self) -> bool {
        self.rapiers_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rapiers_purchased(&mut self, v: u32) {
        self.rapiers_purchased = ::std::option::Option::Some(v);
    }

    // optional uint32 observer_wards_placed = 28;

    pub fn observer_wards_placed(&self) -> u32 {
        self.observer_wards_placed.unwrap_or(0)
    }

    pub fn clear_observer_wards_placed(&mut self) {
        self.observer_wards_placed = ::std::option::Option::None;
    }

    pub fn has_observer_wards_placed(&self) -> bool {
        self.observer_wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observer_wards_placed(&mut self, v: u32) {
        self.observer_wards_placed = ::std::option::Option::Some(v);
    }

    // optional uint32 wards_destroyed = 29;

    pub fn wards_destroyed(&self) -> u32 {
        self.wards_destroyed.unwrap_or(0)
    }

    pub fn clear_wards_destroyed(&mut self) {
        self.wards_destroyed = ::std::option::Option::None;
    }

    pub fn has_wards_destroyed(&self) -> bool {
        self.wards_destroyed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_destroyed(&mut self, v: u32) {
        self.wards_destroyed = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 30;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutPlayerStats {
    const NAME: &'static str = "CMsgSignOutPlayerStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.first_blood_claimed = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.first_blood_given = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.couriers_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.aegises_snatched = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.cheeses_eaten = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.creeps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.fight_score = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.farm_score = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.support_score = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.push_score = ::std::option::Option::Some(is.read_float()?);
                },
                136 => {
                    self.kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                181 => {
                    self.gpm = ::std::option::Option::Some(is.read_float()?);
                },
                189 => {
                    self.xppm = ::std::option::Option::Some(is.read_float()?);
                },
                197 => {
                    self.net_worth = ::std::option::Option::Some(is.read_float()?);
                },
                205 => {
                    self.damage = ::std::option::Option::Some(is.read_float()?);
                },
                213 => {
                    self.heals = ::std::option::Option::Some(is.read_float()?);
                },
                216 => {
                    self.rapiers_purchased = ::std::option::Option::Some(is.read_uint32()?);
                },
                224 => {
                    self.observer_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.wards_destroyed = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.rampages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.first_blood_claimed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.first_blood_given {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.couriers_killed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.aegises_snatched {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.cheeses_eaten {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.creeps_stacked {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.fight_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.farm_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.support_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.push_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.denies {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.gpm {
            my_size += 2 + 4;
        }
        if let Some(v) = self.xppm {
            my_size += 2 + 4;
        }
        if let Some(v) = self.net_worth {
            my_size += 2 + 4;
        }
        if let Some(v) = self.damage {
            my_size += 2 + 4;
        }
        if let Some(v) = self.heals {
            my_size += 2 + 4;
        }
        if let Some(v) = self.rapiers_purchased {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(27, v);
        }
        if let Some(v) = self.observer_wards_placed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.wards_destroyed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.rank {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.first_blood_claimed {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.first_blood_given {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.couriers_killed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.aegises_snatched {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.cheeses_eaten {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.creeps_stacked {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.fight_score {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.farm_score {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.support_score {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.push_score {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.kills {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.assists {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.denies {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.gpm {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.xppm {
            os.write_float(23, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_float(24, v)?;
        }
        if let Some(v) = self.damage {
            os.write_float(25, v)?;
        }
        if let Some(v) = self.heals {
            os.write_float(26, v)?;
        }
        if let Some(v) = self.rapiers_purchased {
            os.write_uint32(27, v)?;
        }
        if let Some(v) = self.observer_wards_placed {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.wards_destroyed {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(30, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutPlayerStats {
        CMsgSignOutPlayerStats::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.rank = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.first_blood_claimed = ::std::option::Option::None;
        self.first_blood_given = ::std::option::Option::None;
        self.couriers_killed = ::std::option::Option::None;
        self.aegises_snatched = ::std::option::Option::None;
        self.cheeses_eaten = ::std::option::Option::None;
        self.creeps_stacked = ::std::option::Option::None;
        self.fight_score = ::std::option::Option::None;
        self.farm_score = ::std::option::Option::None;
        self.support_score = ::std::option::Option::None;
        self.push_score = ::std::option::Option::None;
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.gpm = ::std::option::Option::None;
        self.xppm = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.damage = ::std::option::Option::None;
        self.heals = ::std::option::Option::None;
        self.rapiers_purchased = ::std::option::Option::None;
        self.observer_wards_placed = ::std::option::Option::None;
        self.wards_destroyed = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutPlayerStats {
        static instance: CMsgSignOutPlayerStats = CMsgSignOutPlayerStats {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            rank: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            first_blood_claimed: ::std::option::Option::None,
            first_blood_given: ::std::option::Option::None,
            couriers_killed: ::std::option::Option::None,
            aegises_snatched: ::std::option::Option::None,
            cheeses_eaten: ::std::option::Option::None,
            creeps_stacked: ::std::option::Option::None,
            fight_score: ::std::option::Option::None,
            farm_score: ::std::option::Option::None,
            support_score: ::std::option::Option::None,
            push_score: ::std::option::Option::None,
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            gpm: ::std::option::Option::None,
            xppm: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            damage: ::std::option::Option::None,
            heals: ::std::option::Option::None,
            rapiers_purchased: ::std::option::Option::None,
            observer_wards_placed: ::std::option::Option::None,
            wards_destroyed: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutCommunicationSummary)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutCommunicationSummary {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_communication_summary::PlayerCommunication>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutCommunicationSummary.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutCommunicationSummary {
    fn default() -> &'a CMsgSignOutCommunicationSummary {
        <CMsgSignOutCommunicationSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutCommunicationSummary {
    pub fn new() -> CMsgSignOutCommunicationSummary {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutCommunicationSummary {
    const NAME: &'static str = "CMsgSignOutCommunicationSummary";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutCommunicationSummary {
        CMsgSignOutCommunicationSummary::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutCommunicationSummary {
        static instance: CMsgSignOutCommunicationSummary = CMsgSignOutCommunicationSummary {
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutCommunicationSummary`
pub mod cmsg_sign_out_communication_summary {
    // @@protoc_insertion_point(message:CMsgSignOutCommunicationSummary.PlayerCommunication)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCommunication {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.pings)
        pub pings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.max_pings_per_interval)
        pub max_pings_per_interval: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.teammate_pings)
        pub teammate_pings: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.max_teammate_pings_per_interval)
        pub max_teammate_pings_per_interval: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.team_chat_messages)
        pub team_chat_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.all_chat_messages)
        pub all_chat_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.chat_wheel_messages)
        pub chat_wheel_messages: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.pauses)
        pub pauses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.unpauses)
        pub unpauses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.lines_drawn)
        pub lines_drawn: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.voice_chat_seconds)
        pub voice_chat_seconds: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.chat_mutes)
        pub chat_mutes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.voice_mutes)
        pub voice_mutes: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.ping_details)
        pub ping_details: ::std::vec::Vec<player_communication::PingDetail>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.comms_blocks_solo)
        pub comms_blocks_solo: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.comms_blocks_mass)
        pub comms_blocks_mass: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.chat_log)
        pub chat_log: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutCommunicationSummary.PlayerCommunication.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCommunication {
        fn default() -> &'a PlayerCommunication {
            <PlayerCommunication as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCommunication {
        pub fn new() -> PlayerCommunication {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 pings = 2;

        pub fn pings(&self) -> u32 {
            self.pings.unwrap_or(0)
        }

        pub fn clear_pings(&mut self) {
            self.pings = ::std::option::Option::None;
        }

        pub fn has_pings(&self) -> bool {
            self.pings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pings(&mut self, v: u32) {
            self.pings = ::std::option::Option::Some(v);
        }

        // optional uint32 max_pings_per_interval = 3;

        pub fn max_pings_per_interval(&self) -> u32 {
            self.max_pings_per_interval.unwrap_or(0)
        }

        pub fn clear_max_pings_per_interval(&mut self) {
            self.max_pings_per_interval = ::std::option::Option::None;
        }

        pub fn has_max_pings_per_interval(&self) -> bool {
            self.max_pings_per_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_pings_per_interval(&mut self, v: u32) {
            self.max_pings_per_interval = ::std::option::Option::Some(v);
        }

        // optional uint32 teammate_pings = 4;

        pub fn teammate_pings(&self) -> u32 {
            self.teammate_pings.unwrap_or(0)
        }

        pub fn clear_teammate_pings(&mut self) {
            self.teammate_pings = ::std::option::Option::None;
        }

        pub fn has_teammate_pings(&self) -> bool {
            self.teammate_pings.is_some()
        }

        // Param is passed by value, moved
        pub fn set_teammate_pings(&mut self, v: u32) {
            self.teammate_pings = ::std::option::Option::Some(v);
        }

        // optional uint32 max_teammate_pings_per_interval = 5;

        pub fn max_teammate_pings_per_interval(&self) -> u32 {
            self.max_teammate_pings_per_interval.unwrap_or(0)
        }

        pub fn clear_max_teammate_pings_per_interval(&mut self) {
            self.max_teammate_pings_per_interval = ::std::option::Option::None;
        }

        pub fn has_max_teammate_pings_per_interval(&self) -> bool {
            self.max_teammate_pings_per_interval.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_teammate_pings_per_interval(&mut self, v: u32) {
            self.max_teammate_pings_per_interval = ::std::option::Option::Some(v);
        }

        // optional uint32 team_chat_messages = 6;

        pub fn team_chat_messages(&self) -> u32 {
            self.team_chat_messages.unwrap_or(0)
        }

        pub fn clear_team_chat_messages(&mut self) {
            self.team_chat_messages = ::std::option::Option::None;
        }

        pub fn has_team_chat_messages(&self) -> bool {
            self.team_chat_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_chat_messages(&mut self, v: u32) {
            self.team_chat_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 all_chat_messages = 7;

        pub fn all_chat_messages(&self) -> u32 {
            self.all_chat_messages.unwrap_or(0)
        }

        pub fn clear_all_chat_messages(&mut self) {
            self.all_chat_messages = ::std::option::Option::None;
        }

        pub fn has_all_chat_messages(&self) -> bool {
            self.all_chat_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_all_chat_messages(&mut self, v: u32) {
            self.all_chat_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_wheel_messages = 8;

        pub fn chat_wheel_messages(&self) -> u32 {
            self.chat_wheel_messages.unwrap_or(0)
        }

        pub fn clear_chat_wheel_messages(&mut self) {
            self.chat_wheel_messages = ::std::option::Option::None;
        }

        pub fn has_chat_wheel_messages(&self) -> bool {
            self.chat_wheel_messages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_wheel_messages(&mut self, v: u32) {
            self.chat_wheel_messages = ::std::option::Option::Some(v);
        }

        // optional uint32 pauses = 9;

        pub fn pauses(&self) -> u32 {
            self.pauses.unwrap_or(0)
        }

        pub fn clear_pauses(&mut self) {
            self.pauses = ::std::option::Option::None;
        }

        pub fn has_pauses(&self) -> bool {
            self.pauses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pauses(&mut self, v: u32) {
            self.pauses = ::std::option::Option::Some(v);
        }

        // optional uint32 unpauses = 10;

        pub fn unpauses(&self) -> u32 {
            self.unpauses.unwrap_or(0)
        }

        pub fn clear_unpauses(&mut self) {
            self.unpauses = ::std::option::Option::None;
        }

        pub fn has_unpauses(&self) -> bool {
            self.unpauses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_unpauses(&mut self, v: u32) {
            self.unpauses = ::std::option::Option::Some(v);
        }

        // optional uint32 lines_drawn = 11;

        pub fn lines_drawn(&self) -> u32 {
            self.lines_drawn.unwrap_or(0)
        }

        pub fn clear_lines_drawn(&mut self) {
            self.lines_drawn = ::std::option::Option::None;
        }

        pub fn has_lines_drawn(&self) -> bool {
            self.lines_drawn.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lines_drawn(&mut self, v: u32) {
            self.lines_drawn = ::std::option::Option::Some(v);
        }

        // optional uint32 voice_chat_seconds = 12;

        pub fn voice_chat_seconds(&self) -> u32 {
            self.voice_chat_seconds.unwrap_or(0)
        }

        pub fn clear_voice_chat_seconds(&mut self) {
            self.voice_chat_seconds = ::std::option::Option::None;
        }

        pub fn has_voice_chat_seconds(&self) -> bool {
            self.voice_chat_seconds.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_chat_seconds(&mut self, v: u32) {
            self.voice_chat_seconds = ::std::option::Option::Some(v);
        }

        // optional uint32 chat_mutes = 13;

        pub fn chat_mutes(&self) -> u32 {
            self.chat_mutes.unwrap_or(0)
        }

        pub fn clear_chat_mutes(&mut self) {
            self.chat_mutes = ::std::option::Option::None;
        }

        pub fn has_chat_mutes(&self) -> bool {
            self.chat_mutes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_chat_mutes(&mut self, v: u32) {
            self.chat_mutes = ::std::option::Option::Some(v);
        }

        // optional uint32 voice_mutes = 14;

        pub fn voice_mutes(&self) -> u32 {
            self.voice_mutes.unwrap_or(0)
        }

        pub fn clear_voice_mutes(&mut self) {
            self.voice_mutes = ::std::option::Option::None;
        }

        pub fn has_voice_mutes(&self) -> bool {
            self.voice_mutes.is_some()
        }

        // Param is passed by value, moved
        pub fn set_voice_mutes(&mut self, v: u32) {
            self.voice_mutes = ::std::option::Option::Some(v);
        }

        // optional uint32 comms_blocks_solo = 16;

        pub fn comms_blocks_solo(&self) -> u32 {
            self.comms_blocks_solo.unwrap_or(0)
        }

        pub fn clear_comms_blocks_solo(&mut self) {
            self.comms_blocks_solo = ::std::option::Option::None;
        }

        pub fn has_comms_blocks_solo(&self) -> bool {
            self.comms_blocks_solo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comms_blocks_solo(&mut self, v: u32) {
            self.comms_blocks_solo = ::std::option::Option::Some(v);
        }

        // optional uint32 comms_blocks_mass = 17;

        pub fn comms_blocks_mass(&self) -> u32 {
            self.comms_blocks_mass.unwrap_or(0)
        }

        pub fn clear_comms_blocks_mass(&mut self) {
            self.comms_blocks_mass = ::std::option::Option::None;
        }

        pub fn has_comms_blocks_mass(&self) -> bool {
            self.comms_blocks_mass.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comms_blocks_mass(&mut self, v: u32) {
            self.comms_blocks_mass = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCommunication {
        const NAME: &'static str = "PlayerCommunication";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.pings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.max_pings_per_interval = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.teammate_pings = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.max_teammate_pings_per_interval = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.team_chat_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.all_chat_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.chat_wheel_messages = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.pauses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.unpauses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.lines_drawn = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.voice_chat_seconds = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.chat_mutes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.voice_mutes = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    122 => {
                        self.ping_details.push(is.read_message()?);
                    },
                    128 => {
                        self.comms_blocks_solo = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.comms_blocks_mass = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    146 => {
                        self.chat_log.push(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.pings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.max_pings_per_interval {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.teammate_pings {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.max_teammate_pings_per_interval {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.team_chat_messages {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.all_chat_messages {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.chat_wheel_messages {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.pauses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.unpauses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.lines_drawn {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.voice_chat_seconds {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.chat_mutes {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.voice_mutes {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            for value in &self.ping_details {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.comms_blocks_solo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.comms_blocks_mass {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            for value in &self.chat_log {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(18, &value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.pings {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.max_pings_per_interval {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.teammate_pings {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.max_teammate_pings_per_interval {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.team_chat_messages {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.all_chat_messages {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.chat_wheel_messages {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.pauses {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.unpauses {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.lines_drawn {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.voice_chat_seconds {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.chat_mutes {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.voice_mutes {
                os.write_uint32(14, v)?;
            }
            for v in &self.ping_details {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
            };
            if let Some(v) = self.comms_blocks_solo {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.comms_blocks_mass {
                os.write_uint32(17, v)?;
            }
            for v in &self.chat_log {
                os.write_string(18, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCommunication {
            PlayerCommunication::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.pings = ::std::option::Option::None;
            self.max_pings_per_interval = ::std::option::Option::None;
            self.teammate_pings = ::std::option::Option::None;
            self.max_teammate_pings_per_interval = ::std::option::Option::None;
            self.team_chat_messages = ::std::option::Option::None;
            self.all_chat_messages = ::std::option::Option::None;
            self.chat_wheel_messages = ::std::option::Option::None;
            self.pauses = ::std::option::Option::None;
            self.unpauses = ::std::option::Option::None;
            self.lines_drawn = ::std::option::Option::None;
            self.voice_chat_seconds = ::std::option::Option::None;
            self.chat_mutes = ::std::option::Option::None;
            self.voice_mutes = ::std::option::Option::None;
            self.ping_details.clear();
            self.comms_blocks_solo = ::std::option::Option::None;
            self.comms_blocks_mass = ::std::option::Option::None;
            self.chat_log.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCommunication {
            static instance: PlayerCommunication = PlayerCommunication {
                account_id: ::std::option::Option::None,
                pings: ::std::option::Option::None,
                max_pings_per_interval: ::std::option::Option::None,
                teammate_pings: ::std::option::Option::None,
                max_teammate_pings_per_interval: ::std::option::Option::None,
                team_chat_messages: ::std::option::Option::None,
                all_chat_messages: ::std::option::Option::None,
                chat_wheel_messages: ::std::option::Option::None,
                pauses: ::std::option::Option::None,
                unpauses: ::std::option::Option::None,
                lines_drawn: ::std::option::Option::None,
                voice_chat_seconds: ::std::option::Option::None,
                chat_mutes: ::std::option::Option::None,
                voice_mutes: ::std::option::Option::None,
                ping_details: ::std::vec::Vec::new(),
                comms_blocks_solo: ::std::option::Option::None,
                comms_blocks_mass: ::std::option::Option::None,
                chat_log: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `PlayerCommunication`
    pub mod player_communication {
        // @@protoc_insertion_point(message:CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct PingDetail {
            // message fields
            // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.type)
            pub type_: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.count)
            pub count: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSignOutCommunicationSummary.PlayerCommunication.PingDetail.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a PingDetail {
            fn default() -> &'a PingDetail {
                <PingDetail as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl PingDetail {
            pub fn new() -> PingDetail {
                ::std::default::Default::default()
            }

            // optional uint32 type = 1;

            pub fn type_(&self) -> u32 {
                self.type_.unwrap_or(4294967295u32)
            }

            pub fn clear_type_(&mut self) {
                self.type_ = ::std::option::Option::None;
            }

            pub fn has_type(&self) -> bool {
                self.type_.is_some()
            }

            // Param is passed by value, moved
            pub fn set_type(&mut self, v: u32) {
                self.type_ = ::std::option::Option::Some(v);
            }

            // optional uint32 count = 2;

            pub fn count(&self) -> u32 {
                self.count.unwrap_or(0)
            }

            pub fn clear_count(&mut self) {
                self.count = ::std::option::Option::None;
            }

            pub fn has_count(&self) -> bool {
                self.count.is_some()
            }

            // Param is passed by value, moved
            pub fn set_count(&mut self, v: u32) {
                self.count = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for PingDetail {
            const NAME: &'static str = "PingDetail";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.count = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.type_ {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.count {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.type_ {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.count {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> PingDetail {
                PingDetail::new()
            }

            fn clear(&mut self) {
                self.type_ = ::std::option::Option::None;
                self.count = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static PingDetail {
                static instance: PingDetail = PingDetail {
                    type_: ::std::option::Option::None,
                    count: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignoutResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignoutResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.replay_salt)
    pub replay_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTimedRewardDetails>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.xp_reward_details)
    pub xp_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CSODOTALobbyMember>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.metadata_private_key)
    pub metadata_private_key: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.match_details)
    pub match_details: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.players_metadata)
    pub players_metadata: ::std::vec::Vec<cmsg_game_match_signout_response::PlayerMetadata>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.mvp_data)
    pub mvp_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_match_management::CMvpData>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.ow_private_key)
    pub ow_private_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.ow_salt)
    pub ow_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.ow_replay_id)
    pub ow_replay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.overworld_rewards)
    pub overworld_rewards: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common_overworld::CMsgOverworldMatchRewards>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignoutResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignoutResponse {
    fn default() -> &'a CMsgGameMatchSignoutResponse {
        <CMsgGameMatchSignoutResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignoutResponse {
    pub fn new() -> CMsgGameMatchSignoutResponse {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 replay_salt = 2;

    pub fn replay_salt(&self) -> u32 {
        self.replay_salt.unwrap_or(0)
    }

    pub fn clear_replay_salt(&mut self) {
        self.replay_salt = ::std::option::Option::None;
    }

    pub fn has_replay_salt(&self) -> bool {
        self.replay_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_salt(&mut self, v: u32) {
        self.replay_salt = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 5;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional fixed32 metadata_private_key = 7;

    pub fn metadata_private_key(&self) -> u32 {
        self.metadata_private_key.unwrap_or(0)
    }

    pub fn clear_metadata_private_key(&mut self) {
        self.metadata_private_key = ::std::option::Option::None;
    }

    pub fn has_metadata_private_key(&self) -> bool {
        self.metadata_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata_private_key(&mut self, v: u32) {
        self.metadata_private_key = ::std::option::Option::Some(v);
    }

    // optional fixed64 ow_private_key = 11;

    pub fn ow_private_key(&self) -> u64 {
        self.ow_private_key.unwrap_or(0)
    }

    pub fn clear_ow_private_key(&mut self) {
        self.ow_private_key = ::std::option::Option::None;
    }

    pub fn has_ow_private_key(&self) -> bool {
        self.ow_private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_private_key(&mut self, v: u64) {
        self.ow_private_key = ::std::option::Option::Some(v);
    }

    // optional fixed32 ow_salt = 12;

    pub fn ow_salt(&self) -> u32 {
        self.ow_salt.unwrap_or(0)
    }

    pub fn clear_ow_salt(&mut self) {
        self.ow_salt = ::std::option::Option::None;
    }

    pub fn has_ow_salt(&self) -> bool {
        self.ow_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_salt(&mut self, v: u32) {
        self.ow_salt = ::std::option::Option::Some(v);
    }

    // optional uint64 ow_replay_id = 13;

    pub fn ow_replay_id(&self) -> u64 {
        self.ow_replay_id.unwrap_or(0)
    }

    pub fn clear_ow_replay_id(&mut self) {
        self.ow_replay_id = ::std::option::Option::None;
    }

    pub fn has_ow_replay_id(&self) -> bool {
        self.ow_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ow_replay_id(&mut self, v: u64) {
        self.ow_replay_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignoutResponse {
    const NAME: &'static str = "CMsgGameMatchSignoutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                21 => {
                    self.replay_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                34 => {
                    self.xp_reward_details.push(is.read_message()?);
                },
                40 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.metadata_private_key = ::std::option::Option::Some(is.read_fixed32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_details)?;
                },
                74 => {
                    self.players_metadata.push(is.read_message()?);
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.mvp_data)?;
                },
                89 => {
                    self.ow_private_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                101 => {
                    self.ow_salt = ::std::option::Option::Some(is.read_fixed32()?);
                },
                104 => {
                    self.ow_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                114 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.overworld_rewards)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.replay_salt {
            my_size += 1 + 4;
        }
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.xp_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.metadata_private_key {
            my_size += 1 + 4;
        }
        if let Some(v) = self.match_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.players_metadata {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.mvp_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ow_private_key {
            my_size += 1 + 8;
        }
        if let Some(v) = self.ow_salt {
            my_size += 1 + 4;
        }
        if let Some(v) = self.ow_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(13, v);
        }
        if let Some(v) = self.overworld_rewards.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.replay_salt {
            os.write_fixed32(2, v)?;
        }
        for v in &self.timed_reward_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.xp_reward_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.leagueid {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.metadata_private_key {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.match_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        for v in &self.players_metadata {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if let Some(v) = self.mvp_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.ow_private_key {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.ow_salt {
            os.write_fixed32(12, v)?;
        }
        if let Some(v) = self.ow_replay_id {
            os.write_uint64(13, v)?;
        }
        if let Some(v) = self.overworld_rewards.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignoutResponse {
        CMsgGameMatchSignoutResponse::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.replay_salt = ::std::option::Option::None;
        self.timed_reward_details.clear();
        self.xp_reward_details.clear();
        self.leagueid = ::std::option::Option::None;
        self.metadata_private_key = ::std::option::Option::None;
        self.match_details.clear();
        self.players_metadata.clear();
        self.mvp_data.clear();
        self.ow_private_key = ::std::option::Option::None;
        self.ow_salt = ::std::option::Option::None;
        self.ow_replay_id = ::std::option::Option::None;
        self.overworld_rewards.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignoutResponse {
        static instance: CMsgGameMatchSignoutResponse = CMsgGameMatchSignoutResponse {
            match_id: ::std::option::Option::None,
            replay_salt: ::std::option::Option::None,
            timed_reward_details: ::std::vec::Vec::new(),
            xp_reward_details: ::std::vec::Vec::new(),
            leagueid: ::std::option::Option::None,
            metadata_private_key: ::std::option::Option::None,
            match_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            players_metadata: ::std::vec::Vec::new(),
            mvp_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ow_private_key: ::std::option::Option::None,
            ow_salt: ::std::option::Option::None,
            ow_replay_id: ::std::option::Option::None,
            overworld_rewards: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameMatchSignoutResponse`
pub mod cmsg_game_match_signout_response {
    // @@protoc_insertion_point(message:CMsgGameMatchSignoutResponse.PlayerMetadata)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerMetadata {
        // message fields
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.avg_kills_x16)
        pub avg_kills_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.avg_deaths_x16)
        pub avg_deaths_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.avg_assists_x16)
        pub avg_assists_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.avg_gpm_x16)
        pub avg_gpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.avg_xpm_x16)
        pub avg_xpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.best_kills_x16)
        pub best_kills_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.best_assists_x16)
        pub best_assists_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.best_gpm_x16)
        pub best_gpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.best_xpm_x16)
        pub best_xpm_x16: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.win_streak)
        pub win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.best_win_streak)
        pub best_win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGameMatchSignoutResponse.PlayerMetadata.games_played)
        pub games_played: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGameMatchSignoutResponse.PlayerMetadata.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerMetadata {
        fn default() -> &'a PlayerMetadata {
            <PlayerMetadata as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerMetadata {
        pub fn new() -> PlayerMetadata {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_kills_x16 = 2;

        pub fn avg_kills_x16(&self) -> u32 {
            self.avg_kills_x16.unwrap_or(0)
        }

        pub fn clear_avg_kills_x16(&mut self) {
            self.avg_kills_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_kills_x16(&self) -> bool {
            self.avg_kills_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_kills_x16(&mut self, v: u32) {
            self.avg_kills_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_deaths_x16 = 3;

        pub fn avg_deaths_x16(&self) -> u32 {
            self.avg_deaths_x16.unwrap_or(0)
        }

        pub fn clear_avg_deaths_x16(&mut self) {
            self.avg_deaths_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_deaths_x16(&self) -> bool {
            self.avg_deaths_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_deaths_x16(&mut self, v: u32) {
            self.avg_deaths_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_assists_x16 = 4;

        pub fn avg_assists_x16(&self) -> u32 {
            self.avg_assists_x16.unwrap_or(0)
        }

        pub fn clear_avg_assists_x16(&mut self) {
            self.avg_assists_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_assists_x16(&self) -> bool {
            self.avg_assists_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_assists_x16(&mut self, v: u32) {
            self.avg_assists_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_gpm_x16 = 5;

        pub fn avg_gpm_x16(&self) -> u32 {
            self.avg_gpm_x16.unwrap_or(0)
        }

        pub fn clear_avg_gpm_x16(&mut self) {
            self.avg_gpm_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_gpm_x16(&self) -> bool {
            self.avg_gpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_gpm_x16(&mut self, v: u32) {
            self.avg_gpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_xpm_x16 = 6;

        pub fn avg_xpm_x16(&self) -> u32 {
            self.avg_xpm_x16.unwrap_or(0)
        }

        pub fn clear_avg_xpm_x16(&mut self) {
            self.avg_xpm_x16 = ::std::option::Option::None;
        }

        pub fn has_avg_xpm_x16(&self) -> bool {
            self.avg_xpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_xpm_x16(&mut self, v: u32) {
            self.avg_xpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_kills_x16 = 7;

        pub fn best_kills_x16(&self) -> u32 {
            self.best_kills_x16.unwrap_or(0)
        }

        pub fn clear_best_kills_x16(&mut self) {
            self.best_kills_x16 = ::std::option::Option::None;
        }

        pub fn has_best_kills_x16(&self) -> bool {
            self.best_kills_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_kills_x16(&mut self, v: u32) {
            self.best_kills_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_assists_x16 = 8;

        pub fn best_assists_x16(&self) -> u32 {
            self.best_assists_x16.unwrap_or(0)
        }

        pub fn clear_best_assists_x16(&mut self) {
            self.best_assists_x16 = ::std::option::Option::None;
        }

        pub fn has_best_assists_x16(&self) -> bool {
            self.best_assists_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_assists_x16(&mut self, v: u32) {
            self.best_assists_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_gpm_x16 = 9;

        pub fn best_gpm_x16(&self) -> u32 {
            self.best_gpm_x16.unwrap_or(0)
        }

        pub fn clear_best_gpm_x16(&mut self) {
            self.best_gpm_x16 = ::std::option::Option::None;
        }

        pub fn has_best_gpm_x16(&self) -> bool {
            self.best_gpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_gpm_x16(&mut self, v: u32) {
            self.best_gpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 best_xpm_x16 = 10;

        pub fn best_xpm_x16(&self) -> u32 {
            self.best_xpm_x16.unwrap_or(0)
        }

        pub fn clear_best_xpm_x16(&mut self) {
            self.best_xpm_x16 = ::std::option::Option::None;
        }

        pub fn has_best_xpm_x16(&self) -> bool {
            self.best_xpm_x16.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_xpm_x16(&mut self, v: u32) {
            self.best_xpm_x16 = ::std::option::Option::Some(v);
        }

        // optional uint32 win_streak = 11;

        pub fn win_streak(&self) -> u32 {
            self.win_streak.unwrap_or(0)
        }

        pub fn clear_win_streak(&mut self) {
            self.win_streak = ::std::option::Option::None;
        }

        pub fn has_win_streak(&self) -> bool {
            self.win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_streak(&mut self, v: u32) {
            self.win_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 best_win_streak = 12;

        pub fn best_win_streak(&self) -> u32 {
            self.best_win_streak.unwrap_or(0)
        }

        pub fn clear_best_win_streak(&mut self) {
            self.best_win_streak = ::std::option::Option::None;
        }

        pub fn has_best_win_streak(&self) -> bool {
            self.best_win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_win_streak(&mut self, v: u32) {
            self.best_win_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 games_played = 13;

        pub fn games_played(&self) -> u32 {
            self.games_played.unwrap_or(0)
        }

        pub fn clear_games_played(&mut self) {
            self.games_played = ::std::option::Option::None;
        }

        pub fn has_games_played(&self) -> bool {
            self.games_played.is_some()
        }

        // Param is passed by value, moved
        pub fn set_games_played(&mut self, v: u32) {
            self.games_played = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerMetadata {
        const NAME: &'static str = "PlayerMetadata";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.avg_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.avg_deaths_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.avg_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.avg_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.avg_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.best_kills_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.best_assists_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.best_gpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.best_xpm_x16 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.best_win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.games_played = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.avg_kills_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.avg_deaths_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.avg_assists_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.avg_gpm_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.avg_xpm_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.best_kills_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.best_assists_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.best_gpm_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.best_xpm_x16 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.win_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.best_win_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.games_played {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.avg_kills_x16 {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.avg_deaths_x16 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.avg_assists_x16 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.avg_gpm_x16 {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.avg_xpm_x16 {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.best_kills_x16 {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.best_assists_x16 {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.best_gpm_x16 {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.best_xpm_x16 {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.win_streak {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.best_win_streak {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.games_played {
                os.write_uint32(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerMetadata {
            PlayerMetadata::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.avg_kills_x16 = ::std::option::Option::None;
            self.avg_deaths_x16 = ::std::option::Option::None;
            self.avg_assists_x16 = ::std::option::Option::None;
            self.avg_gpm_x16 = ::std::option::Option::None;
            self.avg_xpm_x16 = ::std::option::Option::None;
            self.best_kills_x16 = ::std::option::Option::None;
            self.best_assists_x16 = ::std::option::Option::None;
            self.best_gpm_x16 = ::std::option::Option::None;
            self.best_xpm_x16 = ::std::option::Option::None;
            self.win_streak = ::std::option::Option::None;
            self.best_win_streak = ::std::option::Option::None;
            self.games_played = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerMetadata {
            static instance: PlayerMetadata = PlayerMetadata {
                hero_id: ::std::option::Option::None,
                avg_kills_x16: ::std::option::Option::None,
                avg_deaths_x16: ::std::option::Option::None,
                avg_assists_x16: ::std::option::Option::None,
                avg_gpm_x16: ::std::option::Option::None,
                avg_xpm_x16: ::std::option::Option::None,
                best_kills_x16: ::std::option::Option::None,
                best_assists_x16: ::std::option::Option::None,
                best_gpm_x16: ::std::option::Option::None,
                best_xpm_x16: ::std::option::Option::None,
                win_streak: ::std::option::Option::None,
                best_win_streak: ::std::option::Option::None,
                games_played: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgTimedRewardContainer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTimedRewardContainer {
    // message fields
    // @@protoc_insertion_point(field:CMsgTimedRewardContainer.timed_reward_details)
    pub timed_reward_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTimedRewardDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTimedRewardContainer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTimedRewardContainer {
    fn default() -> &'a CMsgTimedRewardContainer {
        <CMsgTimedRewardContainer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTimedRewardContainer {
    pub fn new() -> CMsgTimedRewardContainer {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTimedRewardContainer {
    const NAME: &'static str = "CMsgTimedRewardContainer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.timed_reward_details.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.timed_reward_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.timed_reward_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTimedRewardContainer {
        CMsgTimedRewardContainer::new()
    }

    fn clear(&mut self) {
        self.timed_reward_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTimedRewardContainer {
        static instance: CMsgTimedRewardContainer = CMsgTimedRewardContainer {
            timed_reward_details: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOutPermissionRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPermissionRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionRequest.server_version)
    pub server_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionRequest.local_attempt)
    pub local_attempt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionRequest.total_attempt)
    pub total_attempt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionRequest.seconds_waited)
    pub seconds_waited: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOutPermissionRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPermissionRequest {
    fn default() -> &'a CMsgGameMatchSignOutPermissionRequest {
        <CMsgGameMatchSignOutPermissionRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPermissionRequest {
    pub fn new() -> CMsgGameMatchSignOutPermissionRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }

    // optional uint32 local_attempt = 2;

    pub fn local_attempt(&self) -> u32 {
        self.local_attempt.unwrap_or(0)
    }

    pub fn clear_local_attempt(&mut self) {
        self.local_attempt = ::std::option::Option::None;
    }

    pub fn has_local_attempt(&self) -> bool {
        self.local_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_attempt(&mut self, v: u32) {
        self.local_attempt = ::std::option::Option::Some(v);
    }

    // optional uint32 total_attempt = 3;

    pub fn total_attempt(&self) -> u32 {
        self.total_attempt.unwrap_or(0)
    }

    pub fn clear_total_attempt(&mut self) {
        self.total_attempt = ::std::option::Option::None;
    }

    pub fn has_total_attempt(&self) -> bool {
        self.total_attempt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_attempt(&mut self, v: u32) {
        self.total_attempt = ::std::option::Option::Some(v);
    }

    // optional uint32 seconds_waited = 4;

    pub fn seconds_waited(&self) -> u32 {
        self.seconds_waited.unwrap_or(0)
    }

    pub fn clear_seconds_waited(&mut self) {
        self.seconds_waited = ::std::option::Option::None;
    }

    pub fn has_seconds_waited(&self) -> bool {
        self.seconds_waited.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds_waited(&mut self, v: u32) {
        self.seconds_waited = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOutPermissionRequest {
    const NAME: &'static str = "CMsgGameMatchSignOutPermissionRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.local_attempt = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.total_attempt = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.seconds_waited = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.local_attempt {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.total_attempt {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.seconds_waited {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.local_attempt {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_attempt {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.seconds_waited {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPermissionRequest {
        CMsgGameMatchSignOutPermissionRequest::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.local_attempt = ::std::option::Option::None;
        self.total_attempt = ::std::option::Option::None;
        self.seconds_waited = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPermissionRequest {
        static instance: CMsgGameMatchSignOutPermissionRequest = CMsgGameMatchSignOutPermissionRequest {
            server_version: ::std::option::Option::None,
            local_attempt: ::std::option::Option::None,
            total_attempt: ::std::option::Option::None,
            seconds_waited: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOutPermissionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPermissionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionResponse.permission_granted)
    pub permission_granted: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionResponse.abandon_signout)
    pub abandon_signout: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPermissionResponse.retry_delay_seconds)
    pub retry_delay_seconds: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOutPermissionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPermissionResponse {
    fn default() -> &'a CMsgGameMatchSignOutPermissionResponse {
        <CMsgGameMatchSignOutPermissionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPermissionResponse {
    pub fn new() -> CMsgGameMatchSignOutPermissionResponse {
        ::std::default::Default::default()
    }

    // optional bool permission_granted = 1;

    pub fn permission_granted(&self) -> bool {
        self.permission_granted.unwrap_or(false)
    }

    pub fn clear_permission_granted(&mut self) {
        self.permission_granted = ::std::option::Option::None;
    }

    pub fn has_permission_granted(&self) -> bool {
        self.permission_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_permission_granted(&mut self, v: bool) {
        self.permission_granted = ::std::option::Option::Some(v);
    }

    // optional bool abandon_signout = 2;

    pub fn abandon_signout(&self) -> bool {
        self.abandon_signout.unwrap_or(false)
    }

    pub fn clear_abandon_signout(&mut self) {
        self.abandon_signout = ::std::option::Option::None;
    }

    pub fn has_abandon_signout(&self) -> bool {
        self.abandon_signout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_abandon_signout(&mut self, v: bool) {
        self.abandon_signout = ::std::option::Option::Some(v);
    }

    // optional uint32 retry_delay_seconds = 3;

    pub fn retry_delay_seconds(&self) -> u32 {
        self.retry_delay_seconds.unwrap_or(0u32)
    }

    pub fn clear_retry_delay_seconds(&mut self) {
        self.retry_delay_seconds = ::std::option::Option::None;
    }

    pub fn has_retry_delay_seconds(&self) -> bool {
        self.retry_delay_seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retry_delay_seconds(&mut self, v: u32) {
        self.retry_delay_seconds = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOutPermissionResponse {
    const NAME: &'static str = "CMsgGameMatchSignOutPermissionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.permission_granted = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.abandon_signout = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.retry_delay_seconds = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.permission_granted {
            my_size += 1 + 1;
        }
        if let Some(v) = self.abandon_signout {
            my_size += 1 + 1;
        }
        if let Some(v) = self.retry_delay_seconds {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.permission_granted {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.abandon_signout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.retry_delay_seconds {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPermissionResponse {
        CMsgGameMatchSignOutPermissionResponse::new()
    }

    fn clear(&mut self) {
        self.permission_granted = ::std::option::Option::None;
        self.abandon_signout = ::std::option::Option::None;
        self.retry_delay_seconds = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPermissionResponse {
        static instance: CMsgGameMatchSignOutPermissionResponse = CMsgGameMatchSignOutPermissionResponse {
            permission_granted: ::std::option::Option::None,
            abandon_signout: ::std::option::Option::None,
            retry_delay_seconds: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOutEventGameData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutEventGameData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutEventGameData.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutEventGameData.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutEventGameData.map_name)
    pub map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutEventGameData.event_game_data)
    pub event_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutEventGameData.start_time)
    pub start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOutEventGameData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutEventGameData {
    fn default() -> &'a CMsgGameMatchSignOutEventGameData {
        <CMsgGameMatchSignOutEventGameData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutEventGameData {
    pub fn new() -> CMsgGameMatchSignOutEventGameData {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string map_name = 3;

    pub fn map_name(&self) -> &str {
        match self.map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_map_name(&mut self) {
        self.map_name = ::std::option::Option::None;
    }

    pub fn has_map_name(&self) -> bool {
        self.map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_name(&mut self, v: ::std::string::String) {
        self.map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_map_name(&mut self) -> &mut ::std::string::String {
        if self.map_name.is_none() {
            self.map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_map_name(&mut self) -> ::std::string::String {
        self.map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes event_game_data = 4;

    pub fn event_game_data(&self) -> &[u8] {
        match self.event_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_data(&mut self) {
        self.event_game_data = ::std::option::Option::None;
    }

    pub fn has_event_game_data(&self) -> bool {
        self.event_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_data.is_none() {
            self.event_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 start_time = 5;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOutEventGameData {
    const NAME: &'static str = "CMsgGameMatchSignOutEventGameData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.map_name = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.event_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                40 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.map_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.event_game_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.start_time {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutEventGameData {
        CMsgGameMatchSignOutEventGameData::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.map_name = ::std::option::Option::None;
        self.event_game_data = ::std::option::Option::None;
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutEventGameData {
        static instance: CMsgGameMatchSignOutEventGameData = CMsgGameMatchSignOutEventGameData {
            event_id: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            map_name: ::std::option::Option::None,
            event_game_data: ::std::option::Option::None,
            start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOutPerfData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutPerfData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_frame_time)
    pub average_frame_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_frame_time)
    pub max_frame_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.server_average_frame_time)
    pub server_average_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.server_max_frame_time)
    pub server_max_frame_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_compute_time)
    pub average_compute_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_compute_time)
    pub max_compute_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_client_tick_time)
    pub average_client_tick_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_client_tick_time)
    pub max_client_tick_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_client_simulate_time)
    pub average_client_simulate_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_client_simulate_time)
    pub max_client_simulate_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_output_time)
    pub average_output_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_output_time)
    pub max_output_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_wait_for_rendering_to_complete_time)
    pub average_wait_for_rendering_to_complete_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_wait_for_rendering_to_complete_time)
    pub max_wait_for_rendering_to_complete_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_swap_time)
    pub average_swap_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_swap_time)
    pub max_swap_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_frame_update_time)
    pub average_frame_update_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_frame_update_time)
    pub max_frame_update_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_idle_time)
    pub average_idle_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_idle_time)
    pub max_idle_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.average_input_processing_time)
    pub average_input_processing_time: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutPerfData.max_input_processing_time)
    pub max_input_processing_time: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOutPerfData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutPerfData {
    fn default() -> &'a CMsgGameMatchSignOutPerfData {
        <CMsgGameMatchSignOutPerfData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutPerfData {
    pub fn new() -> CMsgGameMatchSignOutPerfData {
        ::std::default::Default::default()
    }

    // optional float server_average_frame_time = 3;

    pub fn server_average_frame_time(&self) -> f32 {
        self.server_average_frame_time.unwrap_or(0.)
    }

    pub fn clear_server_average_frame_time(&mut self) {
        self.server_average_frame_time = ::std::option::Option::None;
    }

    pub fn has_server_average_frame_time(&self) -> bool {
        self.server_average_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_average_frame_time(&mut self, v: f32) {
        self.server_average_frame_time = ::std::option::Option::Some(v);
    }

    // optional float server_max_frame_time = 4;

    pub fn server_max_frame_time(&self) -> f32 {
        self.server_max_frame_time.unwrap_or(0.)
    }

    pub fn clear_server_max_frame_time(&mut self) {
        self.server_max_frame_time = ::std::option::Option::None;
    }

    pub fn has_server_max_frame_time(&self) -> bool {
        self.server_max_frame_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_max_frame_time(&mut self, v: f32) {
        self.server_max_frame_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOutPerfData {
    const NAME: &'static str = "CMsgGameMatchSignOutPerfData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.average_frame_time)?;
                },
                13 => {
                    self.average_frame_time.push(is.read_float()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.max_frame_time)?;
                },
                21 => {
                    self.max_frame_time.push(is.read_float()?);
                },
                29 => {
                    self.server_average_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.server_max_frame_time = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    is.read_repeated_packed_float_into(&mut self.average_compute_time)?;
                },
                45 => {
                    self.average_compute_time.push(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_float_into(&mut self.max_compute_time)?;
                },
                53 => {
                    self.max_compute_time.push(is.read_float()?);
                },
                58 => {
                    is.read_repeated_packed_float_into(&mut self.average_client_tick_time)?;
                },
                61 => {
                    self.average_client_tick_time.push(is.read_float()?);
                },
                66 => {
                    is.read_repeated_packed_float_into(&mut self.max_client_tick_time)?;
                },
                69 => {
                    self.max_client_tick_time.push(is.read_float()?);
                },
                74 => {
                    is.read_repeated_packed_float_into(&mut self.average_client_simulate_time)?;
                },
                77 => {
                    self.average_client_simulate_time.push(is.read_float()?);
                },
                82 => {
                    is.read_repeated_packed_float_into(&mut self.max_client_simulate_time)?;
                },
                85 => {
                    self.max_client_simulate_time.push(is.read_float()?);
                },
                90 => {
                    is.read_repeated_packed_float_into(&mut self.average_output_time)?;
                },
                93 => {
                    self.average_output_time.push(is.read_float()?);
                },
                98 => {
                    is.read_repeated_packed_float_into(&mut self.max_output_time)?;
                },
                101 => {
                    self.max_output_time.push(is.read_float()?);
                },
                106 => {
                    is.read_repeated_packed_float_into(&mut self.average_wait_for_rendering_to_complete_time)?;
                },
                109 => {
                    self.average_wait_for_rendering_to_complete_time.push(is.read_float()?);
                },
                114 => {
                    is.read_repeated_packed_float_into(&mut self.max_wait_for_rendering_to_complete_time)?;
                },
                117 => {
                    self.max_wait_for_rendering_to_complete_time.push(is.read_float()?);
                },
                122 => {
                    is.read_repeated_packed_float_into(&mut self.average_swap_time)?;
                },
                125 => {
                    self.average_swap_time.push(is.read_float()?);
                },
                130 => {
                    is.read_repeated_packed_float_into(&mut self.max_swap_time)?;
                },
                133 => {
                    self.max_swap_time.push(is.read_float()?);
                },
                138 => {
                    is.read_repeated_packed_float_into(&mut self.average_frame_update_time)?;
                },
                141 => {
                    self.average_frame_update_time.push(is.read_float()?);
                },
                146 => {
                    is.read_repeated_packed_float_into(&mut self.max_frame_update_time)?;
                },
                149 => {
                    self.max_frame_update_time.push(is.read_float()?);
                },
                154 => {
                    is.read_repeated_packed_float_into(&mut self.average_idle_time)?;
                },
                157 => {
                    self.average_idle_time.push(is.read_float()?);
                },
                162 => {
                    is.read_repeated_packed_float_into(&mut self.max_idle_time)?;
                },
                165 => {
                    self.max_idle_time.push(is.read_float()?);
                },
                170 => {
                    is.read_repeated_packed_float_into(&mut self.average_input_processing_time)?;
                },
                173 => {
                    self.average_input_processing_time.push(is.read_float()?);
                },
                178 => {
                    is.read_repeated_packed_float_into(&mut self.max_input_processing_time)?;
                },
                181 => {
                    self.max_input_processing_time.push(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.average_frame_time.len() as u64;
        my_size += 5 * self.max_frame_time.len() as u64;
        if let Some(v) = self.server_average_frame_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.server_max_frame_time {
            my_size += 1 + 4;
        }
        my_size += 5 * self.average_compute_time.len() as u64;
        my_size += 5 * self.max_compute_time.len() as u64;
        my_size += 5 * self.average_client_tick_time.len() as u64;
        my_size += 5 * self.max_client_tick_time.len() as u64;
        my_size += 5 * self.average_client_simulate_time.len() as u64;
        my_size += 5 * self.max_client_simulate_time.len() as u64;
        my_size += 5 * self.average_output_time.len() as u64;
        my_size += 5 * self.max_output_time.len() as u64;
        my_size += 5 * self.average_wait_for_rendering_to_complete_time.len() as u64;
        my_size += 5 * self.max_wait_for_rendering_to_complete_time.len() as u64;
        my_size += 5 * self.average_swap_time.len() as u64;
        my_size += 6 * self.max_swap_time.len() as u64;
        my_size += 6 * self.average_frame_update_time.len() as u64;
        my_size += 6 * self.max_frame_update_time.len() as u64;
        my_size += 6 * self.average_idle_time.len() as u64;
        my_size += 6 * self.max_idle_time.len() as u64;
        my_size += 6 * self.average_input_processing_time.len() as u64;
        my_size += 6 * self.max_input_processing_time.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.average_frame_time {
            os.write_float(1, *v)?;
        };
        for v in &self.max_frame_time {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.server_average_frame_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.server_max_frame_time {
            os.write_float(4, v)?;
        }
        for v in &self.average_compute_time {
            os.write_float(5, *v)?;
        };
        for v in &self.max_compute_time {
            os.write_float(6, *v)?;
        };
        for v in &self.average_client_tick_time {
            os.write_float(7, *v)?;
        };
        for v in &self.max_client_tick_time {
            os.write_float(8, *v)?;
        };
        for v in &self.average_client_simulate_time {
            os.write_float(9, *v)?;
        };
        for v in &self.max_client_simulate_time {
            os.write_float(10, *v)?;
        };
        for v in &self.average_output_time {
            os.write_float(11, *v)?;
        };
        for v in &self.max_output_time {
            os.write_float(12, *v)?;
        };
        for v in &self.average_wait_for_rendering_to_complete_time {
            os.write_float(13, *v)?;
        };
        for v in &self.max_wait_for_rendering_to_complete_time {
            os.write_float(14, *v)?;
        };
        for v in &self.average_swap_time {
            os.write_float(15, *v)?;
        };
        for v in &self.max_swap_time {
            os.write_float(16, *v)?;
        };
        for v in &self.average_frame_update_time {
            os.write_float(17, *v)?;
        };
        for v in &self.max_frame_update_time {
            os.write_float(18, *v)?;
        };
        for v in &self.average_idle_time {
            os.write_float(19, *v)?;
        };
        for v in &self.max_idle_time {
            os.write_float(20, *v)?;
        };
        for v in &self.average_input_processing_time {
            os.write_float(21, *v)?;
        };
        for v in &self.max_input_processing_time {
            os.write_float(22, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutPerfData {
        CMsgGameMatchSignOutPerfData::new()
    }

    fn clear(&mut self) {
        self.average_frame_time.clear();
        self.max_frame_time.clear();
        self.server_average_frame_time = ::std::option::Option::None;
        self.server_max_frame_time = ::std::option::Option::None;
        self.average_compute_time.clear();
        self.max_compute_time.clear();
        self.average_client_tick_time.clear();
        self.max_client_tick_time.clear();
        self.average_client_simulate_time.clear();
        self.max_client_simulate_time.clear();
        self.average_output_time.clear();
        self.max_output_time.clear();
        self.average_wait_for_rendering_to_complete_time.clear();
        self.max_wait_for_rendering_to_complete_time.clear();
        self.average_swap_time.clear();
        self.max_swap_time.clear();
        self.average_frame_update_time.clear();
        self.max_frame_update_time.clear();
        self.average_idle_time.clear();
        self.max_idle_time.clear();
        self.average_input_processing_time.clear();
        self.max_input_processing_time.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutPerfData {
        static instance: CMsgGameMatchSignOutPerfData = CMsgGameMatchSignOutPerfData {
            average_frame_time: ::std::vec::Vec::new(),
            max_frame_time: ::std::vec::Vec::new(),
            server_average_frame_time: ::std::option::Option::None,
            server_max_frame_time: ::std::option::Option::None,
            average_compute_time: ::std::vec::Vec::new(),
            max_compute_time: ::std::vec::Vec::new(),
            average_client_tick_time: ::std::vec::Vec::new(),
            max_client_tick_time: ::std::vec::Vec::new(),
            average_client_simulate_time: ::std::vec::Vec::new(),
            max_client_simulate_time: ::std::vec::Vec::new(),
            average_output_time: ::std::vec::Vec::new(),
            max_output_time: ::std::vec::Vec::new(),
            average_wait_for_rendering_to_complete_time: ::std::vec::Vec::new(),
            max_wait_for_rendering_to_complete_time: ::std::vec::Vec::new(),
            average_swap_time: ::std::vec::Vec::new(),
            max_swap_time: ::std::vec::Vec::new(),
            average_frame_update_time: ::std::vec::Vec::new(),
            max_frame_update_time: ::std::vec::Vec::new(),
            average_idle_time: ::std::vec::Vec::new(),
            max_idle_time: ::std::vec::Vec::new(),
            average_input_processing_time: ::std::vec::Vec::new(),
            max_input_processing_time: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameMatchSignOutBanData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameMatchSignOutBanData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutBanData.hero_bans)
    pub hero_bans: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgGameMatchSignOutBanData.hero_ban_votes)
    pub hero_ban_votes: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameMatchSignOutBanData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameMatchSignOutBanData {
    fn default() -> &'a CMsgGameMatchSignOutBanData {
        <CMsgGameMatchSignOutBanData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameMatchSignOutBanData {
    pub fn new() -> CMsgGameMatchSignOutBanData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameMatchSignOutBanData {
    const NAME: &'static str = "CMsgGameMatchSignOutBanData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.hero_bans)?;
                },
                8 => {
                    self.hero_bans.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.hero_ban_votes)?;
                },
                16 => {
                    self.hero_ban_votes.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_bans {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.hero_ban_votes {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_bans {
            os.write_int32(1, *v)?;
        };
        for v in &self.hero_ban_votes {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameMatchSignOutBanData {
        CMsgGameMatchSignOutBanData::new()
    }

    fn clear(&mut self) {
        self.hero_bans.clear();
        self.hero_ban_votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameMatchSignOutBanData {
        static instance: CMsgGameMatchSignOutBanData = CMsgGameMatchSignOutBanData {
            hero_bans: ::std::vec::Vec::new(),
            hero_ban_votes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALiveScoreboardUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALiveScoreboardUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.tournament_id)
    pub tournament_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.tournament_game_id)
    pub tournament_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.duration)
    pub duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.hltv_delay)
    pub hltv_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.team_good)
    pub team_good: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotalive_scoreboard_update::Team>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.team_bad)
    pub team_bad: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotalive_scoreboard_update::Team>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.roshan_respawn_timer)
    pub roshan_respawn_timer: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALiveScoreboardUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALiveScoreboardUpdate {
    fn default() -> &'a CMsgDOTALiveScoreboardUpdate {
        <CMsgDOTALiveScoreboardUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALiveScoreboardUpdate {
    pub fn new() -> CMsgDOTALiveScoreboardUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 tournament_id = 1;

    pub fn tournament_id(&self) -> u32 {
        self.tournament_id.unwrap_or(0)
    }

    pub fn clear_tournament_id(&mut self) {
        self.tournament_id = ::std::option::Option::None;
    }

    pub fn has_tournament_id(&self) -> bool {
        self.tournament_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_id(&mut self, v: u32) {
        self.tournament_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tournament_game_id = 2;

    pub fn tournament_game_id(&self) -> u32 {
        self.tournament_game_id.unwrap_or(0)
    }

    pub fn clear_tournament_game_id(&mut self) {
        self.tournament_game_id = ::std::option::Option::None;
    }

    pub fn has_tournament_game_id(&self) -> bool {
        self.tournament_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_game_id(&mut self, v: u32) {
        self.tournament_game_id = ::std::option::Option::Some(v);
    }

    // optional float duration = 3;

    pub fn duration(&self) -> f32 {
        self.duration.unwrap_or(0.)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional int32 hltv_delay = 4;

    pub fn hltv_delay(&self) -> i32 {
        self.hltv_delay.unwrap_or(0)
    }

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: i32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 roshan_respawn_timer = 7;

    pub fn roshan_respawn_timer(&self) -> u32 {
        self.roshan_respawn_timer.unwrap_or(0)
    }

    pub fn clear_roshan_respawn_timer(&mut self) {
        self.roshan_respawn_timer = ::std::option::Option::None;
    }

    pub fn has_roshan_respawn_timer(&self) -> bool {
        self.roshan_respawn_timer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_roshan_respawn_timer(&mut self, v: u32) {
        self.roshan_respawn_timer = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 8;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 9;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALiveScoreboardUpdate {
    const NAME: &'static str = "CMsgDOTALiveScoreboardUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.tournament_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.hltv_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.team_good)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.team_bad)?;
                },
                56 => {
                    self.roshan_respawn_timer = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tournament_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.tournament_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hltv_delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.team_good.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.team_bad.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.roshan_respawn_timer {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tournament_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.tournament_game_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.team_good.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.team_bad.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.roshan_respawn_timer {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALiveScoreboardUpdate {
        CMsgDOTALiveScoreboardUpdate::new()
    }

    fn clear(&mut self) {
        self.tournament_id = ::std::option::Option::None;
        self.tournament_game_id = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.hltv_delay = ::std::option::Option::None;
        self.team_good.clear();
        self.team_bad.clear();
        self.roshan_respawn_timer = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALiveScoreboardUpdate {
        static instance: CMsgDOTALiveScoreboardUpdate = CMsgDOTALiveScoreboardUpdate {
            tournament_id: ::std::option::Option::None,
            tournament_game_id: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            hltv_delay: ::std::option::Option::None,
            team_good: ::steam_vent_proto_common::protobuf::MessageField::none(),
            team_bad: ::steam_vent_proto_common::protobuf::MessageField::none(),
            roshan_respawn_timer: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTALiveScoreboardUpdate`
pub mod cmsg_dotalive_scoreboard_update {
    // @@protoc_insertion_point(message:CMsgDOTALiveScoreboardUpdate.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.players)
        pub players: ::std::vec::Vec<team::Player>,
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.score)
        pub score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.tower_state)
        pub tower_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.barracks_state)
        pub barracks_state: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.hero_picks)
        pub hero_picks: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.hero_bans)
        pub hero_bans: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTALiveScoreboardUpdate.Team.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }

        // optional uint32 tower_state = 3;

        pub fn tower_state(&self) -> u32 {
            self.tower_state.unwrap_or(0)
        }

        pub fn clear_tower_state(&mut self) {
            self.tower_state = ::std::option::Option::None;
        }

        pub fn has_tower_state(&self) -> bool {
            self.tower_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tower_state(&mut self, v: u32) {
            self.tower_state = ::std::option::Option::Some(v);
        }

        // optional uint32 barracks_state = 4;

        pub fn barracks_state(&self) -> u32 {
            self.barracks_state.unwrap_or(0)
        }

        pub fn clear_barracks_state(&mut self) {
            self.barracks_state = ::std::option::Option::None;
        }

        pub fn has_barracks_state(&self) -> bool {
            self.barracks_state.is_some()
        }

        // Param is passed by value, moved
        pub fn set_barracks_state(&mut self, v: u32) {
            self.barracks_state = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.players.push(is.read_message()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.tower_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.barracks_state = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.hero_picks)?;
                    },
                    40 => {
                        self.hero_picks.push(is.read_int32()?);
                    },
                    50 => {
                        is.read_repeated_packed_int32_into(&mut self.hero_bans)?;
                    },
                    48 => {
                        self.hero_bans.push(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.players {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.tower_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.barracks_state {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.hero_picks {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
            };
            for value in &self.hero_bans {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.players {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.tower_state {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.barracks_state {
                os.write_uint32(4, v)?;
            }
            for v in &self.hero_picks {
                os.write_int32(5, *v)?;
            };
            for v in &self.hero_bans {
                os.write_int32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.players.clear();
            self.score = ::std::option::Option::None;
            self.tower_state = ::std::option::Option::None;
            self.barracks_state = ::std::option::Option::None;
            self.hero_picks.clear();
            self.hero_bans.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                players: ::std::vec::Vec::new(),
                score: ::std::option::Option::None,
                tower_state: ::std::option::Option::None,
                barracks_state: ::std::option::Option::None,
                hero_picks: ::std::vec::Vec::new(),
                hero_bans: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Team`
    pub mod team {
        // @@protoc_insertion_point(message:CMsgDOTALiveScoreboardUpdate.Team.Player)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct Player {
            // message fields
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.player_slot)
            pub player_slot: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.player_name)
            pub player_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.hero_name)
            pub hero_name: ::std::option::Option<::std::string::String>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.hero_id)
            pub hero_id: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.kills)
            pub kills: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.deaths)
            pub deaths: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.assists)
            pub assists: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.last_hits)
            pub last_hits: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.denies)
            pub denies: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.gold)
            pub gold: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.level)
            pub level: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.gold_per_min)
            pub gold_per_min: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.xp_per_min)
            pub xp_per_min: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.ultimate_state)
            pub ultimate_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<player::DOTAUltimateState>>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.ultimate_cooldown)
            pub ultimate_cooldown: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item0)
            pub item0: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item1)
            pub item1: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item2)
            pub item2: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item3)
            pub item3: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item4)
            pub item4: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.item5)
            pub item5: ::std::option::Option<i32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.respawn_timer)
            pub respawn_timer: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.account_id)
            pub account_id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.position_x)
            pub position_x: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.position_y)
            pub position_y: ::std::option::Option<f32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.net_worth)
            pub net_worth: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.abilities)
            pub abilities: ::std::vec::Vec<player::HeroAbility>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgDOTALiveScoreboardUpdate.Team.Player.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a Player {
            fn default() -> &'a Player {
                <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl Player {
            pub fn new() -> Player {
                ::std::default::Default::default()
            }

            // optional uint32 player_slot = 1;

            pub fn player_slot(&self) -> u32 {
                self.player_slot.unwrap_or(0)
            }

            pub fn clear_player_slot(&mut self) {
                self.player_slot = ::std::option::Option::None;
            }

            pub fn has_player_slot(&self) -> bool {
                self.player_slot.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_slot(&mut self, v: u32) {
                self.player_slot = ::std::option::Option::Some(v);
            }

            // optional string player_name = 2;

            pub fn player_name(&self) -> &str {
                match self.player_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_player_name(&mut self) {
                self.player_name = ::std::option::Option::None;
            }

            pub fn has_player_name(&self) -> bool {
                self.player_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_player_name(&mut self, v: ::std::string::String) {
                self.player_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
                if self.player_name.is_none() {
                    self.player_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.player_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_player_name(&mut self) -> ::std::string::String {
                self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional string hero_name = 3;

            pub fn hero_name(&self) -> &str {
                match self.hero_name.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_hero_name(&mut self) {
                self.hero_name = ::std::option::Option::None;
            }

            pub fn has_hero_name(&self) -> bool {
                self.hero_name.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_name(&mut self, v: ::std::string::String) {
                self.hero_name = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_hero_name(&mut self) -> &mut ::std::string::String {
                if self.hero_name.is_none() {
                    self.hero_name = ::std::option::Option::Some(::std::string::String::new());
                }
                self.hero_name.as_mut().unwrap()
            }

            // Take field
            pub fn take_hero_name(&mut self) -> ::std::string::String {
                self.hero_name.take().unwrap_or_else(|| ::std::string::String::new())
            }

            // optional int32 hero_id = 4;

            pub fn hero_id(&self) -> i32 {
                self.hero_id.unwrap_or(0)
            }

            pub fn clear_hero_id(&mut self) {
                self.hero_id = ::std::option::Option::None;
            }

            pub fn has_hero_id(&self) -> bool {
                self.hero_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_hero_id(&mut self, v: i32) {
                self.hero_id = ::std::option::Option::Some(v);
            }

            // optional uint32 kills = 5;

            pub fn kills(&self) -> u32 {
                self.kills.unwrap_or(0)
            }

            pub fn clear_kills(&mut self) {
                self.kills = ::std::option::Option::None;
            }

            pub fn has_kills(&self) -> bool {
                self.kills.is_some()
            }

            // Param is passed by value, moved
            pub fn set_kills(&mut self, v: u32) {
                self.kills = ::std::option::Option::Some(v);
            }

            // optional uint32 deaths = 6;

            pub fn deaths(&self) -> u32 {
                self.deaths.unwrap_or(0)
            }

            pub fn clear_deaths(&mut self) {
                self.deaths = ::std::option::Option::None;
            }

            pub fn has_deaths(&self) -> bool {
                self.deaths.is_some()
            }

            // Param is passed by value, moved
            pub fn set_deaths(&mut self, v: u32) {
                self.deaths = ::std::option::Option::Some(v);
            }

            // optional uint32 assists = 7;

            pub fn assists(&self) -> u32 {
                self.assists.unwrap_or(0)
            }

            pub fn clear_assists(&mut self) {
                self.assists = ::std::option::Option::None;
            }

            pub fn has_assists(&self) -> bool {
                self.assists.is_some()
            }

            // Param is passed by value, moved
            pub fn set_assists(&mut self, v: u32) {
                self.assists = ::std::option::Option::Some(v);
            }

            // optional uint32 last_hits = 8;

            pub fn last_hits(&self) -> u32 {
                self.last_hits.unwrap_or(0)
            }

            pub fn clear_last_hits(&mut self) {
                self.last_hits = ::std::option::Option::None;
            }

            pub fn has_last_hits(&self) -> bool {
                self.last_hits.is_some()
            }

            // Param is passed by value, moved
            pub fn set_last_hits(&mut self, v: u32) {
                self.last_hits = ::std::option::Option::Some(v);
            }

            // optional uint32 denies = 9;

            pub fn denies(&self) -> u32 {
                self.denies.unwrap_or(0)
            }

            pub fn clear_denies(&mut self) {
                self.denies = ::std::option::Option::None;
            }

            pub fn has_denies(&self) -> bool {
                self.denies.is_some()
            }

            // Param is passed by value, moved
            pub fn set_denies(&mut self, v: u32) {
                self.denies = ::std::option::Option::Some(v);
            }

            // optional uint32 gold = 10;

            pub fn gold(&self) -> u32 {
                self.gold.unwrap_or(0)
            }

            pub fn clear_gold(&mut self) {
                self.gold = ::std::option::Option::None;
            }

            pub fn has_gold(&self) -> bool {
                self.gold.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold(&mut self, v: u32) {
                self.gold = ::std::option::Option::Some(v);
            }

            // optional uint32 level = 11;

            pub fn level(&self) -> u32 {
                self.level.unwrap_or(0)
            }

            pub fn clear_level(&mut self) {
                self.level = ::std::option::Option::None;
            }

            pub fn has_level(&self) -> bool {
                self.level.is_some()
            }

            // Param is passed by value, moved
            pub fn set_level(&mut self, v: u32) {
                self.level = ::std::option::Option::Some(v);
            }

            // optional float gold_per_min = 12;

            pub fn gold_per_min(&self) -> f32 {
                self.gold_per_min.unwrap_or(0.)
            }

            pub fn clear_gold_per_min(&mut self) {
                self.gold_per_min = ::std::option::Option::None;
            }

            pub fn has_gold_per_min(&self) -> bool {
                self.gold_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_gold_per_min(&mut self, v: f32) {
                self.gold_per_min = ::std::option::Option::Some(v);
            }

            // optional float xp_per_min = 13;

            pub fn xp_per_min(&self) -> f32 {
                self.xp_per_min.unwrap_or(0.)
            }

            pub fn clear_xp_per_min(&mut self) {
                self.xp_per_min = ::std::option::Option::None;
            }

            pub fn has_xp_per_min(&self) -> bool {
                self.xp_per_min.is_some()
            }

            // Param is passed by value, moved
            pub fn set_xp_per_min(&mut self, v: f32) {
                self.xp_per_min = ::std::option::Option::Some(v);
            }

            // optional .CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState ultimate_state = 14;

            pub fn ultimate_state(&self) -> player::DOTAUltimateState {
                match self.ultimate_state {
                    Some(e) => e.enum_value_or(player::DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                    None => player::DOTAUltimateState::k_EDOTAUltimateStateNotLearned,
                }
            }

            pub fn clear_ultimate_state(&mut self) {
                self.ultimate_state = ::std::option::Option::None;
            }

            pub fn has_ultimate_state(&self) -> bool {
                self.ultimate_state.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ultimate_state(&mut self, v: player::DOTAUltimateState) {
                self.ultimate_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
            }

            // optional float ultimate_cooldown = 15;

            pub fn ultimate_cooldown(&self) -> f32 {
                self.ultimate_cooldown.unwrap_or(0.)
            }

            pub fn clear_ultimate_cooldown(&mut self) {
                self.ultimate_cooldown = ::std::option::Option::None;
            }

            pub fn has_ultimate_cooldown(&self) -> bool {
                self.ultimate_cooldown.is_some()
            }

            // Param is passed by value, moved
            pub fn set_ultimate_cooldown(&mut self, v: f32) {
                self.ultimate_cooldown = ::std::option::Option::Some(v);
            }

            // optional int32 item0 = 16;

            pub fn item0(&self) -> i32 {
                self.item0.unwrap_or(-1i32)
            }

            pub fn clear_item0(&mut self) {
                self.item0 = ::std::option::Option::None;
            }

            pub fn has_item0(&self) -> bool {
                self.item0.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item0(&mut self, v: i32) {
                self.item0 = ::std::option::Option::Some(v);
            }

            // optional int32 item1 = 17;

            pub fn item1(&self) -> i32 {
                self.item1.unwrap_or(-1i32)
            }

            pub fn clear_item1(&mut self) {
                self.item1 = ::std::option::Option::None;
            }

            pub fn has_item1(&self) -> bool {
                self.item1.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item1(&mut self, v: i32) {
                self.item1 = ::std::option::Option::Some(v);
            }

            // optional int32 item2 = 18;

            pub fn item2(&self) -> i32 {
                self.item2.unwrap_or(-1i32)
            }

            pub fn clear_item2(&mut self) {
                self.item2 = ::std::option::Option::None;
            }

            pub fn has_item2(&self) -> bool {
                self.item2.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item2(&mut self, v: i32) {
                self.item2 = ::std::option::Option::Some(v);
            }

            // optional int32 item3 = 19;

            pub fn item3(&self) -> i32 {
                self.item3.unwrap_or(-1i32)
            }

            pub fn clear_item3(&mut self) {
                self.item3 = ::std::option::Option::None;
            }

            pub fn has_item3(&self) -> bool {
                self.item3.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item3(&mut self, v: i32) {
                self.item3 = ::std::option::Option::Some(v);
            }

            // optional int32 item4 = 20;

            pub fn item4(&self) -> i32 {
                self.item4.unwrap_or(-1i32)
            }

            pub fn clear_item4(&mut self) {
                self.item4 = ::std::option::Option::None;
            }

            pub fn has_item4(&self) -> bool {
                self.item4.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item4(&mut self, v: i32) {
                self.item4 = ::std::option::Option::Some(v);
            }

            // optional int32 item5 = 21;

            pub fn item5(&self) -> i32 {
                self.item5.unwrap_or(-1i32)
            }

            pub fn clear_item5(&mut self) {
                self.item5 = ::std::option::Option::None;
            }

            pub fn has_item5(&self) -> bool {
                self.item5.is_some()
            }

            // Param is passed by value, moved
            pub fn set_item5(&mut self, v: i32) {
                self.item5 = ::std::option::Option::Some(v);
            }

            // optional uint32 respawn_timer = 22;

            pub fn respawn_timer(&self) -> u32 {
                self.respawn_timer.unwrap_or(0)
            }

            pub fn clear_respawn_timer(&mut self) {
                self.respawn_timer = ::std::option::Option::None;
            }

            pub fn has_respawn_timer(&self) -> bool {
                self.respawn_timer.is_some()
            }

            // Param is passed by value, moved
            pub fn set_respawn_timer(&mut self, v: u32) {
                self.respawn_timer = ::std::option::Option::Some(v);
            }

            // optional uint32 account_id = 23;

            pub fn account_id(&self) -> u32 {
                self.account_id.unwrap_or(0)
            }

            pub fn clear_account_id(&mut self) {
                self.account_id = ::std::option::Option::None;
            }

            pub fn has_account_id(&self) -> bool {
                self.account_id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_account_id(&mut self, v: u32) {
                self.account_id = ::std::option::Option::Some(v);
            }

            // optional float position_x = 24;

            pub fn position_x(&self) -> f32 {
                self.position_x.unwrap_or(0.)
            }

            pub fn clear_position_x(&mut self) {
                self.position_x = ::std::option::Option::None;
            }

            pub fn has_position_x(&self) -> bool {
                self.position_x.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_x(&mut self, v: f32) {
                self.position_x = ::std::option::Option::Some(v);
            }

            // optional float position_y = 25;

            pub fn position_y(&self) -> f32 {
                self.position_y.unwrap_or(0.)
            }

            pub fn clear_position_y(&mut self) {
                self.position_y = ::std::option::Option::None;
            }

            pub fn has_position_y(&self) -> bool {
                self.position_y.is_some()
            }

            // Param is passed by value, moved
            pub fn set_position_y(&mut self, v: f32) {
                self.position_y = ::std::option::Option::Some(v);
            }

            // optional uint32 net_worth = 26;

            pub fn net_worth(&self) -> u32 {
                self.net_worth.unwrap_or(0)
            }

            pub fn clear_net_worth(&mut self) {
                self.net_worth = ::std::option::Option::None;
            }

            pub fn has_net_worth(&self) -> bool {
                self.net_worth.is_some()
            }

            // Param is passed by value, moved
            pub fn set_net_worth(&mut self, v: u32) {
                self.net_worth = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for Player {
            const NAME: &'static str = "Player";

            fn is_initialized(&self) -> bool {
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.player_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        26 => {
                            self.hero_name = ::std::option::Option::Some(is.read_string()?);
                        },
                        32 => {
                            self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                        },
                        40 => {
                            self.kills = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        48 => {
                            self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        56 => {
                            self.assists = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        64 => {
                            self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        72 => {
                            self.denies = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        80 => {
                            self.gold = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        88 => {
                            self.level = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        101 => {
                            self.gold_per_min = ::std::option::Option::Some(is.read_float()?);
                        },
                        109 => {
                            self.xp_per_min = ::std::option::Option::Some(is.read_float()?);
                        },
                        112 => {
                            self.ultimate_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                        },
                        125 => {
                            self.ultimate_cooldown = ::std::option::Option::Some(is.read_float()?);
                        },
                        128 => {
                            self.item0 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        136 => {
                            self.item1 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        144 => {
                            self.item2 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        152 => {
                            self.item3 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        160 => {
                            self.item4 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        168 => {
                            self.item5 = ::std::option::Option::Some(is.read_int32()?);
                        },
                        176 => {
                            self.respawn_timer = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        184 => {
                            self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        197 => {
                            self.position_x = ::std::option::Option::Some(is.read_float()?);
                        },
                        205 => {
                            self.position_y = ::std::option::Option::Some(is.read_float()?);
                        },
                        208 => {
                            self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        218 => {
                            self.abilities.push(is.read_message()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.player_slot {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.player_name.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
                }
                if let Some(v) = self.hero_name.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
                }
                if let Some(v) = self.hero_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
                }
                if let Some(v) = self.kills {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
                }
                if let Some(v) = self.deaths {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
                }
                if let Some(v) = self.assists {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
                }
                if let Some(v) = self.last_hits {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
                }
                if let Some(v) = self.denies {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
                }
                if let Some(v) = self.gold {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
                }
                if let Some(v) = self.level {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
                }
                if let Some(v) = self.gold_per_min {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.xp_per_min {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.ultimate_state {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v.value());
                }
                if let Some(v) = self.ultimate_cooldown {
                    my_size += 1 + 4;
                }
                if let Some(v) = self.item0 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v);
                }
                if let Some(v) = self.item1 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
                }
                if let Some(v) = self.item2 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(18, v);
                }
                if let Some(v) = self.item3 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v);
                }
                if let Some(v) = self.item4 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(20, v);
                }
                if let Some(v) = self.item5 {
                    my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(21, v);
                }
                if let Some(v) = self.respawn_timer {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
                }
                if let Some(v) = self.account_id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
                }
                if let Some(v) = self.position_x {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.position_y {
                    my_size += 2 + 4;
                }
                if let Some(v) = self.net_worth {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(26, v);
                }
                for value in &self.abilities {
                    let len = value.compute_size();
                    my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
                };
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.player_slot {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.player_name.as_ref() {
                    os.write_string(2, v)?;
                }
                if let Some(v) = self.hero_name.as_ref() {
                    os.write_string(3, v)?;
                }
                if let Some(v) = self.hero_id {
                    os.write_int32(4, v)?;
                }
                if let Some(v) = self.kills {
                    os.write_uint32(5, v)?;
                }
                if let Some(v) = self.deaths {
                    os.write_uint32(6, v)?;
                }
                if let Some(v) = self.assists {
                    os.write_uint32(7, v)?;
                }
                if let Some(v) = self.last_hits {
                    os.write_uint32(8, v)?;
                }
                if let Some(v) = self.denies {
                    os.write_uint32(9, v)?;
                }
                if let Some(v) = self.gold {
                    os.write_uint32(10, v)?;
                }
                if let Some(v) = self.level {
                    os.write_uint32(11, v)?;
                }
                if let Some(v) = self.gold_per_min {
                    os.write_float(12, v)?;
                }
                if let Some(v) = self.xp_per_min {
                    os.write_float(13, v)?;
                }
                if let Some(v) = self.ultimate_state {
                    os.write_enum(14, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
                }
                if let Some(v) = self.ultimate_cooldown {
                    os.write_float(15, v)?;
                }
                if let Some(v) = self.item0 {
                    os.write_int32(16, v)?;
                }
                if let Some(v) = self.item1 {
                    os.write_int32(17, v)?;
                }
                if let Some(v) = self.item2 {
                    os.write_int32(18, v)?;
                }
                if let Some(v) = self.item3 {
                    os.write_int32(19, v)?;
                }
                if let Some(v) = self.item4 {
                    os.write_int32(20, v)?;
                }
                if let Some(v) = self.item5 {
                    os.write_int32(21, v)?;
                }
                if let Some(v) = self.respawn_timer {
                    os.write_uint32(22, v)?;
                }
                if let Some(v) = self.account_id {
                    os.write_uint32(23, v)?;
                }
                if let Some(v) = self.position_x {
                    os.write_float(24, v)?;
                }
                if let Some(v) = self.position_y {
                    os.write_float(25, v)?;
                }
                if let Some(v) = self.net_worth {
                    os.write_uint32(26, v)?;
                }
                for v in &self.abilities {
                    ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(27, v, os)?;
                };
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> Player {
                Player::new()
            }

            fn clear(&mut self) {
                self.player_slot = ::std::option::Option::None;
                self.player_name = ::std::option::Option::None;
                self.hero_name = ::std::option::Option::None;
                self.hero_id = ::std::option::Option::None;
                self.kills = ::std::option::Option::None;
                self.deaths = ::std::option::Option::None;
                self.assists = ::std::option::Option::None;
                self.last_hits = ::std::option::Option::None;
                self.denies = ::std::option::Option::None;
                self.gold = ::std::option::Option::None;
                self.level = ::std::option::Option::None;
                self.gold_per_min = ::std::option::Option::None;
                self.xp_per_min = ::std::option::Option::None;
                self.ultimate_state = ::std::option::Option::None;
                self.ultimate_cooldown = ::std::option::Option::None;
                self.item0 = ::std::option::Option::None;
                self.item1 = ::std::option::Option::None;
                self.item2 = ::std::option::Option::None;
                self.item3 = ::std::option::Option::None;
                self.item4 = ::std::option::Option::None;
                self.item5 = ::std::option::Option::None;
                self.respawn_timer = ::std::option::Option::None;
                self.account_id = ::std::option::Option::None;
                self.position_x = ::std::option::Option::None;
                self.position_y = ::std::option::Option::None;
                self.net_worth = ::std::option::Option::None;
                self.abilities.clear();
                self.special_fields.clear();
            }

            fn default_instance() -> &'static Player {
                static instance: Player = Player {
                    player_slot: ::std::option::Option::None,
                    player_name: ::std::option::Option::None,
                    hero_name: ::std::option::Option::None,
                    hero_id: ::std::option::Option::None,
                    kills: ::std::option::Option::None,
                    deaths: ::std::option::Option::None,
                    assists: ::std::option::Option::None,
                    last_hits: ::std::option::Option::None,
                    denies: ::std::option::Option::None,
                    gold: ::std::option::Option::None,
                    level: ::std::option::Option::None,
                    gold_per_min: ::std::option::Option::None,
                    xp_per_min: ::std::option::Option::None,
                    ultimate_state: ::std::option::Option::None,
                    ultimate_cooldown: ::std::option::Option::None,
                    item0: ::std::option::Option::None,
                    item1: ::std::option::Option::None,
                    item2: ::std::option::Option::None,
                    item3: ::std::option::Option::None,
                    item4: ::std::option::Option::None,
                    item5: ::std::option::Option::None,
                    respawn_timer: ::std::option::Option::None,
                    account_id: ::std::option::Option::None,
                    position_x: ::std::option::Option::None,
                    position_y: ::std::option::Option::None,
                    net_worth: ::std::option::Option::None,
                    abilities: ::std::vec::Vec::new(),
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }

        /// Nested message and enums of message `Player`
        pub mod player {
            // @@protoc_insertion_point(message:CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility)
            #[derive(PartialEq,Clone,Default,Debug)]
            pub struct HeroAbility {
                // message fields
                // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.ability_id)
                pub ability_id: ::std::option::Option<i32>,
                // @@protoc_insertion_point(field:CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.ability_level)
                pub ability_level: ::std::option::Option<u32>,
                // special fields
                // @@protoc_insertion_point(special_field:CMsgDOTALiveScoreboardUpdate.Team.Player.HeroAbility.special_fields)
                pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
            }

            impl<'a> ::std::default::Default for &'a HeroAbility {
                fn default() -> &'a HeroAbility {
                    <HeroAbility as ::steam_vent_proto_common::protobuf::Message>::default_instance()
                }
            }

            impl HeroAbility {
                pub fn new() -> HeroAbility {
                    ::std::default::Default::default()
                }

                // optional int32 ability_id = 1;

                pub fn ability_id(&self) -> i32 {
                    self.ability_id.unwrap_or(-1i32)
                }

                pub fn clear_ability_id(&mut self) {
                    self.ability_id = ::std::option::Option::None;
                }

                pub fn has_ability_id(&self) -> bool {
                    self.ability_id.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ability_id(&mut self, v: i32) {
                    self.ability_id = ::std::option::Option::Some(v);
                }

                // optional uint32 ability_level = 2;

                pub fn ability_level(&self) -> u32 {
                    self.ability_level.unwrap_or(0)
                }

                pub fn clear_ability_level(&mut self) {
                    self.ability_level = ::std::option::Option::None;
                }

                pub fn has_ability_level(&self) -> bool {
                    self.ability_level.is_some()
                }

                // Param is passed by value, moved
                pub fn set_ability_level(&mut self, v: u32) {
                    self.ability_level = ::std::option::Option::Some(v);
                }
            }

            impl ::steam_vent_proto_common::protobuf::Message for HeroAbility {
                const NAME: &'static str = "HeroAbility";

                fn is_initialized(&self) -> bool {
                    true
                }

                fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    while let Some(tag) = is.read_raw_tag_or_eof()? {
                        match tag {
                            8 => {
                                self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                            },
                            16 => {
                                self.ability_level = ::std::option::Option::Some(is.read_uint32()?);
                            },
                            tag => {
                                ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                            },
                        };
                    }
                    ::std::result::Result::Ok(())
                }

                // Compute sizes of nested messages
                #[allow(unused_variables)]
                fn compute_size(&self) -> u64 {
                    let mut my_size = 0;
                    if let Some(v) = self.ability_id {
                        my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
                    }
                    if let Some(v) = self.ability_level {
                        my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                    }
                    my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                    self.special_fields.cached_size().set(my_size as u32);
                    my_size
                }

                fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                    if let Some(v) = self.ability_id {
                        os.write_int32(1, v)?;
                    }
                    if let Some(v) = self.ability_level {
                        os.write_uint32(2, v)?;
                    }
                    os.write_unknown_fields(self.special_fields.unknown_fields())?;
                    ::std::result::Result::Ok(())
                }

                fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                    &self.special_fields
                }

                fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                    &mut self.special_fields
                }

                fn new() -> HeroAbility {
                    HeroAbility::new()
                }

                fn clear(&mut self) {
                    self.ability_id = ::std::option::Option::None;
                    self.ability_level = ::std::option::Option::None;
                    self.special_fields.clear();
                }

                fn default_instance() -> &'static HeroAbility {
                    static instance: HeroAbility = HeroAbility {
                        ability_id: ::std::option::Option::None,
                        ability_level: ::std::option::Option::None,
                        special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                    };
                    &instance
                }
            }

            #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
            // @@protoc_insertion_point(enum:CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState)
            pub enum DOTAUltimateState {
                // @@protoc_insertion_point(enum_value:CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateNotLearned)
                k_EDOTAUltimateStateNotLearned = 0,
                // @@protoc_insertion_point(enum_value:CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateCooldown)
                k_EDOTAUltimateStateCooldown = 1,
                // @@protoc_insertion_point(enum_value:CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateNeedsMana)
                k_EDOTAUltimateStateNeedsMana = 2,
                // @@protoc_insertion_point(enum_value:CMsgDOTALiveScoreboardUpdate.Team.Player.DOTAUltimateState.k_EDOTAUltimateStateReady)
                k_EDOTAUltimateStateReady = 3,
            }

            impl ::steam_vent_proto_common::protobuf::Enum for DOTAUltimateState {
                const NAME: &'static str = "DOTAUltimateState";

                fn value(&self) -> i32 {
                    *self as i32
                }

                fn from_i32(value: i32) -> ::std::option::Option<DOTAUltimateState> {
                    match value {
                        0 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                        1 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateCooldown),
                        2 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNeedsMana),
                        3 => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateReady),
                        _ => ::std::option::Option::None
                    }
                }

                fn from_str(str: &str) -> ::std::option::Option<DOTAUltimateState> {
                    match str {
                        "k_EDOTAUltimateStateNotLearned" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNotLearned),
                        "k_EDOTAUltimateStateCooldown" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateCooldown),
                        "k_EDOTAUltimateStateNeedsMana" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateNeedsMana),
                        "k_EDOTAUltimateStateReady" => ::std::option::Option::Some(DOTAUltimateState::k_EDOTAUltimateStateReady),
                        _ => ::std::option::Option::None
                    }
                }

                const VALUES: &'static [DOTAUltimateState] = &[
                    DOTAUltimateState::k_EDOTAUltimateStateNotLearned,
                    DOTAUltimateState::k_EDOTAUltimateStateCooldown,
                    DOTAUltimateState::k_EDOTAUltimateStateNeedsMana,
                    DOTAUltimateState::k_EDOTAUltimateStateReady,
                ];
            }

            impl ::std::default::Default for DOTAUltimateState {
                fn default() -> Self {
                    DOTAUltimateState::k_EDOTAUltimateStateNotLearned
                }
            }

        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestBatchPlayerResources)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestBatchPlayerResources {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResources.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResources.rank_types)
    pub rank_types: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResources.lobby_type)
    pub lobby_type: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestBatchPlayerResources.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestBatchPlayerResources {
    fn default() -> &'a CMsgServerToGCRequestBatchPlayerResources {
        <CMsgServerToGCRequestBatchPlayerResources as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestBatchPlayerResources {
    pub fn new() -> CMsgServerToGCRequestBatchPlayerResources {
        ::std::default::Default::default()
    }

    // optional int32 lobby_type = 5;

    pub fn lobby_type(&self) -> i32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: i32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestBatchPlayerResources {
    const NAME: &'static str = "CMsgServerToGCRequestBatchPlayerResources";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.rank_types)?;
                },
                32 => {
                    self.rank_types.push(is.read_uint32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(1, &self.account_ids);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(4, &self.rank_types);
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_uint32(1, &self.account_ids)?;
        os.write_repeated_packed_uint32(4, &self.rank_types)?;
        if let Some(v) = self.lobby_type {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestBatchPlayerResources {
        CMsgServerToGCRequestBatchPlayerResources::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.rank_types.clear();
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestBatchPlayerResources {
        static instance: CMsgServerToGCRequestBatchPlayerResources = CMsgServerToGCRequestBatchPlayerResources {
            account_ids: ::std::vec::Vec::new(),
            rank_types: ::std::vec::Vec::new(),
            lobby_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestBatchPlayerResourcesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestBatchPlayerResourcesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.results)
    pub results: ::std::vec::Vec<cmsg_server_to_gcrequest_batch_player_resources_response::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestBatchPlayerResourcesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestBatchPlayerResourcesResponse {
    fn default() -> &'a CMsgServerToGCRequestBatchPlayerResourcesResponse {
        <CMsgServerToGCRequestBatchPlayerResourcesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestBatchPlayerResourcesResponse {
    pub fn new() -> CMsgServerToGCRequestBatchPlayerResourcesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    const NAME: &'static str = "CMsgServerToGCRequestBatchPlayerResourcesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                50 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestBatchPlayerResourcesResponse {
        CMsgServerToGCRequestBatchPlayerResourcesResponse::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestBatchPlayerResourcesResponse {
        static instance: CMsgServerToGCRequestBatchPlayerResourcesResponse = CMsgServerToGCRequestBatchPlayerResourcesResponse {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCRequestBatchPlayerResourcesResponse`
pub mod cmsg_server_to_gcrequest_batch_player_resources_response {
    // @@protoc_insertion_point(message:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.rank_calibrated)
        pub rank_calibrated: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.low_priority)
        pub low_priority: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.is_new_player)
        pub is_new_player: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.is_guide_player)
        pub is_guide_player: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.comm_level)
        pub comm_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.behavior_level)
        pub behavior_level: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.wins)
        pub wins: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.losses)
        pub losses: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.smurf_category)
        pub smurf_category: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCRequestBatchPlayerResourcesResponse.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 4;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional bool rank_calibrated = 5;

        pub fn rank_calibrated(&self) -> bool {
            self.rank_calibrated.unwrap_or(false)
        }

        pub fn clear_rank_calibrated(&mut self) {
            self.rank_calibrated = ::std::option::Option::None;
        }

        pub fn has_rank_calibrated(&self) -> bool {
            self.rank_calibrated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_calibrated(&mut self, v: bool) {
            self.rank_calibrated = ::std::option::Option::Some(v);
        }

        // optional bool low_priority = 6;

        pub fn low_priority(&self) -> bool {
            self.low_priority.unwrap_or(false)
        }

        pub fn clear_low_priority(&mut self) {
            self.low_priority = ::std::option::Option::None;
        }

        pub fn has_low_priority(&self) -> bool {
            self.low_priority.is_some()
        }

        // Param is passed by value, moved
        pub fn set_low_priority(&mut self, v: bool) {
            self.low_priority = ::std::option::Option::Some(v);
        }

        // optional bool is_new_player = 7;

        pub fn is_new_player(&self) -> bool {
            self.is_new_player.unwrap_or(false)
        }

        pub fn clear_is_new_player(&mut self) {
            self.is_new_player = ::std::option::Option::None;
        }

        pub fn has_is_new_player(&self) -> bool {
            self.is_new_player.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_new_player(&mut self, v: bool) {
            self.is_new_player = ::std::option::Option::Some(v);
        }

        // optional bool is_guide_player = 8;

        pub fn is_guide_player(&self) -> bool {
            self.is_guide_player.unwrap_or(false)
        }

        pub fn clear_is_guide_player(&mut self) {
            self.is_guide_player = ::std::option::Option::None;
        }

        pub fn has_is_guide_player(&self) -> bool {
            self.is_guide_player.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_guide_player(&mut self, v: bool) {
            self.is_guide_player = ::std::option::Option::Some(v);
        }

        // optional int32 comm_level = 9;

        pub fn comm_level(&self) -> i32 {
            self.comm_level.unwrap_or(0)
        }

        pub fn clear_comm_level(&mut self) {
            self.comm_level = ::std::option::Option::None;
        }

        pub fn has_comm_level(&self) -> bool {
            self.comm_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comm_level(&mut self, v: i32) {
            self.comm_level = ::std::option::Option::Some(v);
        }

        // optional int32 behavior_level = 10;

        pub fn behavior_level(&self) -> i32 {
            self.behavior_level.unwrap_or(0)
        }

        pub fn clear_behavior_level(&mut self) {
            self.behavior_level = ::std::option::Option::None;
        }

        pub fn has_behavior_level(&self) -> bool {
            self.behavior_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_behavior_level(&mut self, v: i32) {
            self.behavior_level = ::std::option::Option::Some(v);
        }

        // optional int32 wins = 11;

        pub fn wins(&self) -> i32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: i32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional int32 losses = 12;

        pub fn losses(&self) -> i32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: i32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional int32 smurf_category = 13;

        pub fn smurf_category(&self) -> i32 {
            self.smurf_category.unwrap_or(0)
        }

        pub fn clear_smurf_category(&mut self) {
            self.smurf_category = ::std::option::Option::None;
        }

        pub fn has_smurf_category(&self) -> bool {
            self.smurf_category.is_some()
        }

        // Param is passed by value, moved
        pub fn set_smurf_category(&mut self, v: i32) {
            self.smurf_category = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.rank_calibrated = ::std::option::Option::Some(is.read_bool()?);
                    },
                    48 => {
                        self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.is_new_player = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.is_guide_player = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.comm_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.behavior_level = ::std::option::Option::Some(is.read_int32()?);
                    },
                    88 => {
                        self.wins = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.losses = ::std::option::Option::Some(is.read_int32()?);
                    },
                    104 => {
                        self.smurf_category = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.rank_calibrated {
                my_size += 1 + 1;
            }
            if let Some(v) = self.low_priority {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_new_player {
                my_size += 1 + 1;
            }
            if let Some(v) = self.is_guide_player {
                my_size += 1 + 1;
            }
            if let Some(v) = self.comm_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.behavior_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
            }
            if let Some(v) = self.losses {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
            }
            if let Some(v) = self.smurf_category {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.rank_calibrated {
                os.write_bool(5, v)?;
            }
            if let Some(v) = self.low_priority {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.is_new_player {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.is_guide_player {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.comm_level {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.behavior_level {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.wins {
                os.write_int32(11, v)?;
            }
            if let Some(v) = self.losses {
                os.write_int32(12, v)?;
            }
            if let Some(v) = self.smurf_category {
                os.write_int32(13, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.rank_calibrated = ::std::option::Option::None;
            self.low_priority = ::std::option::Option::None;
            self.is_new_player = ::std::option::Option::None;
            self.is_guide_player = ::std::option::Option::None;
            self.comm_level = ::std::option::Option::None;
            self.behavior_level = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.smurf_category = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                account_id: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                rank_calibrated: ::std::option::Option::None,
                low_priority: ::std::option::Option::None,
                is_new_player: ::std::option::Option::None,
                is_guide_player: ::std::option::Option::None,
                comm_level: ::std::option::Option::None,
                behavior_level: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                smurf_category: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAPlayerFailedToConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPlayerFailedToConnect {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPlayerFailedToConnect.failed_loaders)
    pub failed_loaders: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAPlayerFailedToConnect.abandoned_loaders)
    pub abandoned_loaders: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPlayerFailedToConnect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPlayerFailedToConnect {
    fn default() -> &'a CMsgDOTAPlayerFailedToConnect {
        <CMsgDOTAPlayerFailedToConnect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPlayerFailedToConnect {
    pub fn new() -> CMsgDOTAPlayerFailedToConnect {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPlayerFailedToConnect {
    const NAME: &'static str = "CMsgDOTAPlayerFailedToConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.failed_loaders)?;
                },
                9 => {
                    self.failed_loaders.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.abandoned_loaders)?;
                },
                17 => {
                    self.abandoned_loaders.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.failed_loaders.len() as u64;
        my_size += 9 * self.abandoned_loaders.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.failed_loaders {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.abandoned_loaders {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPlayerFailedToConnect {
        CMsgDOTAPlayerFailedToConnect::new()
    }

    fn clear(&mut self) {
        self.failed_loaders.clear();
        self.abandoned_loaders.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPlayerFailedToConnect {
        static instance: CMsgDOTAPlayerFailedToConnect = CMsgDOTAPlayerFailedToConnect {
            failed_loaders: ::std::vec::Vec::new(),
            abandoned_loaders: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToRelayConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToRelayConnect {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.source_tv_public_addr)
    pub source_tv_public_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.source_tv_private_addr)
    pub source_tv_private_addr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.source_tv_port)
    pub source_tv_port: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.game_server_steam_id)
    pub game_server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.parent_count)
    pub parent_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.tv_unique_secret_code)
    pub tv_unique_secret_code: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToRelayConnect.source_tv_steamid)
    pub source_tv_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToRelayConnect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToRelayConnect {
    fn default() -> &'a CMsgGCToRelayConnect {
        <CMsgGCToRelayConnect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToRelayConnect {
    pub fn new() -> CMsgGCToRelayConnect {
        ::std::default::Default::default()
    }

    // optional uint32 source_tv_public_addr = 1;

    pub fn source_tv_public_addr(&self) -> u32 {
        self.source_tv_public_addr.unwrap_or(0)
    }

    pub fn clear_source_tv_public_addr(&mut self) {
        self.source_tv_public_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_public_addr(&self) -> bool {
        self.source_tv_public_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_public_addr(&mut self, v: u32) {
        self.source_tv_public_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 source_tv_private_addr = 2;

    pub fn source_tv_private_addr(&self) -> u32 {
        self.source_tv_private_addr.unwrap_or(0)
    }

    pub fn clear_source_tv_private_addr(&mut self) {
        self.source_tv_private_addr = ::std::option::Option::None;
    }

    pub fn has_source_tv_private_addr(&self) -> bool {
        self.source_tv_private_addr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_private_addr(&mut self, v: u32) {
        self.source_tv_private_addr = ::std::option::Option::Some(v);
    }

    // optional uint32 source_tv_port = 3;

    pub fn source_tv_port(&self) -> u32 {
        self.source_tv_port.unwrap_or(0)
    }

    pub fn clear_source_tv_port(&mut self) {
        self.source_tv_port = ::std::option::Option::None;
    }

    pub fn has_source_tv_port(&self) -> bool {
        self.source_tv_port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_port(&mut self, v: u32) {
        self.source_tv_port = ::std::option::Option::Some(v);
    }

    // optional uint64 game_server_steam_id = 4;

    pub fn game_server_steam_id(&self) -> u64 {
        self.game_server_steam_id.unwrap_or(0)
    }

    pub fn clear_game_server_steam_id(&mut self) {
        self.game_server_steam_id = ::std::option::Option::None;
    }

    pub fn has_game_server_steam_id(&self) -> bool {
        self.game_server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_server_steam_id(&mut self, v: u64) {
        self.game_server_steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 parent_count = 5;

    pub fn parent_count(&self) -> u32 {
        self.parent_count.unwrap_or(0)
    }

    pub fn clear_parent_count(&mut self) {
        self.parent_count = ::std::option::Option::None;
    }

    pub fn has_parent_count(&self) -> bool {
        self.parent_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent_count(&mut self, v: u32) {
        self.parent_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 tv_unique_secret_code = 6;

    pub fn tv_unique_secret_code(&self) -> u64 {
        self.tv_unique_secret_code.unwrap_or(0)
    }

    pub fn clear_tv_unique_secret_code(&mut self) {
        self.tv_unique_secret_code = ::std::option::Option::None;
    }

    pub fn has_tv_unique_secret_code(&self) -> bool {
        self.tv_unique_secret_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_unique_secret_code(&mut self, v: u64) {
        self.tv_unique_secret_code = ::std::option::Option::Some(v);
    }

    // optional fixed64 source_tv_steamid = 7;

    pub fn source_tv_steamid(&self) -> u64 {
        self.source_tv_steamid.unwrap_or(0)
    }

    pub fn clear_source_tv_steamid(&mut self) {
        self.source_tv_steamid = ::std::option::Option::None;
    }

    pub fn has_source_tv_steamid(&self) -> bool {
        self.source_tv_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_tv_steamid(&mut self, v: u64) {
        self.source_tv_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToRelayConnect {
    const NAME: &'static str = "CMsgGCToRelayConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_tv_public_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.source_tv_private_addr = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.source_tv_port = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.parent_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.tv_unique_secret_code = ::std::option::Option::Some(is.read_fixed64()?);
                },
                57 => {
                    self.source_tv_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_tv_public_addr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.source_tv_private_addr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.source_tv_port {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_server_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.parent_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.tv_unique_secret_code {
            my_size += 1 + 8;
        }
        if let Some(v) = self.source_tv_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_tv_public_addr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.source_tv_private_addr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.source_tv_port {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_server_steam_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.parent_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.tv_unique_secret_code {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.source_tv_steamid {
            os.write_fixed64(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToRelayConnect {
        CMsgGCToRelayConnect::new()
    }

    fn clear(&mut self) {
        self.source_tv_public_addr = ::std::option::Option::None;
        self.source_tv_private_addr = ::std::option::Option::None;
        self.source_tv_port = ::std::option::Option::None;
        self.game_server_steam_id = ::std::option::Option::None;
        self.parent_count = ::std::option::Option::None;
        self.tv_unique_secret_code = ::std::option::Option::None;
        self.source_tv_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToRelayConnect {
        static instance: CMsgGCToRelayConnect = CMsgGCToRelayConnect {
            source_tv_public_addr: ::std::option::Option::None,
            source_tv_private_addr: ::std::option::Option::None,
            source_tv_port: ::std::option::Option::None,
            game_server_steam_id: ::std::option::Option::None,
            parent_count: ::std::option::Option::None,
            tv_unique_secret_code: ::std::option::Option::None,
            source_tv_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGCToLANServerRelayConnect)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGCToLANServerRelayConnect {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGCToLANServerRelayConnect.relay_steamid)
    pub relay_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGCToLANServerRelayConnect.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGCToLANServerRelayConnect {
    fn default() -> &'a CMsgGCGCToLANServerRelayConnect {
        <CMsgGCGCToLANServerRelayConnect as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGCToLANServerRelayConnect {
    pub fn new() -> CMsgGCGCToLANServerRelayConnect {
        ::std::default::Default::default()
    }

    // optional fixed64 relay_steamid = 1;

    pub fn relay_steamid(&self) -> u64 {
        self.relay_steamid.unwrap_or(0)
    }

    pub fn clear_relay_steamid(&mut self) {
        self.relay_steamid = ::std::option::Option::None;
    }

    pub fn has_relay_steamid(&self) -> bool {
        self.relay_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relay_steamid(&mut self, v: u64) {
        self.relay_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGCToLANServerRelayConnect {
    const NAME: &'static str = "CMsgGCGCToLANServerRelayConnect";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.relay_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.relay_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.relay_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGCToLANServerRelayConnect {
        CMsgGCGCToLANServerRelayConnect::new()
    }

    fn clear(&mut self) {
        self.relay_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGCToLANServerRelayConnect {
        static instance: CMsgGCGCToLANServerRelayConnect = CMsgGCGCToLANServerRelayConnect {
            relay_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCBanStatusRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCBanStatusRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBanStatusRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBanStatusRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBanStatusRequest {
    fn default() -> &'a CMsgGCBanStatusRequest {
        <CMsgGCBanStatusRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBanStatusRequest {
    pub fn new() -> CMsgGCBanStatusRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCBanStatusRequest {
    const NAME: &'static str = "CMsgGCBanStatusRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBanStatusRequest {
        CMsgGCBanStatusRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBanStatusRequest {
        static instance: CMsgGCBanStatusRequest = CMsgGCBanStatusRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCBanStatusResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCBanStatusResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCBanStatusResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCBanStatusResponse.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCBanStatusResponse.text_chat_banned)
    pub text_chat_banned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCBanStatusResponse.voice_chat_banned)
    pub voice_chat_banned: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCBanStatusResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCBanStatusResponse {
    fn default() -> &'a CMsgGCBanStatusResponse {
        <CMsgGCBanStatusResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCBanStatusResponse {
    pub fn new() -> CMsgGCBanStatusResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 2;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional bool text_chat_banned = 3;

    pub fn text_chat_banned(&self) -> bool {
        self.text_chat_banned.unwrap_or(false)
    }

    pub fn clear_text_chat_banned(&mut self) {
        self.text_chat_banned = ::std::option::Option::None;
    }

    pub fn has_text_chat_banned(&self) -> bool {
        self.text_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_text_chat_banned(&mut self, v: bool) {
        self.text_chat_banned = ::std::option::Option::Some(v);
    }

    // optional bool voice_chat_banned = 4;

    pub fn voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.unwrap_or(false)
    }

    pub fn clear_voice_chat_banned(&mut self) {
        self.voice_chat_banned = ::std::option::Option::None;
    }

    pub fn has_voice_chat_banned(&self) -> bool {
        self.voice_chat_banned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voice_chat_banned(&mut self, v: bool) {
        self.voice_chat_banned = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCBanStatusResponse {
    const NAME: &'static str = "CMsgGCBanStatusResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.text_chat_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.voice_chat_banned = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.text_chat_banned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.voice_chat_banned {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.text_chat_banned {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.voice_chat_banned {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCBanStatusResponse {
        CMsgGCBanStatusResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.text_chat_banned = ::std::option::Option::None;
        self.voice_chat_banned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCBanStatusResponse {
        static instance: CMsgGCBanStatusResponse = CMsgGCBanStatusResponse {
            result: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            text_chat_banned: ::std::option::Option::None,
            voice_chat_banned: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTournamentItemEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTournamentItemEvent {
    // message fields
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.killer_account_id)
    pub killer_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.victim_account_id)
    pub victim_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.event_type)
    pub event_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::DOTA_TournamentEvents>>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.tv_delay)
    pub tv_delay: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.dota_time)
    pub dota_time: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.replay_time)
    pub replay_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.loot_list)
    pub loot_list: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.event_team)
    pub event_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.multi_kill_count)
    pub multi_kill_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.winner_score)
    pub winner_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.loser_score)
    pub loser_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEvent.hero_statues)
    pub hero_statues: ::std::vec::Vec<super::dota_gcmessages_common::CProtoItemHeroStatue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTournamentItemEvent.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTournamentItemEvent {
    fn default() -> &'a CMsgTournamentItemEvent {
        <CMsgTournamentItemEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTournamentItemEvent {
    pub fn new() -> CMsgTournamentItemEvent {
        ::std::default::Default::default()
    }

    // optional fixed32 killer_account_id = 1;

    pub fn killer_account_id(&self) -> u32 {
        self.killer_account_id.unwrap_or(0)
    }

    pub fn clear_killer_account_id(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
    }

    pub fn has_killer_account_id(&self) -> bool {
        self.killer_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_killer_account_id(&mut self, v: u32) {
        self.killer_account_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 victim_account_id = 2;

    pub fn victim_account_id(&self) -> u32 {
        self.victim_account_id.unwrap_or(0)
    }

    pub fn clear_victim_account_id(&mut self) {
        self.victim_account_id = ::std::option::Option::None;
    }

    pub fn has_victim_account_id(&self) -> bool {
        self.victim_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_victim_account_id(&mut self, v: u32) {
        self.victim_account_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_TournamentEvents event_type = 3;

    pub fn event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        match self.event_type {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD),
            None => super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 tv_delay = 4;

    pub fn tv_delay(&self) -> i32 {
        self.tv_delay.unwrap_or(0)
    }

    pub fn clear_tv_delay(&mut self) {
        self.tv_delay = ::std::option::Option::None;
    }

    pub fn has_tv_delay(&self) -> bool {
        self.tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tv_delay(&mut self, v: i32) {
        self.tv_delay = ::std::option::Option::Some(v);
    }

    // optional int32 dota_time = 5;

    pub fn dota_time(&self) -> i32 {
        self.dota_time.unwrap_or(0)
    }

    pub fn clear_dota_time(&mut self) {
        self.dota_time = ::std::option::Option::None;
    }

    pub fn has_dota_time(&self) -> bool {
        self.dota_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_time(&mut self, v: i32) {
        self.dota_time = ::std::option::Option::Some(v);
    }

    // optional float replay_time = 6;

    pub fn replay_time(&self) -> f32 {
        self.replay_time.unwrap_or(0.)
    }

    pub fn clear_replay_time(&mut self) {
        self.replay_time = ::std::option::Option::None;
    }

    pub fn has_replay_time(&self) -> bool {
        self.replay_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replay_time(&mut self, v: f32) {
        self.replay_time = ::std::option::Option::Some(v);
    }

    // optional string loot_list = 7;

    pub fn loot_list(&self) -> &str {
        match self.loot_list.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loot_list(&mut self) {
        self.loot_list = ::std::option::Option::None;
    }

    pub fn has_loot_list(&self) -> bool {
        self.loot_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loot_list(&mut self, v: ::std::string::String) {
        self.loot_list = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loot_list(&mut self) -> &mut ::std::string::String {
        if self.loot_list.is_none() {
            self.loot_list = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loot_list.as_mut().unwrap()
    }

    // Take field
    pub fn take_loot_list(&mut self) -> ::std::string::String {
        self.loot_list.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 event_team = 8;

    pub fn event_team(&self) -> u32 {
        self.event_team.unwrap_or(0)
    }

    pub fn clear_event_team(&mut self) {
        self.event_team = ::std::option::Option::None;
    }

    pub fn has_event_team(&self) -> bool {
        self.event_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_team(&mut self, v: u32) {
        self.event_team = ::std::option::Option::Some(v);
    }

    // optional uint32 multi_kill_count = 9;

    pub fn multi_kill_count(&self) -> u32 {
        self.multi_kill_count.unwrap_or(0)
    }

    pub fn clear_multi_kill_count(&mut self) {
        self.multi_kill_count = ::std::option::Option::None;
    }

    pub fn has_multi_kill_count(&self) -> bool {
        self.multi_kill_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_multi_kill_count(&mut self, v: u32) {
        self.multi_kill_count = ::std::option::Option::Some(v);
    }

    // optional uint32 winner_score = 10;

    pub fn winner_score(&self) -> u32 {
        self.winner_score.unwrap_or(0)
    }

    pub fn clear_winner_score(&mut self) {
        self.winner_score = ::std::option::Option::None;
    }

    pub fn has_winner_score(&self) -> bool {
        self.winner_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winner_score(&mut self, v: u32) {
        self.winner_score = ::std::option::Option::Some(v);
    }

    // optional uint32 loser_score = 11;

    pub fn loser_score(&self) -> u32 {
        self.loser_score.unwrap_or(0)
    }

    pub fn clear_loser_score(&mut self) {
        self.loser_score = ::std::option::Option::None;
    }

    pub fn has_loser_score(&self) -> bool {
        self.loser_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loser_score(&mut self, v: u32) {
        self.loser_score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTournamentItemEvent {
    const NAME: &'static str = "CMsgTournamentItemEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.killer_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                21 => {
                    self.victim_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.tv_delay = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.dota_time = ::std::option::Option::Some(is.read_int32()?);
                },
                53 => {
                    self.replay_time = ::std::option::Option::Some(is.read_float()?);
                },
                58 => {
                    self.loot_list = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.event_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.multi_kill_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.winner_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.loser_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.hero_statues.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.killer_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.victim_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.tv_delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.dota_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.replay_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.loot_list.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.event_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.multi_kill_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.winner_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.loser_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        for value in &self.hero_statues {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.killer_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.victim_account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.tv_delay {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.dota_time {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.replay_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.loot_list.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.event_team {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.multi_kill_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.winner_score {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.loser_score {
            os.write_uint32(11, v)?;
        }
        for v in &self.hero_statues {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTournamentItemEvent {
        CMsgTournamentItemEvent::new()
    }

    fn clear(&mut self) {
        self.killer_account_id = ::std::option::Option::None;
        self.victim_account_id = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.tv_delay = ::std::option::Option::None;
        self.dota_time = ::std::option::Option::None;
        self.replay_time = ::std::option::Option::None;
        self.loot_list = ::std::option::Option::None;
        self.event_team = ::std::option::Option::None;
        self.multi_kill_count = ::std::option::Option::None;
        self.winner_score = ::std::option::Option::None;
        self.loser_score = ::std::option::Option::None;
        self.hero_statues.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTournamentItemEvent {
        static instance: CMsgTournamentItemEvent = CMsgTournamentItemEvent {
            killer_account_id: ::std::option::Option::None,
            victim_account_id: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            tv_delay: ::std::option::Option::None,
            dota_time: ::std::option::Option::None,
            replay_time: ::std::option::Option::None,
            loot_list: ::std::option::Option::None,
            event_team: ::std::option::Option::None,
            multi_kill_count: ::std::option::Option::None,
            winner_score: ::std::option::Option::None,
            loser_score: ::std::option::Option::None,
            hero_statues: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTournamentItemEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTournamentItemEventResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgTournamentItemEventResponse.event_type)
    pub event_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::DOTA_TournamentEvents>>,
    // @@protoc_insertion_point(field:CMsgTournamentItemEventResponse.viewers_granted)
    pub viewers_granted: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTournamentItemEventResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTournamentItemEventResponse {
    fn default() -> &'a CMsgTournamentItemEventResponse {
        <CMsgTournamentItemEventResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTournamentItemEventResponse {
    pub fn new() -> CMsgTournamentItemEventResponse {
        ::std::default::Default::default()
    }

    // optional .DOTA_TournamentEvents event_type = 1;

    pub fn event_type(&self) -> super::dota_gcmessages_common::DOTA_TournamentEvents {
        match self.event_type {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD),
            None => super::dota_gcmessages_common::DOTA_TournamentEvents::TE_FIRST_BLOOD,
        }
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: super::dota_gcmessages_common::DOTA_TournamentEvents) {
        self.event_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 viewers_granted = 6;

    pub fn viewers_granted(&self) -> u32 {
        self.viewers_granted.unwrap_or(0)
    }

    pub fn clear_viewers_granted(&mut self) {
        self.viewers_granted = ::std::option::Option::None;
    }

    pub fn has_viewers_granted(&self) -> bool {
        self.viewers_granted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_viewers_granted(&mut self, v: u32) {
        self.viewers_granted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTournamentItemEventResponse {
    const NAME: &'static str = "CMsgTournamentItemEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                48 => {
                    self.viewers_granted = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.viewers_granted {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.viewers_granted {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTournamentItemEventResponse {
        CMsgTournamentItemEventResponse::new()
    }

    fn clear(&mut self) {
        self.event_type = ::std::option::Option::None;
        self.viewers_granted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTournamentItemEventResponse {
        static instance: CMsgTournamentItemEventResponse = CMsgTournamentItemEventResponse {
            event_type: ::std::option::Option::None,
            viewers_granted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgTeamFanfare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTeamFanfare {
    // message fields
    // @@protoc_insertion_point(field:CMsgTeamFanfare.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTeamFanfare.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTeamFanfare {
    fn default() -> &'a CMsgTeamFanfare {
        <CMsgTeamFanfare as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTeamFanfare {
    pub fn new() -> CMsgTeamFanfare {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTeamFanfare {
    const NAME: &'static str = "CMsgTeamFanfare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTeamFanfare {
        CMsgTeamFanfare::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTeamFanfare {
        static instance: CMsgTeamFanfare = CMsgTeamFanfare {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgResponseTeamFanfare)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResponseTeamFanfare {
    // message fields
    // @@protoc_insertion_point(field:CMsgResponseTeamFanfare.fanfare_goodguys)
    pub fanfare_goodguys: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgResponseTeamFanfare.fanfare_badguys)
    pub fanfare_badguys: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResponseTeamFanfare.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResponseTeamFanfare {
    fn default() -> &'a CMsgResponseTeamFanfare {
        <CMsgResponseTeamFanfare as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgResponseTeamFanfare {
    pub fn new() -> CMsgResponseTeamFanfare {
        ::std::default::Default::default()
    }

    // optional uint32 fanfare_goodguys = 1;

    pub fn fanfare_goodguys(&self) -> u32 {
        self.fanfare_goodguys.unwrap_or(0)
    }

    pub fn clear_fanfare_goodguys(&mut self) {
        self.fanfare_goodguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_goodguys(&self) -> bool {
        self.fanfare_goodguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_goodguys(&mut self, v: u32) {
        self.fanfare_goodguys = ::std::option::Option::Some(v);
    }

    // optional uint32 fanfare_badguys = 2;

    pub fn fanfare_badguys(&self) -> u32 {
        self.fanfare_badguys.unwrap_or(0)
    }

    pub fn clear_fanfare_badguys(&mut self) {
        self.fanfare_badguys = ::std::option::Option::None;
    }

    pub fn has_fanfare_badguys(&self) -> bool {
        self.fanfare_badguys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fanfare_badguys(&mut self, v: u32) {
        self.fanfare_badguys = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgResponseTeamFanfare {
    const NAME: &'static str = "CMsgResponseTeamFanfare";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.fanfare_goodguys = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.fanfare_badguys = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.fanfare_goodguys {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.fanfare_badguys {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.fanfare_goodguys {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.fanfare_badguys {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResponseTeamFanfare {
        CMsgResponseTeamFanfare::new()
    }

    fn clear(&mut self) {
        self.fanfare_goodguys = ::std::option::Option::None;
        self.fanfare_badguys = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResponseTeamFanfare {
        static instance: CMsgResponseTeamFanfare = CMsgResponseTeamFanfare {
            fanfare_goodguys: ::std::option::Option::None,
            fanfare_badguys: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerUploadSaveGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerUploadSaveGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerUploadSaveGame.game_time)
    pub game_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGameServerUploadSaveGame.save_game_data)
    pub save_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGameServerUploadSaveGame.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGameServerUploadSaveGame.player_steam_ids)
    pub player_steam_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerUploadSaveGame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerUploadSaveGame {
    fn default() -> &'a CMsgGameServerUploadSaveGame {
        <CMsgGameServerUploadSaveGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerUploadSaveGame {
    pub fn new() -> CMsgGameServerUploadSaveGame {
        ::std::default::Default::default()
    }

    // optional uint32 game_time = 1;

    pub fn game_time(&self) -> u32 {
        self.game_time.unwrap_or(0)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: u32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bytes save_game_data = 2;

    pub fn save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data = ::std::option::Option::None;
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerUploadSaveGame {
    const NAME: &'static str = "CMsgGameServerUploadSaveGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.save_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_steam_ids)?;
                },
                32 => {
                    self.player_steam_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.save_game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        for value in &self.player_steam_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.save_game_data.as_ref() {
            os.write_bytes(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        for v in &self.player_steam_ids {
            os.write_uint64(4, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerUploadSaveGame {
        CMsgGameServerUploadSaveGame::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.save_game_data = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.player_steam_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerUploadSaveGame {
        static instance: CMsgGameServerUploadSaveGame = CMsgGameServerUploadSaveGame {
            game_time: ::std::option::Option::None,
            save_game_data: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            player_steam_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerSaveGameResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerSaveGameResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerSaveGameResult.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_game_server_save_game_result::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerSaveGameResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerSaveGameResult {
    fn default() -> &'a CMsgGameServerSaveGameResult {
        <CMsgGameServerSaveGameResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerSaveGameResult {
    pub fn new() -> CMsgGameServerSaveGameResult {
        ::std::default::Default::default()
    }

    // optional .CMsgGameServerSaveGameResult.Result result = 1;

    pub fn result(&self) -> cmsg_game_server_save_game_result::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_game_server_save_game_result::Result::SaveSuccessful),
            None => cmsg_game_server_save_game_result::Result::SaveSuccessful,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_game_server_save_game_result::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerSaveGameResult {
    const NAME: &'static str = "CMsgGameServerSaveGameResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerSaveGameResult {
        CMsgGameServerSaveGameResult::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerSaveGameResult {
        static instance: CMsgGameServerSaveGameResult = CMsgGameServerSaveGameResult {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGameServerSaveGameResult`
pub mod cmsg_game_server_save_game_result {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGameServerSaveGameResult.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgGameServerSaveGameResult.Result.SaveSuccessful)
        SaveSuccessful = 0,
        // @@protoc_insertion_point(enum_value:CMsgGameServerSaveGameResult.Result.SessionNotFound)
        SessionNotFound = 1,
        // @@protoc_insertion_point(enum_value:CMsgGameServerSaveGameResult.Result.DatabaseError)
        DatabaseError = 2,
        // @@protoc_insertion_point(enum_value:CMsgGameServerSaveGameResult.Result.TooBig)
        TooBig = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SaveSuccessful),
                1 => ::std::option::Option::Some(Result::SessionNotFound),
                2 => ::std::option::Option::Some(Result::DatabaseError),
                3 => ::std::option::Option::Some(Result::TooBig),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SaveSuccessful" => ::std::option::Option::Some(Result::SaveSuccessful),
                "SessionNotFound" => ::std::option::Option::Some(Result::SessionNotFound),
                "DatabaseError" => ::std::option::Option::Some(Result::DatabaseError),
                "TooBig" => ::std::option::Option::Some(Result::TooBig),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SaveSuccessful,
            Result::SessionNotFound,
            Result::DatabaseError,
            Result::TooBig,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SaveSuccessful
        }
    }

}

// @@protoc_insertion_point(message:CMsgGameServerGetLoadGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerGetLoadGame {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerGetLoadGame.save_id)
    pub save_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerGetLoadGame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerGetLoadGame {
    fn default() -> &'a CMsgGameServerGetLoadGame {
        <CMsgGameServerGetLoadGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerGetLoadGame {
    pub fn new() -> CMsgGameServerGetLoadGame {
        ::std::default::Default::default()
    }

    // optional uint32 save_id = 1;

    pub fn save_id(&self) -> u32 {
        self.save_id.unwrap_or(0)
    }

    pub fn clear_save_id(&mut self) {
        self.save_id = ::std::option::Option::None;
    }

    pub fn has_save_id(&self) -> bool {
        self.save_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_id(&mut self, v: u32) {
        self.save_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerGetLoadGame {
    const NAME: &'static str = "CMsgGameServerGetLoadGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.save_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.save_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.save_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerGetLoadGame {
        CMsgGameServerGetLoadGame::new()
    }

    fn clear(&mut self) {
        self.save_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerGetLoadGame {
        static instance: CMsgGameServerGetLoadGame = CMsgGameServerGetLoadGame {
            save_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGameServerGetLoadGameResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGameServerGetLoadGameResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgGameServerGetLoadGameResult.save_game_data)
    pub save_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGameServerGetLoadGameResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGameServerGetLoadGameResult {
    fn default() -> &'a CMsgGameServerGetLoadGameResult {
        <CMsgGameServerGetLoadGameResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGameServerGetLoadGameResult {
    pub fn new() -> CMsgGameServerGetLoadGameResult {
        ::std::default::Default::default()
    }

    // optional bytes save_game_data = 1;

    pub fn save_game_data(&self) -> &[u8] {
        match self.save_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_save_game_data(&mut self) {
        self.save_game_data = ::std::option::Option::None;
    }

    pub fn has_save_game_data(&self) -> bool {
        self.save_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_save_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.save_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_save_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.save_game_data.is_none() {
            self.save_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.save_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_save_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.save_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGameServerGetLoadGameResult {
    const NAME: &'static str = "CMsgGameServerGetLoadGameResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.save_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.save_game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.save_game_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGameServerGetLoadGameResult {
        CMsgGameServerGetLoadGameResult::new()
    }

    fn clear(&mut self) {
        self.save_game_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGameServerGetLoadGameResult {
        static instance: CMsgGameServerGetLoadGameResult = CMsgGameServerGetLoadGameResult {
            save_game_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAAwardEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAAwardEventPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.award_points)
    pub award_points: ::std::vec::Vec<cmsg_dotaaward_event_points::AwardPoints>,
    // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAAwardEventPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAAwardEventPoints {
    fn default() -> &'a CMsgDOTAAwardEventPoints {
        <CMsgDOTAAwardEventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAAwardEventPoints {
    pub fn new() -> CMsgDOTAAwardEventPoints {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 4;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 5;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 audit_action = 6;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAAwardEventPoints {
    const NAME: &'static str = "CMsgDOTAAwardEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.award_points.push(is.read_message()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.award_points {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.award_points {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAAwardEventPoints {
        CMsgDOTAAwardEventPoints::new()
    }

    fn clear(&mut self) {
        self.award_points.clear();
        self.match_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAAwardEventPoints {
        static instance: CMsgDOTAAwardEventPoints = CMsgDOTAAwardEventPoints {
            award_points: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAAwardEventPoints`
pub mod cmsg_dotaaward_event_points {
    // @@protoc_insertion_point(message:CMsgDOTAAwardEventPoints.AwardPoints)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AwardPoints {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.points)
        pub points: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.premium_points)
        pub premium_points: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.trade_ban_time)
        pub trade_ban_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.eligible_for_periodic_adjustment)
        pub eligible_for_periodic_adjustment: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAAwardEventPoints.AwardPoints.point_cap_periodic_resource_id)
        pub point_cap_periodic_resource_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAAwardEventPoints.AwardPoints.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AwardPoints {
        fn default() -> &'a AwardPoints {
            <AwardPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AwardPoints {
        pub fn new() -> AwardPoints {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 points = 2;

        pub fn points(&self) -> i32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: i32) {
            self.points = ::std::option::Option::Some(v);
        }

        // optional int32 premium_points = 3;

        pub fn premium_points(&self) -> i32 {
            self.premium_points.unwrap_or(0)
        }

        pub fn clear_premium_points(&mut self) {
            self.premium_points = ::std::option::Option::None;
        }

        pub fn has_premium_points(&self) -> bool {
            self.premium_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_premium_points(&mut self, v: i32) {
            self.premium_points = ::std::option::Option::Some(v);
        }

        // optional uint32 trade_ban_time = 5;

        pub fn trade_ban_time(&self) -> u32 {
            self.trade_ban_time.unwrap_or(0)
        }

        pub fn clear_trade_ban_time(&mut self) {
            self.trade_ban_time = ::std::option::Option::None;
        }

        pub fn has_trade_ban_time(&self) -> bool {
            self.trade_ban_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trade_ban_time(&mut self, v: u32) {
            self.trade_ban_time = ::std::option::Option::Some(v);
        }

        // optional bool eligible_for_periodic_adjustment = 6;

        pub fn eligible_for_periodic_adjustment(&self) -> bool {
            self.eligible_for_periodic_adjustment.unwrap_or(false)
        }

        pub fn clear_eligible_for_periodic_adjustment(&mut self) {
            self.eligible_for_periodic_adjustment = ::std::option::Option::None;
        }

        pub fn has_eligible_for_periodic_adjustment(&self) -> bool {
            self.eligible_for_periodic_adjustment.is_some()
        }

        // Param is passed by value, moved
        pub fn set_eligible_for_periodic_adjustment(&mut self, v: bool) {
            self.eligible_for_periodic_adjustment = ::std::option::Option::Some(v);
        }

        // optional uint32 point_cap_periodic_resource_id = 7;

        pub fn point_cap_periodic_resource_id(&self) -> u32 {
            self.point_cap_periodic_resource_id.unwrap_or(0)
        }

        pub fn clear_point_cap_periodic_resource_id(&mut self) {
            self.point_cap_periodic_resource_id = ::std::option::Option::None;
        }

        pub fn has_point_cap_periodic_resource_id(&self) -> bool {
            self.point_cap_periodic_resource_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_point_cap_periodic_resource_id(&mut self, v: u32) {
            self.point_cap_periodic_resource_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AwardPoints {
        const NAME: &'static str = "AwardPoints";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.premium_points = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.trade_ban_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.eligible_for_periodic_adjustment = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.point_cap_periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.premium_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.trade_ban_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.eligible_for_periodic_adjustment {
                my_size += 1 + 1;
            }
            if let Some(v) = self.point_cap_periodic_resource_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.premium_points {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.trade_ban_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.eligible_for_periodic_adjustment {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.point_cap_periodic_resource_id {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AwardPoints {
            AwardPoints::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.premium_points = ::std::option::Option::None;
            self.trade_ban_time = ::std::option::Option::None;
            self.eligible_for_periodic_adjustment = ::std::option::Option::None;
            self.point_cap_periodic_resource_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AwardPoints {
            static instance: AwardPoints = AwardPoints {
                account_id: ::std::option::Option::None,
                points: ::std::option::Option::None,
                premium_points: ::std::option::Option::None,
                trade_ban_time: ::std::option::Option::None,
                eligible_for_periodic_adjustment: ::std::option::Option::None,
                point_cap_periodic_resource_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerPingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerPingRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerPingRequest.request_id)
    pub request_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToServerPingRequest.request_time)
    pub request_time: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerPingRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerPingRequest {
    fn default() -> &'a CMsgGCToServerPingRequest {
        <CMsgGCToServerPingRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerPingRequest {
    pub fn new() -> CMsgGCToServerPingRequest {
        ::std::default::Default::default()
    }

    // optional fixed64 request_id = 1;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 request_time = 2;

    pub fn request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerPingRequest {
    const NAME: &'static str = "CMsgGCToServerPingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.request_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.request_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.request_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerPingRequest {
        CMsgGCToServerPingRequest::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerPingRequest {
        static instance: CMsgGCToServerPingRequest = CMsgGCToServerPingRequest {
            request_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerPingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerPingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerPingResponse.request_id)
    pub request_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToServerPingResponse.request_time)
    pub request_time: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToServerPingResponse.cluster)
    pub cluster: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerPingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerPingResponse {
    fn default() -> &'a CMsgGCToServerPingResponse {
        <CMsgGCToServerPingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerPingResponse {
    pub fn new() -> CMsgGCToServerPingResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 request_id = 1;

    pub fn request_id(&self) -> u64 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u64) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint64 request_time = 2;

    pub fn request_time(&self) -> u64 {
        self.request_time.unwrap_or(0)
    }

    pub fn clear_request_time(&mut self) {
        self.request_time = ::std::option::Option::None;
    }

    pub fn has_request_time(&self) -> bool {
        self.request_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_time(&mut self, v: u64) {
        self.request_time = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 3;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerPingResponse {
    const NAME: &'static str = "CMsgGCToServerPingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.request_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.request_time = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.request_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.request_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.request_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.request_time {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.cluster {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerPingResponse {
        CMsgGCToServerPingResponse::new()
    }

    fn clear(&mut self) {
        self.request_id = ::std::option::Option::None;
        self.request_time = ::std::option::Option::None;
        self.cluster = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerPingResponse {
        static instance: CMsgGCToServerPingResponse = CMsgGCToServerPingResponse {
            request_id: ::std::option::Option::None,
            request_time: ::std::option::Option::None,
            cluster: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCMatchConnectionStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchConnectionStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.region_id)
    pub region_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_connection_stats::Player>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.cluster_id)
    pub cluster_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCMatchConnectionStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchConnectionStats {
    fn default() -> &'a CMsgServerToGCMatchConnectionStats {
        <CMsgServerToGCMatchConnectionStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchConnectionStats {
    pub fn new() -> CMsgServerToGCMatchConnectionStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 region_id = 2;

    pub fn region_id(&self) -> u32 {
        self.region_id.unwrap_or(0)
    }

    pub fn clear_region_id(&mut self) {
        self.region_id = ::std::option::Option::None;
    }

    pub fn has_region_id(&self) -> bool {
        self.region_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_id(&mut self, v: u32) {
        self.region_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster_id = 5;

    pub fn cluster_id(&self) -> u32 {
        self.cluster_id.unwrap_or(0)
    }

    pub fn clear_cluster_id(&mut self) {
        self.cluster_id = ::std::option::Option::None;
    }

    pub fn has_cluster_id(&self) -> bool {
        self.cluster_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: u32) {
        self.cluster_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCMatchConnectionStats {
    const NAME: &'static str = "CMsgServerToGCMatchConnectionStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.region_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.players.push(is.read_message()?);
                },
                40 => {
                    self.cluster_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.region_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.cluster_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.region_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.cluster_id {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchConnectionStats {
        CMsgServerToGCMatchConnectionStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.region_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.players.clear();
        self.cluster_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchConnectionStats {
        static instance: CMsgServerToGCMatchConnectionStats = CMsgServerToGCMatchConnectionStats {
            match_id: ::std::option::Option::None,
            region_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            cluster_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCMatchConnectionStats`
pub mod cmsg_server_to_gcmatch_connection_stats {
    // @@protoc_insertion_point(message:CMsgServerToGCMatchConnectionStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.ip)
        pub ip: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.avg_ping_ms)
        pub avg_ping_ms: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.packet_loss)
        pub packet_loss: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.ping_deviation)
        pub ping_deviation: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchConnectionStats.Player.full_resends)
        pub full_resends: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchConnectionStats.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 ip = 2;

        pub fn ip(&self) -> u32 {
            self.ip.unwrap_or(0)
        }

        pub fn clear_ip(&mut self) {
            self.ip = ::std::option::Option::None;
        }

        pub fn has_ip(&self) -> bool {
            self.ip.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ip(&mut self, v: u32) {
            self.ip = ::std::option::Option::Some(v);
        }

        // optional uint32 avg_ping_ms = 3;

        pub fn avg_ping_ms(&self) -> u32 {
            self.avg_ping_ms.unwrap_or(0)
        }

        pub fn clear_avg_ping_ms(&mut self) {
            self.avg_ping_ms = ::std::option::Option::None;
        }

        pub fn has_avg_ping_ms(&self) -> bool {
            self.avg_ping_ms.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_ping_ms(&mut self, v: u32) {
            self.avg_ping_ms = ::std::option::Option::Some(v);
        }

        // optional float packet_loss = 5;

        pub fn packet_loss(&self) -> f32 {
            self.packet_loss.unwrap_or(0.)
        }

        pub fn clear_packet_loss(&mut self) {
            self.packet_loss = ::std::option::Option::None;
        }

        pub fn has_packet_loss(&self) -> bool {
            self.packet_loss.is_some()
        }

        // Param is passed by value, moved
        pub fn set_packet_loss(&mut self, v: f32) {
            self.packet_loss = ::std::option::Option::Some(v);
        }

        // optional float ping_deviation = 6;

        pub fn ping_deviation(&self) -> f32 {
            self.ping_deviation.unwrap_or(0.)
        }

        pub fn clear_ping_deviation(&mut self) {
            self.ping_deviation = ::std::option::Option::None;
        }

        pub fn has_ping_deviation(&self) -> bool {
            self.ping_deviation.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping_deviation(&mut self, v: f32) {
            self.ping_deviation = ::std::option::Option::Some(v);
        }

        // optional uint32 full_resends = 7;

        pub fn full_resends(&self) -> u32 {
            self.full_resends.unwrap_or(0)
        }

        pub fn clear_full_resends(&mut self) {
            self.full_resends = ::std::option::Option::None;
        }

        pub fn has_full_resends(&self) -> bool {
            self.full_resends.is_some()
        }

        // Param is passed by value, moved
        pub fn set_full_resends(&mut self, v: u32) {
            self.full_resends = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.ip = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    24 => {
                        self.avg_ping_ms = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    45 => {
                        self.packet_loss = ::std::option::Option::Some(is.read_float()?);
                    },
                    53 => {
                        self.ping_deviation = ::std::option::Option::Some(is.read_float()?);
                    },
                    56 => {
                        self.full_resends = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ip {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_ping_ms {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.packet_loss {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ping_deviation {
                my_size += 1 + 4;
            }
            if let Some(v) = self.full_resends {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ip {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.avg_ping_ms {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.packet_loss {
                os.write_float(5, v)?;
            }
            if let Some(v) = self.ping_deviation {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.full_resends {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.ip = ::std::option::Option::None;
            self.avg_ping_ms = ::std::option::Option::None;
            self.packet_loss = ::std::option::Option::None;
            self.ping_deviation = ::std::option::Option::None;
            self.full_resends = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                ip: ::std::option::Option::None,
                avg_ping_ms: ::std::option::Option::None,
                packet_loss: ::std::option::Option::None,
                ping_deviation: ::std::option::Option::None,
                full_resends: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerGCUpdateSpectatorCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerGCUpdateSpectatorCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerGCUpdateSpectatorCount.spectator_count)
    pub spectator_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerGCUpdateSpectatorCount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerGCUpdateSpectatorCount {
    fn default() -> &'a CMsgServerGCUpdateSpectatorCount {
        <CMsgServerGCUpdateSpectatorCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerGCUpdateSpectatorCount {
    pub fn new() -> CMsgServerGCUpdateSpectatorCount {
        ::std::default::Default::default()
    }

    // optional uint32 spectator_count = 1;

    pub fn spectator_count(&self) -> u32 {
        self.spectator_count.unwrap_or(0)
    }

    pub fn clear_spectator_count(&mut self) {
        self.spectator_count = ::std::option::Option::None;
    }

    pub fn has_spectator_count(&self) -> bool {
        self.spectator_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spectator_count(&mut self, v: u32) {
        self.spectator_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerGCUpdateSpectatorCount {
    const NAME: &'static str = "CMsgServerGCUpdateSpectatorCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.spectator_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.spectator_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.spectator_count {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerGCUpdateSpectatorCount {
        CMsgServerGCUpdateSpectatorCount::new()
    }

    fn clear(&mut self) {
        self.spectator_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerGCUpdateSpectatorCount {
        static instance: CMsgServerGCUpdateSpectatorCount = CMsgServerGCUpdateSpectatorCount {
            spectator_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSerializedCombatLog)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSerializedCombatLog {
    // message fields
    // @@protoc_insertion_point(field:CSerializedCombatLog.version)
    pub version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSerializedCombatLog.dictionary)
    pub dictionary: ::steam_vent_proto_common::protobuf::MessageField<cserialized_combat_log::Dictionary>,
    // @@protoc_insertion_point(field:CSerializedCombatLog.entries)
    pub entries: ::std::vec::Vec<super::dota_shared_enums::CMsgDOTACombatLogEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CSerializedCombatLog.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSerializedCombatLog {
    fn default() -> &'a CSerializedCombatLog {
        <CSerializedCombatLog as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSerializedCombatLog {
    pub fn new() -> CSerializedCombatLog {
        ::std::default::Default::default()
    }

    // optional uint32 version = 1;

    pub fn version(&self) -> u32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: u32) {
        self.version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSerializedCombatLog {
    const NAME: &'static str = "CSerializedCombatLog";

    fn is_initialized(&self) -> bool {
        for v in &self.dictionary {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dictionary)?;
                },
                26 => {
                    self.entries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.dictionary.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.dictionary.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSerializedCombatLog {
        CSerializedCombatLog::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.dictionary.clear();
        self.entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSerializedCombatLog {
        static instance: CSerializedCombatLog = CSerializedCombatLog {
            version: ::std::option::Option::None,
            dictionary: ::steam_vent_proto_common::protobuf::MessageField::none(),
            entries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CSerializedCombatLog`
pub mod cserialized_combat_log {
    // @@protoc_insertion_point(message:CSerializedCombatLog.Dictionary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Dictionary {
        // message fields
        // @@protoc_insertion_point(field:CSerializedCombatLog.Dictionary.strings)
        pub strings: ::std::vec::Vec<dictionary::DictString>,
        // special fields
        // @@protoc_insertion_point(special_field:CSerializedCombatLog.Dictionary.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Dictionary {
        fn default() -> &'a Dictionary {
            <Dictionary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Dictionary {
        pub fn new() -> Dictionary {
            ::std::default::Default::default()
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Dictionary {
        const NAME: &'static str = "Dictionary";

        fn is_initialized(&self) -> bool {
            for v in &self.strings {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.strings.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.strings {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.strings {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Dictionary {
            Dictionary::new()
        }

        fn clear(&mut self) {
            self.strings.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Dictionary {
            static instance: Dictionary = Dictionary {
                strings: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Dictionary`
    pub mod dictionary {
        // @@protoc_insertion_point(message:CSerializedCombatLog.Dictionary.DictString)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct DictString {
            // message fields
            // @@protoc_insertion_point(field:CSerializedCombatLog.Dictionary.DictString.id)
            pub id: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CSerializedCombatLog.Dictionary.DictString.value)
            pub value: ::std::option::Option<::std::string::String>,
            // special fields
            // @@protoc_insertion_point(special_field:CSerializedCombatLog.Dictionary.DictString.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a DictString {
            fn default() -> &'a DictString {
                <DictString as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl DictString {
            pub fn new() -> DictString {
                ::std::default::Default::default()
            }

            // required uint32 id = 1;

            pub fn id(&self) -> u32 {
                self.id.unwrap_or(0)
            }

            pub fn clear_id(&mut self) {
                self.id = ::std::option::Option::None;
            }

            pub fn has_id(&self) -> bool {
                self.id.is_some()
            }

            // Param is passed by value, moved
            pub fn set_id(&mut self, v: u32) {
                self.id = ::std::option::Option::Some(v);
            }

            // required string value = 2;

            pub fn value(&self) -> &str {
                match self.value.as_ref() {
                    Some(v) => v,
                    None => "",
                }
            }

            pub fn clear_value(&mut self) {
                self.value = ::std::option::Option::None;
            }

            pub fn has_value(&self) -> bool {
                self.value.is_some()
            }

            // Param is passed by value, moved
            pub fn set_value(&mut self, v: ::std::string::String) {
                self.value = ::std::option::Option::Some(v);
            }

            // Mutable pointer to the field.
            // If field is not initialized, it is initialized with default value first.
            pub fn mut_value(&mut self) -> &mut ::std::string::String {
                if self.value.is_none() {
                    self.value = ::std::option::Option::Some(::std::string::String::new());
                }
                self.value.as_mut().unwrap()
            }

            // Take field
            pub fn take_value(&mut self) -> ::std::string::String {
                self.value.take().unwrap_or_else(|| ::std::string::String::new())
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for DictString {
            const NAME: &'static str = "DictString";

            fn is_initialized(&self) -> bool {
                if self.id.is_none() {
                    return false;
                }
                if self.value.is_none() {
                    return false;
                }
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.id = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        18 => {
                            self.value = ::std::option::Option::Some(is.read_string()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.id {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.value.as_ref() {
                    my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.id {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.value.as_ref() {
                    os.write_string(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> DictString {
                DictString::new()
            }

            fn clear(&mut self) {
                self.id = ::std::option::Option::None;
                self.value = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static DictString {
                static instance: DictString = DictString {
                    id: ::std::option::Option::None,
                    value: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCVictoryPredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCVictoryPredictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.records)
    pub records: ::std::vec::Vec<cmsg_server_to_gcvictory_predictions::Record>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCVictoryPredictions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCVictoryPredictions {
    fn default() -> &'a CMsgServerToGCVictoryPredictions {
        <CMsgServerToGCVictoryPredictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCVictoryPredictions {
    pub fn new() -> CMsgServerToGCVictoryPredictions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCVictoryPredictions {
    const NAME: &'static str = "CMsgServerToGCVictoryPredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.records.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.records {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCVictoryPredictions {
        CMsgServerToGCVictoryPredictions::new()
    }

    fn clear(&mut self) {
        self.records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCVictoryPredictions {
        static instance: CMsgServerToGCVictoryPredictions = CMsgServerToGCVictoryPredictions {
            records: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCVictoryPredictions`
pub mod cmsg_server_to_gcvictory_predictions {
    // @@protoc_insertion_point(message:CMsgServerToGCVictoryPredictions.PredictionItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PredictionItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.PredictionItem.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.PredictionItem.item_def)
        pub item_def: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCVictoryPredictions.PredictionItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PredictionItem {
        fn default() -> &'a PredictionItem {
            <PredictionItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PredictionItem {
        pub fn new() -> PredictionItem {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 item_def = 2;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PredictionItem {
        const NAME: &'static str = "PredictionItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.item_def {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PredictionItem {
            PredictionItem::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.item_def = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PredictionItem {
            static instance: PredictionItem = PredictionItem {
                item_id: ::std::option::Option::None,
                item_def: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCVictoryPredictions.Record)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Record {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.Record.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.Record.item_ids)
        pub item_ids: ::std::vec::Vec<u64>,
        // @@protoc_insertion_point(field:CMsgServerToGCVictoryPredictions.Record.prediction_items)
        pub prediction_items: ::std::vec::Vec<PredictionItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCVictoryPredictions.Record.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Record {
        fn default() -> &'a Record {
            <Record as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Record {
        pub fn new() -> Record {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Record {
        const NAME: &'static str = "Record";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                    },
                    40 => {
                        self.item_ids.push(is.read_uint64()?);
                    },
                    50 => {
                        self.prediction_items.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.item_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, *value);
            };
            for value in &self.prediction_items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.item_ids {
                os.write_uint64(5, *v)?;
            };
            for v in &self.prediction_items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Record {
            Record::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.item_ids.clear();
            self.prediction_items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Record {
            static instance: Record = Record {
                account_id: ::std::option::Option::None,
                item_ids: ::std::vec::Vec::new(),
                prediction_items: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestStatus {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestStatus {
    fn default() -> &'a CMsgServerToGCRequestStatus {
        <CMsgServerToGCRequestStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestStatus {
    pub fn new() -> CMsgServerToGCRequestStatus {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestStatus {
    const NAME: &'static str = "CMsgServerToGCRequestStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestStatus {
        CMsgServerToGCRequestStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestStatus {
        static instance: CMsgServerToGCRequestStatus = CMsgServerToGCRequestStatus {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRequestStatus_Response)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRequestStatus_Response {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRequestStatus_Response.response)
    pub response: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRequestStatus_Response.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRequestStatus_Response {
    fn default() -> &'a CMsgServerToGCRequestStatus_Response {
        <CMsgServerToGCRequestStatus_Response as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRequestStatus_Response {
    pub fn new() -> CMsgServerToGCRequestStatus_Response {
        ::std::default::Default::default()
    }

    // optional uint32 response = 1;

    pub fn response(&self) -> u32 {
        self.response.unwrap_or(0)
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: u32) {
        self.response = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRequestStatus_Response {
    const NAME: &'static str = "CMsgServerToGCRequestStatus_Response";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRequestStatus_Response {
        CMsgServerToGCRequestStatus_Response::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRequestStatus_Response {
        static instance: CMsgServerToGCRequestStatus_Response = CMsgServerToGCRequestStatus_Response {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerEvaluateToxicChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerEvaluateToxicChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerEvaluateToxicChat.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToServerEvaluateToxicChat.reporter_account_id)
    pub reporter_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerEvaluateToxicChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerEvaluateToxicChat {
    fn default() -> &'a CMsgGCToServerEvaluateToxicChat {
        <CMsgGCToServerEvaluateToxicChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerEvaluateToxicChat {
    pub fn new() -> CMsgGCToServerEvaluateToxicChat {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reporter_account_id = 2;

    pub fn reporter_account_id(&self) -> u32 {
        self.reporter_account_id.unwrap_or(0)
    }

    pub fn clear_reporter_account_id(&mut self) {
        self.reporter_account_id = ::std::option::Option::None;
    }

    pub fn has_reporter_account_id(&self) -> bool {
        self.reporter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reporter_account_id(&mut self, v: u32) {
        self.reporter_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerEvaluateToxicChat {
    const NAME: &'static str = "CMsgGCToServerEvaluateToxicChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reporter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reporter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reporter_account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerEvaluateToxicChat {
        CMsgGCToServerEvaluateToxicChat::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.reporter_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerEvaluateToxicChat {
        static instance: CMsgGCToServerEvaluateToxicChat = CMsgGCToServerEvaluateToxicChat {
            target_account_id: ::std::option::Option::None,
            reporter_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCEvaluateToxicChat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCEvaluateToxicChat {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChat.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChat.reporter_account_id)
    pub reporter_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChat.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChat.timestamp)
    pub timestamp: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChat.line)
    pub line: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCEvaluateToxicChat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCEvaluateToxicChat {
    fn default() -> &'a CMsgServerToGCEvaluateToxicChat {
        <CMsgServerToGCEvaluateToxicChat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCEvaluateToxicChat {
    pub fn new() -> CMsgServerToGCEvaluateToxicChat {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reporter_account_id = 2;

    pub fn reporter_account_id(&self) -> u32 {
        self.reporter_account_id.unwrap_or(0)
    }

    pub fn clear_reporter_account_id(&mut self) {
        self.reporter_account_id = ::std::option::Option::None;
    }

    pub fn has_reporter_account_id(&self) -> bool {
        self.reporter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reporter_account_id(&mut self, v: u32) {
        self.reporter_account_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCEvaluateToxicChat {
    const NAME: &'static str = "CMsgServerToGCEvaluateToxicChat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reporter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                25 => {
                    self.match_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.timestamp)?;
                },
                32 => {
                    self.timestamp.push(is.read_uint32()?);
                },
                42 => {
                    self.line.push(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reporter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.match_id {
            my_size += 1 + 8;
        }
        for value in &self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.line {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reporter_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_fixed64(3, v)?;
        }
        for v in &self.timestamp {
            os.write_uint32(4, *v)?;
        };
        for v in &self.line {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCEvaluateToxicChat {
        CMsgServerToGCEvaluateToxicChat::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.reporter_account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.timestamp.clear();
        self.line.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCEvaluateToxicChat {
        static instance: CMsgServerToGCEvaluateToxicChat = CMsgServerToGCEvaluateToxicChat {
            target_account_id: ::std::option::Option::None,
            reporter_account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            timestamp: ::std::vec::Vec::new(),
            line: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCEvaluateToxicChatResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCEvaluateToxicChatResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChatResponse.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChatResponse.reporter_account_id)
    pub reporter_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChatResponse.ban_reason)
    pub ban_reason: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChatResponse.ban_duration)
    pub ban_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCEvaluateToxicChatResponse.toxicity_score)
    pub toxicity_score: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCEvaluateToxicChatResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCEvaluateToxicChatResponse {
    fn default() -> &'a CMsgServerToGCEvaluateToxicChatResponse {
        <CMsgServerToGCEvaluateToxicChatResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCEvaluateToxicChatResponse {
    pub fn new() -> CMsgServerToGCEvaluateToxicChatResponse {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 reporter_account_id = 2;

    pub fn reporter_account_id(&self) -> u32 {
        self.reporter_account_id.unwrap_or(0)
    }

    pub fn clear_reporter_account_id(&mut self) {
        self.reporter_account_id = ::std::option::Option::None;
    }

    pub fn has_reporter_account_id(&self) -> bool {
        self.reporter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reporter_account_id(&mut self, v: u32) {
        self.reporter_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 ban_reason = 3;

    pub fn ban_reason(&self) -> u32 {
        self.ban_reason.unwrap_or(0)
    }

    pub fn clear_ban_reason(&mut self) {
        self.ban_reason = ::std::option::Option::None;
    }

    pub fn has_ban_reason(&self) -> bool {
        self.ban_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_reason(&mut self, v: u32) {
        self.ban_reason = ::std::option::Option::Some(v);
    }

    // optional uint32 ban_duration = 4;

    pub fn ban_duration(&self) -> u32 {
        self.ban_duration.unwrap_or(0)
    }

    pub fn clear_ban_duration(&mut self) {
        self.ban_duration = ::std::option::Option::None;
    }

    pub fn has_ban_duration(&self) -> bool {
        self.ban_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ban_duration(&mut self, v: u32) {
        self.ban_duration = ::std::option::Option::Some(v);
    }

    // optional float toxicity_score = 5;

    pub fn toxicity_score(&self) -> f32 {
        self.toxicity_score.unwrap_or(0.)
    }

    pub fn clear_toxicity_score(&mut self) {
        self.toxicity_score = ::std::option::Option::None;
    }

    pub fn has_toxicity_score(&self) -> bool {
        self.toxicity_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_toxicity_score(&mut self, v: f32) {
        self.toxicity_score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCEvaluateToxicChatResponse {
    const NAME: &'static str = "CMsgServerToGCEvaluateToxicChatResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reporter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.ban_reason = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.ban_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                45 => {
                    self.toxicity_score = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reporter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.ban_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ban_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.toxicity_score {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reporter_account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.ban_reason {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ban_duration {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.toxicity_score {
            os.write_float(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCEvaluateToxicChatResponse {
        CMsgServerToGCEvaluateToxicChatResponse::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.reporter_account_id = ::std::option::Option::None;
        self.ban_reason = ::std::option::Option::None;
        self.ban_duration = ::std::option::Option::None;
        self.toxicity_score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCEvaluateToxicChatResponse {
        static instance: CMsgServerToGCEvaluateToxicChatResponse = CMsgServerToGCEvaluateToxicChatResponse {
            target_account_id: ::std::option::Option::None,
            reporter_account_id: ::std::option::Option::None,
            ban_reason: ::std::option::Option::None,
            ban_duration: ::std::option::Option::None,
            toxicity_score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutAssassinMiniGameInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutAssassinMiniGameInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.winning_players)
    pub winning_players: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.losing_players)
    pub losing_players: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.arcana_owners)
    pub arcana_owners: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.assassin_won)
    pub assassin_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.target_hero_id)
    pub target_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.contract_completed)
    pub contract_completed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.contract_complete_time)
    pub contract_complete_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutAssassinMiniGameInfo.pa_is_radiant)
    pub pa_is_radiant: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutAssassinMiniGameInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutAssassinMiniGameInfo {
    fn default() -> &'a CMsgSignOutAssassinMiniGameInfo {
        <CMsgSignOutAssassinMiniGameInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutAssassinMiniGameInfo {
    pub fn new() -> CMsgSignOutAssassinMiniGameInfo {
        ::std::default::Default::default()
    }

    // optional bool assassin_won = 4;

    pub fn assassin_won(&self) -> bool {
        self.assassin_won.unwrap_or(false)
    }

    pub fn clear_assassin_won(&mut self) {
        self.assassin_won = ::std::option::Option::None;
    }

    pub fn has_assassin_won(&self) -> bool {
        self.assassin_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assassin_won(&mut self, v: bool) {
        self.assassin_won = ::std::option::Option::Some(v);
    }

    // optional int32 target_hero_id = 5;

    pub fn target_hero_id(&self) -> i32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: i32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional bool contract_completed = 6;

    pub fn contract_completed(&self) -> bool {
        self.contract_completed.unwrap_or(false)
    }

    pub fn clear_contract_completed(&mut self) {
        self.contract_completed = ::std::option::Option::None;
    }

    pub fn has_contract_completed(&self) -> bool {
        self.contract_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_completed(&mut self, v: bool) {
        self.contract_completed = ::std::option::Option::Some(v);
    }

    // optional float contract_complete_time = 7;

    pub fn contract_complete_time(&self) -> f32 {
        self.contract_complete_time.unwrap_or(0.)
    }

    pub fn clear_contract_complete_time(&mut self) {
        self.contract_complete_time = ::std::option::Option::None;
    }

    pub fn has_contract_complete_time(&self) -> bool {
        self.contract_complete_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_complete_time(&mut self, v: f32) {
        self.contract_complete_time = ::std::option::Option::Some(v);
    }

    // optional bool pa_is_radiant = 8;

    pub fn pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.unwrap_or(false)
    }

    pub fn clear_pa_is_radiant(&mut self) {
        self.pa_is_radiant = ::std::option::Option::None;
    }

    pub fn has_pa_is_radiant(&self) -> bool {
        self.pa_is_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pa_is_radiant(&mut self, v: bool) {
        self.pa_is_radiant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutAssassinMiniGameInfo {
    const NAME: &'static str = "CMsgSignOutAssassinMiniGameInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.winning_players)?;
                },
                9 => {
                    self.winning_players.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.losing_players)?;
                },
                17 => {
                    self.losing_players.push(is.read_fixed64()?);
                },
                26 => {
                    is.read_repeated_packed_fixed64_into(&mut self.arcana_owners)?;
                },
                25 => {
                    self.arcana_owners.push(is.read_fixed64()?);
                },
                32 => {
                    self.assassin_won = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                48 => {
                    self.contract_completed = ::std::option::Option::Some(is.read_bool()?);
                },
                61 => {
                    self.contract_complete_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.pa_is_radiant = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.winning_players.len() as u64;
        my_size += 9 * self.losing_players.len() as u64;
        my_size += 9 * self.arcana_owners.len() as u64;
        if let Some(v) = self.assassin_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        if let Some(v) = self.contract_completed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.contract_complete_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.pa_is_radiant {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.winning_players {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.losing_players {
            os.write_fixed64(2, *v)?;
        };
        for v in &self.arcana_owners {
            os.write_fixed64(3, *v)?;
        };
        if let Some(v) = self.assassin_won {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.contract_completed {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.contract_complete_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.pa_is_radiant {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutAssassinMiniGameInfo {
        CMsgSignOutAssassinMiniGameInfo::new()
    }

    fn clear(&mut self) {
        self.winning_players.clear();
        self.losing_players.clear();
        self.arcana_owners.clear();
        self.assassin_won = ::std::option::Option::None;
        self.target_hero_id = ::std::option::Option::None;
        self.contract_completed = ::std::option::Option::None;
        self.contract_complete_time = ::std::option::Option::None;
        self.pa_is_radiant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutAssassinMiniGameInfo {
        static instance: CMsgSignOutAssassinMiniGameInfo = CMsgSignOutAssassinMiniGameInfo {
            winning_players: ::std::vec::Vec::new(),
            losing_players: ::std::vec::Vec::new(),
            arcana_owners: ::std::vec::Vec::new(),
            assassin_won: ::std::option::Option::None,
            target_hero_id: ::std::option::Option::None,
            contract_completed: ::std::option::Option::None,
            contract_complete_time: ::std::option::Option::None,
            pa_is_radiant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCKillSummaries)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCKillSummaries {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCKillSummaries.ingameevent_id)
    pub ingameevent_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCKillSummaries.summaries)
    pub summaries: ::std::vec::Vec<cmsg_server_to_gckill_summaries::KillSummary>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCKillSummaries.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCKillSummaries {
    fn default() -> &'a CMsgServerToGCKillSummaries {
        <CMsgServerToGCKillSummaries as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCKillSummaries {
    pub fn new() -> CMsgServerToGCKillSummaries {
        ::std::default::Default::default()
    }

    // optional uint32 ingameevent_id = 1;

    pub fn ingameevent_id(&self) -> u32 {
        self.ingameevent_id.unwrap_or(0)
    }

    pub fn clear_ingameevent_id(&mut self) {
        self.ingameevent_id = ::std::option::Option::None;
    }

    pub fn has_ingameevent_id(&self) -> bool {
        self.ingameevent_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ingameevent_id(&mut self, v: u32) {
        self.ingameevent_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCKillSummaries {
    const NAME: &'static str = "CMsgServerToGCKillSummaries";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ingameevent_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.summaries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ingameevent_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.summaries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ingameevent_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.summaries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCKillSummaries {
        CMsgServerToGCKillSummaries::new()
    }

    fn clear(&mut self) {
        self.ingameevent_id = ::std::option::Option::None;
        self.summaries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCKillSummaries {
        static instance: CMsgServerToGCKillSummaries = CMsgServerToGCKillSummaries {
            ingameevent_id: ::std::option::Option::None,
            summaries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCKillSummaries`
pub mod cmsg_server_to_gckill_summaries {
    // @@protoc_insertion_point(message:CMsgServerToGCKillSummaries.KillSummary)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct KillSummary {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCKillSummaries.KillSummary.killer_hero_id)
        pub killer_hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCKillSummaries.KillSummary.victim_hero_id)
        pub victim_hero_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCKillSummaries.KillSummary.kill_count)
        pub kill_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCKillSummaries.KillSummary.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a KillSummary {
        fn default() -> &'a KillSummary {
            <KillSummary as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl KillSummary {
        pub fn new() -> KillSummary {
            ::std::default::Default::default()
        }

        // optional uint32 killer_hero_id = 1;

        pub fn killer_hero_id(&self) -> u32 {
            self.killer_hero_id.unwrap_or(0)
        }

        pub fn clear_killer_hero_id(&mut self) {
            self.killer_hero_id = ::std::option::Option::None;
        }

        pub fn has_killer_hero_id(&self) -> bool {
            self.killer_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_killer_hero_id(&mut self, v: u32) {
            self.killer_hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 victim_hero_id = 2;

        pub fn victim_hero_id(&self) -> u32 {
            self.victim_hero_id.unwrap_or(0)
        }

        pub fn clear_victim_hero_id(&mut self) {
            self.victim_hero_id = ::std::option::Option::None;
        }

        pub fn has_victim_hero_id(&self) -> bool {
            self.victim_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_victim_hero_id(&mut self, v: u32) {
            self.victim_hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 kill_count = 3;

        pub fn kill_count(&self) -> u32 {
            self.kill_count.unwrap_or(0)
        }

        pub fn clear_kill_count(&mut self) {
            self.kill_count = ::std::option::Option::None;
        }

        pub fn has_kill_count(&self) -> bool {
            self.kill_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kill_count(&mut self, v: u32) {
            self.kill_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for KillSummary {
        const NAME: &'static str = "KillSummary";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.killer_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.victim_hero_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.kill_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.killer_hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.victim_hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.kill_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.killer_hero_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.victim_hero_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.kill_count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> KillSummary {
            KillSummary::new()
        }

        fn clear(&mut self) {
            self.killer_hero_id = ::std::option::Option::None;
            self.victim_hero_id = ::std::option::Option::None;
            self.kill_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static KillSummary {
            static instance: KillSummary = KillSummary {
                killer_hero_id: ::std::option::Option::None,
                victim_hero_id: ::std::option::Option::None,
                kill_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCLockCharmTrading)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCLockCharmTrading {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCLockCharmTrading.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCLockCharmTrading.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCLockCharmTrading.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCLockCharmTrading {
    fn default() -> &'a CMsgServerToGCLockCharmTrading {
        <CMsgServerToGCLockCharmTrading as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCLockCharmTrading {
    pub fn new() -> CMsgServerToGCLockCharmTrading {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCLockCharmTrading {
    const NAME: &'static str = "CMsgServerToGCLockCharmTrading";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCLockCharmTrading {
        CMsgServerToGCLockCharmTrading::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCLockCharmTrading {
        static instance: CMsgServerToGCLockCharmTrading = CMsgServerToGCLockCharmTrading {
            account_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutUpdatePlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutUpdatePlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.completed)
    pub completed: ::std::vec::Vec<cmsg_sign_out_update_player_challenge::Challenge>,
    // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.rerolled)
    pub rerolled: ::std::vec::Vec<cmsg_sign_out_update_player_challenge::Challenge>,
    // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutUpdatePlayerChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutUpdatePlayerChallenge {
    fn default() -> &'a CMsgSignOutUpdatePlayerChallenge {
        <CMsgSignOutUpdatePlayerChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutUpdatePlayerChallenge {
    pub fn new() -> CMsgSignOutUpdatePlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 5;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutUpdatePlayerChallenge {
    const NAME: &'static str = "CMsgSignOutUpdatePlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.completed.push(is.read_message()?);
                },
                26 => {
                    self.rerolled.push(is.read_message()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.completed {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.rerolled {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.rerolled {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutUpdatePlayerChallenge {
        CMsgSignOutUpdatePlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.completed.clear();
        self.rerolled.clear();
        self.match_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutUpdatePlayerChallenge {
        static instance: CMsgSignOutUpdatePlayerChallenge = CMsgSignOutUpdatePlayerChallenge {
            account_id: ::std::option::Option::None,
            completed: ::std::vec::Vec::new(),
            rerolled: ::std::vec::Vec::new(),
            match_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutUpdatePlayerChallenge`
pub mod cmsg_sign_out_update_player_challenge {
    // @@protoc_insertion_point(message:CMsgSignOutUpdatePlayerChallenge.Challenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Challenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.Challenge.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.Challenge.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.Challenge.sequence_id)
        pub sequence_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.Challenge.progress)
        pub progress: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutUpdatePlayerChallenge.Challenge.challenge_rank)
        pub challenge_rank: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutUpdatePlayerChallenge.Challenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Challenge {
        fn default() -> &'a Challenge {
            <Challenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Challenge {
        pub fn new() -> Challenge {
            ::std::default::Default::default()
        }

        // optional .EEvent event_id = 1;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 slot_id = 2;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional uint32 sequence_id = 3;

        pub fn sequence_id(&self) -> u32 {
            self.sequence_id.unwrap_or(0)
        }

        pub fn clear_sequence_id(&mut self) {
            self.sequence_id = ::std::option::Option::None;
        }

        pub fn has_sequence_id(&self) -> bool {
            self.sequence_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sequence_id(&mut self, v: u32) {
            self.sequence_id = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 4;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_rank = 5;

        pub fn challenge_rank(&self) -> u32 {
            self.challenge_rank.unwrap_or(0)
        }

        pub fn clear_challenge_rank(&mut self) {
            self.challenge_rank = ::std::option::Option::None;
        }

        pub fn has_challenge_rank(&self) -> bool {
            self.challenge_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_rank(&mut self, v: u32) {
            self.challenge_rank = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Challenge {
        const NAME: &'static str = "Challenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.sequence_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sequence_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.progress {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.slot_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sequence_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_rank {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Challenge {
            Challenge::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.slot_id = ::std::option::Option::None;
            self.sequence_id = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.challenge_rank = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Challenge {
            static instance: Challenge = Challenge {
                event_id: ::std::option::Option::None,
                slot_id: ::std::option::Option::None,
                sequence_id: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                challenge_rank: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCRerollPlayerChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCRerollPlayerChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCRerollPlayerChallenge.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCRerollPlayerChallenge.reroll_msg)
    pub reroll_msg: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgClientToGCRerollPlayerChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCRerollPlayerChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCRerollPlayerChallenge {
    fn default() -> &'a CMsgServerToGCRerollPlayerChallenge {
        <CMsgServerToGCRerollPlayerChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCRerollPlayerChallenge {
    pub fn new() -> CMsgServerToGCRerollPlayerChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCRerollPlayerChallenge {
    const NAME: &'static str = "CMsgServerToGCRerollPlayerChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.reroll_msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reroll_msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reroll_msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCRerollPlayerChallenge {
        CMsgServerToGCRerollPlayerChallenge::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.reroll_msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCRerollPlayerChallenge {
        static instance: CMsgServerToGCRerollPlayerChallenge = CMsgServerToGCRerollPlayerChallenge {
            account_id: ::std::option::Option::None,
            reroll_msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSpendWager)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpendWager {
    // message fields
    // @@protoc_insertion_point(field:CMsgSpendWager.players)
    pub players: ::std::vec::Vec<cmsg_spend_wager::Player>,
    // @@protoc_insertion_point(field:CMsgSpendWager.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgSpendWager.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSpendWager.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSpendWager.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSpendWager.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpendWager {
    fn default() -> &'a CMsgSpendWager {
        <CMsgSpendWager as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSpendWager {
    pub fn new() -> CMsgSpendWager {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 4;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint64 server_steam_id = 5;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSpendWager {
    const NAME: &'static str = "CMsgSpendWager";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_uint64(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpendWager {
        CMsgSpendWager::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.event_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpendWager {
        static instance: CMsgSpendWager = CMsgSpendWager {
            players: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSpendWager`
pub mod cmsg_spend_wager {
    // @@protoc_insertion_point(message:CMsgSpendWager.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgSpendWager.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSpendWager.Player.wager)
        pub wager: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSpendWager.Player.wager_token_item_id)
        pub wager_token_item_id: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSpendWager.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wager = 2;

        pub fn wager(&self) -> u32 {
            self.wager.unwrap_or(0)
        }

        pub fn clear_wager(&mut self) {
            self.wager = ::std::option::Option::None;
        }

        pub fn has_wager(&self) -> bool {
            self.wager.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager(&mut self, v: u32) {
            self.wager = ::std::option::Option::Some(v);
        }

        // optional uint64 wager_token_item_id = 3;

        pub fn wager_token_item_id(&self) -> u64 {
            self.wager_token_item_id.unwrap_or(0)
        }

        pub fn clear_wager_token_item_id(&mut self) {
            self.wager_token_item_id = ::std::option::Option::None;
        }

        pub fn has_wager_token_item_id(&self) -> bool {
            self.wager_token_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_token_item_id(&mut self, v: u64) {
            self.wager_token_item_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.wager = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.wager {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wager_token_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.wager {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wager_token_item_id {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.wager = ::std::option::Option::None;
            self.wager_token_item_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                wager: ::std::option::Option::None,
                wager_token_item_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutXPCoins)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutXPCoins {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutXPCoins.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_xpcoins::Player>,
    // @@protoc_insertion_point(field:CMsgSignOutXPCoins.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgSignOutXPCoins.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutXPCoins.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutXPCoins.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutXPCoins {
    fn default() -> &'a CMsgSignOutXPCoins {
        <CMsgSignOutXPCoins as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutXPCoins {
    pub fn new() -> CMsgSignOutXPCoins {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutXPCoins {
    const NAME: &'static str = "CMsgSignOutXPCoins";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutXPCoins {
        CMsgSignOutXPCoins::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.event_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutXPCoins {
        static instance: CMsgSignOutXPCoins = CMsgSignOutXPCoins {
            players: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutXPCoins`
pub mod cmsg_sign_out_xpcoins {
    // @@protoc_insertion_point(message:CMsgSignOutXPCoins.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.xp_gained)
        pub xp_gained: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.coins_spent)
        pub coins_spent: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.wager_token_item_id)
        pub wager_token_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.rank_wager)
        pub rank_wager: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutXPCoins.Player.wager_streak)
        pub wager_streak: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutXPCoins.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 xp_gained = 2;

        pub fn xp_gained(&self) -> u32 {
            self.xp_gained.unwrap_or(0)
        }

        pub fn clear_xp_gained(&mut self) {
            self.xp_gained = ::std::option::Option::None;
        }

        pub fn has_xp_gained(&self) -> bool {
            self.xp_gained.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp_gained(&mut self, v: u32) {
            self.xp_gained = ::std::option::Option::Some(v);
        }

        // optional uint32 coins_spent = 3;

        pub fn coins_spent(&self) -> u32 {
            self.coins_spent.unwrap_or(0)
        }

        pub fn clear_coins_spent(&mut self) {
            self.coins_spent = ::std::option::Option::None;
        }

        pub fn has_coins_spent(&self) -> bool {
            self.coins_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coins_spent(&mut self, v: u32) {
            self.coins_spent = ::std::option::Option::Some(v);
        }

        // optional uint64 wager_token_item_id = 4;

        pub fn wager_token_item_id(&self) -> u64 {
            self.wager_token_item_id.unwrap_or(0)
        }

        pub fn clear_wager_token_item_id(&mut self) {
            self.wager_token_item_id = ::std::option::Option::None;
        }

        pub fn has_wager_token_item_id(&self) -> bool {
            self.wager_token_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_token_item_id(&mut self, v: u64) {
            self.wager_token_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank_wager = 5;

        pub fn rank_wager(&self) -> u32 {
            self.rank_wager.unwrap_or(0)
        }

        pub fn clear_rank_wager(&mut self) {
            self.rank_wager = ::std::option::Option::None;
        }

        pub fn has_rank_wager(&self) -> bool {
            self.rank_wager.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_wager(&mut self, v: u32) {
            self.rank_wager = ::std::option::Option::Some(v);
        }

        // optional uint32 wager_streak = 6;

        pub fn wager_streak(&self) -> u32 {
            self.wager_streak.unwrap_or(0)
        }

        pub fn clear_wager_streak(&mut self) {
            self.wager_streak = ::std::option::Option::None;
        }

        pub fn has_wager_streak(&self) -> bool {
            self.wager_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wager_streak(&mut self, v: u32) {
            self.wager_streak = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.xp_gained = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.coins_spent = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.wager_token_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    40 => {
                        self.rank_wager = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.wager_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.xp_gained {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.coins_spent {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.wager_token_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            if let Some(v) = self.rank_wager {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.wager_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.xp_gained {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.coins_spent {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.wager_token_item_id {
                os.write_uint64(4, v)?;
            }
            if let Some(v) = self.rank_wager {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.wager_streak {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.xp_gained = ::std::option::Option::None;
            self.coins_spent = ::std::option::Option::None;
            self.wager_token_item_id = ::std::option::Option::None;
            self.rank_wager = ::std::option::Option::None;
            self.wager_streak = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                xp_gained: ::std::option::Option::None,
                coins_spent: ::std::option::Option::None,
                wager_token_item_id: ::std::option::Option::None,
                rank_wager: ::std::option::Option::None,
                wager_streak: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutBounties)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutBounties {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutBounties.bounties)
    pub bounties: ::std::vec::Vec<cmsg_sign_out_bounties::Bounty>,
    // @@protoc_insertion_point(field:CMsgSignOutBounties.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgSignOutBounties.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutBounties.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutBounties.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutBounties {
    fn default() -> &'a CMsgSignOutBounties {
        <CMsgSignOutBounties as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutBounties {
    pub fn new() -> CMsgSignOutBounties {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 match_id = 3;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 4;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutBounties {
    const NAME: &'static str = "CMsgSignOutBounties";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.bounties.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.bounties {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.bounties {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutBounties {
        CMsgSignOutBounties::new()
    }

    fn clear(&mut self) {
        self.bounties.clear();
        self.event_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutBounties {
        static instance: CMsgSignOutBounties = CMsgSignOutBounties {
            bounties: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutBounties`
pub mod cmsg_sign_out_bounties {
    // @@protoc_insertion_point(message:CMsgSignOutBounties.Bounty)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bounty {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutBounties.Bounty.issuer_account_id)
        pub issuer_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutBounties.Bounty.completer_account_id)
        pub completer_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutBounties.Bounty.target_account_id)
        pub target_account_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutBounties.Bounty.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bounty {
        fn default() -> &'a Bounty {
            <Bounty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bounty {
        pub fn new() -> Bounty {
            ::std::default::Default::default()
        }

        // optional uint32 issuer_account_id = 1;

        pub fn issuer_account_id(&self) -> u32 {
            self.issuer_account_id.unwrap_or(0)
        }

        pub fn clear_issuer_account_id(&mut self) {
            self.issuer_account_id = ::std::option::Option::None;
        }

        pub fn has_issuer_account_id(&self) -> bool {
            self.issuer_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_issuer_account_id(&mut self, v: u32) {
            self.issuer_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 completer_account_id = 2;

        pub fn completer_account_id(&self) -> u32 {
            self.completer_account_id.unwrap_or(0)
        }

        pub fn clear_completer_account_id(&mut self) {
            self.completer_account_id = ::std::option::Option::None;
        }

        pub fn has_completer_account_id(&self) -> bool {
            self.completer_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completer_account_id(&mut self, v: u32) {
            self.completer_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 target_account_id = 3;

        pub fn target_account_id(&self) -> u32 {
            self.target_account_id.unwrap_or(0)
        }

        pub fn clear_target_account_id(&mut self) {
            self.target_account_id = ::std::option::Option::None;
        }

        pub fn has_target_account_id(&self) -> bool {
            self.target_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_target_account_id(&mut self, v: u32) {
            self.target_account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bounty {
        const NAME: &'static str = "Bounty";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.issuer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.completer_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.issuer_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.completer_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.target_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.issuer_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.completer_account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.target_account_id {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bounty {
            Bounty::new()
        }

        fn clear(&mut self) {
            self.issuer_account_id = ::std::option::Option::None;
            self.completer_account_id = ::std::option::Option::None;
            self.target_account_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bounty {
            static instance: Bounty = Bounty {
                issuer_account_id: ::std::option::Option::None,
                completer_account_id: ::std::option::Option::None,
                target_account_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutCommunityGoalProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutCommunityGoalProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutCommunityGoalProgress.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgSignOutCommunityGoalProgress.event_increments)
    pub event_increments: ::std::vec::Vec<cmsg_sign_out_community_goal_progress::EventGoalIncrement>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutCommunityGoalProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutCommunityGoalProgress {
    fn default() -> &'a CMsgSignOutCommunityGoalProgress {
        <CMsgSignOutCommunityGoalProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutCommunityGoalProgress {
    pub fn new() -> CMsgSignOutCommunityGoalProgress {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutCommunityGoalProgress {
    const NAME: &'static str = "CMsgSignOutCommunityGoalProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.event_increments.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.event_increments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.event_increments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutCommunityGoalProgress {
        CMsgSignOutCommunityGoalProgress::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_increments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutCommunityGoalProgress {
        static instance: CMsgSignOutCommunityGoalProgress = CMsgSignOutCommunityGoalProgress {
            event_id: ::std::option::Option::None,
            event_increments: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutCommunityGoalProgress`
pub mod cmsg_sign_out_community_goal_progress {
    // @@protoc_insertion_point(message:CMsgSignOutCommunityGoalProgress.EventGoalIncrement)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventGoalIncrement {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutCommunityGoalProgress.EventGoalIncrement.event_goal_id)
        pub event_goal_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutCommunityGoalProgress.EventGoalIncrement.increment_amount)
        pub increment_amount: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutCommunityGoalProgress.EventGoalIncrement.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventGoalIncrement {
        fn default() -> &'a EventGoalIncrement {
            <EventGoalIncrement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EventGoalIncrement {
        pub fn new() -> EventGoalIncrement {
            ::std::default::Default::default()
        }

        // optional uint32 event_goal_id = 1;

        pub fn event_goal_id(&self) -> u32 {
            self.event_goal_id.unwrap_or(0)
        }

        pub fn clear_event_goal_id(&mut self) {
            self.event_goal_id = ::std::option::Option::None;
        }

        pub fn has_event_goal_id(&self) -> bool {
            self.event_goal_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_goal_id(&mut self, v: u32) {
            self.event_goal_id = ::std::option::Option::Some(v);
        }

        // optional uint32 increment_amount = 2;

        pub fn increment_amount(&self) -> u32 {
            self.increment_amount.unwrap_or(0)
        }

        pub fn clear_increment_amount(&mut self) {
            self.increment_amount = ::std::option::Option::None;
        }

        pub fn has_increment_amount(&self) -> bool {
            self.increment_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_increment_amount(&mut self, v: u32) {
            self.increment_amount = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EventGoalIncrement {
        const NAME: &'static str = "EventGoalIncrement";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_goal_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.increment_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_goal_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.increment_amount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_goal_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.increment_amount {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventGoalIncrement {
            EventGoalIncrement::new()
        }

        fn clear(&mut self) {
            self.event_goal_id = ::std::option::Option::None;
            self.increment_amount = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventGoalIncrement {
            static instance: EventGoalIncrement = EventGoalIncrement {
                event_goal_id: ::std::option::Option::None,
                increment_amount: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCloseCompendiumInGamePredictionVoting)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCloseCompendiumInGamePredictionVoting.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCCloseCompendiumInGamePredictionVoting.hltv_delay)
    pub hltv_delay: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCloseCompendiumInGamePredictionVoting.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCloseCompendiumInGamePredictionVoting.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn default() -> &'a CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        <CMsgServerToGCCloseCompendiumInGamePredictionVoting as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 hltv_delay = 2;

    pub fn hltv_delay(&self) -> u32 {
        self.hltv_delay.unwrap_or(0)
    }

    pub fn clear_hltv_delay(&mut self) {
        self.hltv_delay = ::std::option::Option::None;
    }

    pub fn has_hltv_delay(&self) -> bool {
        self.hltv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hltv_delay(&mut self, v: u32) {
        self.hltv_delay = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    const NAME: &'static str = "CMsgServerToGCCloseCompendiumInGamePredictionVoting";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.hltv_delay = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hltv_delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hltv_delay {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        CMsgServerToGCCloseCompendiumInGamePredictionVoting::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.hltv_delay = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVoting {
        static instance: CMsgServerToGCCloseCompendiumInGamePredictionVoting = CMsgServerToGCCloseCompendiumInGamePredictionVoting {
            match_id: ::std::option::Option::None,
            hltv_delay: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn default() -> &'a CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        <CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    pub fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    const NAME: &'static str = "CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
        static instance: CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse = CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCompendiumInGamePredictionResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCompendiumInGamePredictionResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.results)
    pub results: ::std::vec::Vec<cmsg_server_to_gccompendium_in_game_prediction_results::PredictionResult>,
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCompendiumInGamePredictionResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCompendiumInGamePredictionResults {
    fn default() -> &'a CMsgServerToGCCompendiumInGamePredictionResults {
        <CMsgServerToGCCompendiumInGamePredictionResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_node_id = 4;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCompendiumInGamePredictionResults {
    const NAME: &'static str = "CMsgServerToGCCompendiumInGamePredictionResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.results.push(is.read_message()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCompendiumInGamePredictionResults {
        CMsgServerToGCCompendiumInGamePredictionResults::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.results.clear();
        self.league_id = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCompendiumInGamePredictionResults {
        static instance: CMsgServerToGCCompendiumInGamePredictionResults = CMsgServerToGCCompendiumInGamePredictionResults {
            match_id: ::std::option::Option::None,
            results: ::std::vec::Vec::new(),
            league_id: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCCompendiumInGamePredictionResults`
pub mod cmsg_server_to_gccompendium_in_game_prediction_results {
    // @@protoc_insertion_point(message:CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PredictionResult {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_id)
        pub prediction_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_value)
        pub prediction_value: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.prediction_value_is_mask)
        pub prediction_value_is_mask: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCCompendiumInGamePredictionResults.PredictionResult.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PredictionResult {
        fn default() -> &'a PredictionResult {
            <PredictionResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PredictionResult {
        pub fn new() -> PredictionResult {
            ::std::default::Default::default()
        }

        // optional uint32 prediction_id = 1;

        pub fn prediction_id(&self) -> u32 {
            self.prediction_id.unwrap_or(0)
        }

        pub fn clear_prediction_id(&mut self) {
            self.prediction_id = ::std::option::Option::None;
        }

        pub fn has_prediction_id(&self) -> bool {
            self.prediction_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_id(&mut self, v: u32) {
            self.prediction_id = ::std::option::Option::Some(v);
        }

        // optional uint32 prediction_value = 2;

        pub fn prediction_value(&self) -> u32 {
            self.prediction_value.unwrap_or(0)
        }

        pub fn clear_prediction_value(&mut self) {
            self.prediction_value = ::std::option::Option::None;
        }

        pub fn has_prediction_value(&self) -> bool {
            self.prediction_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_value(&mut self, v: u32) {
            self.prediction_value = ::std::option::Option::Some(v);
        }

        // optional bool prediction_value_is_mask = 3;

        pub fn prediction_value_is_mask(&self) -> bool {
            self.prediction_value_is_mask.unwrap_or(false)
        }

        pub fn clear_prediction_value_is_mask(&mut self) {
            self.prediction_value_is_mask = ::std::option::Option::None;
        }

        pub fn has_prediction_value_is_mask(&self) -> bool {
            self.prediction_value_is_mask.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_value_is_mask(&mut self, v: bool) {
            self.prediction_value_is_mask = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PredictionResult {
        const NAME: &'static str = "PredictionResult";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.prediction_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.prediction_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.prediction_value_is_mask = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prediction_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.prediction_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.prediction_value_is_mask {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.prediction_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.prediction_value {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.prediction_value_is_mask {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PredictionResult {
            PredictionResult::new()
        }

        fn clear(&mut self) {
            self.prediction_id = ::std::option::Option::None;
            self.prediction_value = ::std::option::Option::None;
            self.prediction_value_is_mask = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PredictionResult {
            static instance: PredictionResult = PredictionResult {
                prediction_id: ::std::option::Option::None,
                prediction_value: ::std::option::Option::None,
                prediction_value_is_mask: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCompendiumChosenInGamePredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCompendiumChosenInGamePredictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumChosenInGamePredictions.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumChosenInGamePredictions.predictions_chosen)
    pub predictions_chosen: ::std::vec::Vec<cmsg_server_to_gccompendium_chosen_in_game_predictions::Prediction>,
    // @@protoc_insertion_point(field:CMsgServerToGCCompendiumChosenInGamePredictions.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCompendiumChosenInGamePredictions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCompendiumChosenInGamePredictions {
    fn default() -> &'a CMsgServerToGCCompendiumChosenInGamePredictions {
        <CMsgServerToGCCompendiumChosenInGamePredictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCompendiumChosenInGamePredictions {
    pub fn new() -> CMsgServerToGCCompendiumChosenInGamePredictions {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCompendiumChosenInGamePredictions {
    const NAME: &'static str = "CMsgServerToGCCompendiumChosenInGamePredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.predictions_chosen.push(is.read_message()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.predictions_chosen {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.predictions_chosen {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCompendiumChosenInGamePredictions {
        CMsgServerToGCCompendiumChosenInGamePredictions::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.predictions_chosen.clear();
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCompendiumChosenInGamePredictions {
        static instance: CMsgServerToGCCompendiumChosenInGamePredictions = CMsgServerToGCCompendiumChosenInGamePredictions {
            match_id: ::std::option::Option::None,
            predictions_chosen: ::std::vec::Vec::new(),
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCCompendiumChosenInGamePredictions`
pub mod cmsg_server_to_gccompendium_chosen_in_game_predictions {
    // @@protoc_insertion_point(message:CMsgServerToGCCompendiumChosenInGamePredictions.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCCompendiumChosenInGamePredictions.Prediction.prediction_id)
        pub prediction_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCCompendiumChosenInGamePredictions.Prediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 prediction_id = 1;

        pub fn prediction_id(&self) -> u32 {
            self.prediction_id.unwrap_or(0)
        }

        pub fn clear_prediction_id(&mut self) {
            self.prediction_id = ::std::option::Option::None;
        }

        pub fn has_prediction_id(&self) -> bool {
            self.prediction_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_id(&mut self, v: u32) {
            self.prediction_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.prediction_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prediction_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.prediction_id {
                os.write_uint32(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.prediction_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                prediction_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCCompendiumInGamePredictionResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCCompendiumInGamePredictionResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCCompendiumInGamePredictionResults.results)
    pub results: ::steam_vent_proto_common::protobuf::MessageField<CMsgServerToGCCompendiumInGamePredictionResults>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCCompendiumInGamePredictionResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCCompendiumInGamePredictionResults {
    fn default() -> &'a CMsgGCToGCCompendiumInGamePredictionResults {
        <CMsgGCToGCCompendiumInGamePredictionResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCCompendiumInGamePredictionResults {
    pub fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCCompendiumInGamePredictionResults {
    const NAME: &'static str = "CMsgGCToGCCompendiumInGamePredictionResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.results)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.results.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCCompendiumInGamePredictionResults {
        CMsgGCToGCCompendiumInGamePredictionResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCCompendiumInGamePredictionResults {
        static instance: CMsgGCToGCCompendiumInGamePredictionResults = CMsgGCToGCCompendiumInGamePredictionResults {
            results: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerItemPurchaseHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchPlayerItemPurchaseHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_player_item_purchase_history::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerItemPurchaseHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn default() -> &'a CMsgServerToGCMatchPlayerItemPurchaseHistory {
        <CMsgServerToGCMatchPlayerItemPurchaseHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchPlayerItemPurchaseHistory {
    pub fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr = 2;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    const NAME: &'static str = "CMsgServerToGCMatchPlayerItemPurchaseHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(2, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchPlayerItemPurchaseHistory {
        CMsgServerToGCMatchPlayerItemPurchaseHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.mmr = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchPlayerItemPurchaseHistory {
        static instance: CMsgServerToGCMatchPlayerItemPurchaseHistory = CMsgServerToGCMatchPlayerItemPurchaseHistory {
            match_id: ::std::option::Option::None,
            mmr: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCMatchPlayerItemPurchaseHistory`
pub mod cmsg_server_to_gcmatch_player_item_purchase_history {
    // @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemPurchase {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.item)
        pub item: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.gold)
        pub gold: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.inventory_items)
        pub inventory_items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.talents_skilled)
        pub talents_skilled: ::std::vec::Vec<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerItemPurchaseHistory.ItemPurchase.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPurchase {
        fn default() -> &'a ItemPurchase {
            <ItemPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemPurchase {
        pub fn new() -> ItemPurchase {
            ::std::default::Default::default()
        }

        // optional int32 item = 1;

        pub fn item(&self) -> i32 {
            self.item.unwrap_or(-1i32)
        }

        pub fn clear_item(&mut self) {
            self.item = ::std::option::Option::None;
        }

        pub fn has_item(&self) -> bool {
            self.item.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item(&mut self, v: i32) {
            self.item = ::std::option::Option::Some(v);
        }

        // optional uint32 gold = 2;

        pub fn gold(&self) -> u32 {
            self.gold.unwrap_or(0)
        }

        pub fn clear_gold(&mut self) {
            self.gold = ::std::option::Option::None;
        }

        pub fn has_gold(&self) -> bool {
            self.gold.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gold(&mut self, v: u32) {
            self.gold = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 3;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 game_time = 4;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemPurchase {
        const NAME: &'static str = "ItemPurchase";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.gold = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                    },
                    40 => {
                        self.inventory_items.push(is.read_int32()?);
                    },
                    58 => {
                        is.read_repeated_packed_bool_into(&mut self.talents_skilled)?;
                    },
                    56 => {
                        self.talents_skilled.push(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.gold {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            for value in &self.inventory_items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
            };
            my_size += 2 * self.talents_skilled.len() as u64;
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.gold {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_uint32(4, v)?;
            }
            for v in &self.inventory_items {
                os.write_int32(5, *v)?;
            };
            for v in &self.talents_skilled {
                os.write_bool(7, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPurchase {
            ItemPurchase::new()
        }

        fn clear(&mut self) {
            self.item = ::std::option::Option::None;
            self.gold = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.inventory_items.clear();
            self.talents_skilled.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPurchase {
            static instance: ItemPurchase = ItemPurchase {
                item: ::std::option::Option::None,
                gold: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                inventory_items: ::std::vec::Vec::new(),
                talents_skilled: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.allied_hero_ids)
        pub allied_hero_ids: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.enemy_hero_ids)
        pub enemy_hero_ids: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.item_purchases)
        pub item_purchases: ::std::vec::Vec<ItemPurchase>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.lane)
        pub lane: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.is_winner)
        pub is_winner: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerItemPurchaseHistory.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 player_slot = 1;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 lane = 7;

        pub fn lane(&self) -> u32 {
            self.lane.unwrap_or(0)
        }

        pub fn clear_lane(&mut self) {
            self.lane = ::std::option::Option::None;
        }

        pub fn has_lane(&self) -> bool {
            self.lane.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lane(&mut self, v: u32) {
            self.lane = ::std::option::Option::Some(v);
        }

        // optional bool is_winner = 8;

        pub fn is_winner(&self) -> bool {
            self.is_winner.unwrap_or(false)
        }

        pub fn clear_is_winner(&mut self) {
            self.is_winner = ::std::option::Option::None;
        }

        pub fn has_is_winner(&self) -> bool {
            self.is_winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winner(&mut self, v: bool) {
            self.is_winner = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    34 => {
                        is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                    },
                    32 => {
                        self.allied_hero_ids.push(is.read_int32()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                    },
                    40 => {
                        self.enemy_hero_ids.push(is.read_int32()?);
                    },
                    50 => {
                        self.item_purchases.push(is.read_message()?);
                    },
                    56 => {
                        self.lane = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.is_winner = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            for value in &self.allied_hero_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
            };
            for value in &self.enemy_hero_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
            };
            for value in &self.item_purchases {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.lane {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.is_winner {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player_slot {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            for v in &self.allied_hero_ids {
                os.write_int32(4, *v)?;
            };
            for v in &self.enemy_hero_ids {
                os.write_int32(5, *v)?;
            };
            for v in &self.item_purchases {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            };
            if let Some(v) = self.lane {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.is_winner {
                os.write_bool(8, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.player_slot = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.allied_hero_ids.clear();
            self.enemy_hero_ids.clear();
            self.item_purchases.clear();
            self.lane = ::std::option::Option::None;
            self.is_winner = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                player_slot: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                allied_hero_ids: ::std::vec::Vec::new(),
                enemy_hero_ids: ::std::vec::Vec::new(),
                item_purchases: ::std::vec::Vec::new(),
                lane: ::std::option::Option::None,
                is_winner: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerNeutralItemEquipHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcmatch_player_neutral_item_equip_history::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    fn default() -> &'a CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        <CMsgServerToGCMatchPlayerNeutralItemEquipHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    pub fn new() -> CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    const NAME: &'static str = "CMsgServerToGCMatchPlayerNeutralItemEquipHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        CMsgServerToGCMatchPlayerNeutralItemEquipHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
        static instance: CMsgServerToGCMatchPlayerNeutralItemEquipHistory = CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
            match_id: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCMatchPlayerNeutralItemEquipHistory`
pub mod cmsg_server_to_gcmatch_player_neutral_item_equip_history {
    // @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemEquip {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.item)
        pub item: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.inventory_items)
        pub inventory_items: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.talents_skilled)
        pub talents_skilled: ::std::vec::Vec<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.available_neutral_items)
        pub available_neutral_items: ::std::vec::Vec<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.ItemEquip.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemEquip {
        fn default() -> &'a ItemEquip {
            <ItemEquip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemEquip {
        pub fn new() -> ItemEquip {
            ::std::default::Default::default()
        }

        // optional int32 item = 1;

        pub fn item(&self) -> i32 {
            self.item.unwrap_or(-1i32)
        }

        pub fn clear_item(&mut self) {
            self.item = ::std::option::Option::None;
        }

        pub fn has_item(&self) -> bool {
            self.item.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item(&mut self, v: i32) {
            self.item = ::std::option::Option::Some(v);
        }

        // optional uint32 game_time = 2;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemEquip {
        const NAME: &'static str = "ItemEquip";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                    },
                    24 => {
                        self.inventory_items.push(is.read_int32()?);
                    },
                    34 => {
                        is.read_repeated_packed_bool_into(&mut self.talents_skilled)?;
                    },
                    32 => {
                        self.talents_skilled.push(is.read_bool()?);
                    },
                    42 => {
                        is.read_repeated_packed_int32_into(&mut self.available_neutral_items)?;
                    },
                    40 => {
                        self.available_neutral_items.push(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.inventory_items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
            };
            my_size += 2 * self.talents_skilled.len() as u64;
            for value in &self.available_neutral_items {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.game_time {
                os.write_uint32(2, v)?;
            }
            for v in &self.inventory_items {
                os.write_int32(3, *v)?;
            };
            for v in &self.talents_skilled {
                os.write_bool(4, *v)?;
            };
            for v in &self.available_neutral_items {
                os.write_int32(5, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemEquip {
            ItemEquip::new()
        }

        fn clear(&mut self) {
            self.item = ::std::option::Option::None;
            self.game_time = ::std::option::Option::None;
            self.inventory_items.clear();
            self.talents_skilled.clear();
            self.available_neutral_items.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemEquip {
            static instance: ItemEquip = ItemEquip {
                item: ::std::option::Option::None,
                game_time: ::std::option::Option::None,
                inventory_items: ::std::vec::Vec::new(),
                talents_skilled: ::std::vec::Vec::new(),
                available_neutral_items: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.allied_hero_ids)
        pub allied_hero_ids: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.enemy_hero_ids)
        pub enemy_hero_ids: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.item_equips)
        pub item_equips: ::std::vec::Vec<ItemEquip>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.is_winner)
        pub is_winner: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchPlayerNeutralItemEquipHistory.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional bool is_winner = 5;

        pub fn is_winner(&self) -> bool {
            self.is_winner.unwrap_or(false)
        }

        pub fn clear_is_winner(&mut self) {
            self.is_winner = ::std::option::Option::None;
        }

        pub fn has_is_winner(&self) -> bool {
            self.is_winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_winner(&mut self, v: bool) {
            self.is_winner = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                    },
                    16 => {
                        self.allied_hero_ids.push(is.read_int32()?);
                    },
                    26 => {
                        is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                    },
                    24 => {
                        self.enemy_hero_ids.push(is.read_int32()?);
                    },
                    34 => {
                        self.item_equips.push(is.read_message()?);
                    },
                    40 => {
                        self.is_winner = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.allied_hero_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
            };
            for value in &self.enemy_hero_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
            };
            for value in &self.item_equips {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.is_winner {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.allied_hero_ids {
                os.write_int32(2, *v)?;
            };
            for v in &self.enemy_hero_ids {
                os.write_int32(3, *v)?;
            };
            for v in &self.item_equips {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            if let Some(v) = self.is_winner {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.allied_hero_ids.clear();
            self.enemy_hero_ids.clear();
            self.item_equips.clear();
            self.is_winner = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                allied_hero_ids: ::std::vec::Vec::new(),
                enemy_hero_ids: ::std::vec::Vec::new(),
                item_equips: ::std::vec::Vec::new(),
                is_winner: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCMatchStateHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCMatchStateHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.match_states)
    pub match_states: ::std::vec::Vec<cmsg_server_to_gcmatch_state_history::MatchState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCMatchStateHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCMatchStateHistory {
    fn default() -> &'a CMsgServerToGCMatchStateHistory {
        <CMsgServerToGCMatchStateHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCMatchStateHistory {
    pub fn new() -> CMsgServerToGCMatchStateHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 2;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }

    // optional uint32 mmr = 3;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCMatchStateHistory {
    const NAME: &'static str = "CMsgServerToGCMatchStateHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.match_states.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.match_states {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(3, v)?;
        }
        for v in &self.match_states {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCMatchStateHistory {
        CMsgServerToGCMatchStateHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.mmr = ::std::option::Option::None;
        self.match_states.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCMatchStateHistory {
        static instance: CMsgServerToGCMatchStateHistory = CMsgServerToGCMatchStateHistory {
            match_id: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            mmr: ::std::option::Option::None,
            match_states: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCMatchStateHistory`
pub mod cmsg_server_to_gcmatch_state_history {
    // @@protoc_insertion_point(message:CMsgServerToGCMatchStateHistory.PlayerState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerState {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.respawn_time)
        pub respawn_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.has_aegis)
        pub has_aegis: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.has_rapier)
        pub has_rapier: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.PlayerState.distance)
        pub distance: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchStateHistory.PlayerState.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerState {
        fn default() -> &'a PlayerState {
            <PlayerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerState {
        pub fn new() -> PlayerState {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 2;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 respawn_time = 5;

        pub fn respawn_time(&self) -> u32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: u32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 6;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_aegis = 7;

        pub fn has_aegis(&self) -> bool {
            self.has_aegis.unwrap_or(false)
        }

        pub fn clear_has_aegis(&mut self) {
            self.has_aegis = ::std::option::Option::None;
        }

        pub fn has_has_aegis(&self) -> bool {
            self.has_aegis.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_aegis(&mut self, v: bool) {
            self.has_aegis = ::std::option::Option::Some(v);
        }

        // optional bool has_rapier = 8;

        pub fn has_rapier(&self) -> bool {
            self.has_rapier.unwrap_or(false)
        }

        pub fn clear_has_rapier(&mut self) {
            self.has_rapier = ::std::option::Option::None;
        }

        pub fn has_has_rapier(&self) -> bool {
            self.has_rapier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_rapier(&mut self, v: bool) {
            self.has_rapier = ::std::option::Option::Some(v);
        }

        // optional uint32 distance = 9;

        pub fn distance(&self) -> u32 {
            self.distance.unwrap_or(0)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: u32) {
            self.distance = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerState {
        const NAME: &'static str = "PlayerState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.has_aegis = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.has_rapier = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.distance = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.respawn_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_aegis {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_rapier {
                my_size += 1 + 1;
            }
            if let Some(v) = self.distance {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.has_aegis {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.has_rapier {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.distance {
                os.write_uint32(9, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerState {
            PlayerState::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.has_aegis = ::std::option::Option::None;
            self.has_rapier = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerState {
            static instance: PlayerState = PlayerState {
                hero_id: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                level: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                has_aegis: ::std::option::Option::None,
                has_rapier: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCMatchStateHistory.TeamState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamState {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.player_states)
        pub player_states: ::std::vec::Vec<PlayerState>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.tower_health_pct)
        pub tower_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.barracks_health_pct)
        pub barracks_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.ancient_health_pct)
        pub ancient_health_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.creep_distance_safe)
        pub creep_distance_safe: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.creep_distance_mid)
        pub creep_distance_mid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.TeamState.creep_distance_off)
        pub creep_distance_off: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchStateHistory.TeamState.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamState {
        fn default() -> &'a TeamState {
            <TeamState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamState {
        pub fn new() -> TeamState {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 ancient_health_pct = 5;

        pub fn ancient_health_pct(&self) -> u32 {
            self.ancient_health_pct.unwrap_or(0)
        }

        pub fn clear_ancient_health_pct(&mut self) {
            self.ancient_health_pct = ::std::option::Option::None;
        }

        pub fn has_ancient_health_pct(&self) -> bool {
            self.ancient_health_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ancient_health_pct(&mut self, v: u32) {
            self.ancient_health_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> u32 {
            self.glyph_cooldown.unwrap_or(0)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: u32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 7;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_safe = 8;

        pub fn creep_distance_safe(&self) -> u32 {
            self.creep_distance_safe.unwrap_or(0)
        }

        pub fn clear_creep_distance_safe(&mut self) {
            self.creep_distance_safe = ::std::option::Option::None;
        }

        pub fn has_creep_distance_safe(&self) -> bool {
            self.creep_distance_safe.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_safe(&mut self, v: u32) {
            self.creep_distance_safe = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_mid = 9;

        pub fn creep_distance_mid(&self) -> u32 {
            self.creep_distance_mid.unwrap_or(0)
        }

        pub fn clear_creep_distance_mid(&mut self) {
            self.creep_distance_mid = ::std::option::Option::None;
        }

        pub fn has_creep_distance_mid(&self) -> bool {
            self.creep_distance_mid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_mid(&mut self, v: u32) {
            self.creep_distance_mid = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_off = 10;

        pub fn creep_distance_off(&self) -> u32 {
            self.creep_distance_off.unwrap_or(0)
        }

        pub fn clear_creep_distance_off(&mut self) {
            self.creep_distance_off = ::std::option::Option::None;
        }

        pub fn has_creep_distance_off(&self) -> bool {
            self.creep_distance_off.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_off(&mut self, v: u32) {
            self.creep_distance_off = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamState {
        const NAME: &'static str = "TeamState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_states.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.tower_health_pct)?;
                    },
                    24 => {
                        self.tower_health_pct.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.barracks_health_pct)?;
                    },
                    32 => {
                        self.barracks_health_pct.push(is.read_uint32()?);
                    },
                    40 => {
                        self.ancient_health_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.creep_distance_safe = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.creep_distance_mid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.creep_distance_off = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.player_states {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.tower_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.barracks_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
            };
            if let Some(v) = self.ancient_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.creep_distance_safe {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.creep_distance_mid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.creep_distance_off {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            for v in &self.player_states {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.tower_health_pct {
                os.write_uint32(3, *v)?;
            };
            for v in &self.barracks_health_pct {
                os.write_uint32(4, *v)?;
            };
            if let Some(v) = self.ancient_health_pct {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.creep_distance_safe {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.creep_distance_mid {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.creep_distance_off {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamState {
            TeamState::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.player_states.clear();
            self.tower_health_pct.clear();
            self.barracks_health_pct.clear();
            self.ancient_health_pct = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.creep_distance_safe = ::std::option::Option::None;
            self.creep_distance_mid = ::std::option::Option::None;
            self.creep_distance_off = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamState {
            static instance: TeamState = TeamState {
                team: ::std::option::Option::None,
                player_states: ::std::vec::Vec::new(),
                tower_health_pct: ::std::vec::Vec::new(),
                barracks_health_pct: ::std::vec::Vec::new(),
                ancient_health_pct: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                creep_distance_safe: ::std::option::Option::None,
                creep_distance_mid: ::std::option::Option::None,
                creep_distance_off: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCMatchStateHistory.MatchState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchState {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.MatchState.game_time)
        pub game_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.MatchState.radiant_state)
        pub radiant_state: ::steam_vent_proto_common::protobuf::MessageField<TeamState>,
        // @@protoc_insertion_point(field:CMsgServerToGCMatchStateHistory.MatchState.dire_state)
        pub dire_state: ::steam_vent_proto_common::protobuf::MessageField<TeamState>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCMatchStateHistory.MatchState.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchState {
        fn default() -> &'a MatchState {
            <MatchState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchState {
        pub fn new() -> MatchState {
            ::std::default::Default::default()
        }

        // optional uint32 game_time = 1;

        pub fn game_time(&self) -> u32 {
            self.game_time.unwrap_or(0)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: u32) {
            self.game_time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchState {
        const NAME: &'static str = "MatchState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.game_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_state)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_state)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.radiant_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.dire_state.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.radiant_state.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.dire_state.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchState {
            MatchState::new()
        }

        fn clear(&mut self) {
            self.game_time = ::std::option::Option::None;
            self.radiant_state.clear();
            self.dire_state.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchState {
            static instance: MatchState = MatchState {
                game_time: ::std::option::Option::None,
                radiant_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
                dire_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMatchStateSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchStateSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchStateSteamMLEntry.match_state)
    pub match_state: ::steam_vent_proto_common::protobuf::MessageField<cmsg_server_to_gcmatch_state_history::MatchState>,
    // @@protoc_insertion_point(field:CMsgMatchStateSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchStateSteamMLEntry.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchStateSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchStateSteamMLEntry {
    fn default() -> &'a CMsgMatchStateSteamMLEntry {
        <CMsgMatchStateSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchStateSteamMLEntry {
    pub fn new() -> CMsgMatchStateSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 2;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 3;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchStateSteamMLEntry {
    const NAME: &'static str = "CMsgMatchStateSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_state)?;
                },
                16 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.mmr {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchStateSteamMLEntry {
        CMsgMatchStateSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.match_state.clear();
        self.mmr = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchStateSteamMLEntry {
        static instance: CMsgMatchStateSteamMLEntry = CMsgMatchStateSteamMLEntry {
            match_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            mmr: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLaneSelectionSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLaneSelectionSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgLaneSelectionSteamMLEntry.hero_ids)
    pub hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgLaneSelectionSteamMLEntry.lanes)
    pub lanes: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLaneSelectionSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLaneSelectionSteamMLEntry {
    fn default() -> &'a CMsgLaneSelectionSteamMLEntry {
        <CMsgLaneSelectionSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLaneSelectionSteamMLEntry {
    pub fn new() -> CMsgLaneSelectionSteamMLEntry {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLaneSelectionSteamMLEntry {
    const NAME: &'static str = "CMsgLaneSelectionSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.hero_ids)?;
                },
                8 => {
                    self.hero_ids.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.lanes)?;
                },
                16 => {
                    self.lanes.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.lanes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_ids {
            os.write_int32(1, *v)?;
        };
        for v in &self.lanes {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLaneSelectionSteamMLEntry {
        CMsgLaneSelectionSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.hero_ids.clear();
        self.lanes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLaneSelectionSteamMLEntry {
        static instance: CMsgLaneSelectionSteamMLEntry = CMsgLaneSelectionSteamMLEntry {
            hero_ids: ::std::vec::Vec::new(),
            lanes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAbilitySelectionSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAbilitySelectionSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.abilities)
    pub abilities: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgAbilitySelectionSteamMLEntry.selected_ability)
    pub selected_ability: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAbilitySelectionSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAbilitySelectionSteamMLEntry {
    fn default() -> &'a CMsgAbilitySelectionSteamMLEntry {
        <CMsgAbilitySelectionSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAbilitySelectionSteamMLEntry {
    pub fn new() -> CMsgAbilitySelectionSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 4;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional int32 selected_ability = 6;

    pub fn selected_ability(&self) -> i32 {
        self.selected_ability.unwrap_or(-1i32)
    }

    pub fn clear_selected_ability(&mut self) {
        self.selected_ability = ::std::option::Option::None;
    }

    pub fn has_selected_ability(&self) -> bool {
        self.selected_ability.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selected_ability(&mut self, v: i32) {
        self.selected_ability = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAbilitySelectionSteamMLEntry {
    const NAME: &'static str = "CMsgAbilitySelectionSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                },
                24 => {
                    self.enemy_hero_ids.push(is.read_int32()?);
                },
                32 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.abilities)?;
                },
                40 => {
                    self.abilities.push(is.read_int32()?);
                },
                48 => {
                    self.selected_ability = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.enemy_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        for value in &self.abilities {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
        };
        if let Some(v) = self.selected_ability {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        for v in &self.enemy_hero_ids {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.lane {
            os.write_uint32(4, v)?;
        }
        for v in &self.abilities {
            os.write_int32(5, *v)?;
        };
        if let Some(v) = self.selected_ability {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAbilitySelectionSteamMLEntry {
        CMsgAbilitySelectionSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.enemy_hero_ids.clear();
        self.lane = ::std::option::Option::None;
        self.abilities.clear();
        self.selected_ability = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAbilitySelectionSteamMLEntry {
        static instance: CMsgAbilitySelectionSteamMLEntry = CMsgAbilitySelectionSteamMLEntry {
            mmr: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            enemy_hero_ids: ::std::vec::Vec::new(),
            lane: ::std::option::Option::None,
            abilities: ::std::vec::Vec::new(),
            selected_ability: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgItemPurchasePregameSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchasePregameSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.balance)
    pub balance: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchasePregameSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemPurchasePregameSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchasePregameSteamMLEntry {
    fn default() -> &'a CMsgItemPurchasePregameSteamMLEntry {
        <CMsgItemPurchasePregameSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchasePregameSteamMLEntry {
    pub fn new() -> CMsgItemPurchasePregameSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional float balance = 3;

    pub fn balance(&self) -> f32 {
        self.balance.unwrap_or(0.)
    }

    pub fn clear_balance(&mut self) {
        self.balance = ::std::option::Option::None;
    }

    pub fn has_balance(&self) -> bool {
        self.balance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: f32) {
        self.balance = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemPurchasePregameSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchasePregameSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                29 => {
                    self.balance = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                },
                40 => {
                    self.allied_hero_ids.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                },
                48 => {
                    self.enemy_hero_ids.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                56 => {
                    self.items.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.balance {
            my_size += 1 + 4;
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.items {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.balance {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_int32(5, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_int32(6, *v)?;
        };
        for v in &self.items {
            os.write_int32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchasePregameSteamMLEntry {
        CMsgItemPurchasePregameSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.balance = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchasePregameSteamMLEntry {
        static instance: CMsgItemPurchasePregameSteamMLEntry = CMsgItemPurchasePregameSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            balance: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgItemPurchaseSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchaseSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSteamMLEntry.items_to_be_purchased)
    pub items_to_be_purchased: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemPurchaseSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchaseSteamMLEntry {
    fn default() -> &'a CMsgItemPurchaseSteamMLEntry {
        <CMsgItemPurchaseSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchaseSteamMLEntry {
    pub fn new() -> CMsgItemPurchaseSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 3;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemPurchaseSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchaseSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                },
                32 => {
                    self.allied_hero_ids.push(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                },
                40 => {
                    self.enemy_hero_ids.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                48 => {
                    self.items.push(is.read_int32()?);
                },
                58 => {
                    is.read_repeated_packed_int32_into(&mut self.items_to_be_purchased)?;
                },
                56 => {
                    self.items_to_be_purchased.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.items {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
        };
        for value in &self.items_to_be_purchased {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(3, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_int32(4, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_int32(5, *v)?;
        };
        for v in &self.items {
            os.write_int32(6, *v)?;
        };
        for v in &self.items_to_be_purchased {
            os.write_int32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchaseSteamMLEntry {
        CMsgItemPurchaseSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.items_to_be_purchased.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchaseSteamMLEntry {
        static instance: CMsgItemPurchaseSteamMLEntry = CMsgItemPurchaseSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            items_to_be_purchased: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgItemPurchaseSequenceSteamMLEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemPurchaseSequenceSteamMLEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.mmr)
    pub mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.items)
    pub items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgItemPurchaseSequenceSteamMLEntry.item_to_be_purchased)
    pub item_to_be_purchased: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemPurchaseSequenceSteamMLEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemPurchaseSequenceSteamMLEntry {
    fn default() -> &'a CMsgItemPurchaseSequenceSteamMLEntry {
        <CMsgItemPurchaseSequenceSteamMLEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemPurchaseSequenceSteamMLEntry {
    pub fn new() -> CMsgItemPurchaseSequenceSteamMLEntry {
        ::std::default::Default::default()
    }

    // optional uint32 mmr = 1;

    pub fn mmr(&self) -> u32 {
        self.mmr.unwrap_or(0)
    }

    pub fn clear_mmr(&mut self) {
        self.mmr = ::std::option::Option::None;
    }

    pub fn has_mmr(&self) -> bool {
        self.mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mmr(&mut self, v: u32) {
        self.mmr = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 3;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_to_be_purchased = 7;

    pub fn item_to_be_purchased(&self) -> i32 {
        self.item_to_be_purchased.unwrap_or(-1i32)
    }

    pub fn clear_item_to_be_purchased(&mut self) {
        self.item_to_be_purchased = ::std::option::Option::None;
    }

    pub fn has_item_to_be_purchased(&self) -> bool {
        self.item_to_be_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_to_be_purchased(&mut self, v: i32) {
        self.item_to_be_purchased = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemPurchaseSequenceSteamMLEntry {
    const NAME: &'static str = "CMsgItemPurchaseSequenceSteamMLEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                },
                32 => {
                    self.allied_hero_ids.push(is.read_int32()?);
                },
                42 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                },
                40 => {
                    self.enemy_hero_ids.push(is.read_int32()?);
                },
                50 => {
                    is.read_repeated_packed_int32_into(&mut self.items)?;
                },
                48 => {
                    self.items.push(is.read_int32()?);
                },
                56 => {
                    self.item_to_be_purchased = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, *value);
        };
        for value in &self.items {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, *value);
        };
        if let Some(v) = self.item_to_be_purchased {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(3, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_int32(4, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_int32(5, *v)?;
        };
        for v in &self.items {
            os.write_int32(6, *v)?;
        };
        if let Some(v) = self.item_to_be_purchased {
            os.write_int32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemPurchaseSequenceSteamMLEntry {
        CMsgItemPurchaseSequenceSteamMLEntry::new()
    }

    fn clear(&mut self) {
        self.mmr = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.items.clear();
        self.item_to_be_purchased = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemPurchaseSequenceSteamMLEntry {
        static instance: CMsgItemPurchaseSequenceSteamMLEntry = CMsgItemPurchaseSequenceSteamMLEntry {
            mmr: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            items: ::std::vec::Vec::new(),
            item_to_be_purchased: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCavernCrawlIsHeroActive)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCavernCrawlIsHeroActive {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActive.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActive.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActive.preferred_map_variant)
    pub preferred_map_variant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActive.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActive.turbo_mode)
    pub turbo_mode: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCavernCrawlIsHeroActive.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCavernCrawlIsHeroActive {
    fn default() -> &'a CMsgServerToGCCavernCrawlIsHeroActive {
        <CMsgServerToGCCavernCrawlIsHeroActive as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCavernCrawlIsHeroActive {
    pub fn new() -> CMsgServerToGCCavernCrawlIsHeroActive {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 preferred_map_variant = 3;

    pub fn preferred_map_variant(&self) -> u32 {
        self.preferred_map_variant.unwrap_or(255u32)
    }

    pub fn clear_preferred_map_variant(&mut self) {
        self.preferred_map_variant = ::std::option::Option::None;
    }

    pub fn has_preferred_map_variant(&self) -> bool {
        self.preferred_map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_map_variant(&mut self, v: u32) {
        self.preferred_map_variant = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional bool turbo_mode = 5;

    pub fn turbo_mode(&self) -> bool {
        self.turbo_mode.unwrap_or(false)
    }

    pub fn clear_turbo_mode(&mut self) {
        self.turbo_mode = ::std::option::Option::None;
    }

    pub fn has_turbo_mode(&self) -> bool {
        self.turbo_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_turbo_mode(&mut self, v: bool) {
        self.turbo_mode = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCavernCrawlIsHeroActive {
    const NAME: &'static str = "CMsgServerToGCCavernCrawlIsHeroActive";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.preferred_map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.turbo_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.preferred_map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.turbo_mode {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.preferred_map_variant {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.turbo_mode {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCavernCrawlIsHeroActive {
        CMsgServerToGCCavernCrawlIsHeroActive::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.preferred_map_variant = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.turbo_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCavernCrawlIsHeroActive {
        static instance: CMsgServerToGCCavernCrawlIsHeroActive = CMsgServerToGCCavernCrawlIsHeroActive {
            event_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            preferred_map_variant: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            turbo_mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCPlayerChallengeHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCPlayerChallengeHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.average_rank)
    pub average_rank: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.challenge_records)
    pub challenge_records: ::std::vec::Vec<cmsg_server_to_gcplayer_challenge_history::PlayerChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCPlayerChallengeHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCPlayerChallengeHistory {
    fn default() -> &'a CMsgServerToGCPlayerChallengeHistory {
        <CMsgServerToGCPlayerChallengeHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCPlayerChallengeHistory {
    pub fn new() -> CMsgServerToGCPlayerChallengeHistory {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 average_rank = 2;

    pub fn average_rank(&self) -> u32 {
        self.average_rank.unwrap_or(0)
    }

    pub fn clear_average_rank(&mut self) {
        self.average_rank = ::std::option::Option::None;
    }

    pub fn has_average_rank(&self) -> bool {
        self.average_rank.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_rank(&mut self, v: u32) {
        self.average_rank = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCPlayerChallengeHistory {
    const NAME: &'static str = "CMsgServerToGCPlayerChallengeHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.average_rank = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.challenge_records.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.average_rank {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.challenge_records {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.average_rank {
            os.write_uint32(2, v)?;
        }
        for v in &self.challenge_records {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCPlayerChallengeHistory {
        CMsgServerToGCPlayerChallengeHistory::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.average_rank = ::std::option::Option::None;
        self.challenge_records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCPlayerChallengeHistory {
        static instance: CMsgServerToGCPlayerChallengeHistory = CMsgServerToGCPlayerChallengeHistory {
            match_id: ::std::option::Option::None,
            average_rank: ::std::option::Option::None,
            challenge_records: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCPlayerChallengeHistory`
pub mod cmsg_server_to_gcplayer_challenge_history {
    // @@protoc_insertion_point(message:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_type)
        pub challenge_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EPlayerChallengeHistoryType>>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_id1)
        pub challenge_id1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.challenge_id2)
        pub challenge_id2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.progress_value_start)
        pub progress_value_start: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.progress_value_end)
        pub progress_value_end: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.team_won)
        pub team_won: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.audit_data)
        pub audit_data: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.rank_completed)
        pub rank_completed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCPlayerChallengeHistory.PlayerChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerChallenge {
        fn default() -> &'a PlayerChallenge {
            <PlayerChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerChallenge {
        pub fn new() -> PlayerChallenge {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional .EPlayerChallengeHistoryType challenge_type = 2;

        pub fn challenge_type(&self) -> super::super::dota_shared_enums::EPlayerChallengeHistoryType {
            match self.challenge_type {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid),
                None => super::super::dota_shared_enums::EPlayerChallengeHistoryType::k_EPlayerChallengeHistoryType_Invalid,
            }
        }

        pub fn clear_challenge_type(&mut self) {
            self.challenge_type = ::std::option::Option::None;
        }

        pub fn has_challenge_type(&self) -> bool {
            self.challenge_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_type(&mut self, v: super::super::dota_shared_enums::EPlayerChallengeHistoryType) {
            self.challenge_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 challenge_id1 = 3;

        pub fn challenge_id1(&self) -> u32 {
            self.challenge_id1.unwrap_or(0)
        }

        pub fn clear_challenge_id1(&mut self) {
            self.challenge_id1 = ::std::option::Option::None;
        }

        pub fn has_challenge_id1(&self) -> bool {
            self.challenge_id1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id1(&mut self, v: u32) {
            self.challenge_id1 = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_id2 = 4;

        pub fn challenge_id2(&self) -> u32 {
            self.challenge_id2.unwrap_or(0)
        }

        pub fn clear_challenge_id2(&mut self) {
            self.challenge_id2 = ::std::option::Option::None;
        }

        pub fn has_challenge_id2(&self) -> bool {
            self.challenge_id2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id2(&mut self, v: u32) {
            self.challenge_id2 = ::std::option::Option::Some(v);
        }

        // optional uint32 progress_value_start = 5;

        pub fn progress_value_start(&self) -> u32 {
            self.progress_value_start.unwrap_or(0)
        }

        pub fn clear_progress_value_start(&mut self) {
            self.progress_value_start = ::std::option::Option::None;
        }

        pub fn has_progress_value_start(&self) -> bool {
            self.progress_value_start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress_value_start(&mut self, v: u32) {
            self.progress_value_start = ::std::option::Option::Some(v);
        }

        // optional uint32 progress_value_end = 6;

        pub fn progress_value_end(&self) -> u32 {
            self.progress_value_end.unwrap_or(0)
        }

        pub fn clear_progress_value_end(&mut self) {
            self.progress_value_end = ::std::option::Option::None;
        }

        pub fn has_progress_value_end(&self) -> bool {
            self.progress_value_end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress_value_end(&mut self, v: u32) {
            self.progress_value_end = ::std::option::Option::Some(v);
        }

        // optional bool team_won = 7;

        pub fn team_won(&self) -> bool {
            self.team_won.unwrap_or(false)
        }

        pub fn clear_team_won(&mut self) {
            self.team_won = ::std::option::Option::None;
        }

        pub fn has_team_won(&self) -> bool {
            self.team_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_won(&mut self, v: bool) {
            self.team_won = ::std::option::Option::Some(v);
        }

        // optional uint64 audit_data = 8;

        pub fn audit_data(&self) -> u64 {
            self.audit_data.unwrap_or(0)
        }

        pub fn clear_audit_data(&mut self) {
            self.audit_data = ::std::option::Option::None;
        }

        pub fn has_audit_data(&self) -> bool {
            self.audit_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_data(&mut self, v: u64) {
            self.audit_data = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 9;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 rank_completed = 10;

        pub fn rank_completed(&self) -> u32 {
            self.rank_completed.unwrap_or(0)
        }

        pub fn clear_rank_completed(&mut self) {
            self.rank_completed = ::std::option::Option::None;
        }

        pub fn has_rank_completed(&self) -> bool {
            self.rank_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_completed(&mut self, v: u32) {
            self.rank_completed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerChallenge {
        const NAME: &'static str = "PlayerChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.challenge_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.challenge_id1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_id2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.progress_value_start = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.progress_value_end = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.team_won = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    72 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.rank_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.challenge_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.challenge_id1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_id2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.progress_value_start {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.progress_value_end {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.team_won {
                my_size += 1 + 1;
            }
            if let Some(v) = self.audit_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(8, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.rank_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.challenge_type {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.challenge_id1 {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_id2 {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.progress_value_start {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.progress_value_end {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.team_won {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.audit_data {
                os.write_uint64(8, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.rank_completed {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerChallenge {
            PlayerChallenge::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.challenge_type = ::std::option::Option::None;
            self.challenge_id1 = ::std::option::Option::None;
            self.challenge_id2 = ::std::option::Option::None;
            self.progress_value_start = ::std::option::Option::None;
            self.progress_value_end = ::std::option::Option::None;
            self.team_won = ::std::option::Option::None;
            self.audit_data = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.rank_completed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerChallenge {
            static instance: PlayerChallenge = PlayerChallenge {
                account_id: ::std::option::Option::None,
                challenge_type: ::std::option::Option::None,
                challenge_id1: ::std::option::Option::None,
                challenge_id2: ::std::option::Option::None,
                progress_value_start: ::std::option::Option::None,
                progress_value_end: ::std::option::Option::None,
                team_won: ::std::option::Option::None,
                audit_data: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                rank_completed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCCavernCrawlIsHeroActiveResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.result)
    pub result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.potential_winnings)
    pub potential_winnings: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.map_results)
    pub map_results: ::std::vec::Vec<cmsg_server_to_gccavern_crawl_is_hero_active_response::MapResults>,
    // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.potential_plus_shard_winnings)
    pub potential_plus_shard_winnings: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    fn default() -> &'a CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        <CMsgServerToGCCavernCrawlIsHeroActiveResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    pub fn new() -> CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 5;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }

    // optional uint32 potential_winnings = 2;

    pub fn potential_winnings(&self) -> u32 {
        self.potential_winnings.unwrap_or(0)
    }

    pub fn clear_potential_winnings(&mut self) {
        self.potential_winnings = ::std::option::Option::None;
    }

    pub fn has_potential_winnings(&self) -> bool {
        self.potential_winnings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_potential_winnings(&mut self, v: u32) {
        self.potential_winnings = ::std::option::Option::Some(v);
    }

    // optional uint32 potential_plus_shard_winnings = 4;

    pub fn potential_plus_shard_winnings(&self) -> u32 {
        self.potential_plus_shard_winnings.unwrap_or(0)
    }

    pub fn clear_potential_plus_shard_winnings(&mut self) {
        self.potential_plus_shard_winnings = ::std::option::Option::None;
    }

    pub fn has_potential_plus_shard_winnings(&self) -> bool {
        self.potential_plus_shard_winnings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_potential_plus_shard_winnings(&mut self, v: u32) {
        self.potential_plus_shard_winnings = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    const NAME: &'static str = "CMsgServerToGCCavernCrawlIsHeroActiveResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.potential_winnings = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.map_results.push(is.read_message()?);
                },
                32 => {
                    self.potential_plus_shard_winnings = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.potential_winnings {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.map_results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.potential_plus_shard_winnings {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.map_variant {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.potential_winnings {
            os.write_uint32(2, v)?;
        }
        for v in &self.map_results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.potential_plus_shard_winnings {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        CMsgServerToGCCavernCrawlIsHeroActiveResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.map_variant = ::std::option::Option::None;
        self.potential_winnings = ::std::option::Option::None;
        self.map_results.clear();
        self.potential_plus_shard_winnings = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCCavernCrawlIsHeroActiveResponse {
        static instance: CMsgServerToGCCavernCrawlIsHeroActiveResponse = CMsgServerToGCCavernCrawlIsHeroActiveResponse {
            result: ::std::option::Option::None,
            map_variant: ::std::option::Option::None,
            potential_winnings: ::std::option::Option::None,
            map_results: ::std::vec::Vec::new(),
            potential_plus_shard_winnings: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCCavernCrawlIsHeroActiveResponse`
pub mod cmsg_server_to_gccavern_crawl_is_hero_active_response {
    // @@protoc_insertion_point(message:CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MapResults {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.path_id_completed)
        pub path_id_completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.room_id_claimed)
        pub room_id_claimed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCCavernCrawlIsHeroActiveResponse.MapResults.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MapResults {
        fn default() -> &'a MapResults {
            <MapResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MapResults {
        pub fn new() -> MapResults {
            ::std::default::Default::default()
        }

        // optional uint32 path_id_completed = 1;

        pub fn path_id_completed(&self) -> u32 {
            self.path_id_completed.unwrap_or(255u32)
        }

        pub fn clear_path_id_completed(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
        }

        pub fn has_path_id_completed(&self) -> bool {
            self.path_id_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_id_completed(&mut self, v: u32) {
            self.path_id_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 room_id_claimed = 2;

        pub fn room_id_claimed(&self) -> u32 {
            self.room_id_claimed.unwrap_or(255u32)
        }

        pub fn clear_room_id_claimed(&mut self) {
            self.room_id_claimed = ::std::option::Option::None;
        }

        pub fn has_room_id_claimed(&self) -> bool {
            self.room_id_claimed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_room_id_claimed(&mut self, v: u32) {
            self.room_id_claimed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MapResults {
        const NAME: &'static str = "MapResults";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.path_id_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.room_id_claimed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path_id_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.room_id_claimed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.path_id_completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.room_id_claimed {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MapResults {
            MapResults::new()
        }

        fn clear(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
            self.room_id_claimed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MapResults {
            static instance: MapResults = MapResults {
                path_id_completed: ::std::option::Option::None,
                room_id_claimed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgNeutralItemStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgNeutralItemStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgNeutralItemStats.neutral_items)
    pub neutral_items: ::std::vec::Vec<cmsg_neutral_item_stats::NeutralItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgNeutralItemStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgNeutralItemStats {
    fn default() -> &'a CMsgNeutralItemStats {
        <CMsgNeutralItemStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgNeutralItemStats {
    pub fn new() -> CMsgNeutralItemStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgNeutralItemStats {
    const NAME: &'static str = "CMsgNeutralItemStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.neutral_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.neutral_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.neutral_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgNeutralItemStats {
        CMsgNeutralItemStats::new()
    }

    fn clear(&mut self) {
        self.neutral_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgNeutralItemStats {
        static instance: CMsgNeutralItemStats = CMsgNeutralItemStats {
            neutral_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgNeutralItemStats`
pub mod cmsg_neutral_item_stats {
    // @@protoc_insertion_point(message:CMsgNeutralItemStats.NeutralItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NeutralItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.item_id)
        pub item_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.time_dropped)
        pub time_dropped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.time_last_equipped)
        pub time_last_equipped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.time_last_unequipped)
        pub time_last_unequipped: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgNeutralItemStats.NeutralItem.duration_equipped)
        pub duration_equipped: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgNeutralItemStats.NeutralItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NeutralItem {
        fn default() -> &'a NeutralItem {
            <NeutralItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl NeutralItem {
        pub fn new() -> NeutralItem {
            ::std::default::Default::default()
        }

        // optional int32 item_id = 1;

        pub fn item_id(&self) -> i32 {
            self.item_id.unwrap_or(-1i32)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: i32) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_dropped = 2;

        pub fn time_dropped(&self) -> u32 {
            self.time_dropped.unwrap_or(0)
        }

        pub fn clear_time_dropped(&mut self) {
            self.time_dropped = ::std::option::Option::None;
        }

        pub fn has_time_dropped(&self) -> bool {
            self.time_dropped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_dropped(&mut self, v: u32) {
            self.time_dropped = ::std::option::Option::Some(v);
        }

        // optional uint32 team = 3;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_equipped = 4;

        pub fn time_last_equipped(&self) -> u32 {
            self.time_last_equipped.unwrap_or(0)
        }

        pub fn clear_time_last_equipped(&mut self) {
            self.time_last_equipped = ::std::option::Option::None;
        }

        pub fn has_time_last_equipped(&self) -> bool {
            self.time_last_equipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_equipped(&mut self, v: u32) {
            self.time_last_equipped = ::std::option::Option::Some(v);
        }

        // optional uint32 time_last_unequipped = 5;

        pub fn time_last_unequipped(&self) -> u32 {
            self.time_last_unequipped.unwrap_or(0)
        }

        pub fn clear_time_last_unequipped(&mut self) {
            self.time_last_unequipped = ::std::option::Option::None;
        }

        pub fn has_time_last_unequipped(&self) -> bool {
            self.time_last_unequipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_last_unequipped(&mut self, v: u32) {
            self.time_last_unequipped = ::std::option::Option::Some(v);
        }

        // optional uint32 duration_equipped = 6;

        pub fn duration_equipped(&self) -> u32 {
            self.duration_equipped.unwrap_or(0)
        }

        pub fn clear_duration_equipped(&mut self) {
            self.duration_equipped = ::std::option::Option::None;
        }

        pub fn has_duration_equipped(&self) -> bool {
            self.duration_equipped.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration_equipped(&mut self, v: u32) {
            self.duration_equipped = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for NeutralItem {
        const NAME: &'static str = "NeutralItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.time_dropped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.time_last_equipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.time_last_unequipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.duration_equipped = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.time_dropped {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.time_last_equipped {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.time_last_unequipped {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.duration_equipped {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.time_dropped {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.team {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.time_last_equipped {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.time_last_unequipped {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.duration_equipped {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NeutralItem {
            NeutralItem::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.time_dropped = ::std::option::Option::None;
            self.team = ::std::option::Option::None;
            self.time_last_equipped = ::std::option::Option::None;
            self.time_last_unequipped = ::std::option::Option::None;
            self.duration_equipped = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NeutralItem {
            static instance: NeutralItem = NeutralItem {
                item_id: ::std::option::Option::None,
                time_dropped: ::std::option::Option::None,
                team: ::std::option::Option::None,
                time_last_equipped: ::std::option::Option::None,
                time_last_unequipped: ::std::option::Option::None,
                duration_equipped: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerLobbyHeroBanRates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerLobbyHeroBanRates {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerLobbyHeroBanRates.ban_data)
    pub ban_data: ::std::vec::Vec<cmsg_gcto_server_lobby_hero_ban_rates::HeroBanEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerLobbyHeroBanRates.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerLobbyHeroBanRates {
    fn default() -> &'a CMsgGCToServerLobbyHeroBanRates {
        <CMsgGCToServerLobbyHeroBanRates as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerLobbyHeroBanRates {
    pub fn new() -> CMsgGCToServerLobbyHeroBanRates {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerLobbyHeroBanRates {
    const NAME: &'static str = "CMsgGCToServerLobbyHeroBanRates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ban_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ban_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.ban_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerLobbyHeroBanRates {
        CMsgGCToServerLobbyHeroBanRates::new()
    }

    fn clear(&mut self) {
        self.ban_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerLobbyHeroBanRates {
        static instance: CMsgGCToServerLobbyHeroBanRates = CMsgGCToServerLobbyHeroBanRates {
            ban_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToServerLobbyHeroBanRates`
pub mod cmsg_gcto_server_lobby_hero_ban_rates {
    // @@protoc_insertion_point(message:CMsgGCToServerLobbyHeroBanRates.HeroBanEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroBanEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.ban_count)
        pub ban_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.pick_count)
        pub pick_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToServerLobbyHeroBanRates.HeroBanEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroBanEntry {
        fn default() -> &'a HeroBanEntry {
            <HeroBanEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroBanEntry {
        pub fn new() -> HeroBanEntry {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 ban_count = 2;

        pub fn ban_count(&self) -> u32 {
            self.ban_count.unwrap_or(0)
        }

        pub fn clear_ban_count(&mut self) {
            self.ban_count = ::std::option::Option::None;
        }

        pub fn has_ban_count(&self) -> bool {
            self.ban_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_count(&mut self, v: u32) {
            self.ban_count = ::std::option::Option::Some(v);
        }

        // optional uint32 pick_count = 3;

        pub fn pick_count(&self) -> u32 {
            self.pick_count.unwrap_or(0)
        }

        pub fn clear_pick_count(&mut self) {
            self.pick_count = ::std::option::Option::None;
        }

        pub fn has_pick_count(&self) -> bool {
            self.pick_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_count(&mut self, v: u32) {
            self.pick_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroBanEntry {
        const NAME: &'static str = "HeroBanEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.ban_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.pick_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.ban_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.pick_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.ban_count {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.pick_count {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroBanEntry {
            HeroBanEntry::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.ban_count = ::std::option::Option::None;
            self.pick_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroBanEntry {
            static instance: HeroBanEntry = HeroBanEntry {
                hero_id: ::std::option::Option::None,
                ban_count: ::std::option::Option::None,
                pick_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutGuildContractProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGuildContractProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.player_contracts)
    pub player_contracts: ::std::vec::Vec<cmsg_sign_out_guild_contract_progress::PlayerContract>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutGuildContractProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGuildContractProgress {
    fn default() -> &'a CMsgSignOutGuildContractProgress {
        <CMsgSignOutGuildContractProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGuildContractProgress {
    pub fn new() -> CMsgSignOutGuildContractProgress {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutGuildContractProgress {
    const NAME: &'static str = "CMsgSignOutGuildContractProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_contracts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_contracts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_contracts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGuildContractProgress {
        CMsgSignOutGuildContractProgress::new()
    }

    fn clear(&mut self) {
        self.player_contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGuildContractProgress {
        static instance: CMsgSignOutGuildContractProgress = CMsgSignOutGuildContractProgress {
            player_contracts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutGuildContractProgress`
pub mod cmsg_sign_out_guild_contract_progress {
    // @@protoc_insertion_point(message:CMsgSignOutGuildContractProgress.CompletedGuildEventContracts)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompletedGuildEventContracts {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.contracts)
        pub contracts: ::std::vec::Vec<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutGuildContractProgress.CompletedGuildEventContracts.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompletedGuildEventContracts {
        fn default() -> &'a CompletedGuildEventContracts {
            <CompletedGuildEventContracts as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CompletedGuildEventContracts {
        pub fn new() -> CompletedGuildEventContracts {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional uint32 event_id = 2;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CompletedGuildEventContracts {
        const NAME: &'static str = "CompletedGuildEventContracts";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint64_into(&mut self.contracts)?;
                    },
                    24 => {
                        self.contracts.push(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.contracts {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_uint32(2, v)?;
            }
            for v in &self.contracts {
                os.write_uint64(3, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompletedGuildEventContracts {
            CompletedGuildEventContracts::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompletedGuildEventContracts {
            static instance: CompletedGuildEventContracts = CompletedGuildEventContracts {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                contracts: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSignOutGuildContractProgress.PlayerContract)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerContract {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.PlayerContract.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildContractProgress.PlayerContract.completed_contracts)
        pub completed_contracts: ::std::vec::Vec<CompletedGuildEventContracts>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutGuildContractProgress.PlayerContract.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerContract {
        fn default() -> &'a PlayerContract {
            <PlayerContract as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerContract {
        pub fn new() -> PlayerContract {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerContract {
        const NAME: &'static str = "PlayerContract";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.completed_contracts.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.completed_contracts {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.completed_contracts {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerContract {
            PlayerContract::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.completed_contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerContract {
            static instance: PlayerContract = PlayerContract {
                account_id: ::std::option::Option::None,
                completed_contracts: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutGuildChallengeProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutGuildChallengeProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.guild_challenges_progresses)
    pub guild_challenges_progresses: ::std::vec::Vec<cmsg_sign_out_guild_challenge_progress::ChallengeProgress>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutGuildChallengeProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutGuildChallengeProgress {
    fn default() -> &'a CMsgSignOutGuildChallengeProgress {
        <CMsgSignOutGuildChallengeProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutGuildChallengeProgress {
    pub fn new() -> CMsgSignOutGuildChallengeProgress {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutGuildChallengeProgress {
    const NAME: &'static str = "CMsgSignOutGuildChallengeProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.guild_challenges_progresses.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.guild_challenges_progresses {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.guild_challenges_progresses {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutGuildChallengeProgress {
        CMsgSignOutGuildChallengeProgress::new()
    }

    fn clear(&mut self) {
        self.guild_challenges_progresses.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutGuildChallengeProgress {
        static instance: CMsgSignOutGuildChallengeProgress = CMsgSignOutGuildChallengeProgress {
            guild_challenges_progresses: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutGuildChallengeProgress`
pub mod cmsg_sign_out_guild_challenge_progress {
    // @@protoc_insertion_point(message:CMsgSignOutGuildChallengeProgress.ChallengeProgress)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ChallengeProgress {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_instance_timestamp)
        pub challenge_instance_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_period_serial)
        pub challenge_period_serial: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.progress)
        pub progress: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutGuildChallengeProgress.ChallengeProgress.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ChallengeProgress {
        fn default() -> &'a ChallengeProgress {
            <ChallengeProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ChallengeProgress {
        pub fn new() -> ChallengeProgress {
            ::std::default::Default::default()
        }

        // optional uint32 guild_id = 1;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional uint32 event_id = 2;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_id = 3;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_timestamp = 4;

        pub fn challenge_instance_timestamp(&self) -> u32 {
            self.challenge_instance_timestamp.unwrap_or(0)
        }

        pub fn clear_challenge_instance_timestamp(&mut self) {
            self.challenge_instance_timestamp = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_timestamp(&self) -> bool {
            self.challenge_instance_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_timestamp(&mut self, v: u32) {
            self.challenge_instance_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_period_serial = 5;

        pub fn challenge_period_serial(&self) -> u32 {
            self.challenge_period_serial.unwrap_or(0)
        }

        pub fn clear_challenge_period_serial(&mut self) {
            self.challenge_period_serial = ::std::option::Option::None;
        }

        pub fn has_challenge_period_serial(&self) -> bool {
            self.challenge_period_serial.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_period_serial(&mut self, v: u32) {
            self.challenge_period_serial = ::std::option::Option::Some(v);
        }

        // optional uint32 progress = 6;

        pub fn progress(&self) -> u32 {
            self.progress.unwrap_or(0)
        }

        pub fn clear_progress(&mut self) {
            self.progress = ::std::option::Option::None;
        }

        pub fn has_progress(&self) -> bool {
            self.progress.is_some()
        }

        // Param is passed by value, moved
        pub fn set_progress(&mut self, v: u32) {
            self.progress = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 7;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ChallengeProgress {
        const NAME: &'static str = "ChallengeProgress";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.challenge_instance_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.challenge_period_serial = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.progress = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.guild_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.challenge_instance_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.challenge_period_serial {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.progress {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.guild_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.challenge_instance_timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.challenge_period_serial {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.progress {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ChallengeProgress {
            ChallengeProgress::new()
        }

        fn clear(&mut self) {
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_instance_timestamp = ::std::option::Option::None;
            self.challenge_period_serial = ::std::option::Option::None;
            self.progress = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ChallengeProgress {
            static instance: ChallengeProgress = ChallengeProgress {
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_instance_timestamp: ::std::option::Option::None,
                challenge_period_serial: ::std::option::Option::None,
                progress: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutMVPStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMVPStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutMVPStats.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSignOutMVPStats.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutMVPStats.winning_team)
    pub winning_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSignOutMVPStats.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSignOutMVPStats.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_mvpstats::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutMVPStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMVPStats {
    fn default() -> &'a CMsgSignOutMVPStats {
        <CMsgSignOutMVPStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMVPStats {
    pub fn new() -> CMsgSignOutMVPStats {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 2;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 winning_team = 3;

    pub fn winning_team(&self) -> u32 {
        self.winning_team.unwrap_or(0)
    }

    pub fn clear_winning_team(&mut self) {
        self.winning_team = ::std::option::Option::None;
    }

    pub fn has_winning_team(&self) -> bool {
        self.winning_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_winning_team(&mut self, v: u32) {
        self.winning_team = ::std::option::Option::Some(v);
    }

    // optional float game_time = 4;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutMVPStats {
    const NAME: &'static str = "CMsgSignOutMVPStats";

    fn is_initialized(&self) -> bool {
        for v in &self.players {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.winning_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                42 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.winning_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.winning_team {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_float(4, v)?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMVPStats {
        CMsgSignOutMVPStats::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.winning_team = ::std::option::Option::None;
        self.game_time = ::std::option::Option::None;
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMVPStats {
        static instance: CMsgSignOutMVPStats = CMsgSignOutMVPStats {
            match_id: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            winning_team: ::std::option::Option::None,
            game_time: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutMVPStats`
pub mod cmsg_sign_out_mvpstats {
    // @@protoc_insertion_point(message:CMsgSignOutMVPStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.team_networth_rank)
        pub team_networth_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.player_slot)
        pub player_slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.role)
        pub role: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.kills)
        pub kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.deaths)
        pub deaths: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.assists)
        pub assists: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.xp)
        pub xp: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.net_worth)
        pub net_worth: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.support_gold_spent)
        pub support_gold_spent: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.wards_placed)
        pub wards_placed: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.wards_spotted_for_dewarding)
        pub wards_spotted_for_dewarding: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.camps_stacked)
        pub camps_stacked: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.last_hits)
        pub last_hits: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.denies)
        pub denies: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.building_damage)
        pub building_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.other_damage)
        pub other_damage: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.triple_kills)
        pub triple_kills: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.rampages)
        pub rampages: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.first_blood)
        pub first_blood: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.kill_eater_events)
        pub kill_eater_events: ::std::vec::Vec<player::KillEaterEvent>,
        // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.highest_killstreak)
        pub highest_killstreak: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutMVPStats.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional uint32 team_networth_rank = 2;

        pub fn team_networth_rank(&self) -> u32 {
            self.team_networth_rank.unwrap_or(0)
        }

        pub fn clear_team_networth_rank(&mut self) {
            self.team_networth_rank = ::std::option::Option::None;
        }

        pub fn has_team_networth_rank(&self) -> bool {
            self.team_networth_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_networth_rank(&mut self, v: u32) {
            self.team_networth_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 3;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 player_slot = 32;

        pub fn player_slot(&self) -> u32 {
            self.player_slot.unwrap_or(0)
        }

        pub fn clear_player_slot(&mut self) {
            self.player_slot = ::std::option::Option::None;
        }

        pub fn has_player_slot(&self) -> bool {
            self.player_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_slot(&mut self, v: u32) {
            self.player_slot = ::std::option::Option::Some(v);
        }

        // optional uint32 rank = 33;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 4;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 role = 5;

        pub fn role(&self) -> u32 {
            self.role.unwrap_or(0)
        }

        pub fn clear_role(&mut self) {
            self.role = ::std::option::Option::None;
        }

        pub fn has_role(&self) -> bool {
            self.role.is_some()
        }

        // Param is passed by value, moved
        pub fn set_role(&mut self, v: u32) {
            self.role = ::std::option::Option::Some(v);
        }

        // optional int32 kills = 6;

        pub fn kills(&self) -> i32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: i32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional int32 deaths = 7;

        pub fn deaths(&self) -> i32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: i32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional int32 assists = 8;

        pub fn assists(&self) -> i32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: i32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional int32 xp = 9;

        pub fn xp(&self) -> i32 {
            self.xp.unwrap_or(0)
        }

        pub fn clear_xp(&mut self) {
            self.xp = ::std::option::Option::None;
        }

        pub fn has_xp(&self) -> bool {
            self.xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_xp(&mut self, v: i32) {
            self.xp = ::std::option::Option::Some(v);
        }

        // optional int32 net_worth = 10;

        pub fn net_worth(&self) -> i32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: i32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional int32 support_gold_spent = 12;

        pub fn support_gold_spent(&self) -> i32 {
            self.support_gold_spent.unwrap_or(0)
        }

        pub fn clear_support_gold_spent(&mut self) {
            self.support_gold_spent = ::std::option::Option::None;
        }

        pub fn has_support_gold_spent(&self) -> bool {
            self.support_gold_spent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_gold_spent(&mut self, v: i32) {
            self.support_gold_spent = ::std::option::Option::Some(v);
        }

        // optional int32 wards_placed = 13;

        pub fn wards_placed(&self) -> i32 {
            self.wards_placed.unwrap_or(0)
        }

        pub fn clear_wards_placed(&mut self) {
            self.wards_placed = ::std::option::Option::None;
        }

        pub fn has_wards_placed(&self) -> bool {
            self.wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_placed(&mut self, v: i32) {
            self.wards_placed = ::std::option::Option::Some(v);
        }

        // optional int32 wards_spotted_for_dewarding = 14;

        pub fn wards_spotted_for_dewarding(&self) -> i32 {
            self.wards_spotted_for_dewarding.unwrap_or(0)
        }

        pub fn clear_wards_spotted_for_dewarding(&mut self) {
            self.wards_spotted_for_dewarding = ::std::option::Option::None;
        }

        pub fn has_wards_spotted_for_dewarding(&self) -> bool {
            self.wards_spotted_for_dewarding.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wards_spotted_for_dewarding(&mut self, v: i32) {
            self.wards_spotted_for_dewarding = ::std::option::Option::Some(v);
        }

        // optional int32 camps_stacked = 15;

        pub fn camps_stacked(&self) -> i32 {
            self.camps_stacked.unwrap_or(0)
        }

        pub fn clear_camps_stacked(&mut self) {
            self.camps_stacked = ::std::option::Option::None;
        }

        pub fn has_camps_stacked(&self) -> bool {
            self.camps_stacked.is_some()
        }

        // Param is passed by value, moved
        pub fn set_camps_stacked(&mut self, v: i32) {
            self.camps_stacked = ::std::option::Option::Some(v);
        }

        // optional int32 last_hits = 16;

        pub fn last_hits(&self) -> i32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: i32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional int32 denies = 17;

        pub fn denies(&self) -> i32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: i32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional int32 building_damage = 19;

        pub fn building_damage(&self) -> i32 {
            self.building_damage.unwrap_or(0)
        }

        pub fn clear_building_damage(&mut self) {
            self.building_damage = ::std::option::Option::None;
        }

        pub fn has_building_damage(&self) -> bool {
            self.building_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_building_damage(&mut self, v: i32) {
            self.building_damage = ::std::option::Option::Some(v);
        }

        // optional int32 other_damage = 20;

        pub fn other_damage(&self) -> i32 {
            self.other_damage.unwrap_or(0)
        }

        pub fn clear_other_damage(&mut self) {
            self.other_damage = ::std::option::Option::None;
        }

        pub fn has_other_damage(&self) -> bool {
            self.other_damage.is_some()
        }

        // Param is passed by value, moved
        pub fn set_other_damage(&mut self, v: i32) {
            self.other_damage = ::std::option::Option::Some(v);
        }

        // optional int32 triple_kills = 26;

        pub fn triple_kills(&self) -> i32 {
            self.triple_kills.unwrap_or(0)
        }

        pub fn clear_triple_kills(&mut self) {
            self.triple_kills = ::std::option::Option::None;
        }

        pub fn has_triple_kills(&self) -> bool {
            self.triple_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_triple_kills(&mut self, v: i32) {
            self.triple_kills = ::std::option::Option::Some(v);
        }

        // optional int32 rampages = 28;

        pub fn rampages(&self) -> i32 {
            self.rampages.unwrap_or(0)
        }

        pub fn clear_rampages(&mut self) {
            self.rampages = ::std::option::Option::None;
        }

        pub fn has_rampages(&self) -> bool {
            self.rampages.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rampages(&mut self, v: i32) {
            self.rampages = ::std::option::Option::Some(v);
        }

        // optional int32 first_blood = 31;

        pub fn first_blood(&self) -> i32 {
            self.first_blood.unwrap_or(0)
        }

        pub fn clear_first_blood(&mut self) {
            self.first_blood = ::std::option::Option::None;
        }

        pub fn has_first_blood(&self) -> bool {
            self.first_blood.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_blood(&mut self, v: i32) {
            self.first_blood = ::std::option::Option::Some(v);
        }

        // optional uint32 highest_killstreak = 35;

        pub fn highest_killstreak(&self) -> u32 {
            self.highest_killstreak.unwrap_or(0)
        }

        pub fn clear_highest_killstreak(&mut self) {
            self.highest_killstreak = ::std::option::Option::None;
        }

        pub fn has_highest_killstreak(&self) -> bool {
            self.highest_killstreak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_highest_killstreak(&mut self, v: u32) {
            self.highest_killstreak = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            for v in &self.kill_eater_events {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.team_networth_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    256 => {
                        self.player_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    264 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.role = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.deaths = ::std::option::Option::Some(is.read_int32()?);
                    },
                    64 => {
                        self.assists = ::std::option::Option::Some(is.read_int32()?);
                    },
                    72 => {
                        self.xp = ::std::option::Option::Some(is.read_int32()?);
                    },
                    80 => {
                        self.net_worth = ::std::option::Option::Some(is.read_int32()?);
                    },
                    96 => {
                        self.support_gold_spent = ::std::option::Option::Some(is.read_int32()?);
                    },
                    104 => {
                        self.wards_placed = ::std::option::Option::Some(is.read_int32()?);
                    },
                    112 => {
                        self.wards_spotted_for_dewarding = ::std::option::Option::Some(is.read_int32()?);
                    },
                    120 => {
                        self.camps_stacked = ::std::option::Option::Some(is.read_int32()?);
                    },
                    128 => {
                        self.last_hits = ::std::option::Option::Some(is.read_int32()?);
                    },
                    136 => {
                        self.denies = ::std::option::Option::Some(is.read_int32()?);
                    },
                    152 => {
                        self.building_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    160 => {
                        self.other_damage = ::std::option::Option::Some(is.read_int32()?);
                    },
                    208 => {
                        self.triple_kills = ::std::option::Option::Some(is.read_int32()?);
                    },
                    224 => {
                        self.rampages = ::std::option::Option::Some(is.read_int32()?);
                    },
                    248 => {
                        self.first_blood = ::std::option::Option::Some(is.read_int32()?);
                    },
                    274 => {
                        self.kill_eater_events.push(is.read_message()?);
                    },
                    280 => {
                        self.highest_killstreak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_networth_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.player_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(32, v);
            }
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(33, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.role {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(7, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v);
            }
            if let Some(v) = self.xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v);
            }
            if let Some(v) = self.support_gold_spent {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
            }
            if let Some(v) = self.wards_placed {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(13, v);
            }
            if let Some(v) = self.wards_spotted_for_dewarding {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(14, v);
            }
            if let Some(v) = self.camps_stacked {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(15, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(16, v);
            }
            if let Some(v) = self.denies {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(17, v);
            }
            if let Some(v) = self.building_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(19, v);
            }
            if let Some(v) = self.other_damage {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(20, v);
            }
            if let Some(v) = self.triple_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(26, v);
            }
            if let Some(v) = self.rampages {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(28, v);
            }
            if let Some(v) = self.first_blood {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(31, v);
            }
            for value in &self.kill_eater_events {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.highest_killstreak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(35, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_networth_rank {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.player_slot {
                os.write_uint32(32, v)?;
            }
            if let Some(v) = self.rank {
                os.write_uint32(33, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.role {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.kills {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_int32(7, v)?;
            }
            if let Some(v) = self.assists {
                os.write_int32(8, v)?;
            }
            if let Some(v) = self.xp {
                os.write_int32(9, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_int32(10, v)?;
            }
            if let Some(v) = self.support_gold_spent {
                os.write_int32(12, v)?;
            }
            if let Some(v) = self.wards_placed {
                os.write_int32(13, v)?;
            }
            if let Some(v) = self.wards_spotted_for_dewarding {
                os.write_int32(14, v)?;
            }
            if let Some(v) = self.camps_stacked {
                os.write_int32(15, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_int32(16, v)?;
            }
            if let Some(v) = self.denies {
                os.write_int32(17, v)?;
            }
            if let Some(v) = self.building_damage {
                os.write_int32(19, v)?;
            }
            if let Some(v) = self.other_damage {
                os.write_int32(20, v)?;
            }
            if let Some(v) = self.triple_kills {
                os.write_int32(26, v)?;
            }
            if let Some(v) = self.rampages {
                os.write_int32(28, v)?;
            }
            if let Some(v) = self.first_blood {
                os.write_int32(31, v)?;
            }
            for v in &self.kill_eater_events {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
            };
            if let Some(v) = self.highest_killstreak {
                os.write_uint32(35, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_networth_rank = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.player_slot = ::std::option::Option::None;
            self.rank = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.role = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.xp = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.support_gold_spent = ::std::option::Option::None;
            self.wards_placed = ::std::option::Option::None;
            self.wards_spotted_for_dewarding = ::std::option::Option::None;
            self.camps_stacked = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.building_damage = ::std::option::Option::None;
            self.other_damage = ::std::option::Option::None;
            self.triple_kills = ::std::option::Option::None;
            self.rampages = ::std::option::Option::None;
            self.first_blood = ::std::option::Option::None;
            self.kill_eater_events.clear();
            self.highest_killstreak = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                team_id: ::std::option::Option::None,
                team_networth_rank: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                player_slot: ::std::option::Option::None,
                rank: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                role: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                xp: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                support_gold_spent: ::std::option::Option::None,
                wards_placed: ::std::option::Option::None,
                wards_spotted_for_dewarding: ::std::option::Option::None,
                camps_stacked: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                building_damage: ::std::option::Option::None,
                other_damage: ::std::option::Option::None,
                triple_kills: ::std::option::Option::None,
                rampages: ::std::option::Option::None,
                first_blood: ::std::option::Option::None,
                kill_eater_events: ::std::vec::Vec::new(),
                highest_killstreak: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Player`
    pub mod player {
        // @@protoc_insertion_point(message:CMsgSignOutMVPStats.Player.KillEaterEvent)
        #[derive(PartialEq,Clone,Default,Debug)]
        pub struct KillEaterEvent {
            // message fields
            // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.KillEaterEvent.event_type)
            pub event_type: ::std::option::Option<u32>,
            // @@protoc_insertion_point(field:CMsgSignOutMVPStats.Player.KillEaterEvent.amount)
            pub amount: ::std::option::Option<u32>,
            // special fields
            // @@protoc_insertion_point(special_field:CMsgSignOutMVPStats.Player.KillEaterEvent.special_fields)
            pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
        }

        impl<'a> ::std::default::Default for &'a KillEaterEvent {
            fn default() -> &'a KillEaterEvent {
                <KillEaterEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
            }
        }

        impl KillEaterEvent {
            pub fn new() -> KillEaterEvent {
                ::std::default::Default::default()
            }

            // required uint32 event_type = 1;

            pub fn event_type(&self) -> u32 {
                self.event_type.unwrap_or(0)
            }

            pub fn clear_event_type(&mut self) {
                self.event_type = ::std::option::Option::None;
            }

            pub fn has_event_type(&self) -> bool {
                self.event_type.is_some()
            }

            // Param is passed by value, moved
            pub fn set_event_type(&mut self, v: u32) {
                self.event_type = ::std::option::Option::Some(v);
            }

            // required uint32 amount = 2;

            pub fn amount(&self) -> u32 {
                self.amount.unwrap_or(0)
            }

            pub fn clear_amount(&mut self) {
                self.amount = ::std::option::Option::None;
            }

            pub fn has_amount(&self) -> bool {
                self.amount.is_some()
            }

            // Param is passed by value, moved
            pub fn set_amount(&mut self, v: u32) {
                self.amount = ::std::option::Option::Some(v);
            }
        }

        impl ::steam_vent_proto_common::protobuf::Message for KillEaterEvent {
            const NAME: &'static str = "KillEaterEvent";

            fn is_initialized(&self) -> bool {
                if self.event_type.is_none() {
                    return false;
                }
                if self.amount.is_none() {
                    return false;
                }
                true
            }

            fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                while let Some(tag) = is.read_raw_tag_or_eof()? {
                    match tag {
                        8 => {
                            self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        16 => {
                            self.amount = ::std::option::Option::Some(is.read_uint32()?);
                        },
                        tag => {
                            ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                        },
                    };
                }
                ::std::result::Result::Ok(())
            }

            // Compute sizes of nested messages
            #[allow(unused_variables)]
            fn compute_size(&self) -> u64 {
                let mut my_size = 0;
                if let Some(v) = self.event_type {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
                }
                if let Some(v) = self.amount {
                    my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
                }
                my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
                self.special_fields.cached_size().set(my_size as u32);
                my_size
            }

            fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
                if let Some(v) = self.event_type {
                    os.write_uint32(1, v)?;
                }
                if let Some(v) = self.amount {
                    os.write_uint32(2, v)?;
                }
                os.write_unknown_fields(self.special_fields.unknown_fields())?;
                ::std::result::Result::Ok(())
            }

            fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
                &self.special_fields
            }

            fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
                &mut self.special_fields
            }

            fn new() -> KillEaterEvent {
                KillEaterEvent::new()
            }

            fn clear(&mut self) {
                self.event_type = ::std::option::Option::None;
                self.amount = ::std::option::Option::None;
                self.special_fields.clear();
            }

            fn default_instance() -> &'static KillEaterEvent {
                static instance: KillEaterEvent = KillEaterEvent {
                    event_type: ::std::option::Option::None,
                    amount: ::std::option::Option::None,
                    special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
                };
                &instance
            }
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerRecordTrainingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerRecordTrainingData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerRecordTrainingData.enable)
    pub enable: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerRecordTrainingData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerRecordTrainingData {
    fn default() -> &'a CMsgGCToServerRecordTrainingData {
        <CMsgGCToServerRecordTrainingData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerRecordTrainingData {
    pub fn new() -> CMsgGCToServerRecordTrainingData {
        ::std::default::Default::default()
    }

    // optional bool enable = 1;

    pub fn enable(&self) -> bool {
        self.enable.unwrap_or(false)
    }

    pub fn clear_enable(&mut self) {
        self.enable = ::std::option::Option::None;
    }

    pub fn has_enable(&self) -> bool {
        self.enable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable(&mut self, v: bool) {
        self.enable = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerRecordTrainingData {
    const NAME: &'static str = "CMsgGCToServerRecordTrainingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enable = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enable {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enable {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerRecordTrainingData {
        CMsgGCToServerRecordTrainingData::new()
    }

    fn clear(&mut self) {
        self.enable = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerRecordTrainingData {
        static instance: CMsgGCToServerRecordTrainingData = CMsgGCToServerRecordTrainingData {
            enable: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetGuildContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetGuildContracts {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContracts.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetGuildContracts.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetGuildContracts {
    fn default() -> &'a CMsgServerToGCGetGuildContracts {
        <CMsgServerToGCGetGuildContracts as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetGuildContracts {
    pub fn new() -> CMsgServerToGCGetGuildContracts {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetGuildContracts {
    const NAME: &'static str = "CMsgServerToGCGetGuildContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetGuildContracts {
        CMsgServerToGCGetGuildContracts::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetGuildContracts {
        static instance: CMsgServerToGCGetGuildContracts = CMsgServerToGCGetGuildContracts {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetGuildContractsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetGuildContractsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.player_contracts)
    pub player_contracts: ::std::vec::Vec<cmsg_server_to_gcget_guild_contracts_response::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetGuildContractsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetGuildContractsResponse {
    fn default() -> &'a CMsgServerToGCGetGuildContractsResponse {
        <CMsgServerToGCGetGuildContractsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetGuildContractsResponse {
    pub fn new() -> CMsgServerToGCGetGuildContractsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetGuildContractsResponse {
    const NAME: &'static str = "CMsgServerToGCGetGuildContractsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_contracts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_contracts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_contracts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetGuildContractsResponse {
        CMsgServerToGCGetGuildContractsResponse::new()
    }

    fn clear(&mut self) {
        self.player_contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetGuildContractsResponse {
        static instance: CMsgServerToGCGetGuildContractsResponse = CMsgServerToGCGetGuildContractsResponse {
            player_contracts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCGetGuildContractsResponse`
pub mod cmsg_server_to_gcget_guild_contracts_response {
    // @@protoc_insertion_point(message:CMsgServerToGCGetGuildContractsResponse.ContractDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ContractDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_id)
        pub contract_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.challenge_instance_id)
        pub challenge_instance_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.challenge_parameter)
        pub challenge_parameter: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_stars)
        pub contract_stars: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.contract_slot)
        pub contract_slot: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCGetGuildContractsResponse.ContractDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ContractDetails {
        fn default() -> &'a ContractDetails {
            <ContractDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ContractDetails {
        pub fn new() -> ContractDetails {
            ::std::default::Default::default()
        }

        // optional uint64 contract_id = 1;

        pub fn contract_id(&self) -> u64 {
            self.contract_id.unwrap_or(0)
        }

        pub fn clear_contract_id(&mut self) {
            self.contract_id = ::std::option::Option::None;
        }

        pub fn has_contract_id(&self) -> bool {
            self.contract_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_id(&mut self, v: u64) {
            self.contract_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_instance_id = 2;

        pub fn challenge_instance_id(&self) -> u32 {
            self.challenge_instance_id.unwrap_or(0)
        }

        pub fn clear_challenge_instance_id(&mut self) {
            self.challenge_instance_id = ::std::option::Option::None;
        }

        pub fn has_challenge_instance_id(&self) -> bool {
            self.challenge_instance_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_instance_id(&mut self, v: u32) {
            self.challenge_instance_id = ::std::option::Option::Some(v);
        }

        // optional uint32 challenge_parameter = 3;

        pub fn challenge_parameter(&self) -> u32 {
            self.challenge_parameter.unwrap_or(0)
        }

        pub fn clear_challenge_parameter(&mut self) {
            self.challenge_parameter = ::std::option::Option::None;
        }

        pub fn has_challenge_parameter(&self) -> bool {
            self.challenge_parameter.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_parameter(&mut self, v: u32) {
            self.challenge_parameter = ::std::option::Option::Some(v);
        }

        // optional uint32 contract_stars = 4;

        pub fn contract_stars(&self) -> u32 {
            self.contract_stars.unwrap_or(0)
        }

        pub fn clear_contract_stars(&mut self) {
            self.contract_stars = ::std::option::Option::None;
        }

        pub fn has_contract_stars(&self) -> bool {
            self.contract_stars.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_stars(&mut self, v: u32) {
            self.contract_stars = ::std::option::Option::Some(v);
        }

        // optional uint32 contract_slot = 5;

        pub fn contract_slot(&self) -> u32 {
            self.contract_slot.unwrap_or(0)
        }

        pub fn clear_contract_slot(&mut self) {
            self.contract_slot = ::std::option::Option::None;
        }

        pub fn has_contract_slot(&self) -> bool {
            self.contract_slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contract_slot(&mut self, v: u32) {
            self.contract_slot = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ContractDetails {
        const NAME: &'static str = "ContractDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.contract_stars = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.contract_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.challenge_instance_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.challenge_parameter {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.contract_stars {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.contract_slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.contract_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.challenge_instance_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.challenge_parameter {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.contract_stars {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.contract_slot {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ContractDetails {
            ContractDetails::new()
        }

        fn clear(&mut self) {
            self.contract_id = ::std::option::Option::None;
            self.challenge_instance_id = ::std::option::Option::None;
            self.challenge_parameter = ::std::option::Option::None;
            self.contract_stars = ::std::option::Option::None;
            self.contract_slot = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ContractDetails {
            static instance: ContractDetails = ContractDetails {
                contract_id: ::std::option::Option::None,
                challenge_instance_id: ::std::option::Option::None,
                challenge_parameter: ::std::option::Option::None,
                contract_stars: ::std::option::Option::None,
                contract_slot: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgServerToGCGetGuildContractsResponse.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.Player.guild_id)
        pub guild_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.Player.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetGuildContractsResponse.Player.contracts)
        pub contracts: ::std::vec::Vec<ContractDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCGetGuildContractsResponse.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 guild_id = 2;

        pub fn guild_id(&self) -> u32 {
            self.guild_id.unwrap_or(0)
        }

        pub fn clear_guild_id(&mut self) {
            self.guild_id = ::std::option::Option::None;
        }

        pub fn has_guild_id(&self) -> bool {
            self.guild_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_guild_id(&mut self, v: u32) {
            self.guild_id = ::std::option::Option::Some(v);
        }

        // optional .EEvent event_id = 3;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    34 => {
                        self.contracts.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.guild_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
            }
            for value in &self.contracts {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.guild_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.event_id {
                os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            for v in &self.contracts {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.guild_id = ::std::option::Option::None;
            self.event_id = ::std::option::Option::None;
            self.contracts.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                guild_id: ::std::option::Option::None,
                event_id: ::std::option::Option::None,
                contracts: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMatchDiretideCandy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchDiretideCandy {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.player_candy_data)
    pub player_candy_data: ::std::vec::Vec<cmsg_match_diretide_candy::PlayerCandy>,
    // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchDiretideCandy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchDiretideCandy {
    fn default() -> &'a CMsgMatchDiretideCandy {
        <CMsgMatchDiretideCandy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchDiretideCandy {
    pub fn new() -> CMsgMatchDiretideCandy {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchDiretideCandy {
    const NAME: &'static str = "CMsgMatchDiretideCandy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.player_candy_data.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_candy_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_candy_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchDiretideCandy {
        CMsgMatchDiretideCandy::new()
    }

    fn clear(&mut self) {
        self.player_candy_data.clear();
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchDiretideCandy {
        static instance: CMsgMatchDiretideCandy = CMsgMatchDiretideCandy {
            player_candy_data: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgMatchDiretideCandy`
pub mod cmsg_match_diretide_candy {
    // @@protoc_insertion_point(message:CMsgMatchDiretideCandy.CandyDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CandyDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.CandyDetails.amount)
        pub amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.CandyDetails.audit)
        pub audit: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMatchDiretideCandy.CandyDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CandyDetails {
        fn default() -> &'a CandyDetails {
            <CandyDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CandyDetails {
        pub fn new() -> CandyDetails {
            ::std::default::Default::default()
        }

        // optional uint32 amount = 1;

        pub fn amount(&self) -> u32 {
            self.amount.unwrap_or(0)
        }

        pub fn clear_amount(&mut self) {
            self.amount = ::std::option::Option::None;
        }

        pub fn has_amount(&self) -> bool {
            self.amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_amount(&mut self, v: u32) {
            self.amount = ::std::option::Option::Some(v);
        }

        // optional uint32 audit = 2;

        pub fn audit(&self) -> u32 {
            self.audit.unwrap_or(0)
        }

        pub fn clear_audit(&mut self) {
            self.audit = ::std::option::Option::None;
        }

        pub fn has_audit(&self) -> bool {
            self.audit.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit(&mut self, v: u32) {
            self.audit = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CandyDetails {
        const NAME: &'static str = "CandyDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.audit = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.amount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.audit {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.amount {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.audit {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CandyDetails {
            CandyDetails::new()
        }

        fn clear(&mut self) {
            self.amount = ::std::option::Option::None;
            self.audit = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CandyDetails {
            static instance: CandyDetails = CandyDetails {
                amount: ::std::option::Option::None,
                audit: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgMatchDiretideCandy.PlayerCandy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCandy {
        // message fields
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.PlayerCandy.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.PlayerCandy.candy_amount)
        pub candy_amount: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.PlayerCandy.consumes_periodic_resource)
        pub consumes_periodic_resource: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgMatchDiretideCandy.PlayerCandy.candy_breakdown)
        pub candy_breakdown: ::std::vec::Vec<CandyDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgMatchDiretideCandy.PlayerCandy.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCandy {
        fn default() -> &'a PlayerCandy {
            <PlayerCandy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCandy {
        pub fn new() -> PlayerCandy {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 candy_amount = 3;

        pub fn candy_amount(&self) -> u32 {
            self.candy_amount.unwrap_or(0)
        }

        pub fn clear_candy_amount(&mut self) {
            self.candy_amount = ::std::option::Option::None;
        }

        pub fn has_candy_amount(&self) -> bool {
            self.candy_amount.is_some()
        }

        // Param is passed by value, moved
        pub fn set_candy_amount(&mut self, v: u32) {
            self.candy_amount = ::std::option::Option::Some(v);
        }

        // optional bool consumes_periodic_resource = 4;

        pub fn consumes_periodic_resource(&self) -> bool {
            self.consumes_periodic_resource.unwrap_or(false)
        }

        pub fn clear_consumes_periodic_resource(&mut self) {
            self.consumes_periodic_resource = ::std::option::Option::None;
        }

        pub fn has_consumes_periodic_resource(&self) -> bool {
            self.consumes_periodic_resource.is_some()
        }

        // Param is passed by value, moved
        pub fn set_consumes_periodic_resource(&mut self, v: bool) {
            self.consumes_periodic_resource = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCandy {
        const NAME: &'static str = "PlayerCandy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.candy_amount = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.consumes_periodic_resource = ::std::option::Option::Some(is.read_bool()?);
                    },
                    42 => {
                        self.candy_breakdown.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.candy_amount {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.consumes_periodic_resource {
                my_size += 1 + 1;
            }
            for value in &self.candy_breakdown {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.candy_amount {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.consumes_periodic_resource {
                os.write_bool(4, v)?;
            }
            for v in &self.candy_breakdown {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCandy {
            PlayerCandy::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.candy_amount = ::std::option::Option::None;
            self.consumes_periodic_resource = ::std::option::Option::None;
            self.candy_breakdown.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCandy {
            static instance: PlayerCandy = PlayerCandy {
                account_id: ::std::option::Option::None,
                candy_amount: ::std::option::Option::None,
                consumes_periodic_resource: ::std::option::Option::None,
                candy_breakdown: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerCheerData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerCheerData.cheer_types)
    pub cheer_types: ::std::vec::Vec<cmsg_gcto_server_cheer_data::CheerTypeCount>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerCheerData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerData {
    fn default() -> &'a CMsgGCToServerCheerData {
        <CMsgGCToServerCheerData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerData {
    pub fn new() -> CMsgGCToServerCheerData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerCheerData {
    const NAME: &'static str = "CMsgGCToServerCheerData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cheer_types.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_types {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.cheer_types {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerData {
        CMsgGCToServerCheerData::new()
    }

    fn clear(&mut self) {
        self.cheer_types.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerData {
        static instance: CMsgGCToServerCheerData = CMsgGCToServerCheerData {
            cheer_types: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToServerCheerData`
pub mod cmsg_gcto_server_cheer_data {
    // @@protoc_insertion_point(message:CMsgGCToServerCheerData.CheerTypeCount)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CheerTypeCount {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToServerCheerData.CheerTypeCount.cheer_type)
        pub cheer_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToServerCheerData.CheerTypeCount.cheer_count)
        pub cheer_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToServerCheerData.CheerTypeCount.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CheerTypeCount {
        fn default() -> &'a CheerTypeCount {
            <CheerTypeCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CheerTypeCount {
        pub fn new() -> CheerTypeCount {
            ::std::default::Default::default()
        }

        // optional uint32 cheer_type = 1;

        pub fn cheer_type(&self) -> u32 {
            self.cheer_type.unwrap_or(0)
        }

        pub fn clear_cheer_type(&mut self) {
            self.cheer_type = ::std::option::Option::None;
        }

        pub fn has_cheer_type(&self) -> bool {
            self.cheer_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheer_type(&mut self, v: u32) {
            self.cheer_type = ::std::option::Option::Some(v);
        }

        // optional uint32 cheer_count = 2;

        pub fn cheer_count(&self) -> u32 {
            self.cheer_count.unwrap_or(0)
        }

        pub fn clear_cheer_count(&mut self) {
            self.cheer_count = ::std::option::Option::None;
        }

        pub fn has_cheer_count(&self) -> bool {
            self.cheer_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_cheer_count(&mut self, v: u32) {
            self.cheer_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CheerTypeCount {
        const NAME: &'static str = "CheerTypeCount";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.cheer_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.cheer_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.cheer_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.cheer_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.cheer_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.cheer_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CheerTypeCount {
            CheerTypeCount::new()
        }

        fn clear(&mut self) {
            self.cheer_type = ::std::option::Option::None;
            self.cheer_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CheerTypeCount {
            static instance: CheerTypeCount = CheerTypeCount {
                cheer_type: ::std::option::Option::None,
                cheer_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheers_enabled)
    pub cheers_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.is_valid_league_id)
    pub is_valid_league_id: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.window_duration)
    pub window_duration: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.window_bucket_count)
    pub window_bucket_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.crowd_level_push_time)
    pub crowd_level_push_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.crowd_level_low)
    pub crowd_level_low: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.crowd_level_medium)
    pub crowd_level_medium: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.crowd_level_high)
    pub crowd_level_high: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_start)
    pub cheer_scale_start: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_speed)
    pub cheer_scale_speed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_push_mark)
    pub cheer_scale_push_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_pull_mark)
    pub cheer_scale_pull_mark: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_pct_of_max_cps_clamp)
    pub cheer_scale_pct_of_max_cps_clamp: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_dampener_value)
    pub cheer_scale_dampener_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_scale_dampener_lerp_time)
    pub cheer_scale_dampener_lerp_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_factor_bronze)
    pub cheer_factor_bronze: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_factor_silver)
    pub cheer_factor_silver: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerConfig.cheer_factor_gold)
    pub cheer_factor_gold: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCheerConfig.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerConfig {
    fn default() -> &'a CMsgCheerConfig {
        <CMsgCheerConfig as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerConfig {
    pub fn new() -> CMsgCheerConfig {
        ::std::default::Default::default()
    }

    // optional bool cheers_enabled = 1;

    pub fn cheers_enabled(&self) -> bool {
        self.cheers_enabled.unwrap_or(false)
    }

    pub fn clear_cheers_enabled(&mut self) {
        self.cheers_enabled = ::std::option::Option::None;
    }

    pub fn has_cheers_enabled(&self) -> bool {
        self.cheers_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheers_enabled(&mut self, v: bool) {
        self.cheers_enabled = ::std::option::Option::Some(v);
    }

    // optional bool is_valid_league_id = 2;

    pub fn is_valid_league_id(&self) -> bool {
        self.is_valid_league_id.unwrap_or(false)
    }

    pub fn clear_is_valid_league_id(&mut self) {
        self.is_valid_league_id = ::std::option::Option::None;
    }

    pub fn has_is_valid_league_id(&self) -> bool {
        self.is_valid_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_valid_league_id(&mut self, v: bool) {
        self.is_valid_league_id = ::std::option::Option::Some(v);
    }

    // optional float window_duration = 3;

    pub fn window_duration(&self) -> f32 {
        self.window_duration.unwrap_or(0.)
    }

    pub fn clear_window_duration(&mut self) {
        self.window_duration = ::std::option::Option::None;
    }

    pub fn has_window_duration(&self) -> bool {
        self.window_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_duration(&mut self, v: f32) {
        self.window_duration = ::std::option::Option::Some(v);
    }

    // optional uint32 window_bucket_count = 4;

    pub fn window_bucket_count(&self) -> u32 {
        self.window_bucket_count.unwrap_or(0)
    }

    pub fn clear_window_bucket_count(&mut self) {
        self.window_bucket_count = ::std::option::Option::None;
    }

    pub fn has_window_bucket_count(&self) -> bool {
        self.window_bucket_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window_bucket_count(&mut self, v: u32) {
        self.window_bucket_count = ::std::option::Option::Some(v);
    }

    // optional float crowd_level_push_time = 6;

    pub fn crowd_level_push_time(&self) -> f32 {
        self.crowd_level_push_time.unwrap_or(0.)
    }

    pub fn clear_crowd_level_push_time(&mut self) {
        self.crowd_level_push_time = ::std::option::Option::None;
    }

    pub fn has_crowd_level_push_time(&self) -> bool {
        self.crowd_level_push_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_push_time(&mut self, v: f32) {
        self.crowd_level_push_time = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_low = 10;

    pub fn crowd_level_low(&self) -> u32 {
        self.crowd_level_low.unwrap_or(0)
    }

    pub fn clear_crowd_level_low(&mut self) {
        self.crowd_level_low = ::std::option::Option::None;
    }

    pub fn has_crowd_level_low(&self) -> bool {
        self.crowd_level_low.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_low(&mut self, v: u32) {
        self.crowd_level_low = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_medium = 11;

    pub fn crowd_level_medium(&self) -> u32 {
        self.crowd_level_medium.unwrap_or(0)
    }

    pub fn clear_crowd_level_medium(&mut self) {
        self.crowd_level_medium = ::std::option::Option::None;
    }

    pub fn has_crowd_level_medium(&self) -> bool {
        self.crowd_level_medium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_medium(&mut self, v: u32) {
        self.crowd_level_medium = ::std::option::Option::Some(v);
    }

    // optional uint32 crowd_level_high = 12;

    pub fn crowd_level_high(&self) -> u32 {
        self.crowd_level_high.unwrap_or(0)
    }

    pub fn clear_crowd_level_high(&mut self) {
        self.crowd_level_high = ::std::option::Option::None;
    }

    pub fn has_crowd_level_high(&self) -> bool {
        self.crowd_level_high.is_some()
    }

    // Param is passed by value, moved
    pub fn set_crowd_level_high(&mut self, v: u32) {
        self.crowd_level_high = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_start = 13;

    pub fn cheer_scale_start(&self) -> f32 {
        self.cheer_scale_start.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_start(&mut self) {
        self.cheer_scale_start = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_start(&self) -> bool {
        self.cheer_scale_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_start(&mut self, v: f32) {
        self.cheer_scale_start = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_speed = 14;

    pub fn cheer_scale_speed(&self) -> f32 {
        self.cheer_scale_speed.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_speed(&mut self) {
        self.cheer_scale_speed = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_speed(&self) -> bool {
        self.cheer_scale_speed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_speed(&mut self, v: f32) {
        self.cheer_scale_speed = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_push_mark = 15;

    pub fn cheer_scale_push_mark(&self) -> u32 {
        self.cheer_scale_push_mark.unwrap_or(0)
    }

    pub fn clear_cheer_scale_push_mark(&mut self) {
        self.cheer_scale_push_mark = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_push_mark(&self) -> bool {
        self.cheer_scale_push_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_push_mark(&mut self, v: u32) {
        self.cheer_scale_push_mark = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_pull_mark = 16;

    pub fn cheer_scale_pull_mark(&self) -> u32 {
        self.cheer_scale_pull_mark.unwrap_or(0)
    }

    pub fn clear_cheer_scale_pull_mark(&mut self) {
        self.cheer_scale_pull_mark = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_pull_mark(&self) -> bool {
        self.cheer_scale_pull_mark.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_pull_mark(&mut self, v: u32) {
        self.cheer_scale_pull_mark = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_pct_of_max_cps_clamp = 17;

    pub fn cheer_scale_pct_of_max_cps_clamp(&self) -> f32 {
        self.cheer_scale_pct_of_max_cps_clamp.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_pct_of_max_cps_clamp(&mut self) {
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_pct_of_max_cps_clamp(&self) -> bool {
        self.cheer_scale_pct_of_max_cps_clamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_pct_of_max_cps_clamp(&mut self, v: f32) {
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale_dampener_value = 21;

    pub fn cheer_scale_dampener_value(&self) -> f32 {
        self.cheer_scale_dampener_value.unwrap_or(0.)
    }

    pub fn clear_cheer_scale_dampener_value(&mut self) {
        self.cheer_scale_dampener_value = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_dampener_value(&self) -> bool {
        self.cheer_scale_dampener_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_dampener_value(&mut self, v: f32) {
        self.cheer_scale_dampener_value = ::std::option::Option::Some(v);
    }

    // optional uint32 cheer_scale_dampener_lerp_time = 22;

    pub fn cheer_scale_dampener_lerp_time(&self) -> u32 {
        self.cheer_scale_dampener_lerp_time.unwrap_or(0)
    }

    pub fn clear_cheer_scale_dampener_lerp_time(&mut self) {
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::None;
    }

    pub fn has_cheer_scale_dampener_lerp_time(&self) -> bool {
        self.cheer_scale_dampener_lerp_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale_dampener_lerp_time(&mut self, v: u32) {
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_bronze = 18;

    pub fn cheer_factor_bronze(&self) -> f32 {
        self.cheer_factor_bronze.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_bronze(&mut self) {
        self.cheer_factor_bronze = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_bronze(&self) -> bool {
        self.cheer_factor_bronze.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_bronze(&mut self, v: f32) {
        self.cheer_factor_bronze = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_silver = 19;

    pub fn cheer_factor_silver(&self) -> f32 {
        self.cheer_factor_silver.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_silver(&mut self) {
        self.cheer_factor_silver = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_silver(&self) -> bool {
        self.cheer_factor_silver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_silver(&mut self, v: f32) {
        self.cheer_factor_silver = ::std::option::Option::Some(v);
    }

    // optional float cheer_factor_gold = 20;

    pub fn cheer_factor_gold(&self) -> f32 {
        self.cheer_factor_gold.unwrap_or(0.)
    }

    pub fn clear_cheer_factor_gold(&mut self) {
        self.cheer_factor_gold = ::std::option::Option::None;
    }

    pub fn has_cheer_factor_gold(&self) -> bool {
        self.cheer_factor_gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_factor_gold(&mut self, v: f32) {
        self.cheer_factor_gold = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCheerConfig {
    const NAME: &'static str = "CMsgCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.cheers_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.is_valid_league_id = ::std::option::Option::Some(is.read_bool()?);
                },
                29 => {
                    self.window_duration = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.window_bucket_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                53 => {
                    self.crowd_level_push_time = ::std::option::Option::Some(is.read_float()?);
                },
                80 => {
                    self.crowd_level_low = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.crowd_level_medium = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.crowd_level_high = ::std::option::Option::Some(is.read_uint32()?);
                },
                109 => {
                    self.cheer_scale_start = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.cheer_scale_speed = ::std::option::Option::Some(is.read_float()?);
                },
                120 => {
                    self.cheer_scale_push_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.cheer_scale_pull_mark = ::std::option::Option::Some(is.read_uint32()?);
                },
                141 => {
                    self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.cheer_scale_dampener_value = ::std::option::Option::Some(is.read_float()?);
                },
                176 => {
                    self.cheer_scale_dampener_lerp_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                149 => {
                    self.cheer_factor_bronze = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.cheer_factor_silver = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.cheer_factor_gold = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheers_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.is_valid_league_id {
            my_size += 1 + 1;
        }
        if let Some(v) = self.window_duration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.window_bucket_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.crowd_level_push_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.crowd_level_low {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.crowd_level_medium {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.crowd_level_high {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.cheer_scale_start {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale_speed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale_push_mark {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.cheer_scale_pull_mark {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.cheer_scale_pct_of_max_cps_clamp {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_scale_dampener_value {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_scale_dampener_lerp_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.cheer_factor_bronze {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_factor_silver {
            my_size += 2 + 4;
        }
        if let Some(v) = self.cheer_factor_gold {
            my_size += 2 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cheers_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.is_valid_league_id {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.window_duration {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.window_bucket_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.crowd_level_push_time {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.crowd_level_low {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.crowd_level_medium {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.crowd_level_high {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.cheer_scale_start {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.cheer_scale_speed {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.cheer_scale_push_mark {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.cheer_scale_pull_mark {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.cheer_scale_pct_of_max_cps_clamp {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.cheer_scale_dampener_value {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.cheer_scale_dampener_lerp_time {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.cheer_factor_bronze {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.cheer_factor_silver {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.cheer_factor_gold {
            os.write_float(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerConfig {
        CMsgCheerConfig::new()
    }

    fn clear(&mut self) {
        self.cheers_enabled = ::std::option::Option::None;
        self.is_valid_league_id = ::std::option::Option::None;
        self.window_duration = ::std::option::Option::None;
        self.window_bucket_count = ::std::option::Option::None;
        self.crowd_level_push_time = ::std::option::Option::None;
        self.crowd_level_low = ::std::option::Option::None;
        self.crowd_level_medium = ::std::option::Option::None;
        self.crowd_level_high = ::std::option::Option::None;
        self.cheer_scale_start = ::std::option::Option::None;
        self.cheer_scale_speed = ::std::option::Option::None;
        self.cheer_scale_push_mark = ::std::option::Option::None;
        self.cheer_scale_pull_mark = ::std::option::Option::None;
        self.cheer_scale_pct_of_max_cps_clamp = ::std::option::Option::None;
        self.cheer_scale_dampener_value = ::std::option::Option::None;
        self.cheer_scale_dampener_lerp_time = ::std::option::Option::None;
        self.cheer_factor_bronze = ::std::option::Option::None;
        self.cheer_factor_silver = ::std::option::Option::None;
        self.cheer_factor_gold = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerConfig {
        static instance: CMsgCheerConfig = CMsgCheerConfig {
            cheers_enabled: ::std::option::Option::None,
            is_valid_league_id: ::std::option::Option::None,
            window_duration: ::std::option::Option::None,
            window_bucket_count: ::std::option::Option::None,
            crowd_level_push_time: ::std::option::Option::None,
            crowd_level_low: ::std::option::Option::None,
            crowd_level_medium: ::std::option::Option::None,
            crowd_level_high: ::std::option::Option::None,
            cheer_scale_start: ::std::option::Option::None,
            cheer_scale_speed: ::std::option::Option::None,
            cheer_scale_push_mark: ::std::option::Option::None,
            cheer_scale_pull_mark: ::std::option::Option::None,
            cheer_scale_pct_of_max_cps_clamp: ::std::option::Option::None,
            cheer_scale_dampener_value: ::std::option::Option::None,
            cheer_scale_dampener_lerp_time: ::std::option::Option::None,
            cheer_factor_bronze: ::std::option::Option::None,
            cheer_factor_silver: ::std::option::Option::None,
            cheer_factor_gold: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerCheerConfig.cheer_config)
    pub cheer_config: ::steam_vent_proto_common::protobuf::MessageField<CMsgCheerConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerCheerConfig.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerConfig {
    fn default() -> &'a CMsgGCToServerCheerConfig {
        <CMsgGCToServerCheerConfig as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerConfig {
    pub fn new() -> CMsgGCToServerCheerConfig {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerCheerConfig {
    const NAME: &'static str = "CMsgGCToServerCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerConfig {
        CMsgGCToServerCheerConfig::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerConfig {
        static instance: CMsgGCToServerCheerConfig = CMsgGCToServerCheerConfig {
            cheer_config: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetCheerConfig)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetCheerConfig {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetCheerConfig.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetCheerConfig.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetCheerConfig {
    fn default() -> &'a CMsgServerToGCGetCheerConfig {
        <CMsgServerToGCGetCheerConfig as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetCheerConfig {
    pub fn new() -> CMsgServerToGCGetCheerConfig {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetCheerConfig {
    const NAME: &'static str = "CMsgServerToGCGetCheerConfig";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetCheerConfig {
        CMsgServerToGCGetCheerConfig::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetCheerConfig {
        static instance: CMsgServerToGCGetCheerConfig = CMsgServerToGCGetCheerConfig {
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetCheerConfigResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetCheerConfigResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetCheerConfigResponse.cheer_config)
    pub cheer_config: ::steam_vent_proto_common::protobuf::MessageField<CMsgCheerConfig>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetCheerConfigResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetCheerConfigResponse {
    fn default() -> &'a CMsgServerToGCGetCheerConfigResponse {
        <CMsgServerToGCGetCheerConfigResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetCheerConfigResponse {
    pub fn new() -> CMsgServerToGCGetCheerConfigResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetCheerConfigResponse {
    const NAME: &'static str = "CMsgServerToGCGetCheerConfigResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetCheerConfigResponse {
        CMsgServerToGCGetCheerConfigResponse::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetCheerConfigResponse {
        static instance: CMsgServerToGCGetCheerConfigResponse = CMsgServerToGCGetCheerConfigResponse {
            cheer_config: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerCheerScalesOverride)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerCheerScalesOverride {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerCheerScalesOverride.scales)
    pub scales: ::std::vec::Vec<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerCheerScalesOverride.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerCheerScalesOverride {
    fn default() -> &'a CMsgGCToServerCheerScalesOverride {
        <CMsgGCToServerCheerScalesOverride as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerCheerScalesOverride {
    pub fn new() -> CMsgGCToServerCheerScalesOverride {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerCheerScalesOverride {
    const NAME: &'static str = "CMsgGCToServerCheerScalesOverride";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_float_into(&mut self.scales)?;
                },
                13 => {
                    self.scales.push(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.scales.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.scales {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerCheerScalesOverride {
        CMsgGCToServerCheerScalesOverride::new()
    }

    fn clear(&mut self) {
        self.scales.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerCheerScalesOverride {
        static instance: CMsgGCToServerCheerScalesOverride = CMsgGCToServerCheerScalesOverride {
            scales: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerGetCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerGetCheerState {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerGetCheerState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerGetCheerState {
    fn default() -> &'a CMsgGCToServerGetCheerState {
        <CMsgGCToServerGetCheerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerGetCheerState {
    pub fn new() -> CMsgGCToServerGetCheerState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerGetCheerState {
    const NAME: &'static str = "CMsgGCToServerGetCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerGetCheerState {
        CMsgGCToServerGetCheerState::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerGetCheerState {
        static instance: CMsgGCToServerGetCheerState = CMsgGCToServerGetCheerState {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCheerTypeState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerTypeState {
    // message fields
    // @@protoc_insertion_point(field:CMsgCheerTypeState.cheer_counts)
    pub cheer_counts: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgCheerTypeState.max_per_second)
    pub max_per_second: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerTypeState.cheer_scale)
    pub cheer_scale: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgCheerTypeState.override_scale)
    pub override_scale: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCheerTypeState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerTypeState {
    fn default() -> &'a CMsgCheerTypeState {
        <CMsgCheerTypeState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerTypeState {
    pub fn new() -> CMsgCheerTypeState {
        ::std::default::Default::default()
    }

    // optional float max_per_second = 2;

    pub fn max_per_second(&self) -> f32 {
        self.max_per_second.unwrap_or(0.)
    }

    pub fn clear_max_per_second(&mut self) {
        self.max_per_second = ::std::option::Option::None;
    }

    pub fn has_max_per_second(&self) -> bool {
        self.max_per_second.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_per_second(&mut self, v: f32) {
        self.max_per_second = ::std::option::Option::Some(v);
    }

    // optional float cheer_scale = 3;

    pub fn cheer_scale(&self) -> f32 {
        self.cheer_scale.unwrap_or(0.)
    }

    pub fn clear_cheer_scale(&mut self) {
        self.cheer_scale = ::std::option::Option::None;
    }

    pub fn has_cheer_scale(&self) -> bool {
        self.cheer_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheer_scale(&mut self, v: f32) {
        self.cheer_scale = ::std::option::Option::Some(v);
    }

    // optional float override_scale = 4;

    pub fn override_scale(&self) -> f32 {
        self.override_scale.unwrap_or(0.)
    }

    pub fn clear_override_scale(&mut self) {
        self.override_scale = ::std::option::Option::None;
    }

    pub fn has_override_scale(&self) -> bool {
        self.override_scale.is_some()
    }

    // Param is passed by value, moved
    pub fn set_override_scale(&mut self, v: f32) {
        self.override_scale = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCheerTypeState {
    const NAME: &'static str = "CMsgCheerTypeState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.cheer_counts)?;
                },
                8 => {
                    self.cheer_counts.push(is.read_uint32()?);
                },
                21 => {
                    self.max_per_second = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.cheer_scale = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.override_scale = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_counts {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        if let Some(v) = self.max_per_second {
            my_size += 1 + 4;
        }
        if let Some(v) = self.cheer_scale {
            my_size += 1 + 4;
        }
        if let Some(v) = self.override_scale {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.cheer_counts {
            os.write_uint32(1, *v)?;
        };
        if let Some(v) = self.max_per_second {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.cheer_scale {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.override_scale {
            os.write_float(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerTypeState {
        CMsgCheerTypeState::new()
    }

    fn clear(&mut self) {
        self.cheer_counts.clear();
        self.max_per_second = ::std::option::Option::None;
        self.cheer_scale = ::std::option::Option::None;
        self.override_scale = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerTypeState {
        static instance: CMsgCheerTypeState = CMsgCheerTypeState {
            cheer_counts: ::std::vec::Vec::new(),
            max_per_second: ::std::option::Option::None,
            cheer_scale: ::std::option::Option::None,
            override_scale: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCheerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgCheerState.cheer_types)
    pub cheer_types: ::std::vec::Vec<CMsgCheerTypeState>,
    // @@protoc_insertion_point(field:CMsgCheerState.radiant_crowd_level)
    pub radiant_crowd_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCheerState.dire_crowd_level)
    pub dire_crowd_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCheerState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCheerState {
    fn default() -> &'a CMsgCheerState {
        <CMsgCheerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCheerState {
    pub fn new() -> CMsgCheerState {
        ::std::default::Default::default()
    }

    // optional uint32 radiant_crowd_level = 2;

    pub fn radiant_crowd_level(&self) -> u32 {
        self.radiant_crowd_level.unwrap_or(0)
    }

    pub fn clear_radiant_crowd_level(&mut self) {
        self.radiant_crowd_level = ::std::option::Option::None;
    }

    pub fn has_radiant_crowd_level(&self) -> bool {
        self.radiant_crowd_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_crowd_level(&mut self, v: u32) {
        self.radiant_crowd_level = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_crowd_level = 3;

    pub fn dire_crowd_level(&self) -> u32 {
        self.dire_crowd_level.unwrap_or(0)
    }

    pub fn clear_dire_crowd_level(&mut self) {
        self.dire_crowd_level = ::std::option::Option::None;
    }

    pub fn has_dire_crowd_level(&self) -> bool {
        self.dire_crowd_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_crowd_level(&mut self, v: u32) {
        self.dire_crowd_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCheerState {
    const NAME: &'static str = "CMsgCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.cheer_types.push(is.read_message()?);
                },
                16 => {
                    self.radiant_crowd_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.dire_crowd_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.cheer_types {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.radiant_crowd_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.dire_crowd_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.cheer_types {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.radiant_crowd_level {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.dire_crowd_level {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCheerState {
        CMsgCheerState::new()
    }

    fn clear(&mut self) {
        self.cheer_types.clear();
        self.radiant_crowd_level = ::std::option::Option::None;
        self.dire_crowd_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCheerState {
        static instance: CMsgCheerState = CMsgCheerState {
            cheer_types: ::std::vec::Vec::new(),
            radiant_crowd_level: ::std::option::Option::None,
            dire_crowd_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCReportCheerState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCReportCheerState {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCReportCheerState.cheer_config)
    pub cheer_config: ::steam_vent_proto_common::protobuf::MessageField<CMsgCheerConfig>,
    // @@protoc_insertion_point(field:CMsgServerToGCReportCheerState.cheer_state)
    pub cheer_state: ::steam_vent_proto_common::protobuf::MessageField<CMsgCheerState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCReportCheerState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCReportCheerState {
    fn default() -> &'a CMsgServerToGCReportCheerState {
        <CMsgServerToGCReportCheerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCReportCheerState {
    pub fn new() -> CMsgServerToGCReportCheerState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCReportCheerState {
    const NAME: &'static str = "CMsgServerToGCReportCheerState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_config)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cheer_state)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.cheer_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.cheer_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.cheer_config.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.cheer_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCReportCheerState {
        CMsgServerToGCReportCheerState::new()
    }

    fn clear(&mut self) {
        self.cheer_config.clear();
        self.cheer_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCReportCheerState {
        static instance: CMsgServerToGCReportCheerState = CMsgServerToGCReportCheerState {
            cheer_config: ::steam_vent_proto_common::protobuf::MessageField::none(),
            cheer_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetStickerHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetStickerHeroes {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetStickerHeroes.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetStickerHeroes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetStickerHeroes {
    fn default() -> &'a CMsgServerToGCGetStickerHeroes {
        <CMsgServerToGCGetStickerHeroes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetStickerHeroes {
    pub fn new() -> CMsgServerToGCGetStickerHeroes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetStickerHeroes {
    const NAME: &'static str = "CMsgServerToGCGetStickerHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                8 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetStickerHeroes {
        CMsgServerToGCGetStickerHeroes::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetStickerHeroes {
        static instance: CMsgServerToGCGetStickerHeroes = CMsgServerToGCGetStickerHeroes {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCGetStickerHeroesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCGetStickerHeroesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCGetStickerHeroesResponse.players)
    pub players: ::std::vec::Vec<cmsg_server_to_gcget_sticker_heroes_response::Player>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCGetStickerHeroesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCGetStickerHeroesResponse {
    fn default() -> &'a CMsgServerToGCGetStickerHeroesResponse {
        <CMsgServerToGCGetStickerHeroesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCGetStickerHeroesResponse {
    pub fn new() -> CMsgServerToGCGetStickerHeroesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCGetStickerHeroesResponse {
    const NAME: &'static str = "CMsgServerToGCGetStickerHeroesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCGetStickerHeroesResponse {
        CMsgServerToGCGetStickerHeroesResponse::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCGetStickerHeroesResponse {
        static instance: CMsgServerToGCGetStickerHeroesResponse = CMsgServerToGCGetStickerHeroesResponse {
            players: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgServerToGCGetStickerHeroesResponse`
pub mod cmsg_server_to_gcget_sticker_heroes_response {
    // @@protoc_insertion_point(message:CMsgServerToGCGetStickerHeroesResponse.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgServerToGCGetStickerHeroesResponse.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgServerToGCGetStickerHeroesResponse.Player.stickers)
        pub stickers: ::steam_vent_proto_common::protobuf::MessageField<super::super::dota_gcmessages_common::CMsgStickerHeroes>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgServerToGCGetStickerHeroesResponse.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stickers)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.stickers.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.stickers.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.stickers.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                stickers: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerSteamLearnAccessTokensChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerSteamLearnAccessTokensChanged {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerSteamLearnAccessTokensChanged.access_tokens)
    pub access_tokens: ::steam_vent_proto_common::protobuf::MessageField<super::steammessages_steamlearn_steamworkssdk::CMsgSteamLearnAccessTokens>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerSteamLearnAccessTokensChanged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerSteamLearnAccessTokensChanged {
    fn default() -> &'a CMsgGCToServerSteamLearnAccessTokensChanged {
        <CMsgGCToServerSteamLearnAccessTokensChanged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerSteamLearnAccessTokensChanged {
    pub fn new() -> CMsgGCToServerSteamLearnAccessTokensChanged {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerSteamLearnAccessTokensChanged {
    const NAME: &'static str = "CMsgGCToServerSteamLearnAccessTokensChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.access_tokens)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.access_tokens.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.access_tokens.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerSteamLearnAccessTokensChanged {
        CMsgGCToServerSteamLearnAccessTokensChanged::new()
    }

    fn clear(&mut self) {
        self.access_tokens.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerSteamLearnAccessTokensChanged {
        static instance: CMsgGCToServerSteamLearnAccessTokensChanged = CMsgGCToServerSteamLearnAccessTokensChanged {
            access_tokens: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerSteamLearnUseHTTP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerSteamLearnUseHTTP {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerSteamLearnUseHTTP.use_http)
    pub use_http: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerSteamLearnUseHTTP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerSteamLearnUseHTTP {
    fn default() -> &'a CMsgGCToServerSteamLearnUseHTTP {
        <CMsgGCToServerSteamLearnUseHTTP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerSteamLearnUseHTTP {
    pub fn new() -> CMsgGCToServerSteamLearnUseHTTP {
        ::std::default::Default::default()
    }

    // optional bool use_http = 1;

    pub fn use_http(&self) -> bool {
        self.use_http.unwrap_or(false)
    }

    pub fn clear_use_http(&mut self) {
        self.use_http = ::std::option::Option::None;
    }

    pub fn has_use_http(&self) -> bool {
        self.use_http.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_http(&mut self, v: bool) {
        self.use_http = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerSteamLearnUseHTTP {
    const NAME: &'static str = "CMsgGCToServerSteamLearnUseHTTP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.use_http = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.use_http {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.use_http {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerSteamLearnUseHTTP {
        CMsgGCToServerSteamLearnUseHTTP::new()
    }

    fn clear(&mut self) {
        self.use_http = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerSteamLearnUseHTTP {
        static instance: CMsgGCToServerSteamLearnUseHTTP = CMsgGCToServerSteamLearnUseHTTP {
            use_http: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnMatchInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfo.average_mmr)
    pub average_mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfo.radiant_won)
    pub radiant_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfo.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfo.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfo.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchInfo {
    fn default() -> &'a CMsgSteamLearnMatchInfo {
        <CMsgSteamLearnMatchInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchInfo {
    pub fn new() -> CMsgSteamLearnMatchInfo {
        ::std::default::Default::default()
    }

    // optional uint32 average_mmr = 1;

    pub fn average_mmr(&self) -> u32 {
        self.average_mmr.unwrap_or(0)
    }

    pub fn clear_average_mmr(&mut self) {
        self.average_mmr = ::std::option::Option::None;
    }

    pub fn has_average_mmr(&self) -> bool {
        self.average_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_mmr(&mut self, v: u32) {
        self.average_mmr = ::std::option::Option::Some(v);
    }

    // optional bool radiant_won = 2;

    pub fn radiant_won(&self) -> bool {
        self.radiant_won.unwrap_or(false)
    }

    pub fn clear_radiant_won(&mut self) {
        self.radiant_won = ::std::option::Option::None;
    }

    pub fn has_radiant_won(&self) -> bool {
        self.radiant_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_won(&mut self, v: bool) {
        self.radiant_won = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 4;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 5;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnMatchInfo {
    const NAME: &'static str = "CMsgSteamLearnMatchInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.average_mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.radiant_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.radiant_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.average_mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.radiant_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchInfo {
        CMsgSteamLearnMatchInfo::new()
    }

    fn clear(&mut self) {
        self.average_mmr = ::std::option::Option::None;
        self.radiant_won = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchInfo {
        static instance: CMsgSteamLearnMatchInfo = CMsgSteamLearnMatchInfo {
            average_mmr: ::std::option::Option::None,
            radiant_won: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnMatchInfoPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchInfoPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.average_mmr)
    pub average_mmr: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.team_won)
    pub team_won: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.duration)
    pub duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchInfoPlayer.player_mmr)
    pub player_mmr: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchInfoPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchInfoPlayer {
    fn default() -> &'a CMsgSteamLearnMatchInfoPlayer {
        <CMsgSteamLearnMatchInfoPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchInfoPlayer {
    pub fn new() -> CMsgSteamLearnMatchInfoPlayer {
        ::std::default::Default::default()
    }

    // optional uint32 average_mmr = 1;

    pub fn average_mmr(&self) -> u32 {
        self.average_mmr.unwrap_or(0)
    }

    pub fn clear_average_mmr(&mut self) {
        self.average_mmr = ::std::option::Option::None;
    }

    pub fn has_average_mmr(&self) -> bool {
        self.average_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_average_mmr(&mut self, v: u32) {
        self.average_mmr = ::std::option::Option::Some(v);
    }

    // optional bool team_won = 2;

    pub fn team_won(&self) -> bool {
        self.team_won.unwrap_or(false)
    }

    pub fn clear_team_won(&mut self) {
        self.team_won = ::std::option::Option::None;
    }

    pub fn has_team_won(&self) -> bool {
        self.team_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_won(&mut self, v: bool) {
        self.team_won = ::std::option::Option::Some(v);
    }

    // optional uint32 duration = 3;

    pub fn duration(&self) -> u32 {
        self.duration.unwrap_or(0)
    }

    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: u32) {
        self.duration = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 4;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_type = 5;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }

    // optional uint32 player_mmr = 6;

    pub fn player_mmr(&self) -> u32 {
        self.player_mmr.unwrap_or(0)
    }

    pub fn clear_player_mmr(&mut self) {
        self.player_mmr = ::std::option::Option::None;
    }

    pub fn has_player_mmr(&self) -> bool {
        self.player_mmr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_mmr(&mut self, v: u32) {
        self.player_mmr = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnMatchInfoPlayer {
    const NAME: &'static str = "CMsgSteamLearnMatchInfoPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.average_mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.team_won = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.player_mmr = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.average_mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.team_won {
            my_size += 1 + 1;
        }
        if let Some(v) = self.duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.player_mmr {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.average_mmr {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.team_won {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.duration {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.player_mmr {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchInfoPlayer {
        CMsgSteamLearnMatchInfoPlayer::new()
    }

    fn clear(&mut self) {
        self.average_mmr = ::std::option::Option::None;
        self.team_won = ::std::option::Option::None;
        self.duration = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.player_mmr = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchInfoPlayer {
        static instance: CMsgSteamLearnMatchInfoPlayer = CMsgSteamLearnMatchInfoPlayer {
            average_mmr: ::std::option::Option::None,
            team_won: ::std::option::Option::None,
            duration: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            player_mmr: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnMatchHeroesV3)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchHeroesV3 {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.radiant_hero_ids)
    pub radiant_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.dire_hero_ids)
    pub dire_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.radiant_lanes)
    pub radiant_lanes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.dire_lanes)
    pub dire_lanes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.radiant_hero_facets)
    pub radiant_hero_facets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.dire_hero_facets)
    pub dire_hero_facets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.radiant_positions)
    pub radiant_positions: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroesV3.dire_positions)
    pub dire_positions: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchHeroesV3.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchHeroesV3 {
    fn default() -> &'a CMsgSteamLearnMatchHeroesV3 {
        <CMsgSteamLearnMatchHeroesV3 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchHeroesV3 {
    pub fn new() -> CMsgSteamLearnMatchHeroesV3 {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnMatchHeroesV3 {
    const NAME: &'static str = "CMsgSteamLearnMatchHeroesV3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.radiant_hero_ids)?;
                },
                8 => {
                    self.radiant_hero_ids.push(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.dire_hero_ids)?;
                },
                16 => {
                    self.dire_hero_ids.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.radiant_lanes)?;
                },
                24 => {
                    self.radiant_lanes.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.dire_lanes)?;
                },
                32 => {
                    self.dire_lanes.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.radiant_hero_facets)?;
                },
                40 => {
                    self.radiant_hero_facets.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.dire_hero_facets)?;
                },
                48 => {
                    self.dire_hero_facets.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.radiant_positions)?;
                },
                56 => {
                    self.radiant_positions.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.dire_positions)?;
                },
                64 => {
                    self.dire_positions.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.radiant_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        for value in &self.dire_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.radiant_lanes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.dire_lanes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.radiant_hero_facets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        for value in &self.dire_hero_facets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
        };
        for value in &self.radiant_positions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.dire_positions {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.radiant_hero_ids {
            os.write_int32(1, *v)?;
        };
        for v in &self.dire_hero_ids {
            os.write_int32(2, *v)?;
        };
        for v in &self.radiant_lanes {
            os.write_uint32(3, *v)?;
        };
        for v in &self.dire_lanes {
            os.write_uint32(4, *v)?;
        };
        for v in &self.radiant_hero_facets {
            os.write_uint32(5, *v)?;
        };
        for v in &self.dire_hero_facets {
            os.write_uint32(6, *v)?;
        };
        for v in &self.radiant_positions {
            os.write_uint32(7, *v)?;
        };
        for v in &self.dire_positions {
            os.write_uint32(8, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchHeroesV3 {
        CMsgSteamLearnMatchHeroesV3::new()
    }

    fn clear(&mut self) {
        self.radiant_hero_ids.clear();
        self.dire_hero_ids.clear();
        self.radiant_lanes.clear();
        self.dire_lanes.clear();
        self.radiant_hero_facets.clear();
        self.dire_hero_facets.clear();
        self.radiant_positions.clear();
        self.dire_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchHeroesV3 {
        static instance: CMsgSteamLearnMatchHeroesV3 = CMsgSteamLearnMatchHeroesV3 {
            radiant_hero_ids: ::std::vec::Vec::new(),
            dire_hero_ids: ::std::vec::Vec::new(),
            radiant_lanes: ::std::vec::Vec::new(),
            dire_lanes: ::std::vec::Vec::new(),
            radiant_hero_facets: ::std::vec::Vec::new(),
            dire_hero_facets: ::std::vec::Vec::new(),
            radiant_positions: ::std::vec::Vec::new(),
            dire_positions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnMatchHeroV3)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchHeroV3 {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.lane)
    pub lane: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.position)
    pub position: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.allied_hero_ids)
    pub allied_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.enemy_hero_ids)
    pub enemy_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.hero_facet)
    pub hero_facet: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.allied_hero_facets)
    pub allied_hero_facets: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchHeroV3.enemy_herofacets)
    pub enemy_herofacets: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchHeroV3.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchHeroV3 {
    fn default() -> &'a CMsgSteamLearnMatchHeroV3 {
        <CMsgSteamLearnMatchHeroV3 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchHeroV3 {
    pub fn new() -> CMsgSteamLearnMatchHeroV3 {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lane = 2;

    pub fn lane(&self) -> u32 {
        self.lane.unwrap_or(0)
    }

    pub fn clear_lane(&mut self) {
        self.lane = ::std::option::Option::None;
    }

    pub fn has_lane(&self) -> bool {
        self.lane.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane(&mut self, v: u32) {
        self.lane = ::std::option::Option::Some(v);
    }

    // optional uint32 position = 8;

    pub fn position(&self) -> u32 {
        self.position.unwrap_or(0)
    }

    pub fn clear_position(&mut self) {
        self.position = ::std::option::Option::None;
    }

    pub fn has_position(&self) -> bool {
        self.position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_position(&mut self, v: u32) {
        self.position = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_facet = 5;

    pub fn hero_facet(&self) -> u32 {
        self.hero_facet.unwrap_or(0)
    }

    pub fn clear_hero_facet(&mut self) {
        self.hero_facet = ::std::option::Option::None;
    }

    pub fn has_hero_facet(&self) -> bool {
        self.hero_facet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_facet(&mut self, v: u32) {
        self.hero_facet = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnMatchHeroV3 {
    const NAME: &'static str = "CMsgSteamLearnMatchHeroV3";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.lane = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.position = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.allied_hero_ids)?;
                },
                24 => {
                    self.allied_hero_ids.push(is.read_int32()?);
                },
                34 => {
                    is.read_repeated_packed_int32_into(&mut self.enemy_hero_ids)?;
                },
                32 => {
                    self.enemy_hero_ids.push(is.read_int32()?);
                },
                40 => {
                    self.hero_facet = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.allied_hero_facets)?;
                },
                48 => {
                    self.allied_hero_facets.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.enemy_herofacets)?;
                },
                56 => {
                    self.enemy_herofacets.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.lane {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.position {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        for value in &self.allied_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
        };
        for value in &self.enemy_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, *value);
        };
        if let Some(v) = self.hero_facet {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.allied_hero_facets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
        };
        for value in &self.enemy_herofacets {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.lane {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.position {
            os.write_uint32(8, v)?;
        }
        for v in &self.allied_hero_ids {
            os.write_int32(3, *v)?;
        };
        for v in &self.enemy_hero_ids {
            os.write_int32(4, *v)?;
        };
        if let Some(v) = self.hero_facet {
            os.write_uint32(5, v)?;
        }
        for v in &self.allied_hero_facets {
            os.write_uint32(6, *v)?;
        };
        for v in &self.enemy_herofacets {
            os.write_uint32(7, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchHeroV3 {
        CMsgSteamLearnMatchHeroV3::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.lane = ::std::option::Option::None;
        self.position = ::std::option::Option::None;
        self.allied_hero_ids.clear();
        self.enemy_hero_ids.clear();
        self.hero_facet = ::std::option::Option::None;
        self.allied_hero_facets.clear();
        self.enemy_herofacets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchHeroV3 {
        static instance: CMsgSteamLearnMatchHeroV3 = CMsgSteamLearnMatchHeroV3 {
            hero_id: ::std::option::Option::None,
            lane: ::std::option::Option::None,
            position: ::std::option::Option::None,
            allied_hero_ids: ::std::vec::Vec::new(),
            enemy_hero_ids: ::std::vec::Vec::new(),
            hero_facet: ::std::option::Option::None,
            allied_hero_facets: ::std::vec::Vec::new(),
            enemy_herofacets: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnPlayerTimedStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnPlayerTimedStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.stat_buckets)
    pub stat_buckets: ::std::vec::Vec<cmsg_steam_learn_player_timed_stats::StatBucket>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnPlayerTimedStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnPlayerTimedStats {
    fn default() -> &'a CMsgSteamLearnPlayerTimedStats {
        <CMsgSteamLearnPlayerTimedStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnPlayerTimedStats {
    pub fn new() -> CMsgSteamLearnPlayerTimedStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnPlayerTimedStats {
    const NAME: &'static str = "CMsgSteamLearnPlayerTimedStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.stat_buckets.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.stat_buckets {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.stat_buckets {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnPlayerTimedStats {
        CMsgSteamLearnPlayerTimedStats::new()
    }

    fn clear(&mut self) {
        self.stat_buckets.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnPlayerTimedStats {
        static instance: CMsgSteamLearnPlayerTimedStats = CMsgSteamLearnPlayerTimedStats {
            stat_buckets: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamLearnPlayerTimedStats`
pub mod cmsg_steam_learn_player_timed_stats {
    // @@protoc_insertion_point(message:CMsgSteamLearnPlayerTimedStats.StatBucket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StatBucket {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.game_time)
        pub game_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.assists)
        pub assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.experience)
        pub experience: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.last_hits)
        pub last_hits: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.denies)
        pub denies: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.idle_time)
        pub idle_time: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.commands_issued)
        pub commands_issued: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.sentry_wards_placed)
        pub sentry_wards_placed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnPlayerTimedStats.StatBucket.observer_wards_placed)
        pub observer_wards_placed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnPlayerTimedStats.StatBucket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StatBucket {
        fn default() -> &'a StatBucket {
            <StatBucket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl StatBucket {
        pub fn new() -> StatBucket {
            ::std::default::Default::default()
        }

        // optional float game_time = 1;

        pub fn game_time(&self) -> f32 {
            self.game_time.unwrap_or(0.)
        }

        pub fn clear_game_time(&mut self) {
            self.game_time = ::std::option::Option::None;
        }

        pub fn has_game_time(&self) -> bool {
            self.game_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_time(&mut self, v: f32) {
            self.game_time = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 2;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 3;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 assists = 4;

        pub fn assists(&self) -> u32 {
            self.assists.unwrap_or(0)
        }

        pub fn clear_assists(&mut self) {
            self.assists = ::std::option::Option::None;
        }

        pub fn has_assists(&self) -> bool {
            self.assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_assists(&mut self, v: u32) {
            self.assists = ::std::option::Option::Some(v);
        }

        // optional uint32 experience = 5;

        pub fn experience(&self) -> u32 {
            self.experience.unwrap_or(0)
        }

        pub fn clear_experience(&mut self) {
            self.experience = ::std::option::Option::None;
        }

        pub fn has_experience(&self) -> bool {
            self.experience.is_some()
        }

        // Param is passed by value, moved
        pub fn set_experience(&mut self, v: u32) {
            self.experience = ::std::option::Option::Some(v);
        }

        // optional uint32 last_hits = 6;

        pub fn last_hits(&self) -> u32 {
            self.last_hits.unwrap_or(0)
        }

        pub fn clear_last_hits(&mut self) {
            self.last_hits = ::std::option::Option::None;
        }

        pub fn has_last_hits(&self) -> bool {
            self.last_hits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_hits(&mut self, v: u32) {
            self.last_hits = ::std::option::Option::Some(v);
        }

        // optional uint32 denies = 7;

        pub fn denies(&self) -> u32 {
            self.denies.unwrap_or(0)
        }

        pub fn clear_denies(&mut self) {
            self.denies = ::std::option::Option::None;
        }

        pub fn has_denies(&self) -> bool {
            self.denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_denies(&mut self, v: u32) {
            self.denies = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 8;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional float idle_time = 9;

        pub fn idle_time(&self) -> f32 {
            self.idle_time.unwrap_or(0.)
        }

        pub fn clear_idle_time(&mut self) {
            self.idle_time = ::std::option::Option::None;
        }

        pub fn has_idle_time(&self) -> bool {
            self.idle_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_idle_time(&mut self, v: f32) {
            self.idle_time = ::std::option::Option::Some(v);
        }

        // optional uint32 commands_issued = 10;

        pub fn commands_issued(&self) -> u32 {
            self.commands_issued.unwrap_or(0)
        }

        pub fn clear_commands_issued(&mut self) {
            self.commands_issued = ::std::option::Option::None;
        }

        pub fn has_commands_issued(&self) -> bool {
            self.commands_issued.is_some()
        }

        // Param is passed by value, moved
        pub fn set_commands_issued(&mut self, v: u32) {
            self.commands_issued = ::std::option::Option::Some(v);
        }

        // optional uint32 sentry_wards_placed = 11;

        pub fn sentry_wards_placed(&self) -> u32 {
            self.sentry_wards_placed.unwrap_or(0)
        }

        pub fn clear_sentry_wards_placed(&mut self) {
            self.sentry_wards_placed = ::std::option::Option::None;
        }

        pub fn has_sentry_wards_placed(&self) -> bool {
            self.sentry_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_sentry_wards_placed(&mut self, v: u32) {
            self.sentry_wards_placed = ::std::option::Option::Some(v);
        }

        // optional uint32 observer_wards_placed = 12;

        pub fn observer_wards_placed(&self) -> u32 {
            self.observer_wards_placed.unwrap_or(0)
        }

        pub fn clear_observer_wards_placed(&mut self) {
            self.observer_wards_placed = ::std::option::Option::None;
        }

        pub fn has_observer_wards_placed(&self) -> bool {
            self.observer_wards_placed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_observer_wards_placed(&mut self, v: u32) {
            self.observer_wards_placed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for StatBucket {
        const NAME: &'static str = "StatBucket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.game_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    16 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.experience = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.last_hits = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.denies = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    77 => {
                        self.idle_time = ::std::option::Option::Some(is.read_float()?);
                    },
                    80 => {
                        self.commands_issued = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    88 => {
                        self.sentry_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.observer_wards_placed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.game_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.experience {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.last_hits {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.denies {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.idle_time {
                my_size += 1 + 4;
            }
            if let Some(v) = self.commands_issued {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.sentry_wards_placed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.observer_wards_placed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.game_time {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.assists {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.experience {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.last_hits {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.denies {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.idle_time {
                os.write_float(9, v)?;
            }
            if let Some(v) = self.commands_issued {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.sentry_wards_placed {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.observer_wards_placed {
                os.write_uint32(12, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StatBucket {
            StatBucket::new()
        }

        fn clear(&mut self) {
            self.game_time = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.assists = ::std::option::Option::None;
            self.experience = ::std::option::Option::None;
            self.last_hits = ::std::option::Option::None;
            self.denies = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.idle_time = ::std::option::Option::None;
            self.commands_issued = ::std::option::Option::None;
            self.sentry_wards_placed = ::std::option::Option::None;
            self.observer_wards_placed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StatBucket {
            static instance: StatBucket = StatBucket {
                game_time: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                assists: ::std::option::Option::None,
                experience: ::std::option::Option::None,
                last_hits: ::std::option::Option::None,
                denies: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                idle_time: ::std::option::Option::None,
                commands_issued: ::std::option::Option::None,
                sentry_wards_placed: ::std::option::Option::None,
                observer_wards_placed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnMatchStateV5)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnMatchStateV5 {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.radiant_state)
    pub radiant_state: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_learn_match_state_v5::TeamState>,
    // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.dire_state)
    pub dire_state: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_learn_match_state_v5::TeamState>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchStateV5.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnMatchStateV5 {
    fn default() -> &'a CMsgSteamLearnMatchStateV5 {
        <CMsgSteamLearnMatchStateV5 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnMatchStateV5 {
    pub fn new() -> CMsgSteamLearnMatchStateV5 {
        ::std::default::Default::default()
    }

    // optional float game_time = 1;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnMatchStateV5 {
    const NAME: &'static str = "CMsgSteamLearnMatchStateV5";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_state)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_state)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.radiant_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dire_state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.game_time {
            os.write_float(1, v)?;
        }
        if let Some(v) = self.radiant_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.dire_state.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnMatchStateV5 {
        CMsgSteamLearnMatchStateV5::new()
    }

    fn clear(&mut self) {
        self.game_time = ::std::option::Option::None;
        self.radiant_state.clear();
        self.dire_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnMatchStateV5 {
        static instance: CMsgSteamLearnMatchStateV5 = CMsgSteamLearnMatchStateV5 {
            game_time: ::std::option::Option::None,
            radiant_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dire_state: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamLearnMatchStateV5`
pub mod cmsg_steam_learn_match_state_v5 {
    // @@protoc_insertion_point(message:CMsgSteamLearnMatchStateV5.PlayerState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerState {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.net_worth)
        pub net_worth: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.level)
        pub level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.deaths)
        pub deaths: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.respawn_time)
        pub respawn_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.has_buyback)
        pub has_buyback: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.has_aegis)
        pub has_aegis: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.has_rapier)
        pub has_rapier: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.distance)
        pub distance: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.PlayerState.hero_facet)
        pub hero_facet: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchStateV5.PlayerState.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerState {
        fn default() -> &'a PlayerState {
            <PlayerState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerState {
        pub fn new() -> PlayerState {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 net_worth = 2;

        pub fn net_worth(&self) -> u32 {
            self.net_worth.unwrap_or(0)
        }

        pub fn clear_net_worth(&mut self) {
            self.net_worth = ::std::option::Option::None;
        }

        pub fn has_net_worth(&self) -> bool {
            self.net_worth.is_some()
        }

        // Param is passed by value, moved
        pub fn set_net_worth(&mut self, v: u32) {
            self.net_worth = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 3;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }

        // optional uint32 deaths = 4;

        pub fn deaths(&self) -> u32 {
            self.deaths.unwrap_or(0)
        }

        pub fn clear_deaths(&mut self) {
            self.deaths = ::std::option::Option::None;
        }

        pub fn has_deaths(&self) -> bool {
            self.deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deaths(&mut self, v: u32) {
            self.deaths = ::std::option::Option::Some(v);
        }

        // optional uint32 respawn_time = 5;

        pub fn respawn_time(&self) -> u32 {
            self.respawn_time.unwrap_or(0)
        }

        pub fn clear_respawn_time(&mut self) {
            self.respawn_time = ::std::option::Option::None;
        }

        pub fn has_respawn_time(&self) -> bool {
            self.respawn_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_respawn_time(&mut self, v: u32) {
            self.respawn_time = ::std::option::Option::Some(v);
        }

        // optional bool has_buyback = 6;

        pub fn has_buyback(&self) -> bool {
            self.has_buyback.unwrap_or(false)
        }

        pub fn clear_has_buyback(&mut self) {
            self.has_buyback = ::std::option::Option::None;
        }

        pub fn has_has_buyback(&self) -> bool {
            self.has_buyback.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_buyback(&mut self, v: bool) {
            self.has_buyback = ::std::option::Option::Some(v);
        }

        // optional bool has_aegis = 7;

        pub fn has_aegis(&self) -> bool {
            self.has_aegis.unwrap_or(false)
        }

        pub fn clear_has_aegis(&mut self) {
            self.has_aegis = ::std::option::Option::None;
        }

        pub fn has_has_aegis(&self) -> bool {
            self.has_aegis.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_aegis(&mut self, v: bool) {
            self.has_aegis = ::std::option::Option::Some(v);
        }

        // optional bool has_rapier = 8;

        pub fn has_rapier(&self) -> bool {
            self.has_rapier.unwrap_or(false)
        }

        pub fn clear_has_rapier(&mut self) {
            self.has_rapier = ::std::option::Option::None;
        }

        pub fn has_has_rapier(&self) -> bool {
            self.has_rapier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_has_rapier(&mut self, v: bool) {
            self.has_rapier = ::std::option::Option::Some(v);
        }

        // optional uint32 distance = 9;

        pub fn distance(&self) -> u32 {
            self.distance.unwrap_or(0)
        }

        pub fn clear_distance(&mut self) {
            self.distance = ::std::option::Option::None;
        }

        pub fn has_distance(&self) -> bool {
            self.distance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_distance(&mut self, v: u32) {
            self.distance = ::std::option::Option::Some(v);
        }

        // optional uint32 hero_facet = 10;

        pub fn hero_facet(&self) -> u32 {
            self.hero_facet.unwrap_or(0)
        }

        pub fn clear_hero_facet(&mut self) {
            self.hero_facet = ::std::option::Option::None;
        }

        pub fn has_hero_facet(&self) -> bool {
            self.hero_facet.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_facet(&mut self, v: u32) {
            self.hero_facet = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerState {
        const NAME: &'static str = "PlayerState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.deaths = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.respawn_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.has_buyback = ::std::option::Option::Some(is.read_bool()?);
                    },
                    56 => {
                        self.has_aegis = ::std::option::Option::Some(is.read_bool()?);
                    },
                    64 => {
                        self.has_rapier = ::std::option::Option::Some(is.read_bool()?);
                    },
                    72 => {
                        self.distance = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.hero_facet = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.net_worth {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.deaths {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.respawn_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.has_buyback {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_aegis {
                my_size += 1 + 1;
            }
            if let Some(v) = self.has_rapier {
                my_size += 1 + 1;
            }
            if let Some(v) = self.distance {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.hero_facet {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.net_worth {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.deaths {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.respawn_time {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.has_buyback {
                os.write_bool(6, v)?;
            }
            if let Some(v) = self.has_aegis {
                os.write_bool(7, v)?;
            }
            if let Some(v) = self.has_rapier {
                os.write_bool(8, v)?;
            }
            if let Some(v) = self.distance {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.hero_facet {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerState {
            PlayerState::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.net_worth = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.deaths = ::std::option::Option::None;
            self.respawn_time = ::std::option::Option::None;
            self.has_buyback = ::std::option::Option::None;
            self.has_aegis = ::std::option::Option::None;
            self.has_rapier = ::std::option::Option::None;
            self.distance = ::std::option::Option::None;
            self.hero_facet = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerState {
            static instance: PlayerState = PlayerState {
                hero_id: ::std::option::Option::None,
                net_worth: ::std::option::Option::None,
                level: ::std::option::Option::None,
                deaths: ::std::option::Option::None,
                respawn_time: ::std::option::Option::None,
                has_buyback: ::std::option::Option::None,
                has_aegis: ::std::option::Option::None,
                has_rapier: ::std::option::Option::None,
                distance: ::std::option::Option::None,
                hero_facet: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgSteamLearnMatchStateV5.TeamState)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeamState {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.team)
        pub team: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.player_states)
        pub player_states: ::std::vec::Vec<PlayerState>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.tower_health_pct)
        pub tower_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.barracks_health_pct)
        pub barracks_health_pct: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.ancient_health_pct)
        pub ancient_health_pct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.glyph_cooldown)
        pub glyph_cooldown: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.kills)
        pub kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.creep_distance_safe)
        pub creep_distance_safe: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.creep_distance_mid)
        pub creep_distance_mid: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnMatchStateV5.TeamState.creep_distance_off)
        pub creep_distance_off: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnMatchStateV5.TeamState.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeamState {
        fn default() -> &'a TeamState {
            <TeamState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeamState {
        pub fn new() -> TeamState {
            ::std::default::Default::default()
        }

        // optional uint32 team = 1;

        pub fn team(&self) -> u32 {
            self.team.unwrap_or(0)
        }

        pub fn clear_team(&mut self) {
            self.team = ::std::option::Option::None;
        }

        pub fn has_team(&self) -> bool {
            self.team.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team(&mut self, v: u32) {
            self.team = ::std::option::Option::Some(v);
        }

        // optional uint32 ancient_health_pct = 5;

        pub fn ancient_health_pct(&self) -> u32 {
            self.ancient_health_pct.unwrap_or(0)
        }

        pub fn clear_ancient_health_pct(&mut self) {
            self.ancient_health_pct = ::std::option::Option::None;
        }

        pub fn has_ancient_health_pct(&self) -> bool {
            self.ancient_health_pct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ancient_health_pct(&mut self, v: u32) {
            self.ancient_health_pct = ::std::option::Option::Some(v);
        }

        // optional uint32 glyph_cooldown = 6;

        pub fn glyph_cooldown(&self) -> u32 {
            self.glyph_cooldown.unwrap_or(0)
        }

        pub fn clear_glyph_cooldown(&mut self) {
            self.glyph_cooldown = ::std::option::Option::None;
        }

        pub fn has_glyph_cooldown(&self) -> bool {
            self.glyph_cooldown.is_some()
        }

        // Param is passed by value, moved
        pub fn set_glyph_cooldown(&mut self, v: u32) {
            self.glyph_cooldown = ::std::option::Option::Some(v);
        }

        // optional uint32 kills = 7;

        pub fn kills(&self) -> u32 {
            self.kills.unwrap_or(0)
        }

        pub fn clear_kills(&mut self) {
            self.kills = ::std::option::Option::None;
        }

        pub fn has_kills(&self) -> bool {
            self.kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_kills(&mut self, v: u32) {
            self.kills = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_safe = 8;

        pub fn creep_distance_safe(&self) -> u32 {
            self.creep_distance_safe.unwrap_or(0)
        }

        pub fn clear_creep_distance_safe(&mut self) {
            self.creep_distance_safe = ::std::option::Option::None;
        }

        pub fn has_creep_distance_safe(&self) -> bool {
            self.creep_distance_safe.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_safe(&mut self, v: u32) {
            self.creep_distance_safe = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_mid = 9;

        pub fn creep_distance_mid(&self) -> u32 {
            self.creep_distance_mid.unwrap_or(0)
        }

        pub fn clear_creep_distance_mid(&mut self) {
            self.creep_distance_mid = ::std::option::Option::None;
        }

        pub fn has_creep_distance_mid(&self) -> bool {
            self.creep_distance_mid.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_mid(&mut self, v: u32) {
            self.creep_distance_mid = ::std::option::Option::Some(v);
        }

        // optional uint32 creep_distance_off = 10;

        pub fn creep_distance_off(&self) -> u32 {
            self.creep_distance_off.unwrap_or(0)
        }

        pub fn clear_creep_distance_off(&mut self) {
            self.creep_distance_off = ::std::option::Option::None;
        }

        pub fn has_creep_distance_off(&self) -> bool {
            self.creep_distance_off.is_some()
        }

        // Param is passed by value, moved
        pub fn set_creep_distance_off(&mut self, v: u32) {
            self.creep_distance_off = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeamState {
        const NAME: &'static str = "TeamState";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_states.push(is.read_message()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.tower_health_pct)?;
                    },
                    24 => {
                        self.tower_health_pct.push(is.read_uint32()?);
                    },
                    34 => {
                        is.read_repeated_packed_uint32_into(&mut self.barracks_health_pct)?;
                    },
                    32 => {
                        self.barracks_health_pct.push(is.read_uint32()?);
                    },
                    40 => {
                        self.ancient_health_pct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.glyph_cooldown = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.creep_distance_safe = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.creep_distance_mid = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.creep_distance_off = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.player_states {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.tower_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
            };
            for value in &self.barracks_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
            };
            if let Some(v) = self.ancient_health_pct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.glyph_cooldown {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.creep_distance_safe {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.creep_distance_mid {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.creep_distance_off {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team {
                os.write_uint32(1, v)?;
            }
            for v in &self.player_states {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            for v in &self.tower_health_pct {
                os.write_uint32(3, *v)?;
            };
            for v in &self.barracks_health_pct {
                os.write_uint32(4, *v)?;
            };
            if let Some(v) = self.ancient_health_pct {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.glyph_cooldown {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.kills {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.creep_distance_safe {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.creep_distance_mid {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.creep_distance_off {
                os.write_uint32(10, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeamState {
            TeamState::new()
        }

        fn clear(&mut self) {
            self.team = ::std::option::Option::None;
            self.player_states.clear();
            self.tower_health_pct.clear();
            self.barracks_health_pct.clear();
            self.ancient_health_pct = ::std::option::Option::None;
            self.glyph_cooldown = ::std::option::Option::None;
            self.kills = ::std::option::Option::None;
            self.creep_distance_safe = ::std::option::Option::None;
            self.creep_distance_mid = ::std::option::Option::None;
            self.creep_distance_off = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeamState {
            static instance: TeamState = TeamState {
                team: ::std::option::Option::None,
                player_states: ::std::vec::Vec::new(),
                tower_health_pct: ::std::vec::Vec::new(),
                barracks_health_pct: ::std::vec::Vec::new(),
                ancient_health_pct: ::std::option::Option::None,
                glyph_cooldown: ::std::option::Option::None,
                kills: ::std::option::Option::None,
                creep_distance_safe: ::std::option::Option::None,
                creep_distance_mid: ::std::option::Option::None,
                creep_distance_off: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnItemPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnItemPurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.item_id)
    pub item_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.inventory_items)
    pub inventory_items: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.purchase_history)
    pub purchase_history: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.gold)
    pub gold: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.net_worth)
    pub net_worth: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.is_radiant_team)
    pub is_radiant_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnItemPurchase.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnItemPurchase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnItemPurchase {
    fn default() -> &'a CMsgSteamLearnItemPurchase {
        <CMsgSteamLearnItemPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnItemPurchase {
    pub fn new() -> CMsgSteamLearnItemPurchase {
        ::std::default::Default::default()
    }

    // optional int32 item_id = 1;

    pub fn item_id(&self) -> i32 {
        self.item_id.unwrap_or(-1i32)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: i32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 gold = 4;

    pub fn gold(&self) -> u32 {
        self.gold.unwrap_or(0)
    }

    pub fn clear_gold(&mut self) {
        self.gold = ::std::option::Option::None;
    }

    pub fn has_gold(&self) -> bool {
        self.gold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gold(&mut self, v: u32) {
        self.gold = ::std::option::Option::Some(v);
    }

    // optional uint32 net_worth = 5;

    pub fn net_worth(&self) -> u32 {
        self.net_worth.unwrap_or(0)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: u32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional uint32 is_radiant_team = 6;

    pub fn is_radiant_team(&self) -> u32 {
        self.is_radiant_team.unwrap_or(0)
    }

    pub fn clear_is_radiant_team(&mut self) {
        self.is_radiant_team = ::std::option::Option::None;
    }

    pub fn has_is_radiant_team(&self) -> bool {
        self.is_radiant_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_radiant_team(&mut self, v: u32) {
        self.is_radiant_team = ::std::option::Option::Some(v);
    }

    // optional float game_time = 7;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 8;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnItemPurchase {
    const NAME: &'static str = "CMsgSteamLearnItemPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.inventory_items)?;
                },
                16 => {
                    self.inventory_items.push(is.read_int32()?);
                },
                26 => {
                    is.read_repeated_packed_int32_into(&mut self.purchase_history)?;
                },
                24 => {
                    self.purchase_history.push(is.read_int32()?);
                },
                32 => {
                    self.gold = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.is_radiant_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                61 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                64 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.inventory_items {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        for value in &self.purchase_history {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, *value);
        };
        if let Some(v) = self.gold {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.net_worth {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.is_radiant_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_int32(1, v)?;
        }
        for v in &self.inventory_items {
            os.write_int32(2, *v)?;
        };
        for v in &self.purchase_history {
            os.write_int32(3, *v)?;
        };
        if let Some(v) = self.gold {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.is_radiant_team {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnItemPurchase {
        CMsgSteamLearnItemPurchase::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.inventory_items.clear();
        self.purchase_history.clear();
        self.gold = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.is_radiant_team = ::std::option::Option::None;
        self.game_time = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnItemPurchase {
        static instance: CMsgSteamLearnItemPurchase = CMsgSteamLearnItemPurchase {
            item_id: ::std::option::Option::None,
            inventory_items: ::std::vec::Vec::new(),
            purchase_history: ::std::vec::Vec::new(),
            gold: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            is_radiant_team: ::std::option::Option::None,
            game_time: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnPreGameItemPurchases)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnPreGameItemPurchases {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnPreGameItemPurchases.item_ids)
    pub item_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnPreGameItemPurchases.is_radiant_team)
    pub is_radiant_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnPreGameItemPurchases.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnPreGameItemPurchases.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnPreGameItemPurchases {
    fn default() -> &'a CMsgSteamLearnPreGameItemPurchases {
        <CMsgSteamLearnPreGameItemPurchases as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnPreGameItemPurchases {
    pub fn new() -> CMsgSteamLearnPreGameItemPurchases {
        ::std::default::Default::default()
    }

    // optional uint32 is_radiant_team = 2;

    pub fn is_radiant_team(&self) -> u32 {
        self.is_radiant_team.unwrap_or(0)
    }

    pub fn clear_is_radiant_team(&mut self) {
        self.is_radiant_team = ::std::option::Option::None;
    }

    pub fn has_is_radiant_team(&self) -> bool {
        self.is_radiant_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_radiant_team(&mut self, v: u32) {
        self.is_radiant_team = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 3;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnPreGameItemPurchases {
    const NAME: &'static str = "CMsgSteamLearnPreGameItemPurchases";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_int32()?);
                },
                16 => {
                    self.is_radiant_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        if let Some(v) = self.is_radiant_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_int32(1, *v)?;
        };
        if let Some(v) = self.is_radiant_team {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnPreGameItemPurchases {
        CMsgSteamLearnPreGameItemPurchases::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.is_radiant_team = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnPreGameItemPurchases {
        static instance: CMsgSteamLearnPreGameItemPurchases = CMsgSteamLearnPreGameItemPurchases {
            item_ids: ::std::vec::Vec::new(),
            is_radiant_team: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnNeutralItemPurchase)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnNeutralItemPurchase {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnNeutralItemPurchase.item_id)
    pub item_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnNeutralItemPurchase.tier)
    pub tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnNeutralItemPurchase.is_radiant_team)
    pub is_radiant_team: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnNeutralItemPurchase.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnNeutralItemPurchase.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnNeutralItemPurchase {
    fn default() -> &'a CMsgSteamLearnNeutralItemPurchase {
        <CMsgSteamLearnNeutralItemPurchase as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnNeutralItemPurchase {
    pub fn new() -> CMsgSteamLearnNeutralItemPurchase {
        ::std::default::Default::default()
    }

    // optional int32 item_id = 1;

    pub fn item_id(&self) -> i32 {
        self.item_id.unwrap_or(-1i32)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: i32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 tier = 2;

    pub fn tier(&self) -> u32 {
        self.tier.unwrap_or(0)
    }

    pub fn clear_tier(&mut self) {
        self.tier = ::std::option::Option::None;
    }

    pub fn has_tier(&self) -> bool {
        self.tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tier(&mut self, v: u32) {
        self.tier = ::std::option::Option::Some(v);
    }

    // optional uint32 is_radiant_team = 3;

    pub fn is_radiant_team(&self) -> u32 {
        self.is_radiant_team.unwrap_or(0)
    }

    pub fn clear_is_radiant_team(&mut self) {
        self.is_radiant_team = ::std::option::Option::None;
    }

    pub fn has_is_radiant_team(&self) -> bool {
        self.is_radiant_team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_radiant_team(&mut self, v: u32) {
        self.is_radiant_team = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 4;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnNeutralItemPurchase {
    const NAME: &'static str = "CMsgSteamLearnNeutralItemPurchase";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.is_radiant_team = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.is_radiant_team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.tier {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.is_radiant_team {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnNeutralItemPurchase {
        CMsgSteamLearnNeutralItemPurchase::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.tier = ::std::option::Option::None;
        self.is_radiant_team = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnNeutralItemPurchase {
        static instance: CMsgSteamLearnNeutralItemPurchase = CMsgSteamLearnNeutralItemPurchase {
            item_id: ::std::option::Option::None,
            tier: ::std::option::Option::None,
            is_radiant_team: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnAbilitySkill)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnAbilitySkill {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnAbilitySkill.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnAbilitySkill.skilled_abilities)
    pub skilled_abilities: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnAbilitySkill.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgSteamLearnAbilitySkill.is_using_dota_plus)
    pub is_using_dota_plus: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnAbilitySkill.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnAbilitySkill {
    fn default() -> &'a CMsgSteamLearnAbilitySkill {
        <CMsgSteamLearnAbilitySkill as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnAbilitySkill {
    pub fn new() -> CMsgSteamLearnAbilitySkill {
        ::std::default::Default::default()
    }

    // optional int32 ability_id = 1;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional float game_time = 3;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional bool is_using_dota_plus = 4;

    pub fn is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.unwrap_or(false)
    }

    pub fn clear_is_using_dota_plus(&mut self) {
        self.is_using_dota_plus = ::std::option::Option::None;
    }

    pub fn has_is_using_dota_plus(&self) -> bool {
        self.is_using_dota_plus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_using_dota_plus(&mut self, v: bool) {
        self.is_using_dota_plus = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnAbilitySkill {
    const NAME: &'static str = "CMsgSteamLearnAbilitySkill";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.skilled_abilities)?;
                },
                16 => {
                    self.skilled_abilities.push(is.read_int32()?);
                },
                29 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                32 => {
                    self.is_using_dota_plus = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.skilled_abilities {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.is_using_dota_plus {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ability_id {
            os.write_int32(1, v)?;
        }
        for v in &self.skilled_abilities {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.game_time {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.is_using_dota_plus {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnAbilitySkill {
        CMsgSteamLearnAbilitySkill::new()
    }

    fn clear(&mut self) {
        self.ability_id = ::std::option::Option::None;
        self.skilled_abilities.clear();
        self.game_time = ::std::option::Option::None;
        self.is_using_dota_plus = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnAbilitySkill {
        static instance: CMsgSteamLearnAbilitySkill = CMsgSteamLearnAbilitySkill {
            ability_id: ::std::option::Option::None,
            skilled_abilities: ::std::vec::Vec::new(),
            game_time: ::std::option::Option::None,
            is_using_dota_plus: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnEarlyGameItemPurchases)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnEarlyGameItemPurchases {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnEarlyGameItemPurchases.item_ids)
    pub item_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnEarlyGameItemPurchases.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnEarlyGameItemPurchases {
    fn default() -> &'a CMsgSteamLearnEarlyGameItemPurchases {
        <CMsgSteamLearnEarlyGameItemPurchases as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnEarlyGameItemPurchases {
    pub fn new() -> CMsgSteamLearnEarlyGameItemPurchases {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnEarlyGameItemPurchases {
    const NAME: &'static str = "CMsgSteamLearnEarlyGameItemPurchases";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnEarlyGameItemPurchases {
        CMsgSteamLearnEarlyGameItemPurchases::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnEarlyGameItemPurchases {
        static instance: CMsgSteamLearnEarlyGameItemPurchases = CMsgSteamLearnEarlyGameItemPurchases {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnLateGameItemPurchases)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnLateGameItemPurchases {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnLateGameItemPurchases.item_ids)
    pub item_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnLateGameItemPurchases.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnLateGameItemPurchases {
    fn default() -> &'a CMsgSteamLearnLateGameItemPurchases {
        <CMsgSteamLearnLateGameItemPurchases as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnLateGameItemPurchases {
    pub fn new() -> CMsgSteamLearnLateGameItemPurchases {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnLateGameItemPurchases {
    const NAME: &'static str = "CMsgSteamLearnLateGameItemPurchases";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.item_ids)?;
                },
                8 => {
                    self.item_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnLateGameItemPurchases {
        CMsgSteamLearnLateGameItemPurchases::new()
    }

    fn clear(&mut self) {
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnLateGameItemPurchases {
        static instance: CMsgSteamLearnLateGameItemPurchases = CMsgSteamLearnLateGameItemPurchases {
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSteamLearnWardPlacement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSteamLearnWardPlacement {
    // message fields
    // @@protoc_insertion_point(field:CMsgSteamLearnWardPlacement.ward_loc)
    pub ward_loc: ::steam_vent_proto_common::protobuf::MessageField<cmsg_steam_learn_ward_placement::Location>,
    // @@protoc_insertion_point(field:CMsgSteamLearnWardPlacement.existing_ward_locs)
    pub existing_ward_locs: ::std::vec::Vec<cmsg_steam_learn_ward_placement::Location>,
    // @@protoc_insertion_point(field:CMsgSteamLearnWardPlacement.team)
    pub team: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSteamLearnWardPlacement.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSteamLearnWardPlacement {
    fn default() -> &'a CMsgSteamLearnWardPlacement {
        <CMsgSteamLearnWardPlacement as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSteamLearnWardPlacement {
    pub fn new() -> CMsgSteamLearnWardPlacement {
        ::std::default::Default::default()
    }

    // optional uint32 team = 3;

    pub fn team(&self) -> u32 {
        self.team.unwrap_or(0)
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: u32) {
        self.team = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSteamLearnWardPlacement {
    const NAME: &'static str = "CMsgSteamLearnWardPlacement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ward_loc)?;
                },
                18 => {
                    self.existing_ward_locs.push(is.read_message()?);
                },
                24 => {
                    self.team = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ward_loc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.existing_ward_locs {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.ward_loc.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.existing_ward_locs {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.team {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSteamLearnWardPlacement {
        CMsgSteamLearnWardPlacement::new()
    }

    fn clear(&mut self) {
        self.ward_loc.clear();
        self.existing_ward_locs.clear();
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSteamLearnWardPlacement {
        static instance: CMsgSteamLearnWardPlacement = CMsgSteamLearnWardPlacement {
            ward_loc: ::steam_vent_proto_common::protobuf::MessageField::none(),
            existing_ward_locs: ::std::vec::Vec::new(),
            team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSteamLearnWardPlacement`
pub mod cmsg_steam_learn_ward_placement {
    // @@protoc_insertion_point(message:CMsgSteamLearnWardPlacement.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:CMsgSteamLearnWardPlacement.Location.x)
        pub x: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgSteamLearnWardPlacement.Location.y)
        pub y: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSteamLearnWardPlacement.Location.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional float x = 1;

        pub fn x(&self) -> f32 {
            self.x.unwrap_or(0.)
        }

        pub fn clear_x(&mut self) {
            self.x = ::std::option::Option::None;
        }

        pub fn has_x(&self) -> bool {
            self.x.is_some()
        }

        // Param is passed by value, moved
        pub fn set_x(&mut self, v: f32) {
            self.x = ::std::option::Option::Some(v);
        }

        // optional float y = 2;

        pub fn y(&self) -> f32 {
            self.y.unwrap_or(0.)
        }

        pub fn clear_y(&mut self) {
            self.y = ::std::option::Option::None;
        }

        pub fn has_y(&self) -> bool {
            self.y.is_some()
        }

        // Param is passed by value, moved
        pub fn set_y(&mut self, v: f32) {
            self.y = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.x = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.y = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.x {
                my_size += 1 + 4;
            }
            if let Some(v) = self.y {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.x {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.y {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.x = ::std::option::Option::None;
            self.y = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                x: ::std::option::Option::None,
                y: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSignOutMuertaMinigame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMuertaMinigame {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutMuertaMinigame.event_game_data)
    pub event_game_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutMuertaMinigame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMuertaMinigame {
    fn default() -> &'a CMsgSignOutMuertaMinigame {
        <CMsgSignOutMuertaMinigame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMuertaMinigame {
    pub fn new() -> CMsgSignOutMuertaMinigame {
        ::std::default::Default::default()
    }

    // optional bytes event_game_data = 1;

    pub fn event_game_data(&self) -> &[u8] {
        match self.event_game_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_event_game_data(&mut self) {
        self.event_game_data = ::std::option::Option::None;
    }

    pub fn has_event_game_data(&self) -> bool {
        self.event_game_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_game_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.event_game_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_game_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.event_game_data.is_none() {
            self.event_game_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.event_game_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_game_data(&mut self) -> ::std::vec::Vec<u8> {
        self.event_game_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutMuertaMinigame {
    const NAME: &'static str = "CMsgSignOutMuertaMinigame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_game_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_game_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_game_data.as_ref() {
            os.write_bytes(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMuertaMinigame {
        CMsgSignOutMuertaMinigame::new()
    }

    fn clear(&mut self) {
        self.event_game_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMuertaMinigame {
        static instance: CMsgSignOutMuertaMinigame = CMsgSignOutMuertaMinigame {
            event_game_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutMapStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutMapStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutMapStats.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_map_stats::Player>,
    // @@protoc_insertion_point(field:CMsgSignOutMapStats.global_stats)
    pub global_stats: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgMapStatsSnapshot>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutMapStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutMapStats {
    fn default() -> &'a CMsgSignOutMapStats {
        <CMsgSignOutMapStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutMapStats {
    pub fn new() -> CMsgSignOutMapStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutMapStats {
    const NAME: &'static str = "CMsgSignOutMapStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.global_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutMapStats {
        CMsgSignOutMapStats::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.global_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutMapStats {
        static instance: CMsgSignOutMapStats = CMsgSignOutMapStats {
            players: ::std::vec::Vec::new(),
            global_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutMapStats`
pub mod cmsg_sign_out_map_stats {
    // @@protoc_insertion_point(message:CMsgSignOutMapStats.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutMapStats.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutMapStats.Player.personal_stats)
        pub personal_stats: ::steam_vent_proto_common::protobuf::MessageField<super::super::dota_gcmessages_common::CMsgMapStatsSnapshot>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutMapStats.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.personal_stats)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.personal_stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.personal_stats.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.personal_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                personal_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCNewBloomGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCNewBloomGift {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCNewBloomGift.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCNewBloomGift.gifter_account_id)
    pub gifter_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgServerToGCNewBloomGift.target_account_ids)
    pub target_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCNewBloomGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCNewBloomGift {
    fn default() -> &'a CMsgServerToGCNewBloomGift {
        <CMsgServerToGCNewBloomGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCNewBloomGift {
    pub fn new() -> CMsgServerToGCNewBloomGift {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint32 gifter_account_id = 2;

    pub fn gifter_account_id(&self) -> u32 {
        self.gifter_account_id.unwrap_or(0)
    }

    pub fn clear_gifter_account_id(&mut self) {
        self.gifter_account_id = ::std::option::Option::None;
    }

    pub fn has_gifter_account_id(&self) -> bool {
        self.gifter_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gifter_account_id(&mut self, v: u32) {
        self.gifter_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCNewBloomGift {
    const NAME: &'static str = "CMsgServerToGCNewBloomGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.gifter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.target_account_ids)?;
                },
                24 => {
                    self.target_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.gifter_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.target_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.gifter_account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.target_account_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCNewBloomGift {
        CMsgServerToGCNewBloomGift::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.gifter_account_id = ::std::option::Option::None;
        self.target_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCNewBloomGift {
        static instance: CMsgServerToGCNewBloomGift = CMsgServerToGCNewBloomGift {
            defindex: ::std::option::Option::None,
            gifter_account_id: ::std::option::Option::None,
            target_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerToGCNewBloomGiftResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerToGCNewBloomGiftResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerToGCNewBloomGiftResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::ENewBloomGiftingResponse>>,
    // @@protoc_insertion_point(field:CMsgServerToGCNewBloomGiftResponse.received_account_ids)
    pub received_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerToGCNewBloomGiftResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerToGCNewBloomGiftResponse {
    fn default() -> &'a CMsgServerToGCNewBloomGiftResponse {
        <CMsgServerToGCNewBloomGiftResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerToGCNewBloomGiftResponse {
    pub fn new() -> CMsgServerToGCNewBloomGiftResponse {
        ::std::default::Default::default()
    }

    // optional .ENewBloomGiftingResponse result = 1;

    pub fn result(&self) -> super::dota_gcmessages_common::ENewBloomGiftingResponse {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure),
            None => super::dota_gcmessages_common::ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_gcmessages_common::ENewBloomGiftingResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerToGCNewBloomGiftResponse {
    const NAME: &'static str = "CMsgServerToGCNewBloomGiftResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.received_account_ids)?;
                },
                16 => {
                    self.received_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.received_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.received_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerToGCNewBloomGiftResponse {
        CMsgServerToGCNewBloomGiftResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.received_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerToGCNewBloomGiftResponse {
        static instance: CMsgServerToGCNewBloomGiftResponse = CMsgServerToGCNewBloomGiftResponse {
            result: ::std::option::Option::None,
            received_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSignOutOverworld)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSignOutOverworld {
    // message fields
    // @@protoc_insertion_point(field:CMsgSignOutOverworld.players)
    pub players: ::std::vec::Vec<cmsg_sign_out_overworld::Player>,
    // @@protoc_insertion_point(field:CMsgSignOutOverworld.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSignOutOverworld.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSignOutOverworld {
    fn default() -> &'a CMsgSignOutOverworld {
        <CMsgSignOutOverworld as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSignOutOverworld {
    pub fn new() -> CMsgSignOutOverworld {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSignOutOverworld {
    const NAME: &'static str = "CMsgSignOutOverworld";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.players.push(is.read_message()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSignOutOverworld {
        CMsgSignOutOverworld::new()
    }

    fn clear(&mut self) {
        self.players.clear();
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSignOutOverworld {
        static instance: CMsgSignOutOverworld = CMsgSignOutOverworld {
            players: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSignOutOverworld`
pub mod cmsg_sign_out_overworld {
    // @@protoc_insertion_point(message:CMsgSignOutOverworld.Player)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Player {
        // message fields
        // @@protoc_insertion_point(field:CMsgSignOutOverworld.Player.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutOverworld.Player.overworld_id)
        pub overworld_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSignOutOverworld.Player.desired_token_rewards)
        pub desired_token_rewards: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSignOutOverworld.Player.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Player {
        fn default() -> &'a Player {
            <Player as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Player {
        pub fn new() -> Player {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 overworld_id = 2;

        pub fn overworld_id(&self) -> u32 {
            self.overworld_id.unwrap_or(0)
        }

        pub fn clear_overworld_id(&mut self) {
            self.overworld_id = ::std::option::Option::None;
        }

        pub fn has_overworld_id(&self) -> bool {
            self.overworld_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_overworld_id(&mut self, v: u32) {
            self.overworld_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Player {
        const NAME: &'static str = "Player";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.overworld_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        is.read_repeated_packed_uint32_into(&mut self.desired_token_rewards)?;
                    },
                    24 => {
                        self.desired_token_rewards.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.overworld_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            for value in &self.desired_token_rewards {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.overworld_id {
                os.write_uint32(2, v)?;
            }
            for v in &self.desired_token_rewards {
                os.write_uint32(3, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Player {
            Player::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.overworld_id = ::std::option::Option::None;
            self.desired_token_rewards.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Player {
            static instance: Player = Player {
                account_id: ::std::option::Option::None,
                overworld_id: ::std::option::Option::None,
                desired_token_rewards: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPoorNetworkConditionsType)
pub enum EPoorNetworkConditionsType {
    // @@protoc_insertion_point(enum_value:EPoorNetworkConditionsType.k_EPoorNetworkConditions_None)
    k_EPoorNetworkConditions_None = 0,
    // @@protoc_insertion_point(enum_value:EPoorNetworkConditionsType.k_EPoorNetworkConditions_Unknown)
    k_EPoorNetworkConditions_Unknown = 1,
    // @@protoc_insertion_point(enum_value:EPoorNetworkConditionsType.k_EPoorNetworkConditions_MassDisconnect)
    k_EPoorNetworkConditions_MassDisconnect = 2,
    // @@protoc_insertion_point(enum_value:EPoorNetworkConditionsType.k_EPoorNetworkConditions_ExcessBadQosIntervals)
    k_EPoorNetworkConditions_ExcessBadQosIntervals = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPoorNetworkConditionsType {
    const NAME: &'static str = "EPoorNetworkConditionsType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPoorNetworkConditionsType> {
        match value {
            0 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            1 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown),
            2 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect),
            3 => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPoorNetworkConditionsType> {
        match str {
            "k_EPoorNetworkConditions_None" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_None),
            "k_EPoorNetworkConditions_Unknown" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown),
            "k_EPoorNetworkConditions_MassDisconnect" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect),
            "k_EPoorNetworkConditions_ExcessBadQosIntervals" => ::std::option::Option::Some(EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPoorNetworkConditionsType] = &[
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_None,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_Unknown,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_MassDisconnect,
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_ExcessBadQosIntervals,
    ];
}

impl ::std::default::Default for EPoorNetworkConditionsType {
    fn default() -> Self {
        EPoorNetworkConditionsType::k_EPoorNetworkConditions_None
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::valveextensions::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::econ_gcmessages::*;
#[allow(unused_imports)]
use crate::network_connection::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_lobby::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_match_management::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_overworld::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::steammessages_steamlearn_steamworkssdk::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgPoorNetworkConditions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameserverCrash {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConnectedPlayers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGameServerInfo {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCGameServerInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeaverDetected {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeaverDetectedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyFinalPlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAFantasyLivePlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCRealtimeStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCRealtimeStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRealtimeStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerRealtimeStatsStartStop {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToServerRealtimeStatsStartStop {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerRealtimeStatsStartStop;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerUpdateSteamBroadcasting {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToServerUpdateSteamBroadcasting {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerUpdateSteamBroadcasting;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutGameplayStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOut {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutDraftInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutDraftInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutDraftInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutBotInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutBotInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutBotInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutTextMuteInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutTextMuteInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutTextMuteInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutPlayerStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutCommunicationSummary {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutCommunicationSummary {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutCommunicationSummary;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignoutResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTimedRewardContainer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOutPermissionRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOutPermissionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOutEventGameData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOutPerfData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameMatchSignOutBanData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALiveScoreboardUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCRequestBatchPlayerResources {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRequestBatchPlayerResources {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestBatchPlayerResources;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRequestBatchPlayerResourcesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestBatchPlayerResourcesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPlayerFailedToConnect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToRelayConnect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGCToLANServerRelayConnect {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGCToLANServerRelayConnect {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGCToLANServerRelayConnect;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCBanStatusRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCBanStatusRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCBanStatusRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCBanStatusResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCBanStatusResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCBanStatusResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTournamentItemEvent {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTournamentItemEventResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTeamFanfare {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgTeamFanfare {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgTeamFanfare;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgResponseTeamFanfare {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgResponseTeamFanfare {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgResponseTeamFanfare;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerUploadSaveGame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerSaveGameResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerGetLoadGame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGameServerGetLoadGameResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAAwardEventPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAAwardEventPoints {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAAwardEventPoints;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerPingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerPingRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerPingRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerPingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerPingResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerPingResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCMatchConnectionStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCMatchConnectionStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCMatchConnectionStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerGCUpdateSpectatorCount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerGCUpdateSpectatorCount {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerGCUpdateSpectatorCount;
}
impl ::steam_vent_proto_common::RpcMessage for CSerializedCombatLog {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCVictoryPredictions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCVictoryPredictions {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCVictoryPredictions;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCRequestStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCRequestStatus {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestStatus;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCRequestStatus_Response {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRequestStatus_Response {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRequestStatus_Response;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerEvaluateToxicChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerEvaluateToxicChat {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerEvaluateToxicChat;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCEvaluateToxicChat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCEvaluateToxicChat {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCEvaluateToxicChat;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCEvaluateToxicChatResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCEvaluateToxicChatResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCEvaluateToxicChatResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutAssassinMiniGameInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCKillSummaries {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCLockCharmTrading {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCLockCharmTrading {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCLockCharmTrading;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutUpdatePlayerChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutUpdatePlayerChallenge {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutUpdatePlayerChallenge;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCRerollPlayerChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCRerollPlayerChallenge {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCRerollPlayerChallenge;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSpendWager {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutXPCoins {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutXPCoins {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutXPCoins;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutBounties {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutBounties {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutBounties;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutCommunityGoalProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutCommunityGoalProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutCommunityGoalProgress;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCloseCompendiumInGamePredictionVoting {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCloseCompendiumInGamePredictionVoting;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCloseCompendiumInGamePredictionVotingResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCloseCompendiumInGamePredictionVotingResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCCompendiumInGamePredictionResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCompendiumInGamePredictionResults {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCompendiumInGamePredictionResults;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCCompendiumChosenInGamePredictions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCompendiumChosenInGamePredictions {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCompendiumChosenInGamePredictions;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToGCCompendiumInGamePredictionResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCCompendiumInGamePredictionResults {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToGCCompendiumInGamePredictionResults;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCMatchPlayerItemPurchaseHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCMatchPlayerItemPurchaseHistory;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCMatchPlayerNeutralItemEquipHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCMatchPlayerNeutralItemEquipHistory;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCMatchStateHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCMatchStateHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCMatchStateHistory;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchStateSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLaneSelectionSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAbilitySelectionSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemPurchasePregameSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemPurchaseSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemPurchaseSequenceSteamMLEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCCavernCrawlIsHeroActive {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCavernCrawlIsHeroActive {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCavernCrawlIsHeroActive;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCPlayerChallengeHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCPlayerChallengeHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCPlayerChallengeHistory;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCCavernCrawlIsHeroActiveResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCCavernCrawlIsHeroActiveResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgNeutralItemStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgNeutralItemStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgNeutralItemStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerLobbyHeroBanRates {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerLobbyHeroBanRates {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerLobbyHeroBanRates;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutGuildContractProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutGuildContractProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutGuildContractProgress;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutGuildChallengeProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgSignOutGuildChallengeProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutGuildChallengeProgress;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutMVPStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutMVPStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutMVPStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerRecordTrainingData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerRecordTrainingData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerRecordTrainingData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetGuildContracts {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCGetGuildContracts {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetGuildContracts;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetGuildContractsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCGetGuildContractsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetGuildContractsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchDiretideCandy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerCheerData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCheerConfig {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerCheerConfig {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerCheerConfig {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerCheerConfig;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetCheerConfig {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCGetCheerConfig {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetCheerConfig;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetCheerConfigResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCGetCheerConfigResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetCheerConfigResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerCheerScalesOverride {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToServerCheerScalesOverride {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerCheerScalesOverride;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerGetCheerState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerGetCheerState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerGetCheerState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCheerTypeState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCheerState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCReportCheerState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCReportCheerState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCReportCheerState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetStickerHeroes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCGetStickerHeroes {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetStickerHeroes;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCGetStickerHeroesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCGetStickerHeroesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCGetStickerHeroesResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToServerSteamLearnAccessTokensChanged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToServerSteamLearnAccessTokensChanged {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerSteamLearnAccessTokensChanged;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerSteamLearnUseHTTP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerSteamLearnUseHTTP {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToServerSteamLearnUseHTTP;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnMatchInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnMatchInfoPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnMatchHeroesV3 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnMatchHeroV3 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnPlayerTimedStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnMatchStateV5 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnItemPurchase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnPreGameItemPurchases {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnNeutralItemPurchase {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnAbilitySkill {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnEarlyGameItemPurchases {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnLateGameItemPurchases {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSteamLearnWardPlacement {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutMuertaMinigame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutMuertaMinigame {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutMuertaMinigame;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutMapStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutMapStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutMapStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCNewBloomGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerToGCNewBloomGift {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCNewBloomGift;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerToGCNewBloomGiftResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgServerToGCNewBloomGiftResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgServerToGCNewBloomGiftResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSignOutOverworld {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSignOutOverworld {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSignOutOverworld;
}
