// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_match_management.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgStartFindingMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartFindingMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.key)
    pub key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.matchgroups)
    pub matchgroups: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.game_modes)
    pub game_modes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.match_type)
    pub match_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.matchlanguages)
    pub matchlanguages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.game_language_enum)
    pub game_language_enum: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchLanguages>>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.game_language_name)
    pub game_language_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.ping_data)
    pub ping_data: ::steam_vent_proto_common::protobuf::MessageField<super::base_gcmessages::CMsgClientPingData>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.region_select_flags)
    pub region_select_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.solo_queue)
    pub solo_queue: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.steam_clan_account_id)
    pub steam_clan_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.is_challenge_match)
    pub is_challenge_match: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.disable_experimental_gameplay)
    pub disable_experimental_gameplay: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.custom_game_difficulty_mask)
    pub custom_game_difficulty_mask: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.bot_difficulty_mask)
    pub bot_difficulty_mask: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatch.bot_script_index_mask)
    pub bot_script_index_mask: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartFindingMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartFindingMatch {
    fn default() -> &'a CMsgStartFindingMatch {
        <CMsgStartFindingMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStartFindingMatch {
    pub fn new() -> CMsgStartFindingMatch {
        ::std::default::Default::default()
    }

    // optional string key = 1;

    pub fn key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key(&mut self) {
        self.key = ::std::option::Option::None;
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 matchgroups = 2;

    pub fn matchgroups(&self) -> u32 {
        self.matchgroups.unwrap_or(4294967295u32)
    }

    pub fn clear_matchgroups(&mut self) {
        self.matchgroups = ::std::option::Option::None;
    }

    pub fn has_matchgroups(&self) -> bool {
        self.matchgroups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups(&mut self, v: u32) {
        self.matchgroups = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 game_modes = 4;

    pub fn game_modes(&self) -> u32 {
        self.game_modes.unwrap_or(4294967295u32)
    }

    pub fn clear_game_modes(&mut self) {
        self.game_modes = ::std::option::Option::None;
    }

    pub fn has_game_modes(&self) -> bool {
        self.game_modes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_modes(&mut self, v: u32) {
        self.game_modes = ::std::option::Option::Some(v);
    }

    // optional .MatchType match_type = 6;

    pub fn match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 matchlanguages = 7;

    pub fn matchlanguages(&self) -> u32 {
        self.matchlanguages.unwrap_or(4294967295u32)
    }

    pub fn clear_matchlanguages(&mut self) {
        self.matchlanguages = ::std::option::Option::None;
    }

    pub fn has_matchlanguages(&self) -> bool {
        self.matchlanguages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchlanguages(&mut self, v: u32) {
        self.matchlanguages = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 8;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional .MatchLanguages game_language_enum = 10;

    pub fn game_language_enum(&self) -> super::dota_shared_enums::MatchLanguages {
        match self.game_language_enum {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID),
            None => super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID,
        }
    }

    pub fn clear_game_language_enum(&mut self) {
        self.game_language_enum = ::std::option::Option::None;
    }

    pub fn has_game_language_enum(&self) -> bool {
        self.game_language_enum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_language_enum(&mut self, v: super::dota_shared_enums::MatchLanguages) {
        self.game_language_enum = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string game_language_name = 11;

    pub fn game_language_name(&self) -> &str {
        match self.game_language_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_language_name(&mut self) {
        self.game_language_name = ::std::option::Option::None;
    }

    pub fn has_game_language_name(&self) -> bool {
        self.game_language_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_language_name(&mut self, v: ::std::string::String) {
        self.game_language_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_language_name(&mut self) -> &mut ::std::string::String {
        if self.game_language_name.is_none() {
            self.game_language_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_language_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_language_name(&mut self) -> ::std::string::String {
        self.game_language_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 region_select_flags = 13;

    pub fn region_select_flags(&self) -> u32 {
        self.region_select_flags.unwrap_or(0)
    }

    pub fn clear_region_select_flags(&mut self) {
        self.region_select_flags = ::std::option::Option::None;
    }

    pub fn has_region_select_flags(&self) -> bool {
        self.region_select_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_select_flags(&mut self, v: u32) {
        self.region_select_flags = ::std::option::Option::Some(v);
    }

    // optional bool solo_queue = 14;

    pub fn solo_queue(&self) -> bool {
        self.solo_queue.unwrap_or(false)
    }

    pub fn clear_solo_queue(&mut self) {
        self.solo_queue = ::std::option::Option::None;
    }

    pub fn has_solo_queue(&self) -> bool {
        self.solo_queue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_solo_queue(&mut self, v: bool) {
        self.solo_queue = ::std::option::Option::Some(v);
    }

    // optional uint32 steam_clan_account_id = 16;

    pub fn steam_clan_account_id(&self) -> u32 {
        self.steam_clan_account_id.unwrap_or(0)
    }

    pub fn clear_steam_clan_account_id(&mut self) {
        self.steam_clan_account_id = ::std::option::Option::None;
    }

    pub fn has_steam_clan_account_id(&self) -> bool {
        self.steam_clan_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_clan_account_id(&mut self, v: u32) {
        self.steam_clan_account_id = ::std::option::Option::Some(v);
    }

    // optional bool is_challenge_match = 17;

    pub fn is_challenge_match(&self) -> bool {
        self.is_challenge_match.unwrap_or(false)
    }

    pub fn clear_is_challenge_match(&mut self) {
        self.is_challenge_match = ::std::option::Option::None;
    }

    pub fn has_is_challenge_match(&self) -> bool {
        self.is_challenge_match.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_challenge_match(&mut self, v: bool) {
        self.is_challenge_match = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 18;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 19;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }

    // optional bool disable_experimental_gameplay = 20;

    pub fn disable_experimental_gameplay(&self) -> bool {
        self.disable_experimental_gameplay.unwrap_or(false)
    }

    pub fn clear_disable_experimental_gameplay(&mut self) {
        self.disable_experimental_gameplay = ::std::option::Option::None;
    }

    pub fn has_disable_experimental_gameplay(&self) -> bool {
        self.disable_experimental_gameplay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_experimental_gameplay(&mut self, v: bool) {
        self.disable_experimental_gameplay = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_difficulty_mask = 21;

    pub fn custom_game_difficulty_mask(&self) -> u32 {
        self.custom_game_difficulty_mask.unwrap_or(0)
    }

    pub fn clear_custom_game_difficulty_mask(&mut self) {
        self.custom_game_difficulty_mask = ::std::option::Option::None;
    }

    pub fn has_custom_game_difficulty_mask(&self) -> bool {
        self.custom_game_difficulty_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_difficulty_mask(&mut self, v: u32) {
        self.custom_game_difficulty_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_difficulty_mask = 22;

    pub fn bot_difficulty_mask(&self) -> u32 {
        self.bot_difficulty_mask.unwrap_or(0)
    }

    pub fn clear_bot_difficulty_mask(&mut self) {
        self.bot_difficulty_mask = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_mask(&self) -> bool {
        self.bot_difficulty_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_mask(&mut self, v: u32) {
        self.bot_difficulty_mask = ::std::option::Option::Some(v);
    }

    // optional uint32 bot_script_index_mask = 23;

    pub fn bot_script_index_mask(&self) -> u32 {
        self.bot_script_index_mask.unwrap_or(0)
    }

    pub fn clear_bot_script_index_mask(&mut self) {
        self.bot_script_index_mask = ::std::option::Option::None;
    }

    pub fn has_bot_script_index_mask(&self) -> bool {
        self.bot_script_index_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_script_index_mask(&mut self, v: u32) {
        self.bot_script_index_mask = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStartFindingMatch {
    const NAME: &'static str = "CMsgStartFindingMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.matchgroups = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_modes = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                56 => {
                    self.matchlanguages = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.game_language_enum = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.game_language_name = ::std::option::Option::Some(is.read_string()?);
                },
                98 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                104 => {
                    self.region_select_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.solo_queue = ::std::option::Option::Some(is.read_bool()?);
                },
                128 => {
                    self.steam_clan_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.is_challenge_match = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.disable_experimental_gameplay = ::std::option::Option::Some(is.read_bool()?);
                },
                168 => {
                    self.custom_game_difficulty_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.bot_difficulty_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.bot_script_index_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.matchgroups {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_modes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.match_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.matchlanguages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.game_language_enum {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(10, v.value());
        }
        if let Some(v) = self.game_language_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.region_select_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.solo_queue {
            my_size += 1 + 1;
        }
        if let Some(v) = self.steam_clan_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.is_challenge_match {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 2 + 1;
        }
        if let Some(v) = self.disable_experimental_gameplay {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_difficulty_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.bot_difficulty_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.bot_script_index_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.matchgroups {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_modes {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.match_type {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.matchlanguages {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.game_language_enum {
            os.write_enum(10, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_language_name.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.region_select_flags {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.solo_queue {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.steam_clan_account_id {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.is_challenge_match {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(19, v)?;
        }
        if let Some(v) = self.disable_experimental_gameplay {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.custom_game_difficulty_mask {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.bot_difficulty_mask {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.bot_script_index_mask {
            os.write_uint32(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartFindingMatch {
        CMsgStartFindingMatch::new()
    }

    fn clear(&mut self) {
        self.key = ::std::option::Option::None;
        self.matchgroups = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.game_modes = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.matchlanguages = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.game_language_enum = ::std::option::Option::None;
        self.game_language_name = ::std::option::Option::None;
        self.ping_data.clear();
        self.region_select_flags = ::std::option::Option::None;
        self.solo_queue = ::std::option::Option::None;
        self.steam_clan_account_id = ::std::option::Option::None;
        self.is_challenge_match = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.disable_experimental_gameplay = ::std::option::Option::None;
        self.custom_game_difficulty_mask = ::std::option::Option::None;
        self.bot_difficulty_mask = ::std::option::Option::None;
        self.bot_script_index_mask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartFindingMatch {
        static instance: CMsgStartFindingMatch = CMsgStartFindingMatch {
            key: ::std::option::Option::None,
            matchgroups: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            game_modes: ::std::option::Option::None,
            match_type: ::std::option::Option::None,
            matchlanguages: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            game_language_enum: ::std::option::Option::None,
            game_language_name: ::std::option::Option::None,
            ping_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            region_select_flags: ::std::option::Option::None,
            solo_queue: ::std::option::Option::None,
            steam_clan_account_id: ::std::option::Option::None,
            is_challenge_match: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            disable_experimental_gameplay: ::std::option::Option::None,
            custom_game_difficulty_mask: ::std::option::Option::None,
            bot_difficulty_mask: ::std::option::Option::None,
            bot_script_index_mask: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStartFindingMatchResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStartFindingMatchResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.legacy_generic_eresult)
    pub legacy_generic_eresult: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EStartFindingMatchResult>>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.error_token)
    pub error_token: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.responsible_party_members)
    pub responsible_party_members: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgStartFindingMatchResult.result_metadata)
    pub result_metadata: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStartFindingMatchResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStartFindingMatchResult {
    fn default() -> &'a CMsgStartFindingMatchResult {
        <CMsgStartFindingMatchResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStartFindingMatchResult {
    pub fn new() -> CMsgStartFindingMatchResult {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_generic_eresult = 1;

    pub fn legacy_generic_eresult(&self) -> u32 {
        self.legacy_generic_eresult.unwrap_or(2u32)
    }

    pub fn clear_legacy_generic_eresult(&mut self) {
        self.legacy_generic_eresult = ::std::option::Option::None;
    }

    pub fn has_legacy_generic_eresult(&self) -> bool {
        self.legacy_generic_eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_generic_eresult(&mut self, v: u32) {
        self.legacy_generic_eresult = ::std::option::Option::Some(v);
    }

    // optional .EStartFindingMatchResult result = 2;

    pub fn result(&self) -> EStartFindingMatchResult {
        match self.result {
            Some(e) => e.enum_value_or(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            None => EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EStartFindingMatchResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string error_token = 3;

    pub fn error_token(&self) -> &str {
        match self.error_token.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error_token(&mut self) {
        self.error_token = ::std::option::Option::None;
    }

    pub fn has_error_token(&self) -> bool {
        self.error_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_token(&mut self, v: ::std::string::String) {
        self.error_token = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_token(&mut self) -> &mut ::std::string::String {
        if self.error_token.is_none() {
            self.error_token = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_token(&mut self) -> ::std::string::String {
        self.error_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string debug_message = 4;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 result_metadata = 6;

    pub fn result_metadata(&self) -> u32 {
        self.result_metadata.unwrap_or(0)
    }

    pub fn clear_result_metadata(&mut self) {
        self.result_metadata = ::std::option::Option::None;
    }

    pub fn has_result_metadata(&self) -> bool {
        self.result_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_metadata(&mut self, v: u32) {
        self.result_metadata = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStartFindingMatchResult {
    const NAME: &'static str = "CMsgStartFindingMatchResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_generic_eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.error_token = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    is.read_repeated_packed_fixed64_into(&mut self.responsible_party_members)?;
                },
                41 => {
                    self.responsible_party_members.push(is.read_fixed64()?);
                },
                48 => {
                    self.result_metadata = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_generic_eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.error_token.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += 9 * self.responsible_party_members.len() as u64;
        if let Some(v) = self.result_metadata {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_generic_eresult {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.error_token.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(4, v)?;
        }
        for v in &self.responsible_party_members {
            os.write_fixed64(5, *v)?;
        };
        if let Some(v) = self.result_metadata {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStartFindingMatchResult {
        CMsgStartFindingMatchResult::new()
    }

    fn clear(&mut self) {
        self.legacy_generic_eresult = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.error_token = ::std::option::Option::None;
        self.debug_message = ::std::option::Option::None;
        self.responsible_party_members.clear();
        self.result_metadata = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStartFindingMatchResult {
        static instance: CMsgStartFindingMatchResult = CMsgStartFindingMatchResult {
            legacy_generic_eresult: ::std::option::Option::None,
            result: ::std::option::Option::None,
            error_token: ::std::option::Option::None,
            debug_message: ::std::option::Option::None,
            responsible_party_members: ::std::vec::Vec::new(),
            result_metadata: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgStopFindingMatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgStopFindingMatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgStopFindingMatch.accept_cooldown)
    pub accept_cooldown: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgStopFindingMatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgStopFindingMatch {
    fn default() -> &'a CMsgStopFindingMatch {
        <CMsgStopFindingMatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgStopFindingMatch {
    pub fn new() -> CMsgStopFindingMatch {
        ::std::default::Default::default()
    }

    // optional bool accept_cooldown = 1;

    pub fn accept_cooldown(&self) -> bool {
        self.accept_cooldown.unwrap_or(false)
    }

    pub fn clear_accept_cooldown(&mut self) {
        self.accept_cooldown = ::std::option::Option::None;
    }

    pub fn has_accept_cooldown(&self) -> bool {
        self.accept_cooldown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept_cooldown(&mut self, v: bool) {
        self.accept_cooldown = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgStopFindingMatch {
    const NAME: &'static str = "CMsgStopFindingMatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accept_cooldown = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accept_cooldown {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.accept_cooldown {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgStopFindingMatch {
        CMsgStopFindingMatch::new()
    }

    fn clear(&mut self) {
        self.accept_cooldown = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgStopFindingMatch {
        static instance: CMsgStopFindingMatch = CMsgStopFindingMatch {
            accept_cooldown: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyBuilderOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyBuilderOptions {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyBuilderOptions.additional_slots)
    pub additional_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartyBuilderOptions.match_type)
    pub match_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // @@protoc_insertion_point(field:CMsgPartyBuilderOptions.matchgroups)
    pub matchgroups: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartyBuilderOptions.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartyBuilderOptions.language)
    pub language: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchLanguages>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyBuilderOptions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyBuilderOptions {
    fn default() -> &'a CMsgPartyBuilderOptions {
        <CMsgPartyBuilderOptions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyBuilderOptions {
    pub fn new() -> CMsgPartyBuilderOptions {
        ::std::default::Default::default()
    }

    // optional uint32 additional_slots = 1;

    pub fn additional_slots(&self) -> u32 {
        self.additional_slots.unwrap_or(0)
    }

    pub fn clear_additional_slots(&mut self) {
        self.additional_slots = ::std::option::Option::None;
    }

    pub fn has_additional_slots(&self) -> bool {
        self.additional_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_slots(&mut self, v: u32) {
        self.additional_slots = ::std::option::Option::Some(v);
    }

    // optional .MatchType match_type = 2;

    pub fn match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 matchgroups = 3;

    pub fn matchgroups(&self) -> u32 {
        self.matchgroups.unwrap_or(0)
    }

    pub fn clear_matchgroups(&mut self) {
        self.matchgroups = ::std::option::Option::None;
    }

    pub fn has_matchgroups(&self) -> bool {
        self.matchgroups.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups(&mut self, v: u32) {
        self.matchgroups = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 4;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional .MatchLanguages language = 5;

    pub fn language(&self) -> super::dota_shared_enums::MatchLanguages {
        match self.language {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID),
            None => super::dota_shared_enums::MatchLanguages::MATCH_LANGUAGE_INVALID,
        }
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: super::dota_shared_enums::MatchLanguages) {
        self.language = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyBuilderOptions {
    const NAME: &'static str = "CMsgPartyBuilderOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.matchgroups = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.language = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.matchgroups {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.additional_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.matchgroups {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.language {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyBuilderOptions {
        CMsgPartyBuilderOptions::new()
    }

    fn clear(&mut self) {
        self.additional_slots = ::std::option::Option::None;
        self.match_type = ::std::option::Option::None;
        self.matchgroups = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyBuilderOptions {
        static instance: CMsgPartyBuilderOptions = CMsgPartyBuilderOptions {
            additional_slots: ::std::option::Option::None,
            match_type: ::std::option::Option::None,
            matchgroups: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            language: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReadyUp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReadyUp {
    // message fields
    // @@protoc_insertion_point(field:CMsgReadyUp.state)
    pub state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyReadyState>>,
    // @@protoc_insertion_point(field:CMsgReadyUp.ready_up_key)
    pub ready_up_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgReadyUp.hardware_specs)
    pub hardware_specs: ::steam_vent_proto_common::protobuf::MessageField<super::dota_shared_enums::CDOTAClientHardwareSpecs>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReadyUp.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReadyUp {
    fn default() -> &'a CMsgReadyUp {
        <CMsgReadyUp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReadyUp {
    pub fn new() -> CMsgReadyUp {
        ::std::default::Default::default()
    }

    // optional .DOTALobbyReadyState state = 1;

    pub fn state(&self) -> super::dota_shared_enums::DOTALobbyReadyState {
        match self.state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            None => super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED,
        }
    }

    pub fn clear_state(&mut self) {
        self.state = ::std::option::Option::None;
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: super::dota_shared_enums::DOTALobbyReadyState) {
        self.state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 ready_up_key = 2;

    pub fn ready_up_key(&self) -> u64 {
        self.ready_up_key.unwrap_or(0)
    }

    pub fn clear_ready_up_key(&mut self) {
        self.ready_up_key = ::std::option::Option::None;
    }

    pub fn has_ready_up_key(&self) -> bool {
        self.ready_up_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready_up_key(&mut self, v: u64) {
        self.ready_up_key = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReadyUp {
    const NAME: &'static str = "CMsgReadyUp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                17 => {
                    self.ready_up_key = ::std::option::Option::Some(is.read_fixed64()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hardware_specs)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.ready_up_key {
            my_size += 1 + 8;
        }
        if let Some(v) = self.hardware_specs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.state {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.ready_up_key {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.hardware_specs.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReadyUp {
        CMsgReadyUp::new()
    }

    fn clear(&mut self) {
        self.state = ::std::option::Option::None;
        self.ready_up_key = ::std::option::Option::None;
        self.hardware_specs.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReadyUp {
        static instance: CMsgReadyUp = CMsgReadyUp {
            state: ::std::option::Option::None,
            ready_up_key: ::std::option::Option::None,
            hardware_specs: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgReadyUpStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgReadyUpStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.accepted_ids)
    pub accepted_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.declined_ids)
    pub declined_ids: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.accepted_indices)
    pub accepted_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.declined_indices)
    pub declined_indices: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgReadyUpStatus.local_ready_state)
    pub local_ready_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyReadyState>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgReadyUpStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgReadyUpStatus {
    fn default() -> &'a CMsgReadyUpStatus {
        <CMsgReadyUpStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgReadyUpStatus {
    pub fn new() -> CMsgReadyUpStatus {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .DOTALobbyReadyState local_ready_state = 6;

    pub fn local_ready_state(&self) -> super::dota_shared_enums::DOTALobbyReadyState {
        match self.local_ready_state {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED),
            None => super::dota_shared_enums::DOTALobbyReadyState::DOTALobbyReadyState_UNDECLARED,
        }
    }

    pub fn clear_local_ready_state(&mut self) {
        self.local_ready_state = ::std::option::Option::None;
    }

    pub fn has_local_ready_state(&self) -> bool {
        self.local_ready_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local_ready_state(&mut self, v: super::dota_shared_enums::DOTALobbyReadyState) {
        self.local_ready_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgReadyUpStatus {
    const NAME: &'static str = "CMsgReadyUpStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.accepted_ids)?;
                },
                16 => {
                    self.accepted_ids.push(is.read_uint32()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.declined_ids)?;
                },
                24 => {
                    self.declined_ids.push(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.accepted_indices)?;
                },
                32 => {
                    self.accepted_indices.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.declined_indices)?;
                },
                40 => {
                    self.declined_indices.push(is.read_uint32()?);
                },
                48 => {
                    self.local_ready_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        for value in &self.accepted_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        for value in &self.declined_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        for value in &self.accepted_indices {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, *value);
        };
        for value in &self.declined_indices {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
        };
        if let Some(v) = self.local_ready_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        for v in &self.accepted_ids {
            os.write_uint32(2, *v)?;
        };
        for v in &self.declined_ids {
            os.write_uint32(3, *v)?;
        };
        for v in &self.accepted_indices {
            os.write_uint32(4, *v)?;
        };
        for v in &self.declined_indices {
            os.write_uint32(5, *v)?;
        };
        if let Some(v) = self.local_ready_state {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgReadyUpStatus {
        CMsgReadyUpStatus::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.accepted_ids.clear();
        self.declined_ids.clear();
        self.accepted_indices.clear();
        self.declined_indices.clear();
        self.local_ready_state = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgReadyUpStatus {
        static instance: CMsgReadyUpStatus = CMsgReadyUpStatus {
            lobby_id: ::std::option::Option::None,
            accepted_ids: ::std::vec::Vec::new(),
            declined_ids: ::std::vec::Vec::new(),
            accepted_indices: ::std::vec::Vec::new(),
            declined_indices: ::std::vec::Vec::new(),
            local_ready_state: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAbandonCurrentGame)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAbandonCurrentGame {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAbandonCurrentGame.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAbandonCurrentGame {
    fn default() -> &'a CMsgAbandonCurrentGame {
        <CMsgAbandonCurrentGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAbandonCurrentGame {
    pub fn new() -> CMsgAbandonCurrentGame {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAbandonCurrentGame {
    const NAME: &'static str = "CMsgAbandonCurrentGame";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAbandonCurrentGame {
        CMsgAbandonCurrentGame::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAbandonCurrentGame {
        static instance: CMsgAbandonCurrentGame = CMsgAbandonCurrentGame {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyScenarioSave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyScenarioSave {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyScenarioSave.version)
    pub version: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgLobbyScenarioSave.data)
    pub data: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyScenarioSave.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyScenarioSave {
    fn default() -> &'a CMsgLobbyScenarioSave {
        <CMsgLobbyScenarioSave as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyScenarioSave {
    pub fn new() -> CMsgLobbyScenarioSave {
        ::std::default::Default::default()
    }

    // optional int32 version = 1;

    pub fn version(&self) -> i32 {
        self.version.unwrap_or(0)
    }

    pub fn clear_version(&mut self) {
        self.version = ::std::option::Option::None;
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = ::std::option::Option::Some(v);
    }

    // optional bytes data = 2;

    pub fn data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyScenarioSave {
    const NAME: &'static str = "CMsgLobbyScenarioSave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.version = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.data = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.version {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.version {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyScenarioSave {
        CMsgLobbyScenarioSave::new()
    }

    fn clear(&mut self) {
        self.version = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyScenarioSave {
        static instance: CMsgLobbyScenarioSave = CMsgLobbyScenarioSave {
            version: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbySetDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.game_name)
    pub game_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.team_details)
    pub team_details: ::std::vec::Vec<super::dota_gcmessages_common_lobby::CLobbyTeamDetails>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.cm_pick)
    pub cm_pick: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_CM_PICK>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.bot_difficulty_radiant)
    pub bot_difficulty_radiant: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.allow_cheats)
    pub allow_cheats: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.fill_with_bots)
    pub fill_with_bots: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.intro_mode)
    pub intro_mode: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.allow_spectating)
    pub allow_spectating: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.penalty_level_radiant)
    pub penalty_level_radiant: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.penalty_level_dire)
    pub penalty_level_dire: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.load_game_id)
    pub load_game_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.radiant_series_wins)
    pub radiant_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.dire_series_wins)
    pub dire_series_wins: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.allchat)
    pub allchat: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.dota_tv_delay)
    pub dota_tv_delay: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::LobbyDotaTVDelay>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.lan)
    pub lan: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_difficulty)
    pub custom_difficulty: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_min_players)
    pub custom_min_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_max_players)
    pub custom_max_players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.visibility)
    pub visibility: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTALobbyVisibility>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.previous_match_override)
    pub previous_match_override: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.pause_setting)
    pub pause_setting: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.bot_difficulty_dire)
    pub bot_difficulty_dire: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.bot_radiant)
    pub bot_radiant: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.bot_dire)
    pub bot_dire: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.selection_priority_rules)
    pub selection_priority_rules: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityRules>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.custom_game_penalties)
    pub custom_game_penalties: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.league_node_id)
    pub league_node_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.requested_hero_ids)
    pub requested_hero_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.scenario_save)
    pub scenario_save: ::steam_vent_proto_common::protobuf::MessageField<CMsgLobbyScenarioSave>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.ability_draft_specific_details)
    pub ability_draft_specific_details: ::steam_vent_proto_common::protobuf::MessageField<cmsg_practice_lobby_set_details::AbilityDraftSpecificDetails>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.do_player_draft)
    pub do_player_draft: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbySetDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetDetails {
    fn default() -> &'a CMsgPracticeLobbySetDetails {
        <CMsgPracticeLobbySetDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetDetails {
    pub fn new() -> CMsgPracticeLobbySetDetails {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string game_name = 2;

    pub fn game_name(&self) -> &str {
        match self.game_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_game_name(&mut self) {
        self.game_name = ::std::option::Option::None;
    }

    pub fn has_game_name(&self) -> bool {
        self.game_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_name(&mut self, v: ::std::string::String) {
        self.game_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
        if self.game_name.is_none() {
            self.game_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.game_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_game_name(&mut self) -> ::std::string::String {
        self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 server_region = 4;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint32 game_mode = 5;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .DOTA_CM_PICK cm_pick = 6;

    pub fn cm_pick(&self) -> super::dota_shared_enums::DOTA_CM_PICK {
        match self.cm_pick {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM),
            None => super::dota_shared_enums::DOTA_CM_PICK::DOTA_CM_RANDOM,
        }
    }

    pub fn clear_cm_pick(&mut self) {
        self.cm_pick = ::std::option::Option::None;
    }

    pub fn has_cm_pick(&self) -> bool {
        self.cm_pick.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_pick(&mut self, v: super::dota_shared_enums::DOTA_CM_PICK) {
        self.cm_pick = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .DOTABotDifficulty bot_difficulty_radiant = 9;

    pub fn bot_difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_radiant(&mut self) {
        self.bot_difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_radiant(&self) -> bool {
        self.bot_difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_radiant = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool allow_cheats = 10;

    pub fn allow_cheats(&self) -> bool {
        self.allow_cheats.unwrap_or(false)
    }

    pub fn clear_allow_cheats(&mut self) {
        self.allow_cheats = ::std::option::Option::None;
    }

    pub fn has_allow_cheats(&self) -> bool {
        self.allow_cheats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_cheats(&mut self, v: bool) {
        self.allow_cheats = ::std::option::Option::Some(v);
    }

    // optional bool fill_with_bots = 11;

    pub fn fill_with_bots(&self) -> bool {
        self.fill_with_bots.unwrap_or(false)
    }

    pub fn clear_fill_with_bots(&mut self) {
        self.fill_with_bots = ::std::option::Option::None;
    }

    pub fn has_fill_with_bots(&self) -> bool {
        self.fill_with_bots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fill_with_bots(&mut self, v: bool) {
        self.fill_with_bots = ::std::option::Option::Some(v);
    }

    // optional bool intro_mode = 12;

    pub fn intro_mode(&self) -> bool {
        self.intro_mode.unwrap_or(false)
    }

    pub fn clear_intro_mode(&mut self) {
        self.intro_mode = ::std::option::Option::None;
    }

    pub fn has_intro_mode(&self) -> bool {
        self.intro_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_intro_mode(&mut self, v: bool) {
        self.intro_mode = ::std::option::Option::Some(v);
    }

    // optional bool allow_spectating = 13;

    pub fn allow_spectating(&self) -> bool {
        self.allow_spectating.unwrap_or(false)
    }

    pub fn clear_allow_spectating(&mut self) {
        self.allow_spectating = ::std::option::Option::None;
    }

    pub fn has_allow_spectating(&self) -> bool {
        self.allow_spectating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_spectating(&mut self, v: bool) {
        self.allow_spectating = ::std::option::Option::Some(v);
    }

    // optional string pass_key = 15;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 leagueid = 16;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_radiant = 17;

    pub fn penalty_level_radiant(&self) -> u32 {
        self.penalty_level_radiant.unwrap_or(0)
    }

    pub fn clear_penalty_level_radiant(&mut self) {
        self.penalty_level_radiant = ::std::option::Option::None;
    }

    pub fn has_penalty_level_radiant(&self) -> bool {
        self.penalty_level_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_radiant(&mut self, v: u32) {
        self.penalty_level_radiant = ::std::option::Option::Some(v);
    }

    // optional uint32 penalty_level_dire = 18;

    pub fn penalty_level_dire(&self) -> u32 {
        self.penalty_level_dire.unwrap_or(0)
    }

    pub fn clear_penalty_level_dire(&mut self) {
        self.penalty_level_dire = ::std::option::Option::None;
    }

    pub fn has_penalty_level_dire(&self) -> bool {
        self.penalty_level_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalty_level_dire(&mut self, v: u32) {
        self.penalty_level_dire = ::std::option::Option::Some(v);
    }

    // optional uint32 load_game_id = 19;

    pub fn load_game_id(&self) -> u32 {
        self.load_game_id.unwrap_or(0)
    }

    pub fn clear_load_game_id(&mut self) {
        self.load_game_id = ::std::option::Option::None;
    }

    pub fn has_load_game_id(&self) -> bool {
        self.load_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_load_game_id(&mut self, v: u32) {
        self.load_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 20;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_series_wins = 21;

    pub fn radiant_series_wins(&self) -> u32 {
        self.radiant_series_wins.unwrap_or(0)
    }

    pub fn clear_radiant_series_wins(&mut self) {
        self.radiant_series_wins = ::std::option::Option::None;
    }

    pub fn has_radiant_series_wins(&self) -> bool {
        self.radiant_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_series_wins(&mut self, v: u32) {
        self.radiant_series_wins = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_series_wins = 22;

    pub fn dire_series_wins(&self) -> u32 {
        self.dire_series_wins.unwrap_or(0)
    }

    pub fn clear_dire_series_wins(&mut self) {
        self.dire_series_wins = ::std::option::Option::None;
    }

    pub fn has_dire_series_wins(&self) -> bool {
        self.dire_series_wins.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_series_wins(&mut self, v: u32) {
        self.dire_series_wins = ::std::option::Option::Some(v);
    }

    // optional bool allchat = 23;

    pub fn allchat(&self) -> bool {
        self.allchat.unwrap_or(false)
    }

    pub fn clear_allchat(&mut self) {
        self.allchat = ::std::option::Option::None;
    }

    pub fn has_allchat(&self) -> bool {
        self.allchat.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allchat(&mut self, v: bool) {
        self.allchat = ::std::option::Option::Some(v);
    }

    // optional .LobbyDotaTVDelay dota_tv_delay = 24;

    pub fn dota_tv_delay(&self) -> super::dota_gcmessages_common_lobby::LobbyDotaTVDelay {
        match self.dota_tv_delay {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::LobbyDotaTVDelay::LobbyDotaTV_120),
            None => super::dota_gcmessages_common_lobby::LobbyDotaTVDelay::LobbyDotaTV_120,
        }
    }

    pub fn clear_dota_tv_delay(&mut self) {
        self.dota_tv_delay = ::std::option::Option::None;
    }

    pub fn has_dota_tv_delay(&self) -> bool {
        self.dota_tv_delay.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dota_tv_delay(&mut self, v: super::dota_gcmessages_common_lobby::LobbyDotaTVDelay) {
        self.dota_tv_delay = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool lan = 25;

    pub fn lan(&self) -> bool {
        self.lan.unwrap_or(false)
    }

    pub fn clear_lan(&mut self) {
        self.lan = ::std::option::Option::None;
    }

    pub fn has_lan(&self) -> bool {
        self.lan.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan(&mut self, v: bool) {
        self.lan = ::std::option::Option::Some(v);
    }

    // optional string custom_game_mode = 26;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 27;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 custom_difficulty = 28;

    pub fn custom_difficulty(&self) -> u32 {
        self.custom_difficulty.unwrap_or(0)
    }

    pub fn clear_custom_difficulty(&mut self) {
        self.custom_difficulty = ::std::option::Option::None;
    }

    pub fn has_custom_difficulty(&self) -> bool {
        self.custom_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_difficulty(&mut self, v: u32) {
        self.custom_difficulty = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 29;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_min_players = 30;

    pub fn custom_min_players(&self) -> u32 {
        self.custom_min_players.unwrap_or(0)
    }

    pub fn clear_custom_min_players(&mut self) {
        self.custom_min_players = ::std::option::Option::None;
    }

    pub fn has_custom_min_players(&self) -> bool {
        self.custom_min_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_min_players(&mut self, v: u32) {
        self.custom_min_players = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_max_players = 31;

    pub fn custom_max_players(&self) -> u32 {
        self.custom_max_players.unwrap_or(0)
    }

    pub fn clear_custom_max_players(&mut self) {
        self.custom_max_players = ::std::option::Option::None;
    }

    pub fn has_custom_max_players(&self) -> bool {
        self.custom_max_players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_max_players(&mut self, v: u32) {
        self.custom_max_players = ::std::option::Option::Some(v);
    }

    // optional .DOTALobbyVisibility visibility = 33;

    pub fn visibility(&self) -> super::dota_shared_enums::DOTALobbyVisibility {
        match self.visibility {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public),
            None => super::dota_shared_enums::DOTALobbyVisibility::DOTALobbyVisibility_Public,
        }
    }

    pub fn clear_visibility(&mut self) {
        self.visibility = ::std::option::Option::None;
    }

    pub fn has_visibility(&self) -> bool {
        self.visibility.is_some()
    }

    // Param is passed by value, moved
    pub fn set_visibility(&mut self, v: super::dota_shared_enums::DOTALobbyVisibility) {
        self.visibility = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed64 custom_game_crc = 34;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 37;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 previous_match_override = 38;

    pub fn previous_match_override(&self) -> u64 {
        self.previous_match_override.unwrap_or(0)
    }

    pub fn clear_previous_match_override(&mut self) {
        self.previous_match_override = ::std::option::Option::None;
    }

    pub fn has_previous_match_override(&self) -> bool {
        self.previous_match_override.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous_match_override(&mut self, v: u64) {
        self.previous_match_override = ::std::option::Option::Some(v);
    }

    // optional .LobbyDotaPauseSetting pause_setting = 42;

    pub fn pause_setting(&self) -> super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting {
        match self.pause_setting {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited),
            None => super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting::LobbyDotaPauseSetting_Unlimited,
        }
    }

    pub fn clear_pause_setting(&mut self) {
        self.pause_setting = ::std::option::Option::None;
    }

    pub fn has_pause_setting(&self) -> bool {
        self.pause_setting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pause_setting(&mut self, v: super::dota_gcmessages_common_lobby::LobbyDotaPauseSetting) {
        self.pause_setting = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .DOTABotDifficulty bot_difficulty_dire = 43;

    pub fn bot_difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty_dire(&mut self) {
        self.bot_difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty_dire(&self) -> bool {
        self.bot_difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty_dire = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 bot_radiant = 44;

    pub fn bot_radiant(&self) -> u64 {
        self.bot_radiant.unwrap_or(0)
    }

    pub fn clear_bot_radiant(&mut self) {
        self.bot_radiant = ::std::option::Option::None;
    }

    pub fn has_bot_radiant(&self) -> bool {
        self.bot_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_radiant(&mut self, v: u64) {
        self.bot_radiant = ::std::option::Option::Some(v);
    }

    // optional uint64 bot_dire = 45;

    pub fn bot_dire(&self) -> u64 {
        self.bot_dire.unwrap_or(0)
    }

    pub fn clear_bot_dire(&mut self) {
        self.bot_dire = ::std::option::Option::None;
    }

    pub fn has_bot_dire(&self) -> bool {
        self.bot_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_dire(&mut self, v: u64) {
        self.bot_dire = ::std::option::Option::Some(v);
    }

    // optional .DOTASelectionPriorityRules selection_priority_rules = 46;

    pub fn selection_priority_rules(&self) -> super::dota_shared_enums::DOTASelectionPriorityRules {
        match self.selection_priority_rules {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual),
            None => super::dota_shared_enums::DOTASelectionPriorityRules::k_DOTASelectionPriorityRules_Manual,
        }
    }

    pub fn clear_selection_priority_rules(&mut self) {
        self.selection_priority_rules = ::std::option::Option::None;
    }

    pub fn has_selection_priority_rules(&self) -> bool {
        self.selection_priority_rules.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_priority_rules(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityRules) {
        self.selection_priority_rules = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool custom_game_penalties = 47;

    pub fn custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.unwrap_or(false)
    }

    pub fn clear_custom_game_penalties(&mut self) {
        self.custom_game_penalties = ::std::option::Option::None;
    }

    pub fn has_custom_game_penalties(&self) -> bool {
        self.custom_game_penalties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_penalties(&mut self, v: bool) {
        self.custom_game_penalties = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 48;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_node_id = 49;

    pub fn league_node_id(&self) -> u32 {
        self.league_node_id.unwrap_or(0)
    }

    pub fn clear_league_node_id(&mut self) {
        self.league_node_id = ::std::option::Option::None;
    }

    pub fn has_league_node_id(&self) -> bool {
        self.league_node_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_node_id(&mut self, v: u32) {
        self.league_node_id = ::std::option::Option::Some(v);
    }

    // optional bool do_player_draft = 53;

    pub fn do_player_draft(&self) -> bool {
        self.do_player_draft.unwrap_or(false)
    }

    pub fn clear_do_player_draft(&mut self) {
        self.do_player_draft = ::std::option::Option::None;
    }

    pub fn has_do_player_draft(&self) -> bool {
        self.do_player_draft.is_some()
    }

    // Param is passed by value, moved
    pub fn set_do_player_draft(&mut self, v: bool) {
        self.do_player_draft = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbySetDetails {
    const NAME: &'static str = "CMsgPracticeLobbySetDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.game_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.team_details.push(is.read_message()?);
                },
                32 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.cm_pick = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.bot_difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                80 => {
                    self.allow_cheats = ::std::option::Option::Some(is.read_bool()?);
                },
                88 => {
                    self.fill_with_bots = ::std::option::Option::Some(is.read_bool()?);
                },
                96 => {
                    self.intro_mode = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.allow_spectating = ::std::option::Option::Some(is.read_bool()?);
                },
                122 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.penalty_level_radiant = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.penalty_level_dire = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.load_game_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.radiant_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.dire_series_wins = ::std::option::Option::Some(is.read_uint32()?);
                },
                184 => {
                    self.allchat = ::std::option::Option::Some(is.read_bool()?);
                },
                192 => {
                    self.dota_tv_delay = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                200 => {
                    self.lan = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                218 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                224 => {
                    self.custom_difficulty = ::std::option::Option::Some(is.read_uint32()?);
                },
                232 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                240 => {
                    self.custom_min_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                248 => {
                    self.custom_max_players = ::std::option::Option::Some(is.read_uint32()?);
                },
                264 => {
                    self.visibility = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                273 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                301 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                304 => {
                    self.previous_match_override = ::std::option::Option::Some(is.read_uint64()?);
                },
                336 => {
                    self.pause_setting = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                344 => {
                    self.bot_difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                352 => {
                    self.bot_radiant = ::std::option::Option::Some(is.read_uint64()?);
                },
                360 => {
                    self.bot_dire = ::std::option::Option::Some(is.read_uint64()?);
                },
                368 => {
                    self.selection_priority_rules = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                376 => {
                    self.custom_game_penalties = ::std::option::Option::Some(is.read_bool()?);
                },
                386 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                392 => {
                    self.league_node_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                402 => {
                    is.read_repeated_packed_int32_into(&mut self.requested_hero_ids)?;
                },
                400 => {
                    self.requested_hero_ids.push(is.read_int32()?);
                },
                410 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.scenario_save)?;
                },
                418 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ability_draft_specific_details)?;
                },
                424 => {
                    self.do_player_draft = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.game_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        for value in &self.team_details {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.cm_pick {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.bot_difficulty_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.allow_cheats {
            my_size += 1 + 1;
        }
        if let Some(v) = self.fill_with_bots {
            my_size += 1 + 1;
        }
        if let Some(v) = self.intro_mode {
            my_size += 1 + 1;
        }
        if let Some(v) = self.allow_spectating {
            my_size += 1 + 1;
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.penalty_level_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.penalty_level_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.load_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.radiant_series_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.dire_series_wins {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.allchat {
            my_size += 2 + 1;
        }
        if let Some(v) = self.dota_tv_delay {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(24, v.value());
        }
        if let Some(v) = self.lan {
            my_size += 2 + 1;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(26, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(27, &v);
        }
        if let Some(v) = self.custom_difficulty {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(28, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(29, v);
        }
        if let Some(v) = self.custom_min_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.custom_max_players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(31, v);
        }
        if let Some(v) = self.visibility {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(33, v.value());
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 2 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 2 + 4;
        }
        if let Some(v) = self.previous_match_override {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(38, v);
        }
        if let Some(v) = self.pause_setting {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(42, v.value());
        }
        if let Some(v) = self.bot_difficulty_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(43, v.value());
        }
        if let Some(v) = self.bot_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(44, v);
        }
        if let Some(v) = self.bot_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(45, v);
        }
        if let Some(v) = self.selection_priority_rules {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(46, v.value());
        }
        if let Some(v) = self.custom_game_penalties {
            my_size += 2 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(48, &v);
        }
        if let Some(v) = self.league_node_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(49, v);
        }
        for value in &self.requested_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(50, *value);
        };
        if let Some(v) = self.scenario_save.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.ability_draft_specific_details.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.do_player_draft {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.game_name.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.team_details {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.server_region {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.cm_pick {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_difficulty_radiant {
            os.write_enum(9, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.allow_cheats {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.fill_with_bots {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.intro_mode {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.allow_spectating {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.penalty_level_radiant {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.penalty_level_dire {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.load_game_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.radiant_series_wins {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.dire_series_wins {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.allchat {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.dota_tv_delay {
            os.write_enum(24, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lan {
            os.write_bool(25, v)?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(26, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(27, v)?;
        }
        if let Some(v) = self.custom_difficulty {
            os.write_uint32(28, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(29, v)?;
        }
        if let Some(v) = self.custom_min_players {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.custom_max_players {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.visibility {
            os.write_enum(33, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(34, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(37, v)?;
        }
        if let Some(v) = self.previous_match_override {
            os.write_uint64(38, v)?;
        }
        if let Some(v) = self.pause_setting {
            os.write_enum(42, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_difficulty_dire {
            os.write_enum(43, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.bot_radiant {
            os.write_uint64(44, v)?;
        }
        if let Some(v) = self.bot_dire {
            os.write_uint64(45, v)?;
        }
        if let Some(v) = self.selection_priority_rules {
            os.write_enum(46, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_game_penalties {
            os.write_bool(47, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(48, v)?;
        }
        if let Some(v) = self.league_node_id {
            os.write_uint32(49, v)?;
        }
        for v in &self.requested_hero_ids {
            os.write_int32(50, *v)?;
        };
        if let Some(v) = self.scenario_save.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(51, v, os)?;
        }
        if let Some(v) = self.ability_draft_specific_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(52, v, os)?;
        }
        if let Some(v) = self.do_player_draft {
            os.write_bool(53, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetDetails {
        CMsgPracticeLobbySetDetails::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.game_name = ::std::option::Option::None;
        self.team_details.clear();
        self.server_region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.cm_pick = ::std::option::Option::None;
        self.bot_difficulty_radiant = ::std::option::Option::None;
        self.allow_cheats = ::std::option::Option::None;
        self.fill_with_bots = ::std::option::Option::None;
        self.intro_mode = ::std::option::Option::None;
        self.allow_spectating = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.penalty_level_radiant = ::std::option::Option::None;
        self.penalty_level_dire = ::std::option::Option::None;
        self.load_game_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.radiant_series_wins = ::std::option::Option::None;
        self.dire_series_wins = ::std::option::Option::None;
        self.allchat = ::std::option::Option::None;
        self.dota_tv_delay = ::std::option::Option::None;
        self.lan = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.custom_difficulty = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.custom_min_players = ::std::option::Option::None;
        self.custom_max_players = ::std::option::Option::None;
        self.visibility = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.previous_match_override = ::std::option::Option::None;
        self.pause_setting = ::std::option::Option::None;
        self.bot_difficulty_dire = ::std::option::Option::None;
        self.bot_radiant = ::std::option::Option::None;
        self.bot_dire = ::std::option::Option::None;
        self.selection_priority_rules = ::std::option::Option::None;
        self.custom_game_penalties = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.league_node_id = ::std::option::Option::None;
        self.requested_hero_ids.clear();
        self.scenario_save.clear();
        self.ability_draft_specific_details.clear();
        self.do_player_draft = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetDetails {
        static instance: CMsgPracticeLobbySetDetails = CMsgPracticeLobbySetDetails {
            lobby_id: ::std::option::Option::None,
            game_name: ::std::option::Option::None,
            team_details: ::std::vec::Vec::new(),
            server_region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            cm_pick: ::std::option::Option::None,
            bot_difficulty_radiant: ::std::option::Option::None,
            allow_cheats: ::std::option::Option::None,
            fill_with_bots: ::std::option::Option::None,
            intro_mode: ::std::option::Option::None,
            allow_spectating: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            penalty_level_radiant: ::std::option::Option::None,
            penalty_level_dire: ::std::option::Option::None,
            load_game_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            radiant_series_wins: ::std::option::Option::None,
            dire_series_wins: ::std::option::Option::None,
            allchat: ::std::option::Option::None,
            dota_tv_delay: ::std::option::Option::None,
            lan: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            custom_difficulty: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            custom_min_players: ::std::option::Option::None,
            custom_max_players: ::std::option::Option::None,
            visibility: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            previous_match_override: ::std::option::Option::None,
            pause_setting: ::std::option::Option::None,
            bot_difficulty_dire: ::std::option::Option::None,
            bot_radiant: ::std::option::Option::None,
            bot_dire: ::std::option::Option::None,
            selection_priority_rules: ::std::option::Option::None,
            custom_game_penalties: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            league_node_id: ::std::option::Option::None,
            requested_hero_ids: ::std::vec::Vec::new(),
            scenario_save: ::steam_vent_proto_common::protobuf::MessageField::none(),
            ability_draft_specific_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            do_player_draft: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPracticeLobbySetDetails`
pub mod cmsg_practice_lobby_set_details {
    // @@protoc_insertion_point(message:CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct AbilityDraftSpecificDetails {
        // message fields
        // @@protoc_insertion_point(field:CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails.shuffle_draft_order)
        pub shuffle_draft_order: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPracticeLobbySetDetails.AbilityDraftSpecificDetails.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a AbilityDraftSpecificDetails {
        fn default() -> &'a AbilityDraftSpecificDetails {
            <AbilityDraftSpecificDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl AbilityDraftSpecificDetails {
        pub fn new() -> AbilityDraftSpecificDetails {
            ::std::default::Default::default()
        }

        // optional bool shuffle_draft_order = 1;

        pub fn shuffle_draft_order(&self) -> bool {
            self.shuffle_draft_order.unwrap_or(false)
        }

        pub fn clear_shuffle_draft_order(&mut self) {
            self.shuffle_draft_order = ::std::option::Option::None;
        }

        pub fn has_shuffle_draft_order(&self) -> bool {
            self.shuffle_draft_order.is_some()
        }

        // Param is passed by value, moved
        pub fn set_shuffle_draft_order(&mut self, v: bool) {
            self.shuffle_draft_order = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for AbilityDraftSpecificDetails {
        const NAME: &'static str = "AbilityDraftSpecificDetails";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.shuffle_draft_order = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.shuffle_draft_order {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.shuffle_draft_order {
                os.write_bool(1, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> AbilityDraftSpecificDetails {
            AbilityDraftSpecificDetails::new()
        }

        fn clear(&mut self) {
            self.shuffle_draft_order = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static AbilityDraftSpecificDetails {
            static instance: AbilityDraftSpecificDetails = AbilityDraftSpecificDetails {
                shuffle_draft_order: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyCreate {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.search_key)
    pub search_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.lobby_details)
    pub lobby_details: ::steam_vent_proto_common::protobuf::MessageField<CMsgPracticeLobbySetDetails>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.save_game)
    pub save_game: ::steam_vent_proto_common::protobuf::MessageField<cmsg_practice_lobby_create::SaveGame>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyCreate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyCreate {
    fn default() -> &'a CMsgPracticeLobbyCreate {
        <CMsgPracticeLobbyCreate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyCreate {
    pub fn new() -> CMsgPracticeLobbyCreate {
        ::std::default::Default::default()
    }

    // optional string search_key = 1;

    pub fn search_key(&self) -> &str {
        match self.search_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_key(&mut self) {
        self.search_key = ::std::option::Option::None;
    }

    pub fn has_search_key(&self) -> bool {
        self.search_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_key(&mut self, v: ::std::string::String) {
        self.search_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_key(&mut self) -> &mut ::std::string::String {
        if self.search_key.is_none() {
            self.search_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_key(&mut self) -> ::std::string::String {
        self.search_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pass_key = 5;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 6;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyCreate {
    const NAME: &'static str = "CMsgPracticeLobbyCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_key = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.lobby_details)?;
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.save_game)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.lobby_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.save_game.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.search_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.lobby_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.save_game.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyCreate {
        CMsgPracticeLobbyCreate::new()
    }

    fn clear(&mut self) {
        self.search_key = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.lobby_details.clear();
        self.save_game.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyCreate {
        static instance: CMsgPracticeLobbyCreate = CMsgPracticeLobbyCreate {
            search_key: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            lobby_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            save_game: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPracticeLobbyCreate`
pub mod cmsg_practice_lobby_create {
    // @@protoc_insertion_point(message:CMsgPracticeLobbyCreate.SaveGame)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SaveGame {
        // message fields
        // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.SaveGame.data)
        pub data: ::std::option::Option<::std::vec::Vec<u8>>,
        // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.SaveGame.version)
        pub version: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.SaveGame.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgPracticeLobbyCreate.SaveGame.signature)
        pub signature: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPracticeLobbyCreate.SaveGame.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SaveGame {
        fn default() -> &'a SaveGame {
            <SaveGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SaveGame {
        pub fn new() -> SaveGame {
            ::std::default::Default::default()
        }

        // optional bytes data = 1;

        pub fn data(&self) -> &[u8] {
            match self.data.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_data(&mut self) {
            self.data = ::std::option::Option::None;
        }

        pub fn has_data(&self) -> bool {
            self.data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
            self.data = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.data.is_none() {
                self.data = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.data.as_mut().unwrap()
        }

        // Take field
        pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
            self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }

        // optional int32 version = 2;

        pub fn version(&self) -> i32 {
            self.version.unwrap_or(0)
        }

        pub fn clear_version(&mut self) {
            self.version = ::std::option::Option::None;
        }

        pub fn has_version(&self) -> bool {
            self.version.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version(&mut self, v: i32) {
            self.version = ::std::option::Option::Some(v);
        }

        // optional fixed64 steam_id = 3;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional fixed64 signature = 4;

        pub fn signature(&self) -> u64 {
            self.signature.unwrap_or(0)
        }

        pub fn clear_signature(&mut self) {
            self.signature = ::std::option::Option::None;
        }

        pub fn has_signature(&self) -> bool {
            self.signature.is_some()
        }

        // Param is passed by value, moved
        pub fn set_signature(&mut self, v: u64) {
            self.signature = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SaveGame {
        const NAME: &'static str = "SaveGame";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.data = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    16 => {
                        self.version = ::std::option::Option::Some(is.read_int32()?);
                    },
                    25 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    33 => {
                        self.signature = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.data.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
            }
            if let Some(v) = self.version {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.signature {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.data.as_ref() {
                os.write_bytes(1, v)?;
            }
            if let Some(v) = self.version {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.steam_id {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.signature {
                os.write_fixed64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SaveGame {
            SaveGame::new()
        }

        fn clear(&mut self) {
            self.data = ::std::option::Option::None;
            self.version = ::std::option::Option::None;
            self.steam_id = ::std::option::Option::None;
            self.signature = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SaveGame {
            static instance: SaveGame = SaveGame {
                data: ::std::option::Option::None,
                version: ::std::option::Option::None,
                steam_id: ::std::option::Option::None,
                signature: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbySetTeamSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetTeamSlot {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetTeamSlot.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetTeamSlot.slot)
    pub slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetTeamSlot.bot_difficulty)
    pub bot_difficulty: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbySetTeamSlot.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetTeamSlot {
    fn default() -> &'a CMsgPracticeLobbySetTeamSlot {
        <CMsgPracticeLobbySetTeamSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetTeamSlot {
    pub fn new() -> CMsgPracticeLobbySetTeamSlot {
        ::std::default::Default::default()
    }

    // optional .DOTA_GC_TEAM team = 1;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slot = 2;

    pub fn slot(&self) -> u32 {
        self.slot.unwrap_or(0)
    }

    pub fn clear_slot(&mut self) {
        self.slot = ::std::option::Option::None;
    }

    pub fn has_slot(&self) -> bool {
        self.slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot(&mut self, v: u32) {
        self.slot = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty bot_difficulty = 3;

    pub fn bot_difficulty(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.bot_difficulty {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_bot_difficulty(&mut self) {
        self.bot_difficulty = ::std::option::Option::None;
    }

    pub fn has_bot_difficulty(&self) -> bool {
        self.bot_difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bot_difficulty(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.bot_difficulty = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbySetTeamSlot {
    const NAME: &'static str = "CMsgPracticeLobbySetTeamSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.bot_difficulty = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.bot_difficulty {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.bot_difficulty {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetTeamSlot {
        CMsgPracticeLobbySetTeamSlot::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.slot = ::std::option::Option::None;
        self.bot_difficulty = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetTeamSlot {
        static instance: CMsgPracticeLobbySetTeamSlot = CMsgPracticeLobbySetTeamSlot {
            team: ::std::option::Option::None,
            slot: ::std::option::Option::None,
            bot_difficulty: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbySetCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbySetCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbySetCoach.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbySetCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbySetCoach {
    fn default() -> &'a CMsgPracticeLobbySetCoach {
        <CMsgPracticeLobbySetCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbySetCoach {
    pub fn new() -> CMsgPracticeLobbySetCoach {
        ::std::default::Default::default()
    }

    // optional .DOTA_GC_TEAM team = 1;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbySetCoach {
    const NAME: &'static str = "CMsgPracticeLobbySetCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbySetCoach {
        CMsgPracticeLobbySetCoach::new()
    }

    fn clear(&mut self) {
        self.team = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbySetCoach {
        static instance: CMsgPracticeLobbySetCoach = CMsgPracticeLobbySetCoach {
            team: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyJoinBroadcastChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoinBroadcastChannel {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoinBroadcastChannel.channel)
    pub channel: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoinBroadcastChannel.preferred_description)
    pub preferred_description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoinBroadcastChannel.preferred_country_code)
    pub preferred_country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoinBroadcastChannel.preferred_language_code)
    pub preferred_language_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyJoinBroadcastChannel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoinBroadcastChannel {
    fn default() -> &'a CMsgPracticeLobbyJoinBroadcastChannel {
        <CMsgPracticeLobbyJoinBroadcastChannel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoinBroadcastChannel {
    pub fn new() -> CMsgPracticeLobbyJoinBroadcastChannel {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }

    // optional string preferred_description = 2;

    pub fn preferred_description(&self) -> &str {
        match self.preferred_description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_description(&mut self) {
        self.preferred_description = ::std::option::Option::None;
    }

    pub fn has_preferred_description(&self) -> bool {
        self.preferred_description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_description(&mut self, v: ::std::string::String) {
        self.preferred_description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_description(&mut self) -> &mut ::std::string::String {
        if self.preferred_description.is_none() {
            self.preferred_description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_description.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_description(&mut self) -> ::std::string::String {
        self.preferred_description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preferred_country_code = 3;

    pub fn preferred_country_code(&self) -> &str {
        match self.preferred_country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_country_code(&mut self) {
        self.preferred_country_code = ::std::option::Option::None;
    }

    pub fn has_preferred_country_code(&self) -> bool {
        self.preferred_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_country_code(&mut self, v: ::std::string::String) {
        self.preferred_country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_country_code(&mut self) -> &mut ::std::string::String {
        if self.preferred_country_code.is_none() {
            self.preferred_country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_country_code(&mut self) -> ::std::string::String {
        self.preferred_country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string preferred_language_code = 4;

    pub fn preferred_language_code(&self) -> &str {
        match self.preferred_language_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_preferred_language_code(&mut self) {
        self.preferred_language_code = ::std::option::Option::None;
    }

    pub fn has_preferred_language_code(&self) -> bool {
        self.preferred_language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferred_language_code(&mut self, v: ::std::string::String) {
        self.preferred_language_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferred_language_code(&mut self) -> &mut ::std::string::String {
        if self.preferred_language_code.is_none() {
            self.preferred_language_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.preferred_language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferred_language_code(&mut self) -> ::std::string::String {
        self.preferred_language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyJoinBroadcastChannel {
    const NAME: &'static str = "CMsgPracticeLobbyJoinBroadcastChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.preferred_description = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.preferred_country_code = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.preferred_language_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.preferred_description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.preferred_country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.preferred_language_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.preferred_description.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.preferred_country_code.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.preferred_language_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoinBroadcastChannel {
        CMsgPracticeLobbyJoinBroadcastChannel::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.preferred_description = ::std::option::Option::None;
        self.preferred_country_code = ::std::option::Option::None;
        self.preferred_language_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoinBroadcastChannel {
        static instance: CMsgPracticeLobbyJoinBroadcastChannel = CMsgPracticeLobbyJoinBroadcastChannel {
            channel: ::std::option::Option::None,
            preferred_description: ::std::option::Option::None,
            preferred_country_code: ::std::option::Option::None,
            preferred_language_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyCloseBroadcastChannel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyCloseBroadcastChannel {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyCloseBroadcastChannel.channel)
    pub channel: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyCloseBroadcastChannel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyCloseBroadcastChannel {
    fn default() -> &'a CMsgPracticeLobbyCloseBroadcastChannel {
        <CMsgPracticeLobbyCloseBroadcastChannel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyCloseBroadcastChannel {
    pub fn new() -> CMsgPracticeLobbyCloseBroadcastChannel {
        ::std::default::Default::default()
    }

    // optional uint32 channel = 1;

    pub fn channel(&self) -> u32 {
        self.channel.unwrap_or(0)
    }

    pub fn clear_channel(&mut self) {
        self.channel = ::std::option::Option::None;
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: u32) {
        self.channel = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyCloseBroadcastChannel {
    const NAME: &'static str = "CMsgPracticeLobbyCloseBroadcastChannel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyCloseBroadcastChannel {
        CMsgPracticeLobbyCloseBroadcastChannel::new()
    }

    fn clear(&mut self) {
        self.channel = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyCloseBroadcastChannel {
        static instance: CMsgPracticeLobbyCloseBroadcastChannel = CMsgPracticeLobbyCloseBroadcastChannel {
            channel: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    fn default() -> &'a CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        <CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    pub fn new() -> CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    const NAME: &'static str = "CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
        static instance: CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus = CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyKick)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyKick {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyKick.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyKick.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyKick {
    fn default() -> &'a CMsgPracticeLobbyKick {
        <CMsgPracticeLobbyKick as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyKick {
    pub fn new() -> CMsgPracticeLobbyKick {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyKick {
    const NAME: &'static str = "CMsgPracticeLobbyKick";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyKick {
        CMsgPracticeLobbyKick::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyKick {
        static instance: CMsgPracticeLobbyKick = CMsgPracticeLobbyKick {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyKickFromTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyKickFromTeam {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyKickFromTeam.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyKickFromTeam.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyKickFromTeam {
    fn default() -> &'a CMsgPracticeLobbyKickFromTeam {
        <CMsgPracticeLobbyKickFromTeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyKickFromTeam {
    pub fn new() -> CMsgPracticeLobbyKickFromTeam {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyKickFromTeam {
    const NAME: &'static str = "CMsgPracticeLobbyKickFromTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyKickFromTeam {
        CMsgPracticeLobbyKickFromTeam::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyKickFromTeam {
        static instance: CMsgPracticeLobbyKickFromTeam = CMsgPracticeLobbyKickFromTeam {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyLeave)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyLeave {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyLeave.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyLeave {
    fn default() -> &'a CMsgPracticeLobbyLeave {
        <CMsgPracticeLobbyLeave as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyLeave {
    pub fn new() -> CMsgPracticeLobbyLeave {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyLeave {
    const NAME: &'static str = "CMsgPracticeLobbyLeave";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyLeave {
        CMsgPracticeLobbyLeave::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyLeave {
        static instance: CMsgPracticeLobbyLeave = CMsgPracticeLobbyLeave {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyLaunch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyLaunch {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyLaunch.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyLaunch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyLaunch {
    fn default() -> &'a CMsgPracticeLobbyLaunch {
        <CMsgPracticeLobbyLaunch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyLaunch {
    pub fn new() -> CMsgPracticeLobbyLaunch {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 5;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyLaunch {
    const NAME: &'static str = "CMsgPracticeLobbyLaunch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyLaunch {
        CMsgPracticeLobbyLaunch::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyLaunch {
        static instance: CMsgPracticeLobbyLaunch = CMsgPracticeLobbyLaunch {
            client_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyTeamToPracticeLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyTeamToPracticeLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyTeamToPracticeLobby.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyTeamToPracticeLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyTeamToPracticeLobby {
    fn default() -> &'a CMsgApplyTeamToPracticeLobby {
        <CMsgApplyTeamToPracticeLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyTeamToPracticeLobby {
    pub fn new() -> CMsgApplyTeamToPracticeLobby {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyTeamToPracticeLobby {
    const NAME: &'static str = "CMsgApplyTeamToPracticeLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyTeamToPracticeLobby {
        CMsgApplyTeamToPracticeLobby::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyTeamToPracticeLobby {
        static instance: CMsgApplyTeamToPracticeLobby = CMsgApplyTeamToPracticeLobby {
            team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyList.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyList.region)
    pub region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyList.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyList {
    fn default() -> &'a CMsgPracticeLobbyList {
        <CMsgPracticeLobbyList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyList {
    pub fn new() -> CMsgPracticeLobbyList {
        ::std::default::Default::default()
    }

    // optional string pass_key = 2;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 region = 3;

    pub fn region(&self) -> u32 {
        self.region.unwrap_or(0)
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: u32) {
        self.region = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 4;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyList {
    const NAME: &'static str = "CMsgPracticeLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.region = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.region {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyList {
        CMsgPracticeLobbyList::new()
    }

    fn clear(&mut self) {
        self.pass_key = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyList {
        static instance: CMsgPracticeLobbyList = CMsgPracticeLobbyList {
            pass_key: ::std::option::Option::None,
            region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyListResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyListResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.members)
    pub members: ::std::vec::Vec<cmsg_practice_lobby_list_response_entry::CLobbyMember>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.requires_pass_key)
    pub requires_pass_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.leader_account_id)
    pub leader_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.custom_game_mode)
    pub custom_game_mode: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.friend_present)
    pub friend_present: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.players)
    pub players: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.max_player_count)
    pub max_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.min_player_count)
    pub min_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.penalties_enabled)
    pub penalties_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyListResponseEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyListResponseEntry {
    fn default() -> &'a CMsgPracticeLobbyListResponseEntry {
        <CMsgPracticeLobbyListResponseEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyListResponseEntry {
    pub fn new() -> CMsgPracticeLobbyListResponseEntry {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional bool requires_pass_key = 6;

    pub fn requires_pass_key(&self) -> bool {
        self.requires_pass_key.unwrap_or(false)
    }

    pub fn clear_requires_pass_key(&mut self) {
        self.requires_pass_key = ::std::option::Option::None;
    }

    pub fn has_requires_pass_key(&self) -> bool {
        self.requires_pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requires_pass_key(&mut self, v: bool) {
        self.requires_pass_key = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_account_id = 7;

    pub fn leader_account_id(&self) -> u32 {
        self.leader_account_id.unwrap_or(0)
    }

    pub fn clear_leader_account_id(&mut self) {
        self.leader_account_id = ::std::option::Option::None;
    }

    pub fn has_leader_account_id(&self) -> bool {
        self.leader_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_account_id(&mut self, v: u32) {
        self.leader_account_id = ::std::option::Option::Some(v);
    }

    // optional string name = 10;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_game_mode = 11;

    pub fn custom_game_mode(&self) -> &str {
        match self.custom_game_mode.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_game_mode(&mut self) {
        self.custom_game_mode = ::std::option::Option::None;
    }

    pub fn has_custom_game_mode(&self) -> bool {
        self.custom_game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_mode(&mut self, v: ::std::string::String) {
        self.custom_game_mode = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_game_mode(&mut self) -> &mut ::std::string::String {
        if self.custom_game_mode.is_none() {
            self.custom_game_mode = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_game_mode.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_game_mode(&mut self) -> ::std::string::String {
        self.custom_game_mode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .DOTA_GameMode game_mode = 12;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool friend_present = 13;

    pub fn friend_present(&self) -> bool {
        self.friend_present.unwrap_or(false)
    }

    pub fn clear_friend_present(&mut self) {
        self.friend_present = ::std::option::Option::None;
    }

    pub fn has_friend_present(&self) -> bool {
        self.friend_present.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friend_present(&mut self, v: bool) {
        self.friend_present = ::std::option::Option::Some(v);
    }

    // optional uint32 players = 14;

    pub fn players(&self) -> u32 {
        self.players.unwrap_or(0)
    }

    pub fn clear_players(&mut self) {
        self.players = ::std::option::Option::None;
    }

    pub fn has_players(&self) -> bool {
        self.players.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players(&mut self, v: u32) {
        self.players = ::std::option::Option::Some(v);
    }

    // optional string custom_map_name = 15;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_player_count = 16;

    pub fn max_player_count(&self) -> u32 {
        self.max_player_count.unwrap_or(0)
    }

    pub fn clear_max_player_count(&mut self) {
        self.max_player_count = ::std::option::Option::None;
    }

    pub fn has_max_player_count(&self) -> bool {
        self.max_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_player_count(&mut self, v: u32) {
        self.max_player_count = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 17;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 19;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 20;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 min_player_count = 21;

    pub fn min_player_count(&self) -> u32 {
        self.min_player_count.unwrap_or(0)
    }

    pub fn clear_min_player_count(&mut self) {
        self.min_player_count = ::std::option::Option::None;
    }

    pub fn has_min_player_count(&self) -> bool {
        self.min_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_player_count(&mut self, v: u32) {
        self.min_player_count = ::std::option::Option::Some(v);
    }

    // optional bool penalties_enabled = 22;

    pub fn penalties_enabled(&self) -> bool {
        self.penalties_enabled.unwrap_or(false)
    }

    pub fn clear_penalties_enabled(&mut self) {
        self.penalties_enabled = ::std::option::Option::None;
    }

    pub fn has_penalties_enabled(&self) -> bool {
        self.penalties_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalties_enabled(&mut self, v: bool) {
        self.penalties_enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyListResponseEntry {
    const NAME: &'static str = "CMsgPracticeLobbyListResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.members.push(is.read_message()?);
                },
                48 => {
                    self.requires_pass_key = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                82 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                90 => {
                    self.custom_game_mode = ::std::option::Option::Some(is.read_string()?);
                },
                96 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                104 => {
                    self.friend_present = ::std::option::Option::Some(is.read_bool()?);
                },
                112 => {
                    self.players = ::std::option::Option::Some(is.read_uint32()?);
                },
                122 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.max_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                162 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                168 => {
                    self.min_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                176 => {
                    self.penalties_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.requires_pass_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.leader_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v.value());
        }
        if let Some(v) = self.friend_present {
            my_size += 1 + 1;
        }
        if let Some(v) = self.players {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(15, &v);
        }
        if let Some(v) = self.max_player_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
        }
        if let Some(v) = self.min_player_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
        }
        if let Some(v) = self.penalties_enabled {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.requires_pass_key {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.leader_account_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.custom_game_mode.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(12, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.friend_present {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.players {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(15, v)?;
        }
        if let Some(v) = self.max_player_count {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(20, v)?;
        }
        if let Some(v) = self.min_player_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.penalties_enabled {
            os.write_bool(22, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyListResponseEntry {
        CMsgPracticeLobbyListResponseEntry::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.members.clear();
        self.requires_pass_key = ::std::option::Option::None;
        self.leader_account_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.custom_game_mode = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.friend_present = ::std::option::Option::None;
        self.players = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.max_player_count = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.min_player_count = ::std::option::Option::None;
        self.penalties_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyListResponseEntry {
        static instance: CMsgPracticeLobbyListResponseEntry = CMsgPracticeLobbyListResponseEntry {
            id: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            requires_pass_key: ::std::option::Option::None,
            leader_account_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            custom_game_mode: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            friend_present: ::std::option::Option::None,
            players: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            max_player_count: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            min_player_count: ::std::option::Option::None,
            penalties_enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPracticeLobbyListResponseEntry`
pub mod cmsg_practice_lobby_list_response_entry {
    // @@protoc_insertion_point(message:CMsgPracticeLobbyListResponseEntry.CLobbyMember)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CLobbyMember {
        // message fields
        // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.CLobbyMember.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponseEntry.CLobbyMember.player_name)
        pub player_name: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPracticeLobbyListResponseEntry.CLobbyMember.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CLobbyMember {
        fn default() -> &'a CLobbyMember {
            <CLobbyMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CLobbyMember {
        pub fn new() -> CLobbyMember {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional string player_name = 2;

        pub fn player_name(&self) -> &str {
            match self.player_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_player_name(&mut self) {
            self.player_name = ::std::option::Option::None;
        }

        pub fn has_player_name(&self) -> bool {
            self.player_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_player_name(&mut self, v: ::std::string::String) {
            self.player_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_player_name(&mut self) -> &mut ::std::string::String {
            if self.player_name.is_none() {
                self.player_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.player_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_player_name(&mut self) -> ::std::string::String {
            self.player_name.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CLobbyMember {
        const NAME: &'static str = "CLobbyMember";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.player_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.player_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.player_name.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CLobbyMember {
            CLobbyMember::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.player_name = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CLobbyMember {
            static instance: CLobbyMember = CLobbyMember {
                account_id: ::std::option::Option::None,
                player_name: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyListResponse {
    fn default() -> &'a CMsgPracticeLobbyListResponse {
        <CMsgPracticeLobbyListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyListResponse {
    pub fn new() -> CMsgPracticeLobbyListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyListResponse {
    const NAME: &'static str = "CMsgPracticeLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.lobbies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyListResponse {
        CMsgPracticeLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyListResponse {
        static instance: CMsgPracticeLobbyListResponse = CMsgPracticeLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyList.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyList.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyList {
    fn default() -> &'a CMsgLobbyList {
        <CMsgLobbyList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyList {
    pub fn new() -> CMsgLobbyList {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0u32)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 2;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyList {
    const NAME: &'static str = "CMsgLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyList {
        CMsgLobbyList::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyList {
        static instance: CMsgLobbyList = CMsgLobbyList {
            server_region: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyListResponse {
    fn default() -> &'a CMsgLobbyListResponse {
        <CMsgLobbyListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyListResponse {
    pub fn new() -> CMsgLobbyListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyListResponse {
    const NAME: &'static str = "CMsgLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.lobbies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyListResponse {
        CMsgLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyListResponse {
        static instance: CMsgLobbyListResponse = CMsgLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyJoin)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoin {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoin.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoin.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoin.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoin.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoin.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyJoin.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoin {
    fn default() -> &'a CMsgPracticeLobbyJoin {
        <CMsgPracticeLobbyJoin as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoin {
    pub fn new() -> CMsgPracticeLobbyJoin {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional string pass_key = 3;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed64 custom_game_crc = 4;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 5;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyJoin {
    const NAME: &'static str = "CMsgPracticeLobbyJoin";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                33 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                45 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoin {
        CMsgPracticeLobbyJoin::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoin {
        static instance: CMsgPracticeLobbyJoin = CMsgPracticeLobbyJoin {
            lobby_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPracticeLobbyJoinResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPracticeLobbyJoinResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPracticeLobbyJoinResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTAJoinLobbyResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPracticeLobbyJoinResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPracticeLobbyJoinResponse {
    fn default() -> &'a CMsgPracticeLobbyJoinResponse {
        <CMsgPracticeLobbyJoinResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPracticeLobbyJoinResponse {
    pub fn new() -> CMsgPracticeLobbyJoinResponse {
        ::std::default::Default::default()
    }

    // optional .DOTAJoinLobbyResult result = 1;

    pub fn result(&self) -> super::dota_shared_enums::DOTAJoinLobbyResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            None => super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_shared_enums::DOTAJoinLobbyResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPracticeLobbyJoinResponse {
    const NAME: &'static str = "CMsgPracticeLobbyJoinResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPracticeLobbyJoinResponse {
        CMsgPracticeLobbyJoinResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPracticeLobbyJoinResponse {
        static instance: CMsgPracticeLobbyJoinResponse = CMsgPracticeLobbyJoinResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFriendPracticeLobbyListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFriendPracticeLobbyListRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgFriendPracticeLobbyListRequest.friends)
    pub friends: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFriendPracticeLobbyListRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFriendPracticeLobbyListRequest {
    fn default() -> &'a CMsgFriendPracticeLobbyListRequest {
        <CMsgFriendPracticeLobbyListRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFriendPracticeLobbyListRequest {
    pub fn new() -> CMsgFriendPracticeLobbyListRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFriendPracticeLobbyListRequest {
    const NAME: &'static str = "CMsgFriendPracticeLobbyListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.friends)?;
                },
                8 => {
                    self.friends.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.friends {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.friends {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFriendPracticeLobbyListRequest {
        CMsgFriendPracticeLobbyListRequest::new()
    }

    fn clear(&mut self) {
        self.friends.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFriendPracticeLobbyListRequest {
        static instance: CMsgFriendPracticeLobbyListRequest = CMsgFriendPracticeLobbyListRequest {
            friends: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFriendPracticeLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFriendPracticeLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgFriendPracticeLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgPracticeLobbyListResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFriendPracticeLobbyListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFriendPracticeLobbyListResponse {
    fn default() -> &'a CMsgFriendPracticeLobbyListResponse {
        <CMsgFriendPracticeLobbyListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFriendPracticeLobbyListResponse {
    pub fn new() -> CMsgFriendPracticeLobbyListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFriendPracticeLobbyListResponse {
    const NAME: &'static str = "CMsgFriendPracticeLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.lobbies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFriendPracticeLobbyListResponse {
        CMsgFriendPracticeLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFriendPracticeLobbyListResponse {
        static instance: CMsgFriendPracticeLobbyListResponse = CMsgFriendPracticeLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomGameModesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomGameModesRequest.server_region)
    pub server_region: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomGameModesRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesRequest {
    fn default() -> &'a CMsgJoinableCustomGameModesRequest {
        <CMsgJoinableCustomGameModesRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesRequest {
    pub fn new() -> CMsgJoinableCustomGameModesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomGameModesRequest {
    const NAME: &'static str = "CMsgJoinableCustomGameModesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesRequest {
        CMsgJoinableCustomGameModesRequest::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesRequest {
        static instance: CMsgJoinableCustomGameModesRequest = CMsgJoinableCustomGameModesRequest {
            server_region: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomGameModesResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomGameModesResponseEntry.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomGameModesResponseEntry.lobby_count)
    pub lobby_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomGameModesResponseEntry.player_count)
    pub player_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomGameModesResponseEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesResponseEntry {
    fn default() -> &'a CMsgJoinableCustomGameModesResponseEntry {
        <CMsgJoinableCustomGameModesResponseEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesResponseEntry {
    pub fn new() -> CMsgJoinableCustomGameModesResponseEntry {
        ::std::default::Default::default()
    }

    // optional uint64 custom_game_id = 1;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 lobby_count = 2;

    pub fn lobby_count(&self) -> u32 {
        self.lobby_count.unwrap_or(0)
    }

    pub fn clear_lobby_count(&mut self) {
        self.lobby_count = ::std::option::Option::None;
    }

    pub fn has_lobby_count(&self) -> bool {
        self.lobby_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_count(&mut self, v: u32) {
        self.lobby_count = ::std::option::Option::Some(v);
    }

    // optional uint32 player_count = 3;

    pub fn player_count(&self) -> u32 {
        self.player_count.unwrap_or(0)
    }

    pub fn clear_player_count(&mut self) {
        self.player_count = ::std::option::Option::None;
    }

    pub fn has_player_count(&self) -> bool {
        self.player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_count(&mut self, v: u32) {
        self.player_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomGameModesResponseEntry {
    const NAME: &'static str = "CMsgJoinableCustomGameModesResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.lobby_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.player_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.player_count {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesResponseEntry {
        CMsgJoinableCustomGameModesResponseEntry::new()
    }

    fn clear(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
        self.lobby_count = ::std::option::Option::None;
        self.player_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesResponseEntry {
        static instance: CMsgJoinableCustomGameModesResponseEntry = CMsgJoinableCustomGameModesResponseEntry {
            custom_game_id: ::std::option::Option::None,
            lobby_count: ::std::option::Option::None,
            player_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomGameModesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomGameModesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomGameModesResponse.game_modes)
    pub game_modes: ::std::vec::Vec<CMsgJoinableCustomGameModesResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomGameModesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomGameModesResponse {
    fn default() -> &'a CMsgJoinableCustomGameModesResponse {
        <CMsgJoinableCustomGameModesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomGameModesResponse {
    pub fn new() -> CMsgJoinableCustomGameModesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomGameModesResponse {
    const NAME: &'static str = "CMsgJoinableCustomGameModesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.game_modes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.game_modes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.game_modes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomGameModesResponse {
        CMsgJoinableCustomGameModesResponse::new()
    }

    fn clear(&mut self) {
        self.game_modes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomGameModesResponse {
        static instance: CMsgJoinableCustomGameModesResponse = CMsgJoinableCustomGameModesResponse {
            game_modes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomLobbiesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesRequest.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesRequest.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomLobbiesRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesRequest {
    fn default() -> &'a CMsgJoinableCustomLobbiesRequest {
        <CMsgJoinableCustomLobbiesRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesRequest {
    pub fn new() -> CMsgJoinableCustomLobbiesRequest {
        ::std::default::Default::default()
    }

    // optional uint32 server_region = 1;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomLobbiesRequest {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesRequest {
        CMsgJoinableCustomLobbiesRequest::new()
    }

    fn clear(&mut self) {
        self.server_region = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesRequest {
        static instance: CMsgJoinableCustomLobbiesRequest = CMsgJoinableCustomLobbiesRequest {
            server_region: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomLobbiesResponseEntry)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesResponseEntry {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.lobby_name)
    pub lobby_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.member_count)
    pub member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.leader_account_id)
    pub leader_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.leader_name)
    pub leader_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.custom_map_name)
    pub custom_map_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.max_player_count)
    pub max_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.server_region)
    pub server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.has_pass_key)
    pub has_pass_key: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.lan_host_ping_location)
    pub lan_host_ping_location: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.lobby_creation_time)
    pub lobby_creation_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.min_player_count)
    pub min_player_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponseEntry.penalties_enabled)
    pub penalties_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomLobbiesResponseEntry.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesResponseEntry {
    fn default() -> &'a CMsgJoinableCustomLobbiesResponseEntry {
        <CMsgJoinableCustomLobbiesResponseEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesResponseEntry {
    pub fn new() -> CMsgJoinableCustomLobbiesResponseEntry {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional string lobby_name = 3;

    pub fn lobby_name(&self) -> &str {
        match self.lobby_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lobby_name(&mut self) {
        self.lobby_name = ::std::option::Option::None;
    }

    pub fn has_lobby_name(&self) -> bool {
        self.lobby_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_name(&mut self, v: ::std::string::String) {
        self.lobby_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_name(&mut self) -> &mut ::std::string::String {
        if self.lobby_name.is_none() {
            self.lobby_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lobby_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_name(&mut self) -> ::std::string::String {
        self.lobby_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 member_count = 4;

    pub fn member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 leader_account_id = 5;

    pub fn leader_account_id(&self) -> u32 {
        self.leader_account_id.unwrap_or(0)
    }

    pub fn clear_leader_account_id(&mut self) {
        self.leader_account_id = ::std::option::Option::None;
    }

    pub fn has_leader_account_id(&self) -> bool {
        self.leader_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_account_id(&mut self, v: u32) {
        self.leader_account_id = ::std::option::Option::Some(v);
    }

    // optional string leader_name = 6;

    pub fn leader_name(&self) -> &str {
        match self.leader_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_leader_name(&mut self) {
        self.leader_name = ::std::option::Option::None;
    }

    pub fn has_leader_name(&self) -> bool {
        self.leader_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leader_name(&mut self, v: ::std::string::String) {
        self.leader_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_leader_name(&mut self) -> &mut ::std::string::String {
        if self.leader_name.is_none() {
            self.leader_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.leader_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_leader_name(&mut self) -> ::std::string::String {
        self.leader_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string custom_map_name = 7;

    pub fn custom_map_name(&self) -> &str {
        match self.custom_map_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_map_name(&mut self) {
        self.custom_map_name = ::std::option::Option::None;
    }

    pub fn has_custom_map_name(&self) -> bool {
        self.custom_map_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_map_name(&mut self, v: ::std::string::String) {
        self.custom_map_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_map_name(&mut self) -> &mut ::std::string::String {
        if self.custom_map_name.is_none() {
            self.custom_map_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_map_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_map_name(&mut self) -> ::std::string::String {
        self.custom_map_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 max_player_count = 8;

    pub fn max_player_count(&self) -> u32 {
        self.max_player_count.unwrap_or(0)
    }

    pub fn clear_max_player_count(&mut self) {
        self.max_player_count = ::std::option::Option::None;
    }

    pub fn has_max_player_count(&self) -> bool {
        self.max_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_player_count(&mut self, v: u32) {
        self.max_player_count = ::std::option::Option::Some(v);
    }

    // optional uint32 server_region = 9;

    pub fn server_region(&self) -> u32 {
        self.server_region.unwrap_or(0)
    }

    pub fn clear_server_region(&mut self) {
        self.server_region = ::std::option::Option::None;
    }

    pub fn has_server_region(&self) -> bool {
        self.server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_region(&mut self, v: u32) {
        self.server_region = ::std::option::Option::Some(v);
    }

    // optional bool has_pass_key = 11;

    pub fn has_pass_key(&self) -> bool {
        self.has_pass_key.unwrap_or(false)
    }

    pub fn clear_has_pass_key(&mut self) {
        self.has_pass_key = ::std::option::Option::None;
    }

    pub fn has_has_pass_key(&self) -> bool {
        self.has_pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_pass_key(&mut self, v: bool) {
        self.has_pass_key = ::std::option::Option::Some(v);
    }

    // optional string lan_host_ping_location = 12;

    pub fn lan_host_ping_location(&self) -> &str {
        match self.lan_host_ping_location.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lan_host_ping_location(&mut self) {
        self.lan_host_ping_location = ::std::option::Option::None;
    }

    pub fn has_lan_host_ping_location(&self) -> bool {
        self.lan_host_ping_location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lan_host_ping_location(&mut self, v: ::std::string::String) {
        self.lan_host_ping_location = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lan_host_ping_location(&mut self) -> &mut ::std::string::String {
        if self.lan_host_ping_location.is_none() {
            self.lan_host_ping_location = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lan_host_ping_location.as_mut().unwrap()
    }

    // Take field
    pub fn take_lan_host_ping_location(&mut self) -> ::std::string::String {
        self.lan_host_ping_location.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 lobby_creation_time = 13;

    pub fn lobby_creation_time(&self) -> u32 {
        self.lobby_creation_time.unwrap_or(0)
    }

    pub fn clear_lobby_creation_time(&mut self) {
        self.lobby_creation_time = ::std::option::Option::None;
    }

    pub fn has_lobby_creation_time(&self) -> bool {
        self.lobby_creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_creation_time(&mut self, v: u32) {
        self.lobby_creation_time = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_timestamp = 14;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_crc = 15;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional uint32 min_player_count = 16;

    pub fn min_player_count(&self) -> u32 {
        self.min_player_count.unwrap_or(0)
    }

    pub fn clear_min_player_count(&mut self) {
        self.min_player_count = ::std::option::Option::None;
    }

    pub fn has_min_player_count(&self) -> bool {
        self.min_player_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_min_player_count(&mut self, v: u32) {
        self.min_player_count = ::std::option::Option::Some(v);
    }

    // optional bool penalties_enabled = 17;

    pub fn penalties_enabled(&self) -> bool {
        self.penalties_enabled.unwrap_or(false)
    }

    pub fn clear_penalties_enabled(&mut self) {
        self.penalties_enabled = ::std::option::Option::None;
    }

    pub fn has_penalties_enabled(&self) -> bool {
        self.penalties_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_penalties_enabled(&mut self, v: bool) {
        self.penalties_enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomLobbiesResponseEntry {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesResponseEntry";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    self.lobby_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.leader_name = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.custom_map_name = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.max_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.has_pass_key = ::std::option::Option::Some(is.read_bool()?);
                },
                98 => {
                    self.lan_host_ping_location = ::std::option::Option::Some(is.read_string()?);
                },
                104 => {
                    self.lobby_creation_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                120 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_uint64()?);
                },
                128 => {
                    self.min_player_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.penalties_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.lobby_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.member_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.leader_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.leader_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.max_player_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.has_pass_key {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.lobby_creation_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(15, v);
        }
        if let Some(v) = self.min_player_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
        }
        if let Some(v) = self.penalties_enabled {
            my_size += 2 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.lobby_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.leader_account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.leader_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.custom_map_name.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.max_player_count {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.server_region {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.has_pass_key {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.lan_host_ping_location.as_ref() {
            os.write_string(12, v)?;
        }
        if let Some(v) = self.lobby_creation_time {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_uint64(15, v)?;
        }
        if let Some(v) = self.min_player_count {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.penalties_enabled {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesResponseEntry {
        CMsgJoinableCustomLobbiesResponseEntry::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.lobby_name = ::std::option::Option::None;
        self.member_count = ::std::option::Option::None;
        self.leader_account_id = ::std::option::Option::None;
        self.leader_name = ::std::option::Option::None;
        self.custom_map_name = ::std::option::Option::None;
        self.max_player_count = ::std::option::Option::None;
        self.server_region = ::std::option::Option::None;
        self.has_pass_key = ::std::option::Option::None;
        self.lan_host_ping_location = ::std::option::Option::None;
        self.lobby_creation_time = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.min_player_count = ::std::option::Option::None;
        self.penalties_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesResponseEntry {
        static instance: CMsgJoinableCustomLobbiesResponseEntry = CMsgJoinableCustomLobbiesResponseEntry {
            lobby_id: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            lobby_name: ::std::option::Option::None,
            member_count: ::std::option::Option::None,
            leader_account_id: ::std::option::Option::None,
            leader_name: ::std::option::Option::None,
            custom_map_name: ::std::option::Option::None,
            max_player_count: ::std::option::Option::None,
            server_region: ::std::option::Option::None,
            has_pass_key: ::std::option::Option::None,
            lan_host_ping_location: ::std::option::Option::None,
            lobby_creation_time: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            min_player_count: ::std::option::Option::None,
            penalties_enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgJoinableCustomLobbiesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgJoinableCustomLobbiesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgJoinableCustomLobbiesResponse.lobbies)
    pub lobbies: ::std::vec::Vec<CMsgJoinableCustomLobbiesResponseEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgJoinableCustomLobbiesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgJoinableCustomLobbiesResponse {
    fn default() -> &'a CMsgJoinableCustomLobbiesResponse {
        <CMsgJoinableCustomLobbiesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgJoinableCustomLobbiesResponse {
    pub fn new() -> CMsgJoinableCustomLobbiesResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgJoinableCustomLobbiesResponse {
    const NAME: &'static str = "CMsgJoinableCustomLobbiesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.lobbies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgJoinableCustomLobbiesResponse {
        CMsgJoinableCustomLobbiesResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgJoinableCustomLobbiesResponse {
        static instance: CMsgJoinableCustomLobbiesResponse = CMsgJoinableCustomLobbiesResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgQuickJoinCustomLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuickJoinCustomLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.legacy_server_region)
    pub legacy_server_region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.create_lobby_details)
    pub create_lobby_details: ::steam_vent_proto_common::protobuf::MessageField<CMsgPracticeLobbySetDetails>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.allow_any_map)
    pub allow_any_map: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.legacy_region_pings)
    pub legacy_region_pings: ::std::vec::Vec<cmsg_quick_join_custom_lobby::LegacyRegionPing>,
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.ping_data)
    pub ping_data: ::steam_vent_proto_common::protobuf::MessageField<super::base_gcmessages::CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuickJoinCustomLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuickJoinCustomLobby {
    fn default() -> &'a CMsgQuickJoinCustomLobby {
        <CMsgQuickJoinCustomLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuickJoinCustomLobby {
    pub fn new() -> CMsgQuickJoinCustomLobby {
        ::std::default::Default::default()
    }

    // optional uint32 legacy_server_region = 1;

    pub fn legacy_server_region(&self) -> u32 {
        self.legacy_server_region.unwrap_or(0)
    }

    pub fn clear_legacy_server_region(&mut self) {
        self.legacy_server_region = ::std::option::Option::None;
    }

    pub fn has_legacy_server_region(&self) -> bool {
        self.legacy_server_region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_server_region(&mut self, v: u32) {
        self.legacy_server_region = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional bool allow_any_map = 5;

    pub fn allow_any_map(&self) -> bool {
        self.allow_any_map.unwrap_or(false)
    }

    pub fn clear_allow_any_map(&mut self) {
        self.allow_any_map = ::std::option::Option::None;
    }

    pub fn has_allow_any_map(&self) -> bool {
        self.allow_any_map.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_any_map(&mut self, v: bool) {
        self.allow_any_map = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuickJoinCustomLobby {
    const NAME: &'static str = "CMsgQuickJoinCustomLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.legacy_server_region = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.create_lobby_details)?;
                },
                40 => {
                    self.allow_any_map = ::std::option::Option::Some(is.read_bool()?);
                },
                50 => {
                    self.legacy_region_pings.push(is.read_message()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_server_region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.create_lobby_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.allow_any_map {
            my_size += 1 + 1;
        }
        for value in &self.legacy_region_pings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_server_region {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.create_lobby_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.allow_any_map {
            os.write_bool(5, v)?;
        }
        for v in &self.legacy_region_pings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.ping_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuickJoinCustomLobby {
        CMsgQuickJoinCustomLobby::new()
    }

    fn clear(&mut self) {
        self.legacy_server_region = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.create_lobby_details.clear();
        self.allow_any_map = ::std::option::Option::None;
        self.legacy_region_pings.clear();
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuickJoinCustomLobby {
        static instance: CMsgQuickJoinCustomLobby = CMsgQuickJoinCustomLobby {
            legacy_server_region: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            create_lobby_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            allow_any_map: ::std::option::Option::None,
            legacy_region_pings: ::std::vec::Vec::new(),
            ping_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgQuickJoinCustomLobby`
pub mod cmsg_quick_join_custom_lobby {
    // @@protoc_insertion_point(message:CMsgQuickJoinCustomLobby.LegacyRegionPing)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LegacyRegionPing {
        // message fields
        // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.LegacyRegionPing.server_region)
        pub server_region: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.LegacyRegionPing.ping)
        pub ping: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobby.LegacyRegionPing.region_code)
        pub region_code: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgQuickJoinCustomLobby.LegacyRegionPing.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LegacyRegionPing {
        fn default() -> &'a LegacyRegionPing {
            <LegacyRegionPing as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LegacyRegionPing {
        pub fn new() -> LegacyRegionPing {
            ::std::default::Default::default()
        }

        // optional uint32 server_region = 1;

        pub fn server_region(&self) -> u32 {
            self.server_region.unwrap_or(0)
        }

        pub fn clear_server_region(&mut self) {
            self.server_region = ::std::option::Option::None;
        }

        pub fn has_server_region(&self) -> bool {
            self.server_region.is_some()
        }

        // Param is passed by value, moved
        pub fn set_server_region(&mut self, v: u32) {
            self.server_region = ::std::option::Option::Some(v);
        }

        // optional uint32 ping = 2;

        pub fn ping(&self) -> u32 {
            self.ping.unwrap_or(0)
        }

        pub fn clear_ping(&mut self) {
            self.ping = ::std::option::Option::None;
        }

        pub fn has_ping(&self) -> bool {
            self.ping.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ping(&mut self, v: u32) {
            self.ping = ::std::option::Option::Some(v);
        }

        // optional fixed32 region_code = 3;

        pub fn region_code(&self) -> u32 {
            self.region_code.unwrap_or(0)
        }

        pub fn clear_region_code(&mut self) {
            self.region_code = ::std::option::Option::None;
        }

        pub fn has_region_code(&self) -> bool {
            self.region_code.is_some()
        }

        // Param is passed by value, moved
        pub fn set_region_code(&mut self, v: u32) {
            self.region_code = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LegacyRegionPing {
        const NAME: &'static str = "LegacyRegionPing";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.server_region = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.ping = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.region_code = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.server_region {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.ping {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.region_code {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.server_region {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.ping {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.region_code {
                os.write_fixed32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LegacyRegionPing {
            LegacyRegionPing::new()
        }

        fn clear(&mut self) {
            self.server_region = ::std::option::Option::None;
            self.ping = ::std::option::Option::None;
            self.region_code = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LegacyRegionPing {
            static instance: LegacyRegionPing = LegacyRegionPing {
                server_region: ::std::option::Option::None,
                ping: ::std::option::Option::None,
                region_code: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgQuickJoinCustomLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgQuickJoinCustomLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgQuickJoinCustomLobbyResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTAJoinLobbyResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgQuickJoinCustomLobbyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgQuickJoinCustomLobbyResponse {
    fn default() -> &'a CMsgQuickJoinCustomLobbyResponse {
        <CMsgQuickJoinCustomLobbyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgQuickJoinCustomLobbyResponse {
    pub fn new() -> CMsgQuickJoinCustomLobbyResponse {
        ::std::default::Default::default()
    }

    // optional .DOTAJoinLobbyResult result = 1;

    pub fn result(&self) -> super::dota_shared_enums::DOTAJoinLobbyResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS),
            None => super::dota_shared_enums::DOTAJoinLobbyResult::DOTA_JOIN_RESULT_SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_shared_enums::DOTAJoinLobbyResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgQuickJoinCustomLobbyResponse {
    const NAME: &'static str = "CMsgQuickJoinCustomLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgQuickJoinCustomLobbyResponse {
        CMsgQuickJoinCustomLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgQuickJoinCustomLobbyResponse {
        static instance: CMsgQuickJoinCustomLobbyResponse = CMsgQuickJoinCustomLobbyResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBotGameCreate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBotGameCreate {
    // message fields
    // @@protoc_insertion_point(field:CMsgBotGameCreate.search_key)
    pub search_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgBotGameCreate.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBotGameCreate.difficulty_radiant)
    pub difficulty_radiant: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // @@protoc_insertion_point(field:CMsgBotGameCreate.team)
    pub team: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GC_TEAM>>,
    // @@protoc_insertion_point(field:CMsgBotGameCreate.game_mode)
    pub game_mode: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgBotGameCreate.difficulty_dire)
    pub difficulty_dire: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTABotDifficulty>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBotGameCreate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBotGameCreate {
    fn default() -> &'a CMsgBotGameCreate {
        <CMsgBotGameCreate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBotGameCreate {
    pub fn new() -> CMsgBotGameCreate {
        ::std::default::Default::default()
    }

    // optional string search_key = 1;

    pub fn search_key(&self) -> &str {
        match self.search_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_search_key(&mut self) {
        self.search_key = ::std::option::Option::None;
    }

    pub fn has_search_key(&self) -> bool {
        self.search_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_search_key(&mut self, v: ::std::string::String) {
        self.search_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_search_key(&mut self) -> &mut ::std::string::String {
        if self.search_key.is_none() {
            self.search_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.search_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_search_key(&mut self) -> ::std::string::String {
        self.search_key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty difficulty_radiant = 3;

    pub fn difficulty_radiant(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.difficulty_radiant {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_difficulty_radiant(&mut self) {
        self.difficulty_radiant = ::std::option::Option::None;
    }

    pub fn has_difficulty_radiant(&self) -> bool {
        self.difficulty_radiant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty_radiant(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.difficulty_radiant = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .DOTA_GC_TEAM team = 4;

    pub fn team(&self) -> super::dota_shared_enums::DOTA_GC_TEAM {
        match self.team {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS),
            None => super::dota_shared_enums::DOTA_GC_TEAM::DOTA_GC_TEAM_GOOD_GUYS,
        }
    }

    pub fn clear_team(&mut self) {
        self.team = ::std::option::Option::None;
    }

    pub fn has_team(&self) -> bool {
        self.team.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team(&mut self, v: super::dota_shared_enums::DOTA_GC_TEAM) {
        self.team = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 game_mode = 5;

    pub fn game_mode(&self) -> u32 {
        self.game_mode.unwrap_or(0)
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: u32) {
        self.game_mode = ::std::option::Option::Some(v);
    }

    // optional .DOTABotDifficulty difficulty_dire = 6;

    pub fn difficulty_dire(&self) -> super::dota_shared_enums::DOTABotDifficulty {
        match self.difficulty_dire {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE),
            None => super::dota_shared_enums::DOTABotDifficulty::BOT_DIFFICULTY_PASSIVE,
        }
    }

    pub fn clear_difficulty_dire(&mut self) {
        self.difficulty_dire = ::std::option::Option::None;
    }

    pub fn has_difficulty_dire(&self) -> bool {
        self.difficulty_dire.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty_dire(&mut self, v: super::dota_shared_enums::DOTABotDifficulty) {
        self.difficulty_dire = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBotGameCreate {
    const NAME: &'static str = "CMsgBotGameCreate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.search_key = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.difficulty_radiant = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.team = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.difficulty_dire = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.search_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.difficulty_radiant {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.team {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.difficulty_dire {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.search_key.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.difficulty_radiant {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.team {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.game_mode {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.difficulty_dire {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBotGameCreate {
        CMsgBotGameCreate::new()
    }

    fn clear(&mut self) {
        self.search_key = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.difficulty_radiant = ::std::option::Option::None;
        self.team = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.difficulty_dire = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBotGameCreate {
        static instance: CMsgBotGameCreate = CMsgBotGameCreate {
            search_key: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            difficulty_radiant: ::std::option::Option::None,
            team: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            difficulty_dire: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAPartyMemberSetCoach)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPartyMemberSetCoach {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPartyMemberSetCoach.wants_coach)
    pub wants_coach: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPartyMemberSetCoach.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPartyMemberSetCoach {
    fn default() -> &'a CMsgDOTAPartyMemberSetCoach {
        <CMsgDOTAPartyMemberSetCoach as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPartyMemberSetCoach {
    pub fn new() -> CMsgDOTAPartyMemberSetCoach {
        ::std::default::Default::default()
    }

    // optional bool wants_coach = 1;

    pub fn wants_coach(&self) -> bool {
        self.wants_coach.unwrap_or(false)
    }

    pub fn clear_wants_coach(&mut self) {
        self.wants_coach = ::std::option::Option::None;
    }

    pub fn has_wants_coach(&self) -> bool {
        self.wants_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wants_coach(&mut self, v: bool) {
        self.wants_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPartyMemberSetCoach {
    const NAME: &'static str = "CMsgDOTAPartyMemberSetCoach";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.wants_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.wants_coach {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.wants_coach {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPartyMemberSetCoach {
        CMsgDOTAPartyMemberSetCoach::new()
    }

    fn clear(&mut self) {
        self.wants_coach = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPartyMemberSetCoach {
        static instance: CMsgDOTAPartyMemberSetCoach = CMsgDOTAPartyMemberSetCoach {
            wants_coach: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetGroupLeader)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetGroupLeader {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetGroupLeader.new_leader_steamid)
    pub new_leader_steamid: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetGroupLeader.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetGroupLeader {
    fn default() -> &'a CMsgDOTASetGroupLeader {
        <CMsgDOTASetGroupLeader as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetGroupLeader {
    pub fn new() -> CMsgDOTASetGroupLeader {
        ::std::default::Default::default()
    }

    // optional fixed64 new_leader_steamid = 1;

    pub fn new_leader_steamid(&self) -> u64 {
        self.new_leader_steamid.unwrap_or(0)
    }

    pub fn clear_new_leader_steamid(&mut self) {
        self.new_leader_steamid = ::std::option::Option::None;
    }

    pub fn has_new_leader_steamid(&self) -> bool {
        self.new_leader_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_leader_steamid(&mut self, v: u64) {
        self.new_leader_steamid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetGroupLeader {
    const NAME: &'static str = "CMsgDOTASetGroupLeader";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.new_leader_steamid = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_leader_steamid {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.new_leader_steamid {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetGroupLeader {
        CMsgDOTASetGroupLeader::new()
    }

    fn clear(&mut self) {
        self.new_leader_steamid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetGroupLeader {
        static instance: CMsgDOTASetGroupLeader = CMsgDOTASetGroupLeader {
            new_leader_steamid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACancelGroupInvites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACancelGroupInvites {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACancelGroupInvites.invited_steamids)
    pub invited_steamids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgDOTACancelGroupInvites.invited_groupids)
    pub invited_groupids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACancelGroupInvites.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACancelGroupInvites {
    fn default() -> &'a CMsgDOTACancelGroupInvites {
        <CMsgDOTACancelGroupInvites as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACancelGroupInvites {
    pub fn new() -> CMsgDOTACancelGroupInvites {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACancelGroupInvites {
    const NAME: &'static str = "CMsgDOTACancelGroupInvites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed64_into(&mut self.invited_steamids)?;
                },
                9 => {
                    self.invited_steamids.push(is.read_fixed64()?);
                },
                18 => {
                    is.read_repeated_packed_fixed64_into(&mut self.invited_groupids)?;
                },
                17 => {
                    self.invited_groupids.push(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 9 * self.invited_steamids.len() as u64;
        my_size += 9 * self.invited_groupids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.invited_steamids {
            os.write_fixed64(1, *v)?;
        };
        for v in &self.invited_groupids {
            os.write_fixed64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACancelGroupInvites {
        CMsgDOTACancelGroupInvites::new()
    }

    fn clear(&mut self) {
        self.invited_steamids.clear();
        self.invited_groupids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACancelGroupInvites {
        static instance: CMsgDOTACancelGroupInvites = CMsgDOTACancelGroupInvites {
            invited_steamids: ::std::vec::Vec::new(),
            invited_groupids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetGroupOpenStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetGroupOpenStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetGroupOpenStatus.open)
    pub open: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetGroupOpenStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetGroupOpenStatus {
    fn default() -> &'a CMsgDOTASetGroupOpenStatus {
        <CMsgDOTASetGroupOpenStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetGroupOpenStatus {
    pub fn new() -> CMsgDOTASetGroupOpenStatus {
        ::std::default::Default::default()
    }

    // optional bool open = 1;

    pub fn open(&self) -> bool {
        self.open.unwrap_or(false)
    }

    pub fn clear_open(&mut self) {
        self.open = ::std::option::Option::None;
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetGroupOpenStatus {
    const NAME: &'static str = "CMsgDOTASetGroupOpenStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.open = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.open {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.open {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetGroupOpenStatus {
        CMsgDOTASetGroupOpenStatus::new()
    }

    fn clear(&mut self) {
        self.open = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetGroupOpenStatus {
        static instance: CMsgDOTASetGroupOpenStatus = CMsgDOTASetGroupOpenStatus {
            open: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGroupMergeInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGroupMergeInvite.other_group_id)
    pub other_group_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGroupMergeInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeInvite {
    fn default() -> &'a CMsgDOTAGroupMergeInvite {
        <CMsgDOTAGroupMergeInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeInvite {
    pub fn new() -> CMsgDOTAGroupMergeInvite {
        ::std::default::Default::default()
    }

    // optional fixed64 other_group_id = 1;

    pub fn other_group_id(&self) -> u64 {
        self.other_group_id.unwrap_or(0)
    }

    pub fn clear_other_group_id(&mut self) {
        self.other_group_id = ::std::option::Option::None;
    }

    pub fn has_other_group_id(&self) -> bool {
        self.other_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_other_group_id(&mut self, v: u64) {
        self.other_group_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGroupMergeInvite {
    const NAME: &'static str = "CMsgDOTAGroupMergeInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.other_group_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.other_group_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.other_group_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeInvite {
        CMsgDOTAGroupMergeInvite::new()
    }

    fn clear(&mut self) {
        self.other_group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeInvite {
        static instance: CMsgDOTAGroupMergeInvite = CMsgDOTAGroupMergeInvite {
            other_group_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGroupMergeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGroupMergeResponse.initiator_group_id)
    pub initiator_group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAGroupMergeResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGroupMergeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeResponse {
    fn default() -> &'a CMsgDOTAGroupMergeResponse {
        <CMsgDOTAGroupMergeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeResponse {
    pub fn new() -> CMsgDOTAGroupMergeResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 initiator_group_id = 1;

    pub fn initiator_group_id(&self) -> u64 {
        self.initiator_group_id.unwrap_or(0)
    }

    pub fn clear_initiator_group_id(&mut self) {
        self.initiator_group_id = ::std::option::Option::None;
    }

    pub fn has_initiator_group_id(&self) -> bool {
        self.initiator_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiator_group_id(&mut self, v: u64) {
        self.initiator_group_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGroupMergeResponse {
    const NAME: &'static str = "CMsgDOTAGroupMergeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.initiator_group_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initiator_group_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.initiator_group_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeResponse {
        CMsgDOTAGroupMergeResponse::new()
    }

    fn clear(&mut self) {
        self.initiator_group_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeResponse {
        static instance: CMsgDOTAGroupMergeResponse = CMsgDOTAGroupMergeResponse {
            initiator_group_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGroupMergeReply)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGroupMergeReply {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGroupMergeReply.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_client_enums::EDOTAGroupMergeResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGroupMergeReply.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGroupMergeReply {
    fn default() -> &'a CMsgDOTAGroupMergeReply {
        <CMsgDOTAGroupMergeReply as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGroupMergeReply {
    pub fn new() -> CMsgDOTAGroupMergeReply {
        ::std::default::Default::default()
    }

    // optional .EDOTAGroupMergeResult result = 1;

    pub fn result(&self) -> super::dota_client_enums::EDOTAGroupMergeResult {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_client_enums::EDOTAGroupMergeResult::k_EDOTAGroupMergeResult_OK),
            None => super::dota_client_enums::EDOTAGroupMergeResult::k_EDOTAGroupMergeResult_OK,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_client_enums::EDOTAGroupMergeResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGroupMergeReply {
    const NAME: &'static str = "CMsgDOTAGroupMergeReply";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGroupMergeReply {
        CMsgDOTAGroupMergeReply::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGroupMergeReply {
        static instance: CMsgDOTAGroupMergeReply = CMsgDOTAGroupMergeReply {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSpectatorLobbyGameDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyGameDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.language)
    pub language: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.stream_url)
    pub stream_url: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.stream_name)
    pub stream_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.league_id)
    pub league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.series_type)
    pub series_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.series_game)
    pub series_game: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.radiant_team)
    pub radiant_team: ::steam_vent_proto_common::protobuf::MessageField<cmsg_spectator_lobby_game_details::Team>,
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.dire_team)
    pub dire_team: ::steam_vent_proto_common::protobuf::MessageField<cmsg_spectator_lobby_game_details::Team>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSpectatorLobbyGameDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyGameDetails {
    fn default() -> &'a CMsgSpectatorLobbyGameDetails {
        <CMsgSpectatorLobbyGameDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyGameDetails {
    pub fn new() -> CMsgSpectatorLobbyGameDetails {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn language(&self) -> u32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 server_steam_id = 3;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }

    // optional string stream_url = 4;

    pub fn stream_url(&self) -> &str {
        match self.stream_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stream_url(&mut self) {
        self.stream_url = ::std::option::Option::None;
    }

    pub fn has_stream_url(&self) -> bool {
        self.stream_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_url(&mut self, v: ::std::string::String) {
        self.stream_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_url(&mut self) -> &mut ::std::string::String {
        if self.stream_url.is_none() {
            self.stream_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stream_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_url(&mut self) -> ::std::string::String {
        self.stream_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string stream_name = 5;

    pub fn stream_name(&self) -> &str {
        match self.stream_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_stream_name(&mut self) {
        self.stream_name = ::std::option::Option::None;
    }

    pub fn has_stream_name(&self) -> bool {
        self.stream_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stream_name(&mut self, v: ::std::string::String) {
        self.stream_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stream_name(&mut self) -> &mut ::std::string::String {
        if self.stream_name.is_none() {
            self.stream_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.stream_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_stream_name(&mut self) -> ::std::string::String {
        self.stream_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 league_id = 6;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }

    // optional uint32 series_type = 7;

    pub fn series_type(&self) -> u32 {
        self.series_type.unwrap_or(0)
    }

    pub fn clear_series_type(&mut self) {
        self.series_type = ::std::option::Option::None;
    }

    pub fn has_series_type(&self) -> bool {
        self.series_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_type(&mut self, v: u32) {
        self.series_type = ::std::option::Option::Some(v);
    }

    // optional uint32 series_game = 8;

    pub fn series_game(&self) -> u32 {
        self.series_game.unwrap_or(0)
    }

    pub fn clear_series_game(&mut self) {
        self.series_game = ::std::option::Option::None;
    }

    pub fn has_series_game(&self) -> bool {
        self.series_game.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series_game(&mut self, v: u32) {
        self.series_game = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSpectatorLobbyGameDetails {
    const NAME: &'static str = "CMsgSpectatorLobbyGameDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.language = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                25 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                34 => {
                    self.stream_url = ::std::option::Option::Some(is.read_string()?);
                },
                42 => {
                    self.stream_name = ::std::option::Option::Some(is.read_string()?);
                },
                48 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.series_game = ::std::option::Option::Some(is.read_uint32()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.radiant_team)?;
                },
                82 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.dire_team)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.stream_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.stream_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.series_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.series_game {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.radiant_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.dire_team.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.stream_url.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.stream_name.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.series_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.series_game {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.radiant_team.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.dire_team.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyGameDetails {
        CMsgSpectatorLobbyGameDetails::new()
    }

    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.server_steam_id = ::std::option::Option::None;
        self.stream_url = ::std::option::Option::None;
        self.stream_name = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.series_type = ::std::option::Option::None;
        self.series_game = ::std::option::Option::None;
        self.radiant_team.clear();
        self.dire_team.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyGameDetails {
        static instance: CMsgSpectatorLobbyGameDetails = CMsgSpectatorLobbyGameDetails {
            language: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            server_steam_id: ::std::option::Option::None,
            stream_url: ::std::option::Option::None,
            stream_name: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            series_type: ::std::option::Option::None,
            series_game: ::std::option::Option::None,
            radiant_team: ::steam_vent_proto_common::protobuf::MessageField::none(),
            dire_team: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSpectatorLobbyGameDetails`
pub mod cmsg_spectator_lobby_game_details {
    // @@protoc_insertion_point(message:CMsgSpectatorLobbyGameDetails.Team)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Team {
        // message fields
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.Team.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.Team.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyGameDetails.Team.team_logo)
        pub team_logo: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSpectatorLobbyGameDetails.Team.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Team {
        fn default() -> &'a Team {
            <Team as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Team {
        pub fn new() -> Team {
            ::std::default::Default::default()
        }

        // optional uint32 team_id = 1;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 2;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional fixed64 team_logo = 3;

        pub fn team_logo(&self) -> u64 {
            self.team_logo.unwrap_or(0)
        }

        pub fn clear_team_logo(&mut self) {
            self.team_logo = ::std::option::Option::None;
        }

        pub fn has_team_logo(&self) -> bool {
            self.team_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_logo(&mut self, v: u64) {
            self.team_logo = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Team {
        const NAME: &'static str = "Team";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    25 => {
                        self.team_logo = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.team_logo {
                my_size += 1 + 8;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.team_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.team_logo {
                os.write_fixed64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Team {
            Team::new()
        }

        fn clear(&mut self) {
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.team_logo = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Team {
            static instance: Team = Team {
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                team_logo: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSetSpectatorLobbyDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetSpectatorLobbyDetails {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetSpectatorLobbyDetails.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgSetSpectatorLobbyDetails.lobby_name)
    pub lobby_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetSpectatorLobbyDetails.pass_key)
    pub pass_key: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgSetSpectatorLobbyDetails.game_details)
    pub game_details: ::steam_vent_proto_common::protobuf::MessageField<CMsgSpectatorLobbyGameDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetSpectatorLobbyDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetSpectatorLobbyDetails {
    fn default() -> &'a CMsgSetSpectatorLobbyDetails {
        <CMsgSetSpectatorLobbyDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetSpectatorLobbyDetails {
    pub fn new() -> CMsgSetSpectatorLobbyDetails {
        ::std::default::Default::default()
    }

    // optional uint64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string lobby_name = 2;

    pub fn lobby_name(&self) -> &str {
        match self.lobby_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_lobby_name(&mut self) {
        self.lobby_name = ::std::option::Option::None;
    }

    pub fn has_lobby_name(&self) -> bool {
        self.lobby_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_name(&mut self, v: ::std::string::String) {
        self.lobby_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lobby_name(&mut self) -> &mut ::std::string::String {
        if self.lobby_name.is_none() {
            self.lobby_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.lobby_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_lobby_name(&mut self) -> ::std::string::String {
        self.lobby_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pass_key = 3;

    pub fn pass_key(&self) -> &str {
        match self.pass_key.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_pass_key(&mut self) {
        self.pass_key = ::std::option::Option::None;
    }

    pub fn has_pass_key(&self) -> bool {
        self.pass_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pass_key(&mut self, v: ::std::string::String) {
        self.pass_key = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pass_key(&mut self) -> &mut ::std::string::String {
        if self.pass_key.is_none() {
            self.pass_key = ::std::option::Option::Some(::std::string::String::new());
        }
        self.pass_key.as_mut().unwrap()
    }

    // Take field
    pub fn take_pass_key(&mut self) -> ::std::string::String {
        self.pass_key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetSpectatorLobbyDetails {
    const NAME: &'static str = "CMsgSetSpectatorLobbyDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.lobby_name = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.pass_key = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.game_details)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.lobby_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.pass_key.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.game_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.lobby_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.pass_key.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.game_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetSpectatorLobbyDetails {
        CMsgSetSpectatorLobbyDetails::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.lobby_name = ::std::option::Option::None;
        self.pass_key = ::std::option::Option::None;
        self.game_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetSpectatorLobbyDetails {
        static instance: CMsgSetSpectatorLobbyDetails = CMsgSetSpectatorLobbyDetails {
            lobby_id: ::std::option::Option::None,
            lobby_name: ::std::option::Option::None,
            pass_key: ::std::option::Option::None,
            game_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCreateSpectatorLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCreateSpectatorLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgCreateSpectatorLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgCreateSpectatorLobby.details)
    pub details: ::steam_vent_proto_common::protobuf::MessageField<CMsgSetSpectatorLobbyDetails>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCreateSpectatorLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCreateSpectatorLobby {
    fn default() -> &'a CMsgCreateSpectatorLobby {
        <CMsgCreateSpectatorLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCreateSpectatorLobby {
    pub fn new() -> CMsgCreateSpectatorLobby {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCreateSpectatorLobby {
    const NAME: &'static str = "CMsgCreateSpectatorLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.details)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCreateSpectatorLobby {
        CMsgCreateSpectatorLobby::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCreateSpectatorLobby {
        static instance: CMsgCreateSpectatorLobby = CMsgCreateSpectatorLobby {
            client_version: ::std::option::Option::None,
            details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSpectatorLobbyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyList {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSpectatorLobbyList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyList {
    fn default() -> &'a CMsgSpectatorLobbyList {
        <CMsgSpectatorLobbyList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyList {
    pub fn new() -> CMsgSpectatorLobbyList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSpectatorLobbyList {
    const NAME: &'static str = "CMsgSpectatorLobbyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyList {
        CMsgSpectatorLobbyList::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyList {
        static instance: CMsgSpectatorLobbyList = CMsgSpectatorLobbyList {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSpectatorLobbyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSpectatorLobbyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.lobbies)
    pub lobbies: ::std::vec::Vec<cmsg_spectator_lobby_list_response::SpectatorLobby>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSpectatorLobbyListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSpectatorLobbyListResponse {
    fn default() -> &'a CMsgSpectatorLobbyListResponse {
        <CMsgSpectatorLobbyListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSpectatorLobbyListResponse {
    pub fn new() -> CMsgSpectatorLobbyListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSpectatorLobbyListResponse {
    const NAME: &'static str = "CMsgSpectatorLobbyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.lobbies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.lobbies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.lobbies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSpectatorLobbyListResponse {
        CMsgSpectatorLobbyListResponse::new()
    }

    fn clear(&mut self) {
        self.lobbies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSpectatorLobbyListResponse {
        static instance: CMsgSpectatorLobbyListResponse = CMsgSpectatorLobbyListResponse {
            lobbies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSpectatorLobbyListResponse`
pub mod cmsg_spectator_lobby_list_response {
    // @@protoc_insertion_point(message:CMsgSpectatorLobbyListResponse.SpectatorLobby)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SpectatorLobby {
        // message fields
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.lobby_id)
        pub lobby_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.game_name)
        pub game_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.requires_pass_key)
        pub requires_pass_key: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.leader_account_id)
        pub leader_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.member_count)
        pub member_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSpectatorLobbyListResponse.SpectatorLobby.game_details)
        pub game_details: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgSpectatorLobbyGameDetails>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSpectatorLobbyListResponse.SpectatorLobby.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SpectatorLobby {
        fn default() -> &'a SpectatorLobby {
            <SpectatorLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SpectatorLobby {
        pub fn new() -> SpectatorLobby {
            ::std::default::Default::default()
        }

        // optional uint64 lobby_id = 1;

        pub fn lobby_id(&self) -> u64 {
            self.lobby_id.unwrap_or(0)
        }

        pub fn clear_lobby_id(&mut self) {
            self.lobby_id = ::std::option::Option::None;
        }

        pub fn has_lobby_id(&self) -> bool {
            self.lobby_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_id(&mut self, v: u64) {
            self.lobby_id = ::std::option::Option::Some(v);
        }

        // optional string game_name = 2;

        pub fn game_name(&self) -> &str {
            match self.game_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_game_name(&mut self) {
            self.game_name = ::std::option::Option::None;
        }

        pub fn has_game_name(&self) -> bool {
            self.game_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_name(&mut self, v: ::std::string::String) {
            self.game_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_game_name(&mut self) -> &mut ::std::string::String {
            if self.game_name.is_none() {
                self.game_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.game_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_game_name(&mut self) -> ::std::string::String {
            self.game_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional bool requires_pass_key = 3;

        pub fn requires_pass_key(&self) -> bool {
            self.requires_pass_key.unwrap_or(false)
        }

        pub fn clear_requires_pass_key(&mut self) {
            self.requires_pass_key = ::std::option::Option::None;
        }

        pub fn has_requires_pass_key(&self) -> bool {
            self.requires_pass_key.is_some()
        }

        // Param is passed by value, moved
        pub fn set_requires_pass_key(&mut self, v: bool) {
            self.requires_pass_key = ::std::option::Option::Some(v);
        }

        // optional uint32 leader_account_id = 4;

        pub fn leader_account_id(&self) -> u32 {
            self.leader_account_id.unwrap_or(0)
        }

        pub fn clear_leader_account_id(&mut self) {
            self.leader_account_id = ::std::option::Option::None;
        }

        pub fn has_leader_account_id(&self) -> bool {
            self.leader_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leader_account_id(&mut self, v: u32) {
            self.leader_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 member_count = 5;

        pub fn member_count(&self) -> u32 {
            self.member_count.unwrap_or(0)
        }

        pub fn clear_member_count(&mut self) {
            self.member_count = ::std::option::Option::None;
        }

        pub fn has_member_count(&self) -> bool {
            self.member_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_member_count(&mut self, v: u32) {
            self.member_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SpectatorLobby {
        const NAME: &'static str = "SpectatorLobby";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        self.game_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.requires_pass_key = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.leader_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    58 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.game_details)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.lobby_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.game_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.requires_pass_key {
                my_size += 1 + 1;
            }
            if let Some(v) = self.leader_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.member_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.game_details.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.lobby_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.game_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.requires_pass_key {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.leader_account_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.member_count {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.game_details.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SpectatorLobby {
            SpectatorLobby::new()
        }

        fn clear(&mut self) {
            self.lobby_id = ::std::option::Option::None;
            self.game_name = ::std::option::Option::None;
            self.requires_pass_key = ::std::option::Option::None;
            self.leader_account_id = ::std::option::Option::None;
            self.member_count = ::std::option::Option::None;
            self.game_details.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SpectatorLobby {
            static instance: SpectatorLobby = SpectatorLobby {
                lobby_id: ::std::option::Option::None,
                game_name: ::std::option::Option::None,
                requires_pass_key: ::std::option::Option::None,
                leader_account_id: ::std::option::Option::None,
                member_count: ::std::option::Option::None,
                game_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestSteamDatagramTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSteamDatagramTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSteamDatagramTicket.server_steam_id)
    pub server_steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestSteamDatagramTicket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSteamDatagramTicket {
    fn default() -> &'a CMsgClientToGCRequestSteamDatagramTicket {
        <CMsgClientToGCRequestSteamDatagramTicket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSteamDatagramTicket {
    pub fn new() -> CMsgClientToGCRequestSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional fixed64 server_steam_id = 1;

    pub fn server_steam_id(&self) -> u64 {
        self.server_steam_id.unwrap_or(0)
    }

    pub fn clear_server_steam_id(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
    }

    pub fn has_server_steam_id(&self) -> bool {
        self.server_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_steam_id(&mut self, v: u64) {
        self.server_steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestSteamDatagramTicket {
    const NAME: &'static str = "CMsgClientToGCRequestSteamDatagramTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.server_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_steam_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSteamDatagramTicket {
        CMsgClientToGCRequestSteamDatagramTicket::new()
    }

    fn clear(&mut self) {
        self.server_steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSteamDatagramTicket {
        static instance: CMsgClientToGCRequestSteamDatagramTicket = CMsgClientToGCRequestSteamDatagramTicket {
            server_steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestSteamDatagramTicketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSteamDatagramTicketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSteamDatagramTicketResponse.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSteamDatagramTicketResponse.message)
    pub message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestSteamDatagramTicketResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSteamDatagramTicketResponse {
    fn default() -> &'a CMsgClientToGCRequestSteamDatagramTicketResponse {
        <CMsgClientToGCRequestSteamDatagramTicketResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSteamDatagramTicketResponse {
    pub fn new() -> CMsgClientToGCRequestSteamDatagramTicketResponse {
        ::std::default::Default::default()
    }

    // optional bytes serialized_ticket = 1;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestSteamDatagramTicketResponse {
    const NAME: &'static str = "CMsgClientToGCRequestSteamDatagramTicketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(1, &v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(1, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSteamDatagramTicketResponse {
        CMsgClientToGCRequestSteamDatagramTicketResponse::new()
    }

    fn clear(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSteamDatagramTicketResponse {
        static instance: CMsgClientToGCRequestSteamDatagramTicketResponse = CMsgClientToGCRequestSteamDatagramTicketResponse {
            serialized_ticket: ::std::option::Option::None,
            message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientSteamDatagramTicket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientSteamDatagramTicket {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_time_expiry)
    pub legacy_time_expiry: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_authorized_steam_id)
    pub legacy_authorized_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_authorized_public_ip)
    pub legacy_authorized_public_ip: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_gameserver_steam_id)
    pub legacy_gameserver_steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_gameserver_net_id)
    pub legacy_gameserver_net_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_signature)
    pub legacy_signature: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_app_id)
    pub legacy_app_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.legacy_extra_fields)
    pub legacy_extra_fields: ::std::vec::Vec<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgGCToClientSteamDatagramTicket.serialized_ticket)
    pub serialized_ticket: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientSteamDatagramTicket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSteamDatagramTicket {
    fn default() -> &'a CMsgGCToClientSteamDatagramTicket {
        <CMsgGCToClientSteamDatagramTicket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSteamDatagramTicket {
    pub fn new() -> CMsgGCToClientSteamDatagramTicket {
        ::std::default::Default::default()
    }

    // optional fixed32 legacy_time_expiry = 1;

    pub fn legacy_time_expiry(&self) -> u32 {
        self.legacy_time_expiry.unwrap_or(0)
    }

    pub fn clear_legacy_time_expiry(&mut self) {
        self.legacy_time_expiry = ::std::option::Option::None;
    }

    pub fn has_legacy_time_expiry(&self) -> bool {
        self.legacy_time_expiry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_time_expiry(&mut self, v: u32) {
        self.legacy_time_expiry = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_authorized_steam_id = 2;

    pub fn legacy_authorized_steam_id(&self) -> u64 {
        self.legacy_authorized_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_authorized_steam_id(&mut self) {
        self.legacy_authorized_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_authorized_steam_id(&self) -> bool {
        self.legacy_authorized_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_authorized_steam_id(&mut self, v: u64) {
        self.legacy_authorized_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 legacy_authorized_public_ip = 3;

    pub fn legacy_authorized_public_ip(&self) -> u32 {
        self.legacy_authorized_public_ip.unwrap_or(0)
    }

    pub fn clear_legacy_authorized_public_ip(&mut self) {
        self.legacy_authorized_public_ip = ::std::option::Option::None;
    }

    pub fn has_legacy_authorized_public_ip(&self) -> bool {
        self.legacy_authorized_public_ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_authorized_public_ip(&mut self, v: u32) {
        self.legacy_authorized_public_ip = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_gameserver_steam_id = 4;

    pub fn legacy_gameserver_steam_id(&self) -> u64 {
        self.legacy_gameserver_steam_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_steam_id(&mut self) {
        self.legacy_gameserver_steam_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_steam_id(&self) -> bool {
        self.legacy_gameserver_steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_steam_id(&mut self, v: u64) {
        self.legacy_gameserver_steam_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 legacy_gameserver_net_id = 5;

    pub fn legacy_gameserver_net_id(&self) -> u64 {
        self.legacy_gameserver_net_id.unwrap_or(0)
    }

    pub fn clear_legacy_gameserver_net_id(&mut self) {
        self.legacy_gameserver_net_id = ::std::option::Option::None;
    }

    pub fn has_legacy_gameserver_net_id(&self) -> bool {
        self.legacy_gameserver_net_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_gameserver_net_id(&mut self, v: u64) {
        self.legacy_gameserver_net_id = ::std::option::Option::Some(v);
    }

    // optional bytes legacy_signature = 6;

    pub fn legacy_signature(&self) -> &[u8] {
        match self.legacy_signature.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_legacy_signature(&mut self) {
        self.legacy_signature = ::std::option::Option::None;
    }

    pub fn has_legacy_signature(&self) -> bool {
        self.legacy_signature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.legacy_signature = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.legacy_signature.is_none() {
            self.legacy_signature = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.legacy_signature.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_signature(&mut self) -> ::std::vec::Vec<u8> {
        self.legacy_signature.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional uint32 legacy_app_id = 7;

    pub fn legacy_app_id(&self) -> u32 {
        self.legacy_app_id.unwrap_or(0)
    }

    pub fn clear_legacy_app_id(&mut self) {
        self.legacy_app_id = ::std::option::Option::None;
    }

    pub fn has_legacy_app_id(&self) -> bool {
        self.legacy_app_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_app_id(&mut self, v: u32) {
        self.legacy_app_id = ::std::option::Option::Some(v);
    }

    // optional bytes serialized_ticket = 16;

    pub fn serialized_ticket(&self) -> &[u8] {
        match self.serialized_ticket.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_serialized_ticket(&mut self) {
        self.serialized_ticket = ::std::option::Option::None;
    }

    pub fn has_serialized_ticket(&self) -> bool {
        self.serialized_ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serialized_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.serialized_ticket = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serialized_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.serialized_ticket.is_none() {
            self.serialized_ticket = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.serialized_ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_serialized_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.serialized_ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientSteamDatagramTicket {
    const NAME: &'static str = "CMsgGCToClientSteamDatagramTicket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.legacy_time_expiry = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.legacy_authorized_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.legacy_authorized_public_ip = ::std::option::Option::Some(is.read_fixed32()?);
                },
                33 => {
                    self.legacy_gameserver_steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                41 => {
                    self.legacy_gameserver_net_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                50 => {
                    self.legacy_signature = ::std::option::Option::Some(is.read_bytes()?);
                },
                56 => {
                    self.legacy_app_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.legacy_extra_fields.push(is.read_bytes()?);
                },
                130 => {
                    self.serialized_ticket = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.legacy_time_expiry {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_authorized_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_authorized_public_ip {
            my_size += 1 + 4;
        }
        if let Some(v) = self.legacy_gameserver_steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_gameserver_net_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.legacy_signature.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(6, &v);
        }
        if let Some(v) = self.legacy_app_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        for value in &self.legacy_extra_fields {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(8, &value);
        };
        if let Some(v) = self.serialized_ticket.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(16, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.legacy_time_expiry {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.legacy_authorized_steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.legacy_authorized_public_ip {
            os.write_fixed32(3, v)?;
        }
        if let Some(v) = self.legacy_gameserver_steam_id {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.legacy_gameserver_net_id {
            os.write_fixed64(5, v)?;
        }
        if let Some(v) = self.legacy_signature.as_ref() {
            os.write_bytes(6, v)?;
        }
        if let Some(v) = self.legacy_app_id {
            os.write_uint32(7, v)?;
        }
        for v in &self.legacy_extra_fields {
            os.write_bytes(8, &v)?;
        };
        if let Some(v) = self.serialized_ticket.as_ref() {
            os.write_bytes(16, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientSteamDatagramTicket {
        CMsgGCToClientSteamDatagramTicket::new()
    }

    fn clear(&mut self) {
        self.legacy_time_expiry = ::std::option::Option::None;
        self.legacy_authorized_steam_id = ::std::option::Option::None;
        self.legacy_authorized_public_ip = ::std::option::Option::None;
        self.legacy_gameserver_steam_id = ::std::option::Option::None;
        self.legacy_gameserver_net_id = ::std::option::Option::None;
        self.legacy_signature = ::std::option::Option::None;
        self.legacy_app_id = ::std::option::Option::None;
        self.legacy_extra_fields.clear();
        self.serialized_ticket = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientSteamDatagramTicket {
        static instance: CMsgGCToClientSteamDatagramTicket = CMsgGCToClientSteamDatagramTicket {
            legacy_time_expiry: ::std::option::Option::None,
            legacy_authorized_steam_id: ::std::option::Option::None,
            legacy_authorized_public_ip: ::std::option::Option::None,
            legacy_gameserver_steam_id: ::std::option::Option::None,
            legacy_gameserver_net_id: ::std::option::Option::None,
            legacy_signature: ::std::option::Option::None,
            legacy_app_id: ::std::option::Option::None,
            legacy_extra_fields: ::std::vec::Vec::new(),
            serialized_ticket: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRequestLaneSelection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestLaneSelection {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRequestLaneSelection.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestLaneSelection {
    fn default() -> &'a CMsgGCToClientRequestLaneSelection {
        <CMsgGCToClientRequestLaneSelection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestLaneSelection {
    pub fn new() -> CMsgGCToClientRequestLaneSelection {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRequestLaneSelection {
    const NAME: &'static str = "CMsgGCToClientRequestLaneSelection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestLaneSelection {
        CMsgGCToClientRequestLaneSelection::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestLaneSelection {
        static instance: CMsgGCToClientRequestLaneSelection = CMsgGCToClientRequestLaneSelection {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRequestLaneSelectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestLaneSelectionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRequestLaneSelectionResponse.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientRequestLaneSelectionResponse.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRequestLaneSelectionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestLaneSelectionResponse {
    fn default() -> &'a CMsgGCToClientRequestLaneSelectionResponse {
        <CMsgGCToClientRequestLaneSelectionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestLaneSelectionResponse {
    pub fn new() -> CMsgGCToClientRequestLaneSelectionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 2;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRequestLaneSelectionResponse {
    const NAME: &'static str = "CMsgGCToClientRequestLaneSelectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestLaneSelectionResponse {
        CMsgGCToClientRequestLaneSelectionResponse::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestLaneSelectionResponse {
        static instance: CMsgGCToClientRequestLaneSelectionResponse = CMsgGCToClientRequestLaneSelectionResponse {
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRequestMMInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestMMInfo {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRequestMMInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestMMInfo {
    fn default() -> &'a CMsgGCToClientRequestMMInfo {
        <CMsgGCToClientRequestMMInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestMMInfo {
    pub fn new() -> CMsgGCToClientRequestMMInfo {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRequestMMInfo {
    const NAME: &'static str = "CMsgGCToClientRequestMMInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestMMInfo {
        CMsgGCToClientRequestMMInfo::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestMMInfo {
        static instance: CMsgGCToClientRequestMMInfo = CMsgGCToClientRequestMMInfo {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCMMInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCMMInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCMMInfo.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCMMInfo.high_priority_disabled)
    pub high_priority_disabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCMMInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCMMInfo {
    fn default() -> &'a CMsgClientToGCMMInfo {
        <CMsgClientToGCMMInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCMMInfo {
    pub fn new() -> CMsgClientToGCMMInfo {
        ::std::default::Default::default()
    }

    // optional uint32 lane_selection_flags = 1;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }

    // optional bool high_priority_disabled = 2;

    pub fn high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.unwrap_or(false)
    }

    pub fn clear_high_priority_disabled(&mut self) {
        self.high_priority_disabled = ::std::option::Option::None;
    }

    pub fn has_high_priority_disabled(&self) -> bool {
        self.high_priority_disabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_high_priority_disabled(&mut self, v: bool) {
        self.high_priority_disabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCMMInfo {
    const NAME: &'static str = "CMsgClientToGCMMInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.high_priority_disabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.high_priority_disabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.high_priority_disabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCMMInfo {
        CMsgClientToGCMMInfo::new()
    }

    fn clear(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
        self.high_priority_disabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCMMInfo {
        static instance: CMsgClientToGCMMInfo = CMsgClientToGCMMInfo {
            lane_selection_flags: ::std::option::Option::None,
            high_priority_disabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EStartFindingMatchResult)
pub enum EStartFindingMatchResult {
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_Invalid)
    k_EStartFindingMatchResult_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_OK)
    k_EStartFindingMatchResult_OK = 1,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_AlreadySearching)
    k_EStartFindingMatchResult_AlreadySearching = 2,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_FailGeneric)
    k_EStartFindingMatchResult_FailGeneric = 100,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_FailedIgnore)
    k_EStartFindingMatchResult_FailedIgnore = 101,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingDisabled)
    k_EStartFindingMatchResult_MatchmakingDisabled = 102,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_RegionOffline)
    k_EStartFindingMatchResult_RegionOffline = 103,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingCooldown)
    k_EStartFindingMatchResult_MatchmakingCooldown = 104,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_ClientOutOfDate)
    k_EStartFindingMatchResult_ClientOutOfDate = 105,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNoLowPriority)
    k_EStartFindingMatchResult_CompetitiveNoLowPriority = 106,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotUnlocked)
    k_EStartFindingMatchResult_CompetitiveNotUnlocked = 107,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_GameModeNotUnlocked)
    k_EStartFindingMatchResult_GameModeNotUnlocked = 108,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime)
    k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime = 109,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MissingInitialSkill)
    k_EStartFindingMatchResult_MissingInitialSkill = 110,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge)
    k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge = 111,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberAlreadyInLobby)
    k_EStartFindingMatchResult_MemberAlreadyInLobby = 112,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberNotVACVerified)
    k_EStartFindingMatchResult_MemberNotVACVerified = 113,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyBadPartySize)
    k_EStartFindingMatchResult_WeekendTourneyBadPartySize = 114,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall)
    k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall = 115,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge)
    k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge = 116,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge)
    k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge = 117,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingEventOwnership)
    k_EStartFindingMatchResult_MemberMissingEventOwnership = 118,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyNotUnlocked)
    k_EStartFindingMatchResult_WeekendTourneyNotUnlocked = 119,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_WeekendTourneyRecentParticipation)
    k_EStartFindingMatchResult_WeekendTourneyRecentParticipation = 120,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber)
    k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber = 121,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_NotMemberOfClan)
    k_EStartFindingMatchResult_NotMemberOfClan = 122,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeBadPartySize)
    k_EStartFindingMatchResult_CoachesChallengeBadPartySize = 123,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet)
    k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet = 124,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_InvalidRoleSelections)
    k_EStartFindingMatchResult_InvalidRoleSelections = 125,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_PhoneNumberDiscrepancy)
    k_EStartFindingMatchResult_PhoneNumberDiscrepancy = 126,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_NoQueuePoints)
    k_EStartFindingMatchResult_NoQueuePoints = 127,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberMissingGauntletFlag)
    k_EStartFindingMatchResult_MemberMissingGauntletFlag = 128,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MemberGauntletTooRecent)
    k_EStartFindingMatchResult_MemberGauntletTooRecent = 129,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_DifficultyNotUnlocked)
    k_EStartFindingMatchResult_DifficultyNotUnlocked = 130,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_CoachesNotAllowedInParty)
    k_EStartFindingMatchResult_CoachesNotAllowedInParty = 131,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_MatchmakingBusy)
    k_EStartFindingMatchResult_MatchmakingBusy = 132,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaBanned)
    k_EStartFindingMatchResult_SteamChinaBanned = 133,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_SteamChinaInvalidMixedParty)
    k_EStartFindingMatchResult_SteamChinaInvalidMixedParty = 134,
    // @@protoc_insertion_point(enum_value:EStartFindingMatchResult.k_EStartFindingMatchResult_RestrictedFromRanked)
    k_EStartFindingMatchResult_RestrictedFromRanked = 135,
}

impl ::steam_vent_proto_common::protobuf::Enum for EStartFindingMatchResult {
    const NAME: &'static str = "EStartFindingMatchResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EStartFindingMatchResult> {
        match value {
            0 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            1 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_OK),
            2 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching),
            100 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric),
            101 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore),
            102 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled),
            103 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline),
            104 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown),
            105 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate),
            106 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority),
            107 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked),
            108 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked),
            109 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime),
            110 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill),
            111 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge),
            112 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby),
            113 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified),
            114 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize),
            115 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall),
            116 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge),
            117 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge),
            118 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership),
            119 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked),
            120 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation),
            121 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber),
            122 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan),
            123 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize),
            124 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet),
            125 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections),
            126 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy),
            127 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints),
            128 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag),
            129 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent),
            130 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked),
            131 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty),
            132 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy),
            133 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned),
            134 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty),
            135 => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RestrictedFromRanked),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EStartFindingMatchResult> {
        match str {
            "k_EStartFindingMatchResult_Invalid" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid),
            "k_EStartFindingMatchResult_OK" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_OK),
            "k_EStartFindingMatchResult_AlreadySearching" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching),
            "k_EStartFindingMatchResult_FailGeneric" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric),
            "k_EStartFindingMatchResult_FailedIgnore" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore),
            "k_EStartFindingMatchResult_MatchmakingDisabled" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled),
            "k_EStartFindingMatchResult_RegionOffline" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline),
            "k_EStartFindingMatchResult_MatchmakingCooldown" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown),
            "k_EStartFindingMatchResult_ClientOutOfDate" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate),
            "k_EStartFindingMatchResult_CompetitiveNoLowPriority" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority),
            "k_EStartFindingMatchResult_CompetitiveNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked),
            "k_EStartFindingMatchResult_GameModeNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked),
            "k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime),
            "k_EStartFindingMatchResult_MissingInitialSkill" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill),
            "k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge),
            "k_EStartFindingMatchResult_MemberAlreadyInLobby" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby),
            "k_EStartFindingMatchResult_MemberNotVACVerified" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified),
            "k_EStartFindingMatchResult_WeekendTourneyBadPartySize" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize),
            "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall),
            "k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge),
            "k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge),
            "k_EStartFindingMatchResult_MemberMissingEventOwnership" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership),
            "k_EStartFindingMatchResult_WeekendTourneyNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked),
            "k_EStartFindingMatchResult_WeekendTourneyRecentParticipation" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation),
            "k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber),
            "k_EStartFindingMatchResult_NotMemberOfClan" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan),
            "k_EStartFindingMatchResult_CoachesChallengeBadPartySize" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize),
            "k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet),
            "k_EStartFindingMatchResult_InvalidRoleSelections" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections),
            "k_EStartFindingMatchResult_PhoneNumberDiscrepancy" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy),
            "k_EStartFindingMatchResult_NoQueuePoints" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints),
            "k_EStartFindingMatchResult_MemberMissingGauntletFlag" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag),
            "k_EStartFindingMatchResult_MemberGauntletTooRecent" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent),
            "k_EStartFindingMatchResult_DifficultyNotUnlocked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked),
            "k_EStartFindingMatchResult_CoachesNotAllowedInParty" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty),
            "k_EStartFindingMatchResult_MatchmakingBusy" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy),
            "k_EStartFindingMatchResult_SteamChinaBanned" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned),
            "k_EStartFindingMatchResult_SteamChinaInvalidMixedParty" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty),
            "k_EStartFindingMatchResult_RestrictedFromRanked" => ::std::option::Option::Some(EStartFindingMatchResult::k_EStartFindingMatchResult_RestrictedFromRanked),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EStartFindingMatchResult] = &[
        EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid,
        EStartFindingMatchResult::k_EStartFindingMatchResult_OK,
        EStartFindingMatchResult::k_EStartFindingMatchResult_AlreadySearching,
        EStartFindingMatchResult::k_EStartFindingMatchResult_FailGeneric,
        EStartFindingMatchResult::k_EStartFindingMatchResult_FailedIgnore,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingDisabled,
        EStartFindingMatchResult::k_EStartFindingMatchResult_RegionOffline,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingCooldown,
        EStartFindingMatchResult::k_EStartFindingMatchResult_ClientOutOfDate,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNoLowPriority,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_GameModeNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveNotEnoughPlayTime,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MissingInitialSkill,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CompetitiveRankSpreadTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberAlreadyInLobby,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberNotVACVerified,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyBadPartySize,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooSmall,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyIndividualBuyInTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyTeamBuyInTooLarge,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingEventOwnership,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_WeekendTourneyRecentParticipation,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingAnchoredPhoneNumber,
        EStartFindingMatchResult::k_EStartFindingMatchResult_NotMemberOfClan,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeBadPartySize,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesChallengeRequirementsNotMet,
        EStartFindingMatchResult::k_EStartFindingMatchResult_InvalidRoleSelections,
        EStartFindingMatchResult::k_EStartFindingMatchResult_PhoneNumberDiscrepancy,
        EStartFindingMatchResult::k_EStartFindingMatchResult_NoQueuePoints,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberMissingGauntletFlag,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MemberGauntletTooRecent,
        EStartFindingMatchResult::k_EStartFindingMatchResult_DifficultyNotUnlocked,
        EStartFindingMatchResult::k_EStartFindingMatchResult_CoachesNotAllowedInParty,
        EStartFindingMatchResult::k_EStartFindingMatchResult_MatchmakingBusy,
        EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaBanned,
        EStartFindingMatchResult::k_EStartFindingMatchResult_SteamChinaInvalidMixedParty,
        EStartFindingMatchResult::k_EStartFindingMatchResult_RestrictedFromRanked,
    ];
}

impl ::std::default::Default for EStartFindingMatchResult {
    fn default() -> Self {
        EStartFindingMatchResult::k_EStartFindingMatchResult_Invalid
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_client_enums::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_lobby::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgStartFindingMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStartFindingMatchResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgStopFindingMatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyBuilderOptions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReadyUp {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgReadyUpStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAbandonCurrentGame {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyScenarioSave {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbySetDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyCreate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbySetTeamSlot {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbySetCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyJoinBroadcastChannel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyCloseBroadcastChannel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgPracticeLobbyToggleBroadcastChannelCameramanStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyKick {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyKickFromTeam {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyLeave {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyLaunch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyTeamToPracticeLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyListResponseEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyJoin {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPracticeLobbyJoinResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFriendPracticeLobbyListRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFriendPracticeLobbyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomGameModesRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomGameModesResponseEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomGameModesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomLobbiesRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomLobbiesResponseEntry {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgJoinableCustomLobbiesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuickJoinCustomLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgQuickJoinCustomLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBotGameCreate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPartyMemberSetCoach {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetGroupLeader {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACancelGroupInvites {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetGroupOpenStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGroupMergeInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGroupMergeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGroupMergeReply {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSpectatorLobbyGameDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSpectatorLobbyGameDetails {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgSpectatorLobbyGameDetails;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetSpectatorLobbyDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCreateSpectatorLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSpectatorLobbyList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSpectatorLobbyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestSteamDatagramTicket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestSteamDatagramTicket {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestSteamDatagramTicket;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestSteamDatagramTicketResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestSteamDatagramTicketResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestSteamDatagramTicketResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientSteamDatagramTicket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientSteamDatagramTicket {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientSteamDatagramTicket;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRequestLaneSelection {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRequestLaneSelection {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRequestLaneSelection;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientRequestLaneSelectionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRequestLaneSelectionResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRequestLaneSelectionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRequestMMInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientRequestMMInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRequestMMInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCMMInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCMMInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCMMInfo;
}
