// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `base_gcmessages.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CGCStorePurchaseInit_LineItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CGCStorePurchaseInit_LineItem {
    // message fields
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.item_def_id)
    pub item_def_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.cost_in_local_currency)
    pub cost_in_local_currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.purchase_type)
    pub purchase_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.source_reference_id)
    pub source_reference_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CGCStorePurchaseInit_LineItem.price_index)
    pub price_index: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CGCStorePurchaseInit_LineItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CGCStorePurchaseInit_LineItem {
    fn default() -> &'a CGCStorePurchaseInit_LineItem {
        <CGCStorePurchaseInit_LineItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CGCStorePurchaseInit_LineItem {
    pub fn new() -> CGCStorePurchaseInit_LineItem {
        ::std::default::Default::default()
    }

    // optional uint32 item_def_id = 1;

    pub fn item_def_id(&self) -> u32 {
        self.item_def_id.unwrap_or(0)
    }

    pub fn clear_item_def_id(&mut self) {
        self.item_def_id = ::std::option::Option::None;
    }

    pub fn has_item_def_id(&self) -> bool {
        self.item_def_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def_id(&mut self, v: u32) {
        self.item_def_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 cost_in_local_currency = 3;

    pub fn cost_in_local_currency(&self) -> u32 {
        self.cost_in_local_currency.unwrap_or(0)
    }

    pub fn clear_cost_in_local_currency(&mut self) {
        self.cost_in_local_currency = ::std::option::Option::None;
    }

    pub fn has_cost_in_local_currency(&self) -> bool {
        self.cost_in_local_currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_in_local_currency(&mut self, v: u32) {
        self.cost_in_local_currency = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_type = 4;

    pub fn purchase_type(&self) -> u32 {
        self.purchase_type.unwrap_or(0)
    }

    pub fn clear_purchase_type(&mut self) {
        self.purchase_type = ::std::option::Option::None;
    }

    pub fn has_purchase_type(&self) -> bool {
        self.purchase_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_type(&mut self, v: u32) {
        self.purchase_type = ::std::option::Option::Some(v);
    }

    // optional uint64 source_reference_id = 5;

    pub fn source_reference_id(&self) -> u64 {
        self.source_reference_id.unwrap_or(0)
    }

    pub fn clear_source_reference_id(&mut self) {
        self.source_reference_id = ::std::option::Option::None;
    }

    pub fn has_source_reference_id(&self) -> bool {
        self.source_reference_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_reference_id(&mut self, v: u64) {
        self.source_reference_id = ::std::option::Option::Some(v);
    }

    // optional int32 price_index = 6;

    pub fn price_index(&self) -> i32 {
        self.price_index.unwrap_or(0)
    }

    pub fn clear_price_index(&mut self) {
        self.price_index = ::std::option::Option::None;
    }

    pub fn has_price_index(&self) -> bool {
        self.price_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_price_index(&mut self, v: i32) {
        self.price_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CGCStorePurchaseInit_LineItem {
    const NAME: &'static str = "CGCStorePurchaseInit_LineItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cost_in_local_currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.purchase_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.source_reference_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                48 => {
                    self.price_index = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cost_in_local_currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.purchase_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.source_reference_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
        }
        if let Some(v) = self.price_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cost_in_local_currency {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.purchase_type {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.source_reference_id {
            os.write_uint64(5, v)?;
        }
        if let Some(v) = self.price_index {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CGCStorePurchaseInit_LineItem {
        CGCStorePurchaseInit_LineItem::new()
    }

    fn clear(&mut self) {
        self.item_def_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.cost_in_local_currency = ::std::option::Option::None;
        self.purchase_type = ::std::option::Option::None;
        self.source_reference_id = ::std::option::Option::None;
        self.price_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CGCStorePurchaseInit_LineItem {
        static instance: CGCStorePurchaseInit_LineItem = CGCStorePurchaseInit_LineItem {
            item_def_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            cost_in_local_currency: ::std::option::Option::None,
            purchase_type: ::std::option::Option::None,
            source_reference_id: ::std::option::Option::None,
            price_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseInit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInit {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.country)
    pub country: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.language)
    pub language: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.currency)
    pub currency: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInit.line_items)
    pub line_items: ::std::vec::Vec<CGCStorePurchaseInit_LineItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInit {
    fn default() -> &'a CMsgGCStorePurchaseInit {
        <CMsgGCStorePurchaseInit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInit {
    pub fn new() -> CMsgGCStorePurchaseInit {
        ::std::default::Default::default()
    }

    // optional string country = 1;

    pub fn country(&self) -> &str {
        match self.country.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country(&mut self) {
        self.country = ::std::option::Option::None;
    }

    pub fn has_country(&self) -> bool {
        self.country.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        if self.country.is_none() {
            self.country = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country.as_mut().unwrap()
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        self.country.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 language = 2;

    pub fn language(&self) -> i32 {
        self.language.unwrap_or(0)
    }

    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional int32 currency = 3;

    pub fn currency(&self) -> i32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: i32) {
        self.currency = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseInit {
    const NAME: &'static str = "CMsgGCStorePurchaseInit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.country = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.language = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.currency = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.line_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.country.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.language {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        for value in &self.line_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.country.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.currency {
            os.write_int32(3, v)?;
        }
        for v in &self.line_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInit {
        CMsgGCStorePurchaseInit::new()
    }

    fn clear(&mut self) {
        self.country = ::std::option::Option::None;
        self.language = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.line_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInit {
        static instance: CMsgGCStorePurchaseInit = CMsgGCStorePurchaseInit {
            country: ::std::option::Option::None,
            language: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            line_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseInitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseInitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.result)
    pub result: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseInitResponse.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseInitResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseInitResponse {
    fn default() -> &'a CMsgGCStorePurchaseInitResponse {
        <CMsgGCStorePurchaseInitResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseInitResponse {
    pub fn new() -> CMsgGCStorePurchaseInitResponse {
        ::std::default::Default::default()
    }

    // optional int32 result = 1;

    pub fn result(&self) -> i32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: i32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint64 txn_id = 2;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseInitResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseInitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.txn_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseInitResponse {
        CMsgGCStorePurchaseInitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseInitResponse {
        static instance: CMsgGCStorePurchaseInitResponse = CMsgGCStorePurchaseInitResponse {
            result: ::std::option::Option::None,
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientPingData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientPingData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientPingData.relay_codes)
    pub relay_codes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPingData.relay_pings)
    pub relay_pings: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPingData.region_codes)
    pub region_codes: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPingData.region_pings)
    pub region_pings: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientPingData.region_ping_failed_bitmask)
    pub region_ping_failed_bitmask: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientPingData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientPingData {
    fn default() -> &'a CMsgClientPingData {
        <CMsgClientPingData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientPingData {
    pub fn new() -> CMsgClientPingData {
        ::std::default::Default::default()
    }

    // optional uint32 region_ping_failed_bitmask = 10;

    pub fn region_ping_failed_bitmask(&self) -> u32 {
        self.region_ping_failed_bitmask.unwrap_or(0)
    }

    pub fn clear_region_ping_failed_bitmask(&mut self) {
        self.region_ping_failed_bitmask = ::std::option::Option::None;
    }

    pub fn has_region_ping_failed_bitmask(&self) -> bool {
        self.region_ping_failed_bitmask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region_ping_failed_bitmask(&mut self, v: u32) {
        self.region_ping_failed_bitmask = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientPingData {
    const NAME: &'static str = "CMsgClientPingData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    is.read_repeated_packed_fixed32_into(&mut self.relay_codes)?;
                },
                37 => {
                    self.relay_codes.push(is.read_fixed32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.relay_pings)?;
                },
                40 => {
                    self.relay_pings.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.region_codes)?;
                },
                64 => {
                    self.region_codes.push(is.read_uint32()?);
                },
                74 => {
                    is.read_repeated_packed_uint32_into(&mut self.region_pings)?;
                },
                72 => {
                    self.region_pings.push(is.read_uint32()?);
                },
                80 => {
                    self.region_ping_failed_bitmask = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_fixed32_size(4, &self.relay_codes);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(5, &self.relay_pings);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(8, &self.region_codes);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(9, &self.region_pings);
        if let Some(v) = self.region_ping_failed_bitmask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_repeated_packed_fixed32(4, &self.relay_codes)?;
        os.write_repeated_packed_uint32(5, &self.relay_pings)?;
        os.write_repeated_packed_uint32(8, &self.region_codes)?;
        os.write_repeated_packed_uint32(9, &self.region_pings)?;
        if let Some(v) = self.region_ping_failed_bitmask {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientPingData {
        CMsgClientPingData::new()
    }

    fn clear(&mut self) {
        self.relay_codes.clear();
        self.relay_pings.clear();
        self.region_codes.clear();
        self.region_pings.clear();
        self.region_ping_failed_bitmask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientPingData {
        static instance: CMsgClientPingData = CMsgClientPingData {
            relay_codes: ::std::vec::Vec::new(),
            relay_pings: ::std::vec::Vec::new(),
            region_codes: ::std::vec::Vec::new(),
            region_pings: ::std::vec::Vec::new(),
            region_ping_failed_bitmask: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInviteToParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInviteToParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgInviteToParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.as_coach)
    pub as_coach: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgInviteToParty.ping_data)
    pub ping_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInviteToParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToParty {
    fn default() -> &'a CMsgInviteToParty {
        <CMsgInviteToParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToParty {
    pub fn new() -> CMsgInviteToParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 3;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional bool as_coach = 4;

    pub fn as_coach(&self) -> bool {
        self.as_coach.unwrap_or(false)
    }

    pub fn clear_as_coach(&mut self) {
        self.as_coach = ::std::option::Option::None;
    }

    pub fn has_as_coach(&self) -> bool {
        self.as_coach.is_some()
    }

    // Param is passed by value, moved
    pub fn set_as_coach(&mut self, v: bool) {
        self.as_coach = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgInviteToParty {
    const NAME: &'static str = "CMsgInviteToParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.as_coach = ::std::option::Option::Some(is.read_bool()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.as_coach {
            my_size += 1 + 1;
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.as_coach {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInviteToParty {
        CMsgInviteToParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.as_coach = ::std::option::Option::None;
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInviteToParty {
        static instance: CMsgInviteToParty = CMsgInviteToParty {
            steam_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            as_coach: ::std::option::Option::None,
            ping_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInviteToLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInviteToLobby {
    // message fields
    // @@protoc_insertion_point(field:CMsgInviteToLobby.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInviteToLobby.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInviteToLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInviteToLobby {
    fn default() -> &'a CMsgInviteToLobby {
        <CMsgInviteToLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgInviteToLobby {
    pub fn new() -> CMsgInviteToLobby {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgInviteToLobby {
    const NAME: &'static str = "CMsgInviteToLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInviteToLobby {
        CMsgInviteToLobby::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInviteToLobby {
        static instance: CMsgInviteToLobby = CMsgInviteToLobby {
            steam_id: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInvitationCreated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInvitationCreated {
    // message fields
    // @@protoc_insertion_point(field:CMsgInvitationCreated.group_id)
    pub group_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInvitationCreated.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgInvitationCreated.user_offline)
    pub user_offline: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInvitationCreated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInvitationCreated {
    fn default() -> &'a CMsgInvitationCreated {
        <CMsgInvitationCreated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgInvitationCreated {
    pub fn new() -> CMsgInvitationCreated {
        ::std::default::Default::default()
    }

    // optional uint64 group_id = 1;

    pub fn group_id(&self) -> u64 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u64) {
        self.group_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 steam_id = 2;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }

    // optional bool user_offline = 3;

    pub fn user_offline(&self) -> bool {
        self.user_offline.unwrap_or(false)
    }

    pub fn clear_user_offline(&mut self) {
        self.user_offline = ::std::option::Option::None;
    }

    pub fn has_user_offline(&self) -> bool {
        self.user_offline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_offline(&mut self, v: bool) {
        self.user_offline = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgInvitationCreated {
    const NAME: &'static str = "CMsgInvitationCreated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                17 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                24 => {
                    self.user_offline = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.user_offline {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.steam_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.user_offline {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInvitationCreated {
        CMsgInvitationCreated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.steam_id = ::std::option::Option::None;
        self.user_offline = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInvitationCreated {
        static instance: CMsgInvitationCreated = CMsgInvitationCreated {
            group_id: ::std::option::Option::None,
            steam_id: ::std::option::Option::None,
            user_offline: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPartyInviteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartyInviteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartyInviteResponse.ping_data)
    pub ping_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgClientPingData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartyInviteResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartyInviteResponse {
    fn default() -> &'a CMsgPartyInviteResponse {
        <CMsgPartyInviteResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartyInviteResponse {
    pub fn new() -> CMsgPartyInviteResponse {
        ::std::default::Default::default()
    }

    // optional uint64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartyInviteResponse {
    const NAME: &'static str = "CMsgPartyInviteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.party_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.ping_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.ping_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.ping_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartyInviteResponse {
        CMsgPartyInviteResponse::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.ping_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartyInviteResponse {
        static instance: CMsgPartyInviteResponse = CMsgPartyInviteResponse {
            party_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            ping_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyInviteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyInviteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyInviteResponse.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgLobbyInviteResponse.accept)
    pub accept: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgLobbyInviteResponse.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyInviteResponse.custom_game_crc)
    pub custom_game_crc: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgLobbyInviteResponse.custom_game_timestamp)
    pub custom_game_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyInviteResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyInviteResponse {
    fn default() -> &'a CMsgLobbyInviteResponse {
        <CMsgLobbyInviteResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyInviteResponse {
    pub fn new() -> CMsgLobbyInviteResponse {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional bool accept = 2;

    pub fn accept(&self) -> bool {
        self.accept.unwrap_or(false)
    }

    pub fn clear_accept(&mut self) {
        self.accept = ::std::option::Option::None;
    }

    pub fn has_accept(&self) -> bool {
        self.accept.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accept(&mut self, v: bool) {
        self.accept = ::std::option::Option::Some(v);
    }

    // optional uint32 client_version = 3;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_crc = 6;

    pub fn custom_game_crc(&self) -> u64 {
        self.custom_game_crc.unwrap_or(0)
    }

    pub fn clear_custom_game_crc(&mut self) {
        self.custom_game_crc = ::std::option::Option::None;
    }

    pub fn has_custom_game_crc(&self) -> bool {
        self.custom_game_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_crc(&mut self, v: u64) {
        self.custom_game_crc = ::std::option::Option::Some(v);
    }

    // optional fixed32 custom_game_timestamp = 7;

    pub fn custom_game_timestamp(&self) -> u32 {
        self.custom_game_timestamp.unwrap_or(0)
    }

    pub fn clear_custom_game_timestamp(&mut self) {
        self.custom_game_timestamp = ::std::option::Option::None;
    }

    pub fn has_custom_game_timestamp(&self) -> bool {
        self.custom_game_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_timestamp(&mut self, v: u32) {
        self.custom_game_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyInviteResponse {
    const NAME: &'static str = "CMsgLobbyInviteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.accept = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.custom_game_crc = ::std::option::Option::Some(is.read_fixed64()?);
                },
                61 => {
                    self.custom_game_timestamp = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.accept {
            my_size += 1 + 1;
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.custom_game_crc {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_timestamp {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.accept {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.custom_game_crc {
            os.write_fixed64(6, v)?;
        }
        if let Some(v) = self.custom_game_timestamp {
            os.write_fixed32(7, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyInviteResponse {
        CMsgLobbyInviteResponse::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.accept = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.custom_game_crc = ::std::option::Option::None;
        self.custom_game_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyInviteResponse {
        static instance: CMsgLobbyInviteResponse = CMsgLobbyInviteResponse {
            lobby_id: ::std::option::Option::None,
            accept: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            custom_game_crc: ::std::option::Option::None,
            custom_game_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgKickFromParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgKickFromParty {
    // message fields
    // @@protoc_insertion_point(field:CMsgKickFromParty.steam_id)
    pub steam_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgKickFromParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgKickFromParty {
    fn default() -> &'a CMsgKickFromParty {
        <CMsgKickFromParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgKickFromParty {
    pub fn new() -> CMsgKickFromParty {
        ::std::default::Default::default()
    }

    // optional fixed64 steam_id = 1;

    pub fn steam_id(&self) -> u64 {
        self.steam_id.unwrap_or(0)
    }

    pub fn clear_steam_id(&mut self) {
        self.steam_id = ::std::option::Option::None;
    }

    pub fn has_steam_id(&self) -> bool {
        self.steam_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steam_id(&mut self, v: u64) {
        self.steam_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgKickFromParty {
    const NAME: &'static str = "CMsgKickFromParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.steam_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.steam_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgKickFromParty {
        CMsgKickFromParty::new()
    }

    fn clear(&mut self) {
        self.steam_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgKickFromParty {
        static instance: CMsgKickFromParty = CMsgKickFromParty {
            steam_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLeaveParty)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLeaveParty {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLeaveParty.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLeaveParty {
    fn default() -> &'a CMsgLeaveParty {
        <CMsgLeaveParty as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLeaveParty {
    pub fn new() -> CMsgLeaveParty {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLeaveParty {
    const NAME: &'static str = "CMsgLeaveParty";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLeaveParty {
        CMsgLeaveParty::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLeaveParty {
        static instance: CMsgLeaveParty = CMsgLeaveParty {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgCustomGameInstallStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgCustomGameInstallStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgCustomGameInstallStatus.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ECustomGameInstallStatus>>,
    // @@protoc_insertion_point(field:CMsgCustomGameInstallStatus.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgCustomGameInstallStatus.latest_timestamp_from_steam)
    pub latest_timestamp_from_steam: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgCustomGameInstallStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgCustomGameInstallStatus {
    fn default() -> &'a CMsgCustomGameInstallStatus {
        <CMsgCustomGameInstallStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgCustomGameInstallStatus {
    pub fn new() -> CMsgCustomGameInstallStatus {
        ::std::default::Default::default()
    }

    // optional .ECustomGameInstallStatus status = 1;

    pub fn status(&self) -> ECustomGameInstallStatus {
        match self.status {
            Some(e) => e.enum_value_or(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            None => ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ECustomGameInstallStatus) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string message = 2;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional fixed32 latest_timestamp_from_steam = 3;

    pub fn latest_timestamp_from_steam(&self) -> u32 {
        self.latest_timestamp_from_steam.unwrap_or(0)
    }

    pub fn clear_latest_timestamp_from_steam(&mut self) {
        self.latest_timestamp_from_steam = ::std::option::Option::None;
    }

    pub fn has_latest_timestamp_from_steam(&self) -> bool {
        self.latest_timestamp_from_steam.is_some()
    }

    // Param is passed by value, moved
    pub fn set_latest_timestamp_from_steam(&mut self, v: u32) {
        self.latest_timestamp_from_steam = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgCustomGameInstallStatus {
    const NAME: &'static str = "CMsgCustomGameInstallStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                29 => {
                    self.latest_timestamp_from_steam = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.latest_timestamp_from_steam {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.status {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.latest_timestamp_from_steam {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgCustomGameInstallStatus {
        CMsgCustomGameInstallStatus::new()
    }

    fn clear(&mut self) {
        self.status = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.latest_timestamp_from_steam = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgCustomGameInstallStatus {
        static instance: CMsgCustomGameInstallStatus = CMsgCustomGameInstallStatus {
            status: ::std::option::Option::None,
            message: ::std::option::Option::None,
            latest_timestamp_from_steam: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgServerAvailable.custom_game_install_status)
    pub custom_game_install_status: ::steam_vent_proto_common::protobuf::MessageField<CMsgCustomGameInstallStatus>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgServerAvailable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgServerAvailable {
    fn default() -> &'a CMsgServerAvailable {
        <CMsgServerAvailable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgServerAvailable {
    pub fn new() -> CMsgServerAvailable {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgServerAvailable {
    const NAME: &'static str = "CMsgServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.custom_game_install_status)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_install_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.custom_game_install_status.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgServerAvailable {
        CMsgServerAvailable::new()
    }

    fn clear(&mut self) {
        self.custom_game_install_status.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgServerAvailable {
        static instance: CMsgServerAvailable = CMsgServerAvailable {
            custom_game_install_status: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLANServerAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLANServerAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgLANServerAvailable.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLANServerAvailable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLANServerAvailable {
    fn default() -> &'a CMsgLANServerAvailable {
        <CMsgLANServerAvailable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLANServerAvailable {
    pub fn new() -> CMsgLANServerAvailable {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLANServerAvailable {
    const NAME: &'static str = "CMsgLANServerAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLANServerAvailable {
        CMsgLANServerAvailable::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLANServerAvailable {
        static instance: CMsgLANServerAvailable = CMsgLANServerAvailable {
            lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconGameAccountClient)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconGameAccountClient {
    // message fields
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.additional_backpack_slots)
    pub additional_backpack_slots: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trial_account)
    pub trial_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.eligible_for_online_play)
    pub eligible_for_online_play: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.need_to_choose_most_helpful_friend)
    pub need_to_choose_most_helpful_friend: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.in_coaches_list)
    pub in_coaches_list: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.trade_ban_expiration)
    pub trade_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.duel_ban_expiration)
    pub duel_ban_expiration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconGameAccountClient.made_first_purchase)
    pub made_first_purchase: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconGameAccountClient.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconGameAccountClient {
    fn default() -> &'a CSOEconGameAccountClient {
        <CSOEconGameAccountClient as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconGameAccountClient {
    pub fn new() -> CSOEconGameAccountClient {
        ::std::default::Default::default()
    }

    // optional uint32 additional_backpack_slots = 1;

    pub fn additional_backpack_slots(&self) -> u32 {
        self.additional_backpack_slots.unwrap_or(0u32)
    }

    pub fn clear_additional_backpack_slots(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
    }

    pub fn has_additional_backpack_slots(&self) -> bool {
        self.additional_backpack_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_backpack_slots(&mut self, v: u32) {
        self.additional_backpack_slots = ::std::option::Option::Some(v);
    }

    // optional bool trial_account = 2;

    pub fn trial_account(&self) -> bool {
        self.trial_account.unwrap_or(false)
    }

    pub fn clear_trial_account(&mut self) {
        self.trial_account = ::std::option::Option::None;
    }

    pub fn has_trial_account(&self) -> bool {
        self.trial_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trial_account(&mut self, v: bool) {
        self.trial_account = ::std::option::Option::Some(v);
    }

    // optional bool eligible_for_online_play = 3;

    pub fn eligible_for_online_play(&self) -> bool {
        self.eligible_for_online_play.unwrap_or(true)
    }

    pub fn clear_eligible_for_online_play(&mut self) {
        self.eligible_for_online_play = ::std::option::Option::None;
    }

    pub fn has_eligible_for_online_play(&self) -> bool {
        self.eligible_for_online_play.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eligible_for_online_play(&mut self, v: bool) {
        self.eligible_for_online_play = ::std::option::Option::Some(v);
    }

    // optional bool need_to_choose_most_helpful_friend = 4;

    pub fn need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.unwrap_or(false)
    }

    pub fn clear_need_to_choose_most_helpful_friend(&mut self) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
    }

    pub fn has_need_to_choose_most_helpful_friend(&self) -> bool {
        self.need_to_choose_most_helpful_friend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_need_to_choose_most_helpful_friend(&mut self, v: bool) {
        self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(v);
    }

    // optional bool in_coaches_list = 5;

    pub fn in_coaches_list(&self) -> bool {
        self.in_coaches_list.unwrap_or(false)
    }

    pub fn clear_in_coaches_list(&mut self) {
        self.in_coaches_list = ::std::option::Option::None;
    }

    pub fn has_in_coaches_list(&self) -> bool {
        self.in_coaches_list.is_some()
    }

    // Param is passed by value, moved
    pub fn set_in_coaches_list(&mut self, v: bool) {
        self.in_coaches_list = ::std::option::Option::Some(v);
    }

    // optional fixed32 trade_ban_expiration = 6;

    pub fn trade_ban_expiration(&self) -> u32 {
        self.trade_ban_expiration.unwrap_or(0)
    }

    pub fn clear_trade_ban_expiration(&mut self) {
        self.trade_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_trade_ban_expiration(&self) -> bool {
        self.trade_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trade_ban_expiration(&mut self, v: u32) {
        self.trade_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional fixed32 duel_ban_expiration = 7;

    pub fn duel_ban_expiration(&self) -> u32 {
        self.duel_ban_expiration.unwrap_or(0)
    }

    pub fn clear_duel_ban_expiration(&mut self) {
        self.duel_ban_expiration = ::std::option::Option::None;
    }

    pub fn has_duel_ban_expiration(&self) -> bool {
        self.duel_ban_expiration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duel_ban_expiration(&mut self, v: u32) {
        self.duel_ban_expiration = ::std::option::Option::Some(v);
    }

    // optional bool made_first_purchase = 9;

    pub fn made_first_purchase(&self) -> bool {
        self.made_first_purchase.unwrap_or(false)
    }

    pub fn clear_made_first_purchase(&mut self) {
        self.made_first_purchase = ::std::option::Option::None;
    }

    pub fn has_made_first_purchase(&self) -> bool {
        self.made_first_purchase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_made_first_purchase(&mut self, v: bool) {
        self.made_first_purchase = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconGameAccountClient {
    const NAME: &'static str = "CSOEconGameAccountClient";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_backpack_slots = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trial_account = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.eligible_for_online_play = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.need_to_choose_most_helpful_friend = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.in_coaches_list = ::std::option::Option::Some(is.read_bool()?);
                },
                53 => {
                    self.trade_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                61 => {
                    self.duel_ban_expiration = ::std::option::Option::Some(is.read_fixed32()?);
                },
                72 => {
                    self.made_first_purchase = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_backpack_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trial_account {
            my_size += 1 + 1;
        }
        if let Some(v) = self.eligible_for_online_play {
            my_size += 1 + 1;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            my_size += 1 + 1;
        }
        if let Some(v) = self.in_coaches_list {
            my_size += 1 + 1;
        }
        if let Some(v) = self.trade_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.duel_ban_expiration {
            my_size += 1 + 4;
        }
        if let Some(v) = self.made_first_purchase {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.additional_backpack_slots {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trial_account {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.eligible_for_online_play {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.need_to_choose_most_helpful_friend {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.in_coaches_list {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.trade_ban_expiration {
            os.write_fixed32(6, v)?;
        }
        if let Some(v) = self.duel_ban_expiration {
            os.write_fixed32(7, v)?;
        }
        if let Some(v) = self.made_first_purchase {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconGameAccountClient {
        CSOEconGameAccountClient::new()
    }

    fn clear(&mut self) {
        self.additional_backpack_slots = ::std::option::Option::None;
        self.trial_account = ::std::option::Option::None;
        self.eligible_for_online_play = ::std::option::Option::None;
        self.need_to_choose_most_helpful_friend = ::std::option::Option::None;
        self.in_coaches_list = ::std::option::Option::None;
        self.trade_ban_expiration = ::std::option::Option::None;
        self.duel_ban_expiration = ::std::option::Option::None;
        self.made_first_purchase = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconGameAccountClient {
        static instance: CSOEconGameAccountClient = CSOEconGameAccountClient {
            additional_backpack_slots: ::std::option::Option::None,
            trial_account: ::std::option::Option::None,
            eligible_for_online_play: ::std::option::Option::None,
            need_to_choose_most_helpful_friend: ::std::option::Option::None,
            in_coaches_list: ::std::option::Option::None,
            trade_ban_expiration: ::std::option::Option::None,
            duel_ban_expiration: ::std::option::Option::None,
            made_first_purchase: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyStrangePart)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyStrangePart {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.strange_part_item_id)
    pub strange_part_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyStrangePart.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyStrangePart.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyStrangePart {
    fn default() -> &'a CMsgApplyStrangePart {
        <CMsgApplyStrangePart as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyStrangePart {
    pub fn new() -> CMsgApplyStrangePart {
        ::std::default::Default::default()
    }

    // optional uint64 strange_part_item_id = 1;

    pub fn strange_part_item_id(&self) -> u64 {
        self.strange_part_item_id.unwrap_or(0)
    }

    pub fn clear_strange_part_item_id(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
    }

    pub fn has_strange_part_item_id(&self) -> bool {
        self.strange_part_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_strange_part_item_id(&mut self, v: u64) {
        self.strange_part_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyStrangePart {
    const NAME: &'static str = "CMsgApplyStrangePart";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.strange_part_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.strange_part_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.strange_part_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyStrangePart {
        CMsgApplyStrangePart::new()
    }

    fn clear(&mut self) {
        self.strange_part_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyStrangePart {
        static instance: CMsgApplyStrangePart = CMsgApplyStrangePart {
            strange_part_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyPennantUpgrade)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyPennantUpgrade {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyPennantUpgrade.upgrade_item_id)
    pub upgrade_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyPennantUpgrade.pennant_item_id)
    pub pennant_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyPennantUpgrade.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyPennantUpgrade {
    fn default() -> &'a CMsgApplyPennantUpgrade {
        <CMsgApplyPennantUpgrade as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyPennantUpgrade {
    pub fn new() -> CMsgApplyPennantUpgrade {
        ::std::default::Default::default()
    }

    // optional uint64 upgrade_item_id = 1;

    pub fn upgrade_item_id(&self) -> u64 {
        self.upgrade_item_id.unwrap_or(0)
    }

    pub fn clear_upgrade_item_id(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
    }

    pub fn has_upgrade_item_id(&self) -> bool {
        self.upgrade_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_item_id(&mut self, v: u64) {
        self.upgrade_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 pennant_item_id = 2;

    pub fn pennant_item_id(&self) -> u64 {
        self.pennant_item_id.unwrap_or(0)
    }

    pub fn clear_pennant_item_id(&mut self) {
        self.pennant_item_id = ::std::option::Option::None;
    }

    pub fn has_pennant_item_id(&self) -> bool {
        self.pennant_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pennant_item_id(&mut self, v: u64) {
        self.pennant_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyPennantUpgrade {
    const NAME: &'static str = "CMsgApplyPennantUpgrade";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.upgrade_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.pennant_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upgrade_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pennant_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.upgrade_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pennant_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyPennantUpgrade {
        CMsgApplyPennantUpgrade::new()
    }

    fn clear(&mut self) {
        self.upgrade_item_id = ::std::option::Option::None;
        self.pennant_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyPennantUpgrade {
        static instance: CMsgApplyPennantUpgrade = CMsgApplyPennantUpgrade {
            upgrade_item_id: ::std::option::Option::None,
            pennant_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyEggEssence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyEggEssence {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyEggEssence.essence_item_id)
    pub essence_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgApplyEggEssence.egg_item_id)
    pub egg_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyEggEssence.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyEggEssence {
    fn default() -> &'a CMsgApplyEggEssence {
        <CMsgApplyEggEssence as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyEggEssence {
    pub fn new() -> CMsgApplyEggEssence {
        ::std::default::Default::default()
    }

    // optional uint64 essence_item_id = 1;

    pub fn essence_item_id(&self) -> u64 {
        self.essence_item_id.unwrap_or(0)
    }

    pub fn clear_essence_item_id(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
    }

    pub fn has_essence_item_id(&self) -> bool {
        self.essence_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_essence_item_id(&mut self, v: u64) {
        self.essence_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 egg_item_id = 2;

    pub fn egg_item_id(&self) -> u64 {
        self.egg_item_id.unwrap_or(0)
    }

    pub fn clear_egg_item_id(&mut self) {
        self.egg_item_id = ::std::option::Option::None;
    }

    pub fn has_egg_item_id(&self) -> bool {
        self.egg_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_egg_item_id(&mut self, v: u64) {
        self.egg_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyEggEssence {
    const NAME: &'static str = "CMsgApplyEggEssence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.essence_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.egg_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.essence_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.egg_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.essence_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.egg_item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyEggEssence {
        CMsgApplyEggEssence::new()
    }

    fn clear(&mut self) {
        self.essence_item_id = ::std::option::Option::None;
        self.egg_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyEggEssence {
        static instance: CMsgApplyEggEssence = CMsgApplyEggEssence {
            essence_item_id: ::std::option::Option::None,
            egg_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemAttribute)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemAttribute {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemAttribute.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value)
    pub value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemAttribute.value_bytes)
    pub value_bytes: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemAttribute.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemAttribute {
    fn default() -> &'a CSOEconItemAttribute {
        <CSOEconItemAttribute as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemAttribute {
    pub fn new() -> CSOEconItemAttribute {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(65535u32)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 value = 2;

    pub fn value(&self) -> u32 {
        self.value.unwrap_or(0)
    }

    pub fn clear_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: u32) {
        self.value = ::std::option::Option::Some(v);
    }

    // optional bytes value_bytes = 3;

    pub fn value_bytes(&self) -> &[u8] {
        match self.value_bytes.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_value_bytes(&mut self) {
        self.value_bytes = ::std::option::Option::None;
    }

    pub fn has_value_bytes(&self) -> bool {
        self.value_bytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value_bytes(&mut self, v: ::std::vec::Vec<u8>) {
        self.value_bytes = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value_bytes(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.value_bytes.is_none() {
            self.value_bytes = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.value_bytes.as_mut().unwrap()
    }

    // Take field
    pub fn take_value_bytes(&mut self) -> ::std::vec::Vec<u8> {
        self.value_bytes.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemAttribute {
    const NAME: &'static str = "CSOEconItemAttribute";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.value = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.value_bytes = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.value_bytes.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.value_bytes.as_ref() {
            os.write_bytes(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemAttribute {
        CSOEconItemAttribute::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value_bytes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemAttribute {
        static instance: CSOEconItemAttribute = CSOEconItemAttribute {
            def_index: ::std::option::Option::None,
            value: ::std::option::Option::None,
            value_bytes: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItemEquipped)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItemEquipped {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_class)
    pub new_class: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItemEquipped.new_slot)
    pub new_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItemEquipped.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItemEquipped {
    fn default() -> &'a CSOEconItemEquipped {
        <CSOEconItemEquipped as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItemEquipped {
    pub fn new() -> CSOEconItemEquipped {
        ::std::default::Default::default()
    }

    // optional uint32 new_class = 1;

    pub fn new_class(&self) -> u32 {
        self.new_class.unwrap_or(0)
    }

    pub fn clear_new_class(&mut self) {
        self.new_class = ::std::option::Option::None;
    }

    pub fn has_new_class(&self) -> bool {
        self.new_class.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_class(&mut self, v: u32) {
        self.new_class = ::std::option::Option::Some(v);
    }

    // optional uint32 new_slot = 2;

    pub fn new_slot(&self) -> u32 {
        self.new_slot.unwrap_or(0)
    }

    pub fn clear_new_slot(&mut self) {
        self.new_slot = ::std::option::Option::None;
    }

    pub fn has_new_slot(&self) -> bool {
        self.new_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_slot(&mut self, v: u32) {
        self.new_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItemEquipped {
    const NAME: &'static str = "CSOEconItemEquipped";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.new_class = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.new_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.new_class {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.new_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.new_class {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.new_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItemEquipped {
        CSOEconItemEquipped::new()
    }

    fn clear(&mut self) {
        self.new_class = ::std::option::Option::None;
        self.new_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItemEquipped {
        static instance: CSOEconItemEquipped = CSOEconItemEquipped {
            new_class: ::std::option::Option::None,
            new_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CSOEconItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSOEconItem {
    // message fields
    // @@protoc_insertion_point(field:CSOEconItem.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.level)
    pub level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.origin)
    pub origin: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.attribute)
    pub attribute: ::std::vec::Vec<CSOEconItemAttribute>,
    // @@protoc_insertion_point(field:CSOEconItem.interior_item)
    pub interior_item: ::steam_vent_proto_common::protobuf::MessageField<CSOEconItem>,
    // @@protoc_insertion_point(field:CSOEconItem.style)
    pub style: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSOEconItem.original_id)
    pub original_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CSOEconItem.equipped_state)
    pub equipped_state: ::std::vec::Vec<CSOEconItemEquipped>,
    // special fields
    // @@protoc_insertion_point(special_field:CSOEconItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSOEconItem {
    fn default() -> &'a CSOEconItem {
        <CSOEconItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSOEconItem {
    pub fn new() -> CSOEconItem {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 3;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 4;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 5;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(1u32)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional uint32 level = 6;

    pub fn level(&self) -> u32 {
        self.level.unwrap_or(1u32)
    }

    pub fn clear_level(&mut self) {
        self.level = ::std::option::Option::None;
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: u32) {
        self.level = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 7;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(4u32)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 8;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0u32)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 9;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0u32)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }

    // optional uint32 style = 15;

    pub fn style(&self) -> u32 {
        self.style.unwrap_or(0u32)
    }

    pub fn clear_style(&mut self) {
        self.style = ::std::option::Option::None;
    }

    pub fn has_style(&self) -> bool {
        self.style.is_some()
    }

    // Param is passed by value, moved
    pub fn set_style(&mut self, v: u32) {
        self.style = ::std::option::Option::Some(v);
    }

    // optional uint64 original_id = 16;

    pub fn original_id(&self) -> u64 {
        self.original_id.unwrap_or(0)
    }

    pub fn clear_original_id(&mut self) {
        self.original_id = ::std::option::Option::None;
    }

    pub fn has_original_id(&self) -> bool {
        self.original_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_id(&mut self, v: u64) {
        self.original_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSOEconItem {
    const NAME: &'static str = "CSOEconItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.level = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                98 => {
                    self.attribute.push(is.read_message()?);
                },
                106 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.interior_item)?;
                },
                120 => {
                    self.style = ::std::option::Option::Some(is.read_uint32()?);
                },
                128 => {
                    self.original_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                146 => {
                    self.equipped_state.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.origin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        for value in &self.attribute {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.interior_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.style {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
        }
        if let Some(v) = self.original_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(16, v);
        }
        for value in &self.equipped_state {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.level {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(9, v)?;
        }
        for v in &self.attribute {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        };
        if let Some(v) = self.interior_item.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.style {
            os.write_uint32(15, v)?;
        }
        if let Some(v) = self.original_id {
            os.write_uint64(16, v)?;
        }
        for v in &self.equipped_state {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(18, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSOEconItem {
        CSOEconItem::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.level = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.attribute.clear();
        self.interior_item.clear();
        self.style = ::std::option::Option::None;
        self.original_id = ::std::option::Option::None;
        self.equipped_state.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSOEconItem {
        static instance: CSOEconItem = CSOEconItem {
            id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            level: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            attribute: ::std::vec::Vec::new(),
            interior_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
            style: ::std::option::Option::None,
            original_id: ::std::option::Option::None,
            equipped_state: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSortItems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSortItems {
    // message fields
    // @@protoc_insertion_point(field:CMsgSortItems.sort_type)
    pub sort_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSortItems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSortItems {
    fn default() -> &'a CMsgSortItems {
        <CMsgSortItems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSortItems {
    pub fn new() -> CMsgSortItems {
        ::std::default::Default::default()
    }

    // optional uint32 sort_type = 1;

    pub fn sort_type(&self) -> u32 {
        self.sort_type.unwrap_or(0)
    }

    pub fn clear_sort_type(&mut self) {
        self.sort_type = ::std::option::Option::None;
    }

    pub fn has_sort_type(&self) -> bool {
        self.sort_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sort_type(&mut self, v: u32) {
        self.sort_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSortItems {
    const NAME: &'static str = "CMsgSortItems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sort_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sort_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sort_type {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSortItems {
        CMsgSortItems::new()
    }

    fn clear(&mut self) {
        self.sort_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSortItems {
        static instance: CMsgSortItems = CMsgSortItems {
            sort_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgItemAcknowledged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgItemAcknowledged {
    // message fields
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.inventory)
    pub inventory: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.quality)
    pub quality: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.rarity)
    pub rarity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgItemAcknowledged.origin)
    pub origin: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgItemAcknowledged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgItemAcknowledged {
    fn default() -> &'a CMsgItemAcknowledged {
        <CMsgItemAcknowledged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgItemAcknowledged {
    pub fn new() -> CMsgItemAcknowledged {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 inventory = 2;

    pub fn inventory(&self) -> u32 {
        self.inventory.unwrap_or(0)
    }

    pub fn clear_inventory(&mut self) {
        self.inventory = ::std::option::Option::None;
    }

    pub fn has_inventory(&self) -> bool {
        self.inventory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inventory(&mut self, v: u32) {
        self.inventory = ::std::option::Option::Some(v);
    }

    // optional uint32 def_index = 3;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional uint32 quality = 4;

    pub fn quality(&self) -> u32 {
        self.quality.unwrap_or(0)
    }

    pub fn clear_quality(&mut self) {
        self.quality = ::std::option::Option::None;
    }

    pub fn has_quality(&self) -> bool {
        self.quality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quality(&mut self, v: u32) {
        self.quality = ::std::option::Option::Some(v);
    }

    // optional uint32 rarity = 5;

    pub fn rarity(&self) -> u32 {
        self.rarity.unwrap_or(0)
    }

    pub fn clear_rarity(&mut self) {
        self.rarity = ::std::option::Option::None;
    }

    pub fn has_rarity(&self) -> bool {
        self.rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rarity(&mut self, v: u32) {
        self.rarity = ::std::option::Option::Some(v);
    }

    // optional uint32 origin = 6;

    pub fn origin(&self) -> u32 {
        self.origin.unwrap_or(0)
    }

    pub fn clear_origin(&mut self) {
        self.origin = ::std::option::Option::None;
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: u32) {
        self.origin = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgItemAcknowledged {
    const NAME: &'static str = "CMsgItemAcknowledged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.inventory = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.quality = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rarity = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.origin = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.inventory {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.quality {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rarity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.origin {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.inventory {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.def_index {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.quality {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rarity {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.origin {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgItemAcknowledged {
        CMsgItemAcknowledged::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.inventory = ::std::option::Option::None;
        self.def_index = ::std::option::Option::None;
        self.quality = ::std::option::Option::None;
        self.rarity = ::std::option::Option::None;
        self.origin = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgItemAcknowledged {
        static instance: CMsgItemAcknowledged = CMsgItemAcknowledged {
            account_id: ::std::option::Option::None,
            inventory: ::std::option::Option::None,
            def_index: ::std::option::Option::None,
            quality: ::std::option::Option::None,
            rarity: ::std::option::Option::None,
            origin: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSetItemPositions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSetItemPositions {
    // message fields
    // @@protoc_insertion_point(field:CMsgSetItemPositions.item_positions)
    pub item_positions: ::std::vec::Vec<cmsg_set_item_positions::ItemPosition>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSetItemPositions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSetItemPositions {
    fn default() -> &'a CMsgSetItemPositions {
        <CMsgSetItemPositions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSetItemPositions {
    pub fn new() -> CMsgSetItemPositions {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSetItemPositions {
    const NAME: &'static str = "CMsgSetItemPositions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.item_positions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.item_positions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.item_positions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSetItemPositions {
        CMsgSetItemPositions::new()
    }

    fn clear(&mut self) {
        self.item_positions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSetItemPositions {
        static instance: CMsgSetItemPositions = CMsgSetItemPositions {
            item_positions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSetItemPositions`
pub mod cmsg_set_item_positions {
    // @@protoc_insertion_point(message:CMsgSetItemPositions.ItemPosition)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemPosition {
        // message fields
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.item_id)
        pub item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSetItemPositions.ItemPosition.position)
        pub position: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSetItemPositions.ItemPosition.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemPosition {
        fn default() -> &'a ItemPosition {
            <ItemPosition as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemPosition {
        pub fn new() -> ItemPosition {
            ::std::default::Default::default()
        }

        // optional uint64 item_id = 1;

        pub fn item_id(&self) -> u64 {
            self.item_id.unwrap_or(0)
        }

        pub fn clear_item_id(&mut self) {
            self.item_id = ::std::option::Option::None;
        }

        pub fn has_item_id(&self) -> bool {
            self.item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_id(&mut self, v: u64) {
            self.item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 position = 2;

        pub fn position(&self) -> u32 {
            self.position.unwrap_or(0)
        }

        pub fn clear_position(&mut self) {
            self.position = ::std::option::Option::None;
        }

        pub fn has_position(&self) -> bool {
            self.position.is_some()
        }

        // Param is passed by value, moved
        pub fn set_position(&mut self, v: u32) {
            self.position = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemPosition {
        const NAME: &'static str = "ItemPosition";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.position = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.position {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.position {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemPosition {
            ItemPosition::new()
        }

        fn clear(&mut self) {
            self.item_id = ::std::option::Option::None;
            self.position = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemPosition {
            static instance: ItemPosition = ItemPosition {
                item_id: ::std::option::Option::None,
                position: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancel)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancel {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancel.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancel.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancel {
    fn default() -> &'a CMsgGCStorePurchaseCancel {
        <CMsgGCStorePurchaseCancel as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancel {
    pub fn new() -> CMsgGCStorePurchaseCancel {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseCancel {
    const NAME: &'static str = "CMsgGCStorePurchaseCancel";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancel {
        CMsgGCStorePurchaseCancel::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancel {
        static instance: CMsgGCStorePurchaseCancel = CMsgGCStorePurchaseCancel {
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseCancelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseCancelResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseCancelResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseCancelResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseCancelResponse {
    fn default() -> &'a CMsgGCStorePurchaseCancelResponse {
        <CMsgGCStorePurchaseCancelResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseCancelResponse {
    pub fn new() -> CMsgGCStorePurchaseCancelResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseCancelResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseCancelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseCancelResponse {
        CMsgGCStorePurchaseCancelResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseCancelResponse {
        static instance: CMsgGCStorePurchaseCancelResponse = CMsgGCStorePurchaseCancelResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalize)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalize {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalize.txn_id)
    pub txn_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalize.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalize {
    fn default() -> &'a CMsgGCStorePurchaseFinalize {
        <CMsgGCStorePurchaseFinalize as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalize {
    pub fn new() -> CMsgGCStorePurchaseFinalize {
        ::std::default::Default::default()
    }

    // optional uint64 txn_id = 1;

    pub fn txn_id(&self) -> u64 {
        self.txn_id.unwrap_or(0)
    }

    pub fn clear_txn_id(&mut self) {
        self.txn_id = ::std::option::Option::None;
    }

    pub fn has_txn_id(&self) -> bool {
        self.txn_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_txn_id(&mut self, v: u64) {
        self.txn_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseFinalize {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalize";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.txn_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.txn_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.txn_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalize {
        CMsgGCStorePurchaseFinalize::new()
    }

    fn clear(&mut self) {
        self.txn_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalize {
        static instance: CMsgGCStorePurchaseFinalize = CMsgGCStorePurchaseFinalize {
            txn_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCStorePurchaseFinalizeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCStorePurchaseFinalizeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCStorePurchaseFinalizeResponse.item_ids)
    pub item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCStorePurchaseFinalizeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCStorePurchaseFinalizeResponse {
    fn default() -> &'a CMsgGCStorePurchaseFinalizeResponse {
        <CMsgGCStorePurchaseFinalizeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCStorePurchaseFinalizeResponse {
    pub fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCStorePurchaseFinalizeResponse {
    const NAME: &'static str = "CMsgGCStorePurchaseFinalizeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.item_ids)?;
                },
                16 => {
                    self.item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCStorePurchaseFinalizeResponse {
        CMsgGCStorePurchaseFinalizeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCStorePurchaseFinalizeResponse {
        static instance: CMsgGCStorePurchaseFinalizeResponse = CMsgGCStorePurchaseFinalizeResponse {
            result: ::std::option::Option::None,
            item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCBannedWordListUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCBannedWordListUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCBannedWordListUpdated.group_id)
    pub group_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCBannedWordListUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCBannedWordListUpdated {
    fn default() -> &'a CMsgGCToGCBannedWordListUpdated {
        <CMsgGCToGCBannedWordListUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCBannedWordListUpdated {
    pub fn new() -> CMsgGCToGCBannedWordListUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 group_id = 1;

    pub fn group_id(&self) -> u32 {
        self.group_id.unwrap_or(0)
    }

    pub fn clear_group_id(&mut self) {
        self.group_id = ::std::option::Option::None;
    }

    pub fn has_group_id(&self) -> bool {
        self.group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_id(&mut self, v: u32) {
        self.group_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCBannedWordListUpdated {
    const NAME: &'static str = "CMsgGCToGCBannedWordListUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.group_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.group_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.group_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCBannedWordListUpdated {
        CMsgGCToGCBannedWordListUpdated::new()
    }

    fn clear(&mut self) {
        self.group_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCBannedWordListUpdated {
        static instance: CMsgGCToGCBannedWordListUpdated = CMsgGCToGCBannedWordListUpdated {
            group_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCDirtySDOCache)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCDirtySDOCache {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCDirtySDOCache.sdo_type)
    pub sdo_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToGCDirtySDOCache.key_uint64)
    pub key_uint64: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCDirtySDOCache.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCDirtySDOCache {
    fn default() -> &'a CMsgGCToGCDirtySDOCache {
        <CMsgGCToGCDirtySDOCache as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCDirtySDOCache {
    pub fn new() -> CMsgGCToGCDirtySDOCache {
        ::std::default::Default::default()
    }

    // optional uint32 sdo_type = 1;

    pub fn sdo_type(&self) -> u32 {
        self.sdo_type.unwrap_or(0)
    }

    pub fn clear_sdo_type(&mut self) {
        self.sdo_type = ::std::option::Option::None;
    }

    pub fn has_sdo_type(&self) -> bool {
        self.sdo_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sdo_type(&mut self, v: u32) {
        self.sdo_type = ::std::option::Option::Some(v);
    }

    // optional uint64 key_uint64 = 2;

    pub fn key_uint64(&self) -> u64 {
        self.key_uint64.unwrap_or(0)
    }

    pub fn clear_key_uint64(&mut self) {
        self.key_uint64 = ::std::option::Option::None;
    }

    pub fn has_key_uint64(&self) -> bool {
        self.key_uint64.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_uint64(&mut self, v: u64) {
        self.key_uint64 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCDirtySDOCache {
    const NAME: &'static str = "CMsgGCToGCDirtySDOCache";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.sdo_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.key_uint64 = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.sdo_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.key_uint64 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.sdo_type {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.key_uint64 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCDirtySDOCache {
        CMsgGCToGCDirtySDOCache::new()
    }

    fn clear(&mut self) {
        self.sdo_type = ::std::option::Option::None;
        self.key_uint64 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCDirtySDOCache {
        static instance: CMsgGCToGCDirtySDOCache = CMsgGCToGCDirtySDOCache {
            sdo_type: ::std::option::Option::None,
            key_uint64: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSDONoMemcached)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSDONoMemcached {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSDONoMemcached.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSDONoMemcached {
    fn default() -> &'a CMsgSDONoMemcached {
        <CMsgSDONoMemcached as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSDONoMemcached {
    pub fn new() -> CMsgSDONoMemcached {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSDONoMemcached {
    const NAME: &'static str = "CMsgSDONoMemcached";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSDONoMemcached {
        CMsgSDONoMemcached::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSDONoMemcached {
        static instance: CMsgSDONoMemcached = CMsgSDONoMemcached {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCUpdateSQLKeyValue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCUpdateSQLKeyValue {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCUpdateSQLKeyValue.key_name)
    pub key_name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCUpdateSQLKeyValue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCUpdateSQLKeyValue {
    fn default() -> &'a CMsgGCToGCUpdateSQLKeyValue {
        <CMsgGCToGCUpdateSQLKeyValue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCUpdateSQLKeyValue {
    pub fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        ::std::default::Default::default()
    }

    // optional string key_name = 1;

    pub fn key_name(&self) -> &str {
        match self.key_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_key_name(&mut self) {
        self.key_name = ::std::option::Option::None;
    }

    pub fn has_key_name(&self) -> bool {
        self.key_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key_name(&mut self, v: ::std::string::String) {
        self.key_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_name(&mut self) -> &mut ::std::string::String {
        if self.key_name.is_none() {
            self.key_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.key_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_key_name(&mut self) -> ::std::string::String {
        self.key_name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCUpdateSQLKeyValue {
    const NAME: &'static str = "CMsgGCToGCUpdateSQLKeyValue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key_name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.key_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.key_name.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCUpdateSQLKeyValue {
        CMsgGCToGCUpdateSQLKeyValue::new()
    }

    fn clear(&mut self) {
        self.key_name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCUpdateSQLKeyValue {
        static instance: CMsgGCToGCUpdateSQLKeyValue = CMsgGCToGCUpdateSQLKeyValue {
            key_name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCServerVersionUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCServerVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCServerVersionUpdated.server_version)
    pub server_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCServerVersionUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCServerVersionUpdated {
    fn default() -> &'a CMsgGCServerVersionUpdated {
        <CMsgGCServerVersionUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCServerVersionUpdated {
    pub fn new() -> CMsgGCServerVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 server_version = 1;

    pub fn server_version(&self) -> u32 {
        self.server_version.unwrap_or(0)
    }

    pub fn clear_server_version(&mut self) {
        self.server_version = ::std::option::Option::None;
    }

    pub fn has_server_version(&self) -> bool {
        self.server_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_version(&mut self, v: u32) {
        self.server_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCServerVersionUpdated {
    const NAME: &'static str = "CMsgGCServerVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.server_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.server_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.server_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCServerVersionUpdated {
        CMsgGCServerVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.server_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCServerVersionUpdated {
        static instance: CMsgGCServerVersionUpdated = CMsgGCServerVersionUpdated {
            server_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCClientVersionUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCClientVersionUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCClientVersionUpdated.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCClientVersionUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCClientVersionUpdated {
    fn default() -> &'a CMsgGCClientVersionUpdated {
        <CMsgGCClientVersionUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCClientVersionUpdated {
    pub fn new() -> CMsgGCClientVersionUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCClientVersionUpdated {
    const NAME: &'static str = "CMsgGCClientVersionUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCClientVersionUpdated {
        CMsgGCClientVersionUpdated::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCClientVersionUpdated {
        static instance: CMsgGCClientVersionUpdated = CMsgGCClientVersionUpdated {
            client_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCWebAPIAccountChanged)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCWebAPIAccountChanged {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCWebAPIAccountChanged.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCWebAPIAccountChanged {
    fn default() -> &'a CMsgGCToGCWebAPIAccountChanged {
        <CMsgGCToGCWebAPIAccountChanged as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCWebAPIAccountChanged {
    pub fn new() -> CMsgGCToGCWebAPIAccountChanged {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCWebAPIAccountChanged {
    const NAME: &'static str = "CMsgGCToGCWebAPIAccountChanged";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCWebAPIAccountChanged {
        CMsgGCToGCWebAPIAccountChanged::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCWebAPIAccountChanged {
        static instance: CMsgGCToGCWebAPIAccountChanged = CMsgGCToGCWebAPIAccountChanged {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgExtractGems)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExtractGems {
    // message fields
    // @@protoc_insertion_point(field:CMsgExtractGems.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgExtractGems.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgExtractGems.item_socket_id)
    pub item_socket_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExtractGems.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExtractGems {
    fn default() -> &'a CMsgExtractGems {
        <CMsgExtractGems as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgExtractGems {
    pub fn new() -> CMsgExtractGems {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_socket_id = 3;

    pub fn item_socket_id(&self) -> u32 {
        self.item_socket_id.unwrap_or(65535u32)
    }

    pub fn clear_item_socket_id(&mut self) {
        self.item_socket_id = ::std::option::Option::None;
    }

    pub fn has_item_socket_id(&self) -> bool {
        self.item_socket_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_socket_id(&mut self, v: u32) {
        self.item_socket_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgExtractGems {
    const NAME: &'static str = "CMsgExtractGems";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.item_socket_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.item_socket_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.item_socket_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExtractGems {
        CMsgExtractGems::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.item_socket_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExtractGems {
        static instance: CMsgExtractGems = CMsgExtractGems {
            tool_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            item_socket_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgExtractGemsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgExtractGemsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgExtractGemsResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgExtractGemsResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_extract_gems_response::EExtractGems>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgExtractGemsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgExtractGemsResponse {
    fn default() -> &'a CMsgExtractGemsResponse {
        <CMsgExtractGemsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgExtractGemsResponse {
    pub fn new() -> CMsgExtractGemsResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgExtractGemsResponse.EExtractGems response = 2;

    pub fn response(&self) -> cmsg_extract_gems_response::EExtractGems {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_extract_gems_response::EExtractGems::k_ExtractGems_Succeeded),
            None => cmsg_extract_gems_response::EExtractGems::k_ExtractGems_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_extract_gems_response::EExtractGems) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgExtractGemsResponse {
    const NAME: &'static str = "CMsgExtractGemsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.response {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgExtractGemsResponse {
        CMsgExtractGemsResponse::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgExtractGemsResponse {
        static instance: CMsgExtractGemsResponse = CMsgExtractGemsResponse {
            item_id: ::std::option::Option::None,
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgExtractGemsResponse`
pub mod cmsg_extract_gems_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgExtractGemsResponse.EExtractGems)
    pub enum EExtractGems {
        // @@protoc_insertion_point(enum_value:CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Succeeded)
        k_ExtractGems_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ToolIsInvalid)
        k_ExtractGems_Failed_ToolIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ItemIsInvalid)
        k_ExtractGems_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_ToolCannotRemoveGem)
        k_ExtractGems_Failed_ToolCannotRemoveGem = 3,
        // @@protoc_insertion_point(enum_value:CMsgExtractGemsResponse.EExtractGems.k_ExtractGems_Failed_FailedToRemoveGem)
        k_ExtractGems_Failed_FailedToRemoveGem = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EExtractGems {
        const NAME: &'static str = "EExtractGems";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EExtractGems> {
            match value {
                0 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Succeeded),
                1 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolIsInvalid),
                2 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem),
                4 => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EExtractGems> {
            match str {
                "k_ExtractGems_Succeeded" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Succeeded),
                "k_ExtractGems_Failed_ToolIsInvalid" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolIsInvalid),
                "k_ExtractGems_Failed_ItemIsInvalid" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ItemIsInvalid),
                "k_ExtractGems_Failed_ToolCannotRemoveGem" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem),
                "k_ExtractGems_Failed_FailedToRemoveGem" => ::std::option::Option::Some(EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EExtractGems] = &[
            EExtractGems::k_ExtractGems_Succeeded,
            EExtractGems::k_ExtractGems_Failed_ToolIsInvalid,
            EExtractGems::k_ExtractGems_Failed_ItemIsInvalid,
            EExtractGems::k_ExtractGems_Failed_ToolCannotRemoveGem,
            EExtractGems::k_ExtractGems_Failed_FailedToRemoveGem,
        ];
    }

    impl ::std::default::Default for EExtractGems {
        fn default() -> Self {
            EExtractGems::k_ExtractGems_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgAddSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddSocket {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddSocket.tool_item_id)
    pub tool_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddSocket.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddSocket.unusual)
    pub unusual: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddSocket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddSocket {
    fn default() -> &'a CMsgAddSocket {
        <CMsgAddSocket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAddSocket {
    pub fn new() -> CMsgAddSocket {
        ::std::default::Default::default()
    }

    // optional uint64 tool_item_id = 1;

    pub fn tool_item_id(&self) -> u64 {
        self.tool_item_id.unwrap_or(0)
    }

    pub fn clear_tool_item_id(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
    }

    pub fn has_tool_item_id(&self) -> bool {
        self.tool_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool_item_id(&mut self, v: u64) {
        self.tool_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_item_id = 2;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional bool unusual = 3;

    pub fn unusual(&self) -> bool {
        self.unusual.unwrap_or(false)
    }

    pub fn clear_unusual(&mut self) {
        self.unusual = ::std::option::Option::None;
    }

    pub fn has_unusual(&self) -> bool {
        self.unusual.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unusual(&mut self, v: bool) {
        self.unusual = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAddSocket {
    const NAME: &'static str = "CMsgAddSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.tool_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.unusual = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.tool_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.unusual {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.tool_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.unusual {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddSocket {
        CMsgAddSocket::new()
    }

    fn clear(&mut self) {
        self.tool_item_id = ::std::option::Option::None;
        self.item_item_id = ::std::option::Option::None;
        self.unusual = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddSocket {
        static instance: CMsgAddSocket = CMsgAddSocket {
            tool_item_id: ::std::option::Option::None,
            item_item_id: ::std::option::Option::None,
            unusual: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAddSocketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddSocketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddSocketResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddSocketResponse.updated_socket_index)
    pub updated_socket_index: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgAddSocketResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_add_socket_response::EAddSocket>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddSocketResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddSocketResponse {
    fn default() -> &'a CMsgAddSocketResponse {
        <CMsgAddSocketResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAddSocketResponse {
    pub fn new() -> CMsgAddSocketResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgAddSocketResponse.EAddSocket response = 3;

    pub fn response(&self) -> cmsg_add_socket_response::EAddSocket {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_add_socket_response::EAddSocket::k_AddSocket_Succeeded),
            None => cmsg_add_socket_response::EAddSocket::k_AddSocket_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_add_socket_response::EAddSocket) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAddSocketResponse {
    const NAME: &'static str = "CMsgAddSocketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.updated_socket_index)?;
                },
                16 => {
                    self.updated_socket_index.push(is.read_uint32()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.updated_socket_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.updated_socket_index {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddSocketResponse {
        CMsgAddSocketResponse::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.updated_socket_index.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddSocketResponse {
        static instance: CMsgAddSocketResponse = CMsgAddSocketResponse {
            item_id: ::std::option::Option::None,
            updated_socket_index: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgAddSocketResponse`
pub mod cmsg_add_socket_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgAddSocketResponse.EAddSocket)
    pub enum EAddSocket {
        // @@protoc_insertion_point(enum_value:CMsgAddSocketResponse.EAddSocket.k_AddSocket_Succeeded)
        k_AddSocket_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_ToolIsInvalid)
        k_AddSocket_Failed_ToolIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_ItemCannotBeSocketed)
        k_AddSocket_Failed_ItemCannotBeSocketed = 2,
        // @@protoc_insertion_point(enum_value:CMsgAddSocketResponse.EAddSocket.k_AddSocket_Failed_FailedToAddSocket)
        k_AddSocket_Failed_FailedToAddSocket = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EAddSocket {
        const NAME: &'static str = "EAddSocket";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EAddSocket> {
            match value {
                0 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Succeeded),
                1 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ToolIsInvalid),
                2 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed),
                3 => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_FailedToAddSocket),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EAddSocket> {
            match str {
                "k_AddSocket_Succeeded" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Succeeded),
                "k_AddSocket_Failed_ToolIsInvalid" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ToolIsInvalid),
                "k_AddSocket_Failed_ItemCannotBeSocketed" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed),
                "k_AddSocket_Failed_FailedToAddSocket" => ::std::option::Option::Some(EAddSocket::k_AddSocket_Failed_FailedToAddSocket),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EAddSocket] = &[
            EAddSocket::k_AddSocket_Succeeded,
            EAddSocket::k_AddSocket_Failed_ToolIsInvalid,
            EAddSocket::k_AddSocket_Failed_ItemCannotBeSocketed,
            EAddSocket::k_AddSocket_Failed_FailedToAddSocket,
        ];
    }

    impl ::std::default::Default for EAddSocket {
        fn default() -> Self {
            EAddSocket::k_AddSocket_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgAddItemToSocketData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocketData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddItemToSocketData.gem_item_id)
    pub gem_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddItemToSocketData.socket_index)
    pub socket_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddItemToSocketData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocketData {
    fn default() -> &'a CMsgAddItemToSocketData {
        <CMsgAddItemToSocketData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocketData {
    pub fn new() -> CMsgAddItemToSocketData {
        ::std::default::Default::default()
    }

    // optional uint64 gem_item_id = 1;

    pub fn gem_item_id(&self) -> u64 {
        self.gem_item_id.unwrap_or(0)
    }

    pub fn clear_gem_item_id(&mut self) {
        self.gem_item_id = ::std::option::Option::None;
    }

    pub fn has_gem_item_id(&self) -> bool {
        self.gem_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gem_item_id(&mut self, v: u64) {
        self.gem_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_index = 2;

    pub fn socket_index(&self) -> u32 {
        self.socket_index.unwrap_or(65535u32)
    }

    pub fn clear_socket_index(&mut self) {
        self.socket_index = ::std::option::Option::None;
    }

    pub fn has_socket_index(&self) -> bool {
        self.socket_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_index(&mut self, v: u32) {
        self.socket_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAddItemToSocketData {
    const NAME: &'static str = "CMsgAddItemToSocketData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.gem_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.socket_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.gem_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.socket_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.gem_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.socket_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocketData {
        CMsgAddItemToSocketData::new()
    }

    fn clear(&mut self) {
        self.gem_item_id = ::std::option::Option::None;
        self.socket_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocketData {
        static instance: CMsgAddItemToSocketData = CMsgAddItemToSocketData {
            gem_item_id: ::std::option::Option::None,
            socket_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAddItemToSocket)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocket {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddItemToSocket.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddItemToSocket.gems_to_socket)
    pub gems_to_socket: ::std::vec::Vec<CMsgAddItemToSocketData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddItemToSocket.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocket {
    fn default() -> &'a CMsgAddItemToSocket {
        <CMsgAddItemToSocket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocket {
    pub fn new() -> CMsgAddItemToSocket {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAddItemToSocket {
    const NAME: &'static str = "CMsgAddItemToSocket";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.gems_to_socket.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.gems_to_socket {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.gems_to_socket {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocket {
        CMsgAddItemToSocket::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.gems_to_socket.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocket {
        static instance: CMsgAddItemToSocket = CMsgAddItemToSocket {
            item_item_id: ::std::option::Option::None,
            gems_to_socket: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAddItemToSocketResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAddItemToSocketResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgAddItemToSocketResponse.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgAddItemToSocketResponse.updated_socket_index)
    pub updated_socket_index: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgAddItemToSocketResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_add_item_to_socket_response::EAddGem>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAddItemToSocketResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAddItemToSocketResponse {
    fn default() -> &'a CMsgAddItemToSocketResponse {
        <CMsgAddItemToSocketResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAddItemToSocketResponse {
    pub fn new() -> CMsgAddItemToSocketResponse {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional .CMsgAddItemToSocketResponse.EAddGem response = 3;

    pub fn response(&self) -> cmsg_add_item_to_socket_response::EAddGem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_add_item_to_socket_response::EAddGem::k_AddGem_Succeeded),
            None => cmsg_add_item_to_socket_response::EAddGem::k_AddGem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_add_item_to_socket_response::EAddGem) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAddItemToSocketResponse {
    const NAME: &'static str = "CMsgAddItemToSocketResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.updated_socket_index)?;
                },
                16 => {
                    self.updated_socket_index.push(is.read_uint32()?);
                },
                24 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.updated_socket_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.updated_socket_index {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.response {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAddItemToSocketResponse {
        CMsgAddItemToSocketResponse::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.updated_socket_index.clear();
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAddItemToSocketResponse {
        static instance: CMsgAddItemToSocketResponse = CMsgAddItemToSocketResponse {
            item_item_id: ::std::option::Option::None,
            updated_socket_index: ::std::vec::Vec::new(),
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgAddItemToSocketResponse`
pub mod cmsg_add_item_to_socket_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgAddItemToSocketResponse.EAddGem)
    pub enum EAddGem {
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Succeeded)
        k_AddGem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_GemIsInvalid)
        k_AddGem_Failed_GemIsInvalid = 1,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_ItemIsInvalid)
        k_AddGem_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_FailedToAddGem)
        k_AddGem_Failed_FailedToAddGem = 3,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForSocket)
        k_AddGem_Failed_InvalidGemTypeForSocket = 4,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForHero)
        k_AddGem_Failed_InvalidGemTypeForHero = 5,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_InvalidGemTypeForSlot)
        k_AddGem_Failed_InvalidGemTypeForSlot = 6,
        // @@protoc_insertion_point(enum_value:CMsgAddItemToSocketResponse.EAddGem.k_AddGem_Failed_SocketContainsUnremovableGem)
        k_AddGem_Failed_SocketContainsUnremovableGem = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EAddGem {
        const NAME: &'static str = "EAddGem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EAddGem> {
            match value {
                0 => ::std::option::Option::Some(EAddGem::k_AddGem_Succeeded),
                1 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_GemIsInvalid),
                2 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_FailedToAddGem),
                4 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket),
                5 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForHero),
                6 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot),
                7 => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EAddGem> {
            match str {
                "k_AddGem_Succeeded" => ::std::option::Option::Some(EAddGem::k_AddGem_Succeeded),
                "k_AddGem_Failed_GemIsInvalid" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_GemIsInvalid),
                "k_AddGem_Failed_ItemIsInvalid" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_ItemIsInvalid),
                "k_AddGem_Failed_FailedToAddGem" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_FailedToAddGem),
                "k_AddGem_Failed_InvalidGemTypeForSocket" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket),
                "k_AddGem_Failed_InvalidGemTypeForHero" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForHero),
                "k_AddGem_Failed_InvalidGemTypeForSlot" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot),
                "k_AddGem_Failed_SocketContainsUnremovableGem" => ::std::option::Option::Some(EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EAddGem] = &[
            EAddGem::k_AddGem_Succeeded,
            EAddGem::k_AddGem_Failed_GemIsInvalid,
            EAddGem::k_AddGem_Failed_ItemIsInvalid,
            EAddGem::k_AddGem_Failed_FailedToAddGem,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForSocket,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForHero,
            EAddGem::k_AddGem_Failed_InvalidGemTypeForSlot,
            EAddGem::k_AddGem_Failed_SocketContainsUnremovableGem,
        ];
    }

    impl ::std::default::Default for EAddGem {
        fn default() -> Self {
            EAddGem::k_AddGem_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgResetStrangeGemCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResetStrangeGemCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgResetStrangeGemCount.item_item_id)
    pub item_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgResetStrangeGemCount.socket_index)
    pub socket_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResetStrangeGemCount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResetStrangeGemCount {
    fn default() -> &'a CMsgResetStrangeGemCount {
        <CMsgResetStrangeGemCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgResetStrangeGemCount {
    pub fn new() -> CMsgResetStrangeGemCount {
        ::std::default::Default::default()
    }

    // optional uint64 item_item_id = 1;

    pub fn item_item_id(&self) -> u64 {
        self.item_item_id.unwrap_or(0)
    }

    pub fn clear_item_item_id(&mut self) {
        self.item_item_id = ::std::option::Option::None;
    }

    pub fn has_item_item_id(&self) -> bool {
        self.item_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_item_id(&mut self, v: u64) {
        self.item_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 socket_index = 2;

    pub fn socket_index(&self) -> u32 {
        self.socket_index.unwrap_or(65535u32)
    }

    pub fn clear_socket_index(&mut self) {
        self.socket_index = ::std::option::Option::None;
    }

    pub fn has_socket_index(&self) -> bool {
        self.socket_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_socket_index(&mut self, v: u32) {
        self.socket_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgResetStrangeGemCount {
    const NAME: &'static str = "CMsgResetStrangeGemCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.socket_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.socket_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.socket_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResetStrangeGemCount {
        CMsgResetStrangeGemCount::new()
    }

    fn clear(&mut self) {
        self.item_item_id = ::std::option::Option::None;
        self.socket_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResetStrangeGemCount {
        static instance: CMsgResetStrangeGemCount = CMsgResetStrangeGemCount {
            item_item_id: ::std::option::Option::None,
            socket_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgResetStrangeGemCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgResetStrangeGemCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgResetStrangeGemCountResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_reset_strange_gem_count_response::EResetGem>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgResetStrangeGemCountResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgResetStrangeGemCountResponse {
    fn default() -> &'a CMsgResetStrangeGemCountResponse {
        <CMsgResetStrangeGemCountResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgResetStrangeGemCountResponse {
    pub fn new() -> CMsgResetStrangeGemCountResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgResetStrangeGemCountResponse.EResetGem response = 1;

    pub fn response(&self) -> cmsg_reset_strange_gem_count_response::EResetGem {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_reset_strange_gem_count_response::EResetGem::k_ResetGem_Succeeded),
            None => cmsg_reset_strange_gem_count_response::EResetGem::k_ResetGem_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_reset_strange_gem_count_response::EResetGem) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgResetStrangeGemCountResponse {
    const NAME: &'static str = "CMsgResetStrangeGemCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgResetStrangeGemCountResponse {
        CMsgResetStrangeGemCountResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgResetStrangeGemCountResponse {
        static instance: CMsgResetStrangeGemCountResponse = CMsgResetStrangeGemCountResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgResetStrangeGemCountResponse`
pub mod cmsg_reset_strange_gem_count_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgResetStrangeGemCountResponse.EResetGem)
    pub enum EResetGem {
        // @@protoc_insertion_point(enum_value:CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Succeeded)
        k_ResetGem_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_FailedToResetGem)
        k_ResetGem_Failed_FailedToResetGem = 1,
        // @@protoc_insertion_point(enum_value:CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_ItemIsInvalid)
        k_ResetGem_Failed_ItemIsInvalid = 2,
        // @@protoc_insertion_point(enum_value:CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_InvalidSocketId)
        k_ResetGem_Failed_InvalidSocketId = 3,
        // @@protoc_insertion_point(enum_value:CMsgResetStrangeGemCountResponse.EResetGem.k_ResetGem_Failed_SocketCannotBeReset)
        k_ResetGem_Failed_SocketCannotBeReset = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResetGem {
        const NAME: &'static str = "EResetGem";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResetGem> {
            match value {
                0 => ::std::option::Option::Some(EResetGem::k_ResetGem_Succeeded),
                1 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_FailedToResetGem),
                2 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_ItemIsInvalid),
                3 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_InvalidSocketId),
                4 => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_SocketCannotBeReset),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResetGem> {
            match str {
                "k_ResetGem_Succeeded" => ::std::option::Option::Some(EResetGem::k_ResetGem_Succeeded),
                "k_ResetGem_Failed_FailedToResetGem" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_FailedToResetGem),
                "k_ResetGem_Failed_ItemIsInvalid" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_ItemIsInvalid),
                "k_ResetGem_Failed_InvalidSocketId" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_InvalidSocketId),
                "k_ResetGem_Failed_SocketCannotBeReset" => ::std::option::Option::Some(EResetGem::k_ResetGem_Failed_SocketCannotBeReset),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResetGem] = &[
            EResetGem::k_ResetGem_Succeeded,
            EResetGem::k_ResetGem_Failed_FailedToResetGem,
            EResetGem::k_ResetGem_Failed_ItemIsInvalid,
            EResetGem::k_ResetGem_Failed_InvalidSocketId,
            EResetGem::k_ResetGem_Failed_SocketCannotBeReset,
        ];
    }

    impl ::std::default::Default for EResetGem {
        fn default() -> Self {
            EResetGem::k_ResetGem_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientPollFileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollFileRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileRequest.file_name)
    pub file_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileRequest.client_version)
    pub client_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileRequest.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPollFileRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollFileRequest {
    fn default() -> &'a CMsgGCToClientPollFileRequest {
        <CMsgGCToClientPollFileRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollFileRequest {
    pub fn new() -> CMsgGCToClientPollFileRequest {
        ::std::default::Default::default()
    }

    // optional string file_name = 1;

    pub fn file_name(&self) -> &str {
        match self.file_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_file_name(&mut self) {
        self.file_name = ::std::option::Option::None;
    }

    pub fn has_file_name(&self) -> bool {
        self.file_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_name(&mut self, v: ::std::string::String) {
        self.file_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file_name(&mut self) -> &mut ::std::string::String {
        if self.file_name.is_none() {
            self.file_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.file_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_file_name(&mut self) -> ::std::string::String {
        self.file_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 client_version = 2;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }

    // optional uint32 poll_id = 3;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPollFileRequest {
    const NAME: &'static str = "CMsgGCToClientPollFileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.file_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.poll_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.file_name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.client_version {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.poll_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollFileRequest {
        CMsgGCToClientPollFileRequest::new()
    }

    fn clear(&mut self) {
        self.file_name = ::std::option::Option::None;
        self.client_version = ::std::option::Option::None;
        self.poll_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollFileRequest {
        static instance: CMsgGCToClientPollFileRequest = CMsgGCToClientPollFileRequest {
            file_name: ::std::option::Option::None,
            client_version: ::std::option::Option::None,
            poll_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPollFileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPollFileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileResponse.poll_id)
    pub poll_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileResponse.file_size)
    pub file_size: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPollFileResponse.file_crc)
    pub file_crc: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPollFileResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPollFileResponse {
    fn default() -> &'a CMsgGCToClientPollFileResponse {
        <CMsgGCToClientPollFileResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPollFileResponse {
    pub fn new() -> CMsgGCToClientPollFileResponse {
        ::std::default::Default::default()
    }

    // optional uint32 poll_id = 1;

    pub fn poll_id(&self) -> u32 {
        self.poll_id.unwrap_or(0)
    }

    pub fn clear_poll_id(&mut self) {
        self.poll_id = ::std::option::Option::None;
    }

    pub fn has_poll_id(&self) -> bool {
        self.poll_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_poll_id(&mut self, v: u32) {
        self.poll_id = ::std::option::Option::Some(v);
    }

    // optional uint32 file_size = 2;

    pub fn file_size(&self) -> u32 {
        self.file_size.unwrap_or(0)
    }

    pub fn clear_file_size(&mut self) {
        self.file_size = ::std::option::Option::None;
    }

    pub fn has_file_size(&self) -> bool {
        self.file_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_size(&mut self, v: u32) {
        self.file_size = ::std::option::Option::Some(v);
    }

    // optional uint32 file_crc = 3;

    pub fn file_crc(&self) -> u32 {
        self.file_crc.unwrap_or(0)
    }

    pub fn clear_file_crc(&mut self) {
        self.file_crc = ::std::option::Option::None;
    }

    pub fn has_file_crc(&self) -> bool {
        self.file_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_file_crc(&mut self, v: u32) {
        self.file_crc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPollFileResponse {
    const NAME: &'static str = "CMsgGCToClientPollFileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.poll_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.file_size = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.file_crc = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.poll_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.file_size {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.file_crc {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.poll_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.file_size {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.file_crc {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPollFileResponse {
        CMsgGCToClientPollFileResponse::new()
    }

    fn clear(&mut self) {
        self.poll_id = ::std::option::Option::None;
        self.file_size = ::std::option::Option::None;
        self.file_crc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPollFileResponse {
        static instance: CMsgGCToClientPollFileResponse = CMsgGCToClientPollFileResponse {
            poll_id: ::std::option::Option::None,
            file_size: ::std::option::Option::None,
            file_crc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPerformManualOp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPerformManualOp {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCPerformManualOp.op_id)
    pub op_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToGCPerformManualOp.group_code)
    pub group_code: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPerformManualOp.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPerformManualOp {
    fn default() -> &'a CMsgGCToGCPerformManualOp {
        <CMsgGCToGCPerformManualOp as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPerformManualOp {
    pub fn new() -> CMsgGCToGCPerformManualOp {
        ::std::default::Default::default()
    }

    // optional uint64 op_id = 1;

    pub fn op_id(&self) -> u64 {
        self.op_id.unwrap_or(0)
    }

    pub fn clear_op_id(&mut self) {
        self.op_id = ::std::option::Option::None;
    }

    pub fn has_op_id(&self) -> bool {
        self.op_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: u64) {
        self.op_id = ::std::option::Option::Some(v);
    }

    // optional uint32 group_code = 2;

    pub fn group_code(&self) -> u32 {
        self.group_code.unwrap_or(0)
    }

    pub fn clear_group_code(&mut self) {
        self.group_code = ::std::option::Option::None;
    }

    pub fn has_group_code(&self) -> bool {
        self.group_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_code(&mut self, v: u32) {
        self.group_code = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPerformManualOp {
    const NAME: &'static str = "CMsgGCToGCPerformManualOp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.op_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.group_code = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.op_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.group_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.op_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.group_code {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPerformManualOp {
        CMsgGCToGCPerformManualOp::new()
    }

    fn clear(&mut self) {
        self.op_id = ::std::option::Option::None;
        self.group_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPerformManualOp {
        static instance: CMsgGCToGCPerformManualOp = CMsgGCToGCPerformManualOp {
            op_id: ::std::option::Option::None,
            group_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCPerformManualOpCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCPerformManualOpCompleted {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCPerformManualOpCompleted.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToGCPerformManualOpCompleted.source_gc)
    pub source_gc: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCPerformManualOpCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCPerformManualOpCompleted {
    fn default() -> &'a CMsgGCToGCPerformManualOpCompleted {
        <CMsgGCToGCPerformManualOpCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCPerformManualOpCompleted {
    pub fn new() -> CMsgGCToGCPerformManualOpCompleted {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }

    // optional int32 source_gc = 2;

    pub fn source_gc(&self) -> i32 {
        self.source_gc.unwrap_or(-1i32)
    }

    pub fn clear_source_gc(&mut self) {
        self.source_gc = ::std::option::Option::None;
    }

    pub fn has_source_gc(&self) -> bool {
        self.source_gc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_gc(&mut self, v: i32) {
        self.source_gc = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCPerformManualOpCompleted {
    const NAME: &'static str = "CMsgGCToGCPerformManualOpCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.source_gc = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        if let Some(v) = self.source_gc {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.source_gc {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCPerformManualOpCompleted {
        CMsgGCToGCPerformManualOpCompleted::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.source_gc = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCPerformManualOpCompleted {
        static instance: CMsgGCToGCPerformManualOpCompleted = CMsgGCToGCPerformManualOpCompleted {
            success: ::std::option::Option::None,
            source_gc: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCReloadServerRegionSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCReloadServerRegionSettings {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCReloadServerRegionSettings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCReloadServerRegionSettings {
    fn default() -> &'a CMsgGCToGCReloadServerRegionSettings {
        <CMsgGCToGCReloadServerRegionSettings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCReloadServerRegionSettings {
    pub fn new() -> CMsgGCToGCReloadServerRegionSettings {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCReloadServerRegionSettings {
    const NAME: &'static str = "CMsgGCToGCReloadServerRegionSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCReloadServerRegionSettings {
        CMsgGCToGCReloadServerRegionSettings::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCReloadServerRegionSettings {
        static instance: CMsgGCToGCReloadServerRegionSettings = CMsgGCToGCReloadServerRegionSettings {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCAdditionalWelcomeMsgList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCAdditionalWelcomeMsgList {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCAdditionalWelcomeMsgList.welcome_messages)
    pub welcome_messages: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCAdditionalWelcomeMsgList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCAdditionalWelcomeMsgList {
    fn default() -> &'a CMsgGCAdditionalWelcomeMsgList {
        <CMsgGCAdditionalWelcomeMsgList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCAdditionalWelcomeMsgList {
    pub fn new() -> CMsgGCAdditionalWelcomeMsgList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCAdditionalWelcomeMsgList {
    const NAME: &'static str = "CMsgGCAdditionalWelcomeMsgList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.welcome_messages.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.welcome_messages {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.welcome_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCAdditionalWelcomeMsgList {
        CMsgGCAdditionalWelcomeMsgList::new()
    }

    fn clear(&mut self) {
        self.welcome_messages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCAdditionalWelcomeMsgList {
        static instance: CMsgGCAdditionalWelcomeMsgList = CMsgGCAdditionalWelcomeMsgList {
            welcome_messages: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.con_vars)
    pub con_vars: ::std::vec::Vec<cmsg_apply_remote_con_vars::ConVar>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgApplyRemoteConVars.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgApplyRemoteConVars {
    fn default() -> &'a CMsgApplyRemoteConVars {
        <CMsgApplyRemoteConVars as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgApplyRemoteConVars {
    pub fn new() -> CMsgApplyRemoteConVars {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgApplyRemoteConVars {
    const NAME: &'static str = "CMsgApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.con_vars.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.con_vars {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.con_vars {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgApplyRemoteConVars {
        CMsgApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.con_vars.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgApplyRemoteConVars {
        static instance: CMsgApplyRemoteConVars = CMsgApplyRemoteConVars {
            con_vars: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgApplyRemoteConVars`
pub mod cmsg_apply_remote_con_vars {
    // @@protoc_insertion_point(message:CMsgApplyRemoteConVars.ConVar)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ConVar {
        // message fields
        // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.ConVar.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.ConVar.value)
        pub value: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.ConVar.version_min)
        pub version_min: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.ConVar.version_max)
        pub version_max: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgApplyRemoteConVars.ConVar.platform)
        pub platform: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::steammessages::EGCPlatform>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgApplyRemoteConVars.ConVar.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ConVar {
        fn default() -> &'a ConVar {
            <ConVar as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ConVar {
        pub fn new() -> ConVar {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string value = 2;

        pub fn value(&self) -> &str {
            match self.value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: ::std::string::String) {
            self.value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_value(&mut self) -> &mut ::std::string::String {
            if self.value.is_none() {
                self.value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.value.as_mut().unwrap()
        }

        // Take field
        pub fn take_value(&mut self) -> ::std::string::String {
            self.value.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 version_min = 3;

        pub fn version_min(&self) -> u32 {
            self.version_min.unwrap_or(0)
        }

        pub fn clear_version_min(&mut self) {
            self.version_min = ::std::option::Option::None;
        }

        pub fn has_version_min(&self) -> bool {
            self.version_min.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_min(&mut self, v: u32) {
            self.version_min = ::std::option::Option::Some(v);
        }

        // optional uint32 version_max = 4;

        pub fn version_max(&self) -> u32 {
            self.version_max.unwrap_or(0)
        }

        pub fn clear_version_max(&mut self) {
            self.version_max = ::std::option::Option::None;
        }

        pub fn has_version_max(&self) -> bool {
            self.version_max.is_some()
        }

        // Param is passed by value, moved
        pub fn set_version_max(&mut self, v: u32) {
            self.version_max = ::std::option::Option::Some(v);
        }

        // optional .EGCPlatform platform = 5;

        pub fn platform(&self) -> super::super::steammessages::EGCPlatform {
            match self.platform {
                Some(e) => e.enum_value_or(super::super::steammessages::EGCPlatform::k_eGCPlatform_None),
                None => super::super::steammessages::EGCPlatform::k_eGCPlatform_None,
            }
        }

        pub fn clear_platform(&mut self) {
            self.platform = ::std::option::Option::None;
        }

        pub fn has_platform(&self) -> bool {
            self.platform.is_some()
        }

        // Param is passed by value, moved
        pub fn set_platform(&mut self, v: super::super::steammessages::EGCPlatform) {
            self.platform = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ConVar {
        const NAME: &'static str = "ConVar";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.value = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.version_min = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.version_max = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.platform = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.version_min {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.version_max {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.platform {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.value.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.version_min {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.version_max {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.platform {
                os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ConVar {
            ConVar::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.version_min = ::std::option::Option::None;
            self.version_max = ::std::option::Option::None;
            self.platform = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ConVar {
            static instance: ConVar = ConVar {
                name: ::std::option::Option::None,
                value: ::std::option::Option::None,
                version_min: ::std::option::Option::None,
                version_max: ::std::option::Option::None,
                platform: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientApplyRemoteConVars.msg)
    pub msg: ::steam_vent_proto_common::protobuf::MessageField<CMsgApplyRemoteConVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientApplyRemoteConVars.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientApplyRemoteConVars {
    fn default() -> &'a CMsgGCToClientApplyRemoteConVars {
        <CMsgGCToClientApplyRemoteConVars as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientApplyRemoteConVars {
    pub fn new() -> CMsgGCToClientApplyRemoteConVars {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientApplyRemoteConVars {
    const NAME: &'static str = "CMsgGCToClientApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientApplyRemoteConVars {
        CMsgGCToClientApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientApplyRemoteConVars {
        static instance: CMsgGCToClientApplyRemoteConVars = CMsgGCToClientApplyRemoteConVars {
            msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToServerApplyRemoteConVars)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToServerApplyRemoteConVars {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToServerApplyRemoteConVars.msg)
    pub msg: ::steam_vent_proto_common::protobuf::MessageField<CMsgApplyRemoteConVars>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToServerApplyRemoteConVars.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToServerApplyRemoteConVars {
    fn default() -> &'a CMsgGCToServerApplyRemoteConVars {
        <CMsgGCToServerApplyRemoteConVars as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToServerApplyRemoteConVars {
    pub fn new() -> CMsgGCToServerApplyRemoteConVars {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToServerApplyRemoteConVars {
    const NAME: &'static str = "CMsgGCToServerApplyRemoteConVars";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.msg)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.msg.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.msg.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToServerApplyRemoteConVars {
        CMsgGCToServerApplyRemoteConVars::new()
    }

    fn clear(&mut self) {
        self.msg.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToServerApplyRemoteConVars {
        static instance: CMsgGCToServerApplyRemoteConVars = CMsgGCToServerApplyRemoteConVars {
            msg: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCIntegrityStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCIntegrityStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.report)
    pub report: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.secure_allowed)
    pub secure_allowed: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.diagnostics)
    pub diagnostics: ::std::vec::Vec<cmsg_client_to_gcintegrity_status::Keyvalue>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCIntegrityStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCIntegrityStatus {
    fn default() -> &'a CMsgClientToGCIntegrityStatus {
        <CMsgClientToGCIntegrityStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCIntegrityStatus {
    pub fn new() -> CMsgClientToGCIntegrityStatus {
        ::std::default::Default::default()
    }

    // optional string report = 1;

    pub fn report(&self) -> &str {
        match self.report.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_report(&mut self) {
        self.report = ::std::option::Option::None;
    }

    pub fn has_report(&self) -> bool {
        self.report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report(&mut self, v: ::std::string::String) {
        self.report = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_report(&mut self) -> &mut ::std::string::String {
        if self.report.is_none() {
            self.report = ::std::option::Option::Some(::std::string::String::new());
        }
        self.report.as_mut().unwrap()
    }

    // Take field
    pub fn take_report(&mut self) -> ::std::string::String {
        self.report.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool secure_allowed = 2;

    pub fn secure_allowed(&self) -> bool {
        self.secure_allowed.unwrap_or(false)
    }

    pub fn clear_secure_allowed(&mut self) {
        self.secure_allowed = ::std::option::Option::None;
    }

    pub fn has_secure_allowed(&self) -> bool {
        self.secure_allowed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secure_allowed(&mut self, v: bool) {
        self.secure_allowed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCIntegrityStatus {
    const NAME: &'static str = "CMsgClientToGCIntegrityStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.report = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.secure_allowed = ::std::option::Option::Some(is.read_bool()?);
                },
                26 => {
                    self.diagnostics.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.report.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.secure_allowed {
            my_size += 1 + 1;
        }
        for value in &self.diagnostics {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.report.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.secure_allowed {
            os.write_bool(2, v)?;
        }
        for v in &self.diagnostics {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCIntegrityStatus {
        CMsgClientToGCIntegrityStatus::new()
    }

    fn clear(&mut self) {
        self.report = ::std::option::Option::None;
        self.secure_allowed = ::std::option::Option::None;
        self.diagnostics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCIntegrityStatus {
        static instance: CMsgClientToGCIntegrityStatus = CMsgClientToGCIntegrityStatus {
            report: ::std::option::Option::None,
            secure_allowed: ::std::option::Option::None,
            diagnostics: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCIntegrityStatus`
pub mod cmsg_client_to_gcintegrity_status {
    // @@protoc_insertion_point(message:CMsgClientToGCIntegrityStatus.keyvalue)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Keyvalue {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.keyvalue.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.keyvalue.extended)
        pub extended: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.keyvalue.value)
        pub value: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCIntegrityStatus.keyvalue.string_value)
        pub string_value: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCIntegrityStatus.keyvalue.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Keyvalue {
        fn default() -> &'a Keyvalue {
            <Keyvalue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Keyvalue {
        pub fn new() -> Keyvalue {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional uint32 extended = 2;

        pub fn extended(&self) -> u32 {
            self.extended.unwrap_or(0)
        }

        pub fn clear_extended(&mut self) {
            self.extended = ::std::option::Option::None;
        }

        pub fn has_extended(&self) -> bool {
            self.extended.is_some()
        }

        // Param is passed by value, moved
        pub fn set_extended(&mut self, v: u32) {
            self.extended = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 3;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }

        // optional string string_value = 4;

        pub fn string_value(&self) -> &str {
            match self.string_value.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_string_value(&mut self) {
            self.string_value = ::std::option::Option::None;
        }

        pub fn has_string_value(&self) -> bool {
            self.string_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_string_value(&mut self, v: ::std::string::String) {
            self.string_value = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_string_value(&mut self) -> &mut ::std::string::String {
            if self.string_value.is_none() {
                self.string_value = ::std::option::Option::Some(::std::string::String::new());
            }
            self.string_value.as_mut().unwrap()
        }

        // Take field
        pub fn take_string_value(&mut self) -> ::std::string::String {
            self.string_value.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Keyvalue {
        const NAME: &'static str = "keyvalue";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.extended = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    34 => {
                        self.string_value = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.extended {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.string_value.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.extended {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.string_value.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Keyvalue {
            Keyvalue::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.extended = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.string_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Keyvalue {
            static instance: Keyvalue = Keyvalue {
                id: ::std::option::Option::None,
                extended: ::std::option::Option::None,
                value: ::std::option::Option::None,
                string_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCAggregateMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAggregateMetrics {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAggregateMetrics.metrics)
    pub metrics: ::std::vec::Vec<cmsg_client_to_gcaggregate_metrics::SingleMetric>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAggregateMetrics.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAggregateMetrics {
    fn default() -> &'a CMsgClientToGCAggregateMetrics {
        <CMsgClientToGCAggregateMetrics as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAggregateMetrics {
    pub fn new() -> CMsgClientToGCAggregateMetrics {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAggregateMetrics {
    const NAME: &'static str = "CMsgClientToGCAggregateMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.metrics.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.metrics {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAggregateMetrics {
        CMsgClientToGCAggregateMetrics::new()
    }

    fn clear(&mut self) {
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAggregateMetrics {
        static instance: CMsgClientToGCAggregateMetrics = CMsgClientToGCAggregateMetrics {
            metrics: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCAggregateMetrics`
pub mod cmsg_client_to_gcaggregate_metrics {
    // @@protoc_insertion_point(message:CMsgClientToGCAggregateMetrics.SingleMetric)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleMetric {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCAggregateMetrics.SingleMetric.metric_name)
        pub metric_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgClientToGCAggregateMetrics.SingleMetric.metric_count)
        pub metric_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCAggregateMetrics.SingleMetric.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleMetric {
        fn default() -> &'a SingleMetric {
            <SingleMetric as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleMetric {
        pub fn new() -> SingleMetric {
            ::std::default::Default::default()
        }

        // optional string metric_name = 1;

        pub fn metric_name(&self) -> &str {
            match self.metric_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_metric_name(&mut self) {
            self.metric_name = ::std::option::Option::None;
        }

        pub fn has_metric_name(&self) -> bool {
            self.metric_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metric_name(&mut self, v: ::std::string::String) {
            self.metric_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_metric_name(&mut self) -> &mut ::std::string::String {
            if self.metric_name.is_none() {
                self.metric_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.metric_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_metric_name(&mut self) -> ::std::string::String {
            self.metric_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 metric_count = 2;

        pub fn metric_count(&self) -> u32 {
            self.metric_count.unwrap_or(0)
        }

        pub fn clear_metric_count(&mut self) {
            self.metric_count = ::std::option::Option::None;
        }

        pub fn has_metric_count(&self) -> bool {
            self.metric_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_metric_count(&mut self, v: u32) {
            self.metric_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleMetric {
        const NAME: &'static str = "SingleMetric";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.metric_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.metric_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.metric_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.metric_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.metric_name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.metric_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleMetric {
            SingleMetric::new()
        }

        fn clear(&mut self) {
            self.metric_name = ::std::option::Option::None;
            self.metric_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleMetric {
            static instance: SingleMetric = SingleMetric {
                metric_name: ::std::option::Option::None,
                metric_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientAggregateMetricsBackoff)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientAggregateMetricsBackoff {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientAggregateMetricsBackoff.upload_rate_modifier)
    pub upload_rate_modifier: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientAggregateMetricsBackoff.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientAggregateMetricsBackoff {
    fn default() -> &'a CMsgGCToClientAggregateMetricsBackoff {
        <CMsgGCToClientAggregateMetricsBackoff as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientAggregateMetricsBackoff {
    pub fn new() -> CMsgGCToClientAggregateMetricsBackoff {
        ::std::default::Default::default()
    }

    // optional float upload_rate_modifier = 1;

    pub fn upload_rate_modifier(&self) -> f32 {
        self.upload_rate_modifier.unwrap_or(0.)
    }

    pub fn clear_upload_rate_modifier(&mut self) {
        self.upload_rate_modifier = ::std::option::Option::None;
    }

    pub fn has_upload_rate_modifier(&self) -> bool {
        self.upload_rate_modifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_rate_modifier(&mut self, v: f32) {
        self.upload_rate_modifier = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientAggregateMetricsBackoff {
    const NAME: &'static str = "CMsgGCToClientAggregateMetricsBackoff";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.upload_rate_modifier = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.upload_rate_modifier {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.upload_rate_modifier {
            os.write_float(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientAggregateMetricsBackoff {
        CMsgGCToClientAggregateMetricsBackoff::new()
    }

    fn clear(&mut self) {
        self.upload_rate_modifier = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientAggregateMetricsBackoff {
        static instance: CMsgGCToClientAggregateMetricsBackoff = CMsgGCToClientAggregateMetricsBackoff {
            upload_rate_modifier: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGCBaseMsg)
pub enum EGCBaseMsg {
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInviteToParty)
    k_EMsgGCInviteToParty = 4501,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInvitationCreated)
    k_EMsgGCInvitationCreated = 4502,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCPartyInviteResponse)
    k_EMsgGCPartyInviteResponse = 4503,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCKickFromParty)
    k_EMsgGCKickFromParty = 4504,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLeaveParty)
    k_EMsgGCLeaveParty = 4505,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCServerAvailable)
    k_EMsgGCServerAvailable = 4506,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCClientConnectToServer)
    k_EMsgGCClientConnectToServer = 4507,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCGameServerInfo)
    k_EMsgGCGameServerInfo = 4508,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLANServerAvailable)
    k_EMsgGCLANServerAvailable = 4511,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCInviteToLobby)
    k_EMsgGCInviteToLobby = 4512,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCLobbyInviteResponse)
    k_EMsgGCLobbyInviteResponse = 4513,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToClientPollFileRequest)
    k_EMsgGCToClientPollFileRequest = 4514,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToClientPollFileResponse)
    k_EMsgGCToClientPollFileResponse = 4515,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToGCPerformManualOp)
    k_EMsgGCToGCPerformManualOp = 4516,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToGCPerformManualOpCompleted)
    k_EMsgGCToGCPerformManualOpCompleted = 4517,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToGCReloadServerRegionSettings)
    k_EMsgGCToGCReloadServerRegionSettings = 4518,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCAdditionalWelcomeMsgList)
    k_EMsgGCAdditionalWelcomeMsgList = 4519,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToClientApplyRemoteConVars)
    k_EMsgGCToClientApplyRemoteConVars = 4520,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToServerApplyRemoteConVars)
    k_EMsgGCToServerApplyRemoteConVars = 4521,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgClientToGCIntegrityStatus)
    k_EMsgClientToGCIntegrityStatus = 4522,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgClientToGCAggregateMetrics)
    k_EMsgClientToGCAggregateMetrics = 4523,
    // @@protoc_insertion_point(enum_value:EGCBaseMsg.k_EMsgGCToClientAggregateMetricsBackoff)
    k_EMsgGCToClientAggregateMetricsBackoff = 4524,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGCBaseMsg {
    const NAME: &'static str = "EGCBaseMsg";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGCBaseMsg> {
        match value {
            4501 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            4502 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            4503 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            4504 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            4505 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            4506 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            4507 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            4508 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            4511 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            4512 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToLobby),
            4513 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLobbyInviteResponse),
            4514 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileRequest),
            4515 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileResponse),
            4516 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOp),
            4517 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted),
            4518 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings),
            4519 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList),
            4520 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars),
            4521 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars),
            4522 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCIntegrityStatus),
            4523 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCAggregateMetrics),
            4524 => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGCBaseMsg> {
        match str {
            "k_EMsgGCInviteToParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToParty),
            "k_EMsgGCInvitationCreated" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInvitationCreated),
            "k_EMsgGCPartyInviteResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCPartyInviteResponse),
            "k_EMsgGCKickFromParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCKickFromParty),
            "k_EMsgGCLeaveParty" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLeaveParty),
            "k_EMsgGCServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCServerAvailable),
            "k_EMsgGCClientConnectToServer" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCClientConnectToServer),
            "k_EMsgGCGameServerInfo" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCGameServerInfo),
            "k_EMsgGCLANServerAvailable" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLANServerAvailable),
            "k_EMsgGCInviteToLobby" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCInviteToLobby),
            "k_EMsgGCLobbyInviteResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCLobbyInviteResponse),
            "k_EMsgGCToClientPollFileRequest" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileRequest),
            "k_EMsgGCToClientPollFileResponse" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientPollFileResponse),
            "k_EMsgGCToGCPerformManualOp" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOp),
            "k_EMsgGCToGCPerformManualOpCompleted" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted),
            "k_EMsgGCToGCReloadServerRegionSettings" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings),
            "k_EMsgGCAdditionalWelcomeMsgList" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList),
            "k_EMsgGCToClientApplyRemoteConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars),
            "k_EMsgGCToServerApplyRemoteConVars" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars),
            "k_EMsgClientToGCIntegrityStatus" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCIntegrityStatus),
            "k_EMsgClientToGCAggregateMetrics" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgClientToGCAggregateMetrics),
            "k_EMsgGCToClientAggregateMetricsBackoff" => ::std::option::Option::Some(EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGCBaseMsg] = &[
        EGCBaseMsg::k_EMsgGCInviteToParty,
        EGCBaseMsg::k_EMsgGCInvitationCreated,
        EGCBaseMsg::k_EMsgGCPartyInviteResponse,
        EGCBaseMsg::k_EMsgGCKickFromParty,
        EGCBaseMsg::k_EMsgGCLeaveParty,
        EGCBaseMsg::k_EMsgGCServerAvailable,
        EGCBaseMsg::k_EMsgGCClientConnectToServer,
        EGCBaseMsg::k_EMsgGCGameServerInfo,
        EGCBaseMsg::k_EMsgGCLANServerAvailable,
        EGCBaseMsg::k_EMsgGCInviteToLobby,
        EGCBaseMsg::k_EMsgGCLobbyInviteResponse,
        EGCBaseMsg::k_EMsgGCToClientPollFileRequest,
        EGCBaseMsg::k_EMsgGCToClientPollFileResponse,
        EGCBaseMsg::k_EMsgGCToGCPerformManualOp,
        EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted,
        EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings,
        EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList,
        EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars,
        EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars,
        EGCBaseMsg::k_EMsgClientToGCIntegrityStatus,
        EGCBaseMsg::k_EMsgClientToGCAggregateMetrics,
        EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EGCBaseMsg {
    fn default() -> Self {
        EGCBaseMsg::k_EMsgGCInviteToParty
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ECustomGameInstallStatus)
pub enum ECustomGameInstallStatus {
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_Unknown)
    k_ECustomGameInstallStatus_Unknown = 0,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_Ready)
    k_ECustomGameInstallStatus_Ready = 1,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_Busy)
    k_ECustomGameInstallStatus_Busy = 2,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedGeneric)
    k_ECustomGameInstallStatus_FailedGeneric = 101,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedInternalError)
    k_ECustomGameInstallStatus_FailedInternalError = 102,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooOld)
    k_ECustomGameInstallStatus_RequestedTimestampTooOld = 103,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_RequestedTimestampTooNew)
    k_ECustomGameInstallStatus_RequestedTimestampTooNew = 104,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_CRCMismatch)
    k_ECustomGameInstallStatus_CRCMismatch = 105,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedSteam)
    k_ECustomGameInstallStatus_FailedSteam = 106,
    // @@protoc_insertion_point(enum_value:ECustomGameInstallStatus.k_ECustomGameInstallStatus_FailedCanceled)
    k_ECustomGameInstallStatus_FailedCanceled = 107,
}

impl ::steam_vent_proto_common::protobuf::Enum for ECustomGameInstallStatus {
    const NAME: &'static str = "ECustomGameInstallStatus";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ECustomGameInstallStatus> {
        match value {
            0 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            1 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready),
            2 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy),
            101 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric),
            102 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError),
            103 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld),
            104 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew),
            105 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch),
            106 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam),
            107 => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ECustomGameInstallStatus> {
        match str {
            "k_ECustomGameInstallStatus_Unknown" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown),
            "k_ECustomGameInstallStatus_Ready" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready),
            "k_ECustomGameInstallStatus_Busy" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy),
            "k_ECustomGameInstallStatus_FailedGeneric" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric),
            "k_ECustomGameInstallStatus_FailedInternalError" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError),
            "k_ECustomGameInstallStatus_RequestedTimestampTooOld" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld),
            "k_ECustomGameInstallStatus_RequestedTimestampTooNew" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew),
            "k_ECustomGameInstallStatus_CRCMismatch" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch),
            "k_ECustomGameInstallStatus_FailedSteam" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam),
            "k_ECustomGameInstallStatus_FailedCanceled" => ::std::option::Option::Some(ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ECustomGameInstallStatus] = &[
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Ready,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Busy,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedGeneric,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedInternalError,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooOld,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_RequestedTimestampTooNew,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_CRCMismatch,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedSteam,
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_FailedCanceled,
    ];
}

impl ::std::default::Default for ECustomGameInstallStatus {
    fn default() -> Self {
        ECustomGameInstallStatus::k_ECustomGameInstallStatus_Unknown
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
impl ::steam_vent_proto_common::RpcMessage for CGCStorePurchaseInit_LineItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseInit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCStorePurchaseInit {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseInit;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseInitResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCStorePurchaseInitResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseInitResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientPingData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgInviteToParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgInviteToParty {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCInviteToParty;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgInviteToLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgInviteToLobby {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCInviteToLobby;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgInvitationCreated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgInvitationCreated {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCInvitationCreated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartyInviteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgPartyInviteResponse {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCPartyInviteResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyInviteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLobbyInviteResponse {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCLobbyInviteResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgKickFromParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgKickFromParty {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCKickFromParty;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLeaveParty {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLeaveParty {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCLeaveParty;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgCustomGameInstallStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgServerAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgServerAvailable {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCServerAvailable;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLANServerAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLANServerAvailable {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCLANServerAvailable;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconGameAccountClient {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyStrangePart {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyStrangePart {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyStrangePart;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyPennantUpgrade {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyPennantUpgrade {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyPennantUpgrade;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyEggEssence {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgApplyEggEssence {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCApplyEggEssence;
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemAttribute {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItemEquipped {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSOEconItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSortItems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSortItems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSortItems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgItemAcknowledged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgItemAcknowledged {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCItemAcknowledged;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSetItemPositions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgSetItemPositions {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCSetItemPositions;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseCancel {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCStorePurchaseCancel {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseCancel;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseCancelResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCStorePurchaseCancelResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseCancelResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseFinalize {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCStorePurchaseFinalize {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseFinalize;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCStorePurchaseFinalizeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCStorePurchaseFinalizeResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCStorePurchaseFinalizeResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCBannedWordListUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCBannedWordListUpdated {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCBannedWordListUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCDirtySDOCache {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCDirtySDOCache {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCDirtySDOCache;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSDONoMemcached {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCUpdateSQLKeyValue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCUpdateSQLKeyValue {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCUpdateSQLKeyValue;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCServerVersionUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCServerVersionUpdated {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCServerVersionUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCClientVersionUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCClientVersionUpdated {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCClientVersionUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCWebAPIAccountChanged {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCWebAPIAccountChanged {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCToGCWebAPIAccountChanged;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgExtractGems {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgExtractGems {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCExtractGems;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgExtractGemsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgExtractGemsResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCExtractGemsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAddSocket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAddSocket {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAddSocket;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAddSocketResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAddSocketResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAddSocketResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAddItemToSocketData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAddItemToSocket {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAddItemToSocket {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAddItemToSocket;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAddItemToSocketResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgAddItemToSocketResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCAddItemToSocketResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgResetStrangeGemCount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgResetStrangeGemCount {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCResetStrangeGemCount;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgResetStrangeGemCountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgResetStrangeGemCountResponse {
    type KindEnum = crate::econ_gcmessages::EGCItemMsg;
    const KIND: Self::KindEnum = crate::econ_gcmessages::EGCItemMsg::k_EMsgGCResetStrangeGemCountResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPollFileRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPollFileRequest {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToClientPollFileRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPollFileResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPollFileResponse {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToClientPollFileResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPerformManualOp {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToGCPerformManualOp {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToGCPerformManualOp;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCPerformManualOpCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCPerformManualOpCompleted {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToGCPerformManualOpCompleted;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCReloadServerRegionSettings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToGCReloadServerRegionSettings {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToGCReloadServerRegionSettings;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCAdditionalWelcomeMsgList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCAdditionalWelcomeMsgList {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCAdditionalWelcomeMsgList;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgApplyRemoteConVars {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientApplyRemoteConVars {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientApplyRemoteConVars {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToClientApplyRemoteConVars;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToServerApplyRemoteConVars {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToServerApplyRemoteConVars {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToServerApplyRemoteConVars;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCIntegrityStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCIntegrityStatus {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgClientToGCIntegrityStatus;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAggregateMetrics {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCAggregateMetrics {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgClientToGCAggregateMetrics;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientAggregateMetricsBackoff {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientAggregateMetricsBackoff {
    type KindEnum = crate::base_gcmessages::EGCBaseMsg;
    const KIND: Self::KindEnum = crate::base_gcmessages::EGCBaseMsg::k_EMsgGCToClientAggregateMetricsBackoff;
}
impl ::steam_vent_proto_common::MsgKindEnum for EGCBaseMsg {}
