// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgClientSuspended)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientSuspended {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientSuspended.time_end)
    pub time_end: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientSuspended.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientSuspended {
    fn default() -> &'a CMsgClientSuspended {
        <CMsgClientSuspended as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientSuspended {
    pub fn new() -> CMsgClientSuspended {
        ::std::default::Default::default()
    }

    // optional uint32 time_end = 1;

    pub fn time_end(&self) -> u32 {
        self.time_end.unwrap_or(0)
    }

    pub fn clear_time_end(&mut self) {
        self.time_end = ::std::option::Option::None;
    }

    pub fn has_time_end(&self) -> bool {
        self.time_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_end(&mut self, v: u32) {
        self.time_end = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientSuspended {
    const NAME: &'static str = "CMsgClientSuspended";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.time_end = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.time_end {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.time_end {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientSuspended {
        CMsgClientSuspended::new()
    }

    fn clear(&mut self) {
        self.time_end = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientSuspended {
        static instance: CMsgClientSuspended = CMsgClientSuspended {
            time_end: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgBalancedShuffleLobby)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgBalancedShuffleLobby {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgBalancedShuffleLobby.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgBalancedShuffleLobby {
    fn default() -> &'a CMsgBalancedShuffleLobby {
        <CMsgBalancedShuffleLobby as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgBalancedShuffleLobby {
    pub fn new() -> CMsgBalancedShuffleLobby {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgBalancedShuffleLobby {
    const NAME: &'static str = "CMsgBalancedShuffleLobby";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgBalancedShuffleLobby {
        CMsgBalancedShuffleLobby::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgBalancedShuffleLobby {
        static instance: CMsgBalancedShuffleLobby = CMsgBalancedShuffleLobby {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgInitialQuestionnaireResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgInitialQuestionnaireResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgInitialQuestionnaireResponse.initial_skill)
    pub initial_skill: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgInitialQuestionnaireResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgInitialQuestionnaireResponse {
    fn default() -> &'a CMsgInitialQuestionnaireResponse {
        <CMsgInitialQuestionnaireResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgInitialQuestionnaireResponse {
    pub fn new() -> CMsgInitialQuestionnaireResponse {
        ::std::default::Default::default()
    }

    // optional uint32 initial_skill = 1;

    pub fn initial_skill(&self) -> u32 {
        self.initial_skill.unwrap_or(0)
    }

    pub fn clear_initial_skill(&mut self) {
        self.initial_skill = ::std::option::Option::None;
    }

    pub fn has_initial_skill(&self) -> bool {
        self.initial_skill.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initial_skill(&mut self, v: u32) {
        self.initial_skill = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgInitialQuestionnaireResponse {
    const NAME: &'static str = "CMsgInitialQuestionnaireResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.initial_skill = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.initial_skill {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.initial_skill {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgInitialQuestionnaireResponse {
        CMsgInitialQuestionnaireResponse::new()
    }

    fn clear(&mut self) {
        self.initial_skill = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgInitialQuestionnaireResponse {
        static instance: CMsgInitialQuestionnaireResponse = CMsgInitialQuestionnaireResponse {
            initial_skill: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTARequestMatchesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARequestMatchesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.matches)
    pub matches: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.series)
    pub series: ::std::vec::Vec<cmsg_dotarequest_matches_response::Series>,
    // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.total_results)
    pub total_results: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.results_remaining)
    pub results_remaining: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTARequestMatchesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARequestMatchesResponse {
    fn default() -> &'a CMsgDOTARequestMatchesResponse {
        <CMsgDOTARequestMatchesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARequestMatchesResponse {
    pub fn new() -> CMsgDOTARequestMatchesResponse {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 3;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional uint32 total_results = 4;

    pub fn total_results(&self) -> u32 {
        self.total_results.unwrap_or(0)
    }

    pub fn clear_total_results(&mut self) {
        self.total_results = ::std::option::Option::None;
    }

    pub fn has_total_results(&self) -> bool {
        self.total_results.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_results(&mut self, v: u32) {
        self.total_results = ::std::option::Option::Some(v);
    }

    // optional uint32 results_remaining = 5;

    pub fn results_remaining(&self) -> u32 {
        self.results_remaining.unwrap_or(0)
    }

    pub fn clear_results_remaining(&mut self) {
        self.results_remaining = ::std::option::Option::None;
    }

    pub fn has_results_remaining(&self) -> bool {
        self.results_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_results_remaining(&mut self, v: u32) {
        self.results_remaining = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTARequestMatchesResponse {
    const NAME: &'static str = "CMsgDOTARequestMatchesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                18 => {
                    self.series.push(is.read_message()?);
                },
                24 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_results = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.results_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.series {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_results {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.results_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.series {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.request_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_results {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.results_remaining {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARequestMatchesResponse {
        CMsgDOTARequestMatchesResponse::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.series.clear();
        self.request_id = ::std::option::Option::None;
        self.total_results = ::std::option::Option::None;
        self.results_remaining = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARequestMatchesResponse {
        static instance: CMsgDOTARequestMatchesResponse = CMsgDOTARequestMatchesResponse {
            matches: ::std::vec::Vec::new(),
            series: ::std::vec::Vec::new(),
            request_id: ::std::option::Option::None,
            total_results: ::std::option::Option::None,
            results_remaining: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTARequestMatchesResponse`
pub mod cmsg_dotarequest_matches_response {
    // @@protoc_insertion_point(message:CMsgDOTARequestMatchesResponse.Series)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Series {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.Series.matches)
        pub matches: ::std::vec::Vec<super::super::dota_gcmessages_common::CMsgDOTAMatch>,
        // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.Series.series_id)
        pub series_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTARequestMatchesResponse.Series.series_type)
        pub series_type: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTARequestMatchesResponse.Series.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Series {
        fn default() -> &'a Series {
            <Series as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Series {
        pub fn new() -> Series {
            ::std::default::Default::default()
        }

        // optional uint32 series_id = 2;

        pub fn series_id(&self) -> u32 {
            self.series_id.unwrap_or(0)
        }

        pub fn clear_series_id(&mut self) {
            self.series_id = ::std::option::Option::None;
        }

        pub fn has_series_id(&self) -> bool {
            self.series_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_id(&mut self, v: u32) {
            self.series_id = ::std::option::Option::Some(v);
        }

        // optional uint32 series_type = 3;

        pub fn series_type(&self) -> u32 {
            self.series_type.unwrap_or(0)
        }

        pub fn clear_series_type(&mut self) {
            self.series_type = ::std::option::Option::None;
        }

        pub fn has_series_type(&self) -> bool {
            self.series_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_series_type(&mut self, v: u32) {
            self.series_type = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Series {
        const NAME: &'static str = "Series";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.matches.push(is.read_message()?);
                    },
                    16 => {
                        self.series_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.series_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            for value in &self.matches {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.series_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.series_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            for v in &self.matches {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            };
            if let Some(v) = self.series_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.series_type {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Series {
            Series::new()
        }

        fn clear(&mut self) {
            self.matches.clear();
            self.series_id = ::std::option::Option::None;
            self.series_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Series {
            static instance: Series = Series {
                matches: ::std::vec::Vec::new(),
                series_id: ::std::option::Option::None,
                series_type: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAPopup)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPopup {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPopup.id)
    pub id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotapopup::PopupID>>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.custom_text)
    pub custom_text: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.int_data)
    pub int_data: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.popup_data)
    pub popup_data: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.loc_token_header)
    pub loc_token_header: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.loc_token_msg)
    pub loc_token_msg: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.var_names)
    pub var_names: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.var_values)
    pub var_values: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPopup.debug_text)
    pub debug_text: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPopup.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPopup {
    fn default() -> &'a CMsgDOTAPopup {
        <CMsgDOTAPopup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPopup {
    pub fn new() -> CMsgDOTAPopup {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAPopup.PopupID id = 1;

    pub fn id(&self) -> cmsg_dotapopup::PopupID {
        match self.id {
            Some(e) => e.enum_value_or(cmsg_dotapopup::PopupID::NONE),
            None => cmsg_dotapopup::PopupID::NONE,
        }
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: cmsg_dotapopup::PopupID) {
        self.id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string custom_text = 2;

    pub fn custom_text(&self) -> &str {
        match self.custom_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_custom_text(&mut self) {
        self.custom_text = ::std::option::Option::None;
    }

    pub fn has_custom_text(&self) -> bool {
        self.custom_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_text(&mut self, v: ::std::string::String) {
        self.custom_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_text(&mut self) -> &mut ::std::string::String {
        if self.custom_text.is_none() {
            self.custom_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.custom_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_custom_text(&mut self) -> ::std::string::String {
        self.custom_text.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional sint32 int_data = 3;

    pub fn int_data(&self) -> i32 {
        self.int_data.unwrap_or(0)
    }

    pub fn clear_int_data(&mut self) {
        self.int_data = ::std::option::Option::None;
    }

    pub fn has_int_data(&self) -> bool {
        self.int_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_int_data(&mut self, v: i32) {
        self.int_data = ::std::option::Option::Some(v);
    }

    // optional bytes popup_data = 4;

    pub fn popup_data(&self) -> &[u8] {
        match self.popup_data.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_popup_data(&mut self) {
        self.popup_data = ::std::option::Option::None;
    }

    pub fn has_popup_data(&self) -> bool {
        self.popup_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_popup_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.popup_data = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_popup_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.popup_data.is_none() {
            self.popup_data = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.popup_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_popup_data(&mut self) -> ::std::vec::Vec<u8> {
        self.popup_data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string loc_token_header = 5;

    pub fn loc_token_header(&self) -> &str {
        match self.loc_token_header.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_token_header(&mut self) {
        self.loc_token_header = ::std::option::Option::None;
    }

    pub fn has_loc_token_header(&self) -> bool {
        self.loc_token_header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_token_header(&mut self, v: ::std::string::String) {
        self.loc_token_header = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_token_header(&mut self) -> &mut ::std::string::String {
        if self.loc_token_header.is_none() {
            self.loc_token_header = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_token_header.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_token_header(&mut self) -> ::std::string::String {
        self.loc_token_header.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loc_token_msg = 6;

    pub fn loc_token_msg(&self) -> &str {
        match self.loc_token_msg.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_loc_token_msg(&mut self) {
        self.loc_token_msg = ::std::option::Option::None;
    }

    pub fn has_loc_token_msg(&self) -> bool {
        self.loc_token_msg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loc_token_msg(&mut self, v: ::std::string::String) {
        self.loc_token_msg = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loc_token_msg(&mut self) -> &mut ::std::string::String {
        if self.loc_token_msg.is_none() {
            self.loc_token_msg = ::std::option::Option::Some(::std::string::String::new());
        }
        self.loc_token_msg.as_mut().unwrap()
    }

    // Take field
    pub fn take_loc_token_msg(&mut self) -> ::std::string::String {
        self.loc_token_msg.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string debug_text = 9;

    pub fn debug_text(&self) -> &str {
        match self.debug_text.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_text(&mut self) {
        self.debug_text = ::std::option::Option::None;
    }

    pub fn has_debug_text(&self) -> bool {
        self.debug_text.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_text(&mut self, v: ::std::string::String) {
        self.debug_text = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_text(&mut self) -> &mut ::std::string::String {
        if self.debug_text.is_none() {
            self.debug_text = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_text.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_text(&mut self) -> ::std::string::String {
        self.debug_text.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPopup {
    const NAME: &'static str = "CMsgDOTAPopup";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.custom_text = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.int_data = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.popup_data = ::std::option::Option::Some(is.read_bytes()?);
                },
                42 => {
                    self.loc_token_header = ::std::option::Option::Some(is.read_string()?);
                },
                50 => {
                    self.loc_token_msg = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.var_names.push(is.read_string()?);
                },
                66 => {
                    self.var_values.push(is.read_string()?);
                },
                74 => {
                    self.debug_text = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.custom_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.int_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.popup_data.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(4, &v);
        }
        if let Some(v) = self.loc_token_header.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.loc_token_msg.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        for value in &self.var_names {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &value);
        };
        for value in &self.var_values {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &value);
        };
        if let Some(v) = self.debug_text.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(9, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.custom_text.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.int_data {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.popup_data.as_ref() {
            os.write_bytes(4, v)?;
        }
        if let Some(v) = self.loc_token_header.as_ref() {
            os.write_string(5, v)?;
        }
        if let Some(v) = self.loc_token_msg.as_ref() {
            os.write_string(6, v)?;
        }
        for v in &self.var_names {
            os.write_string(7, &v)?;
        };
        for v in &self.var_values {
            os.write_string(8, &v)?;
        };
        if let Some(v) = self.debug_text.as_ref() {
            os.write_string(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPopup {
        CMsgDOTAPopup::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.custom_text = ::std::option::Option::None;
        self.int_data = ::std::option::Option::None;
        self.popup_data = ::std::option::Option::None;
        self.loc_token_header = ::std::option::Option::None;
        self.loc_token_msg = ::std::option::Option::None;
        self.var_names.clear();
        self.var_values.clear();
        self.debug_text = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPopup {
        static instance: CMsgDOTAPopup = CMsgDOTAPopup {
            id: ::std::option::Option::None,
            custom_text: ::std::option::Option::None,
            int_data: ::std::option::Option::None,
            popup_data: ::std::option::Option::None,
            loc_token_header: ::std::option::Option::None,
            loc_token_msg: ::std::option::Option::None,
            var_names: ::std::vec::Vec::new(),
            var_values: ::std::vec::Vec::new(),
            debug_text: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAPopup`
pub mod cmsg_dotapopup {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAPopup.PopupID)
    pub enum PopupID {
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.NONE)
        NONE = -1,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.KICKED_FROM_LOBBY)
        KICKED_FROM_LOBBY = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.KICKED_FROM_PARTY)
        KICKED_FROM_PARTY = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.KICKED_FROM_TEAM)
        KICKED_FROM_TEAM = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_WAS_DISBANDED)
        TEAM_WAS_DISBANDED = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_ALREADY_MATCH)
        TEAM_MATCHMAKE_ALREADY_MATCH = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_ALREADY_FINDING)
        TEAM_MATCHMAKE_ALREADY_FINDING = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_FULL)
        TEAM_MATCHMAKE_FULL = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_FAIL_ADD)
        TEAM_MATCHMAKE_FAIL_ADD = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_FAIL_ADD_CURRENT)
        TEAM_MATCHMAKE_FAIL_ADD_CURRENT = 8,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_FAILED_TEAM_MEMBER)
        TEAM_MATCHMAKE_FAILED_TEAM_MEMBER = 9,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_ALREADY_GAME)
        TEAM_MATCHMAKE_ALREADY_GAME = 10,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TEAM_MATCHMAKE_FAIL_GET_PARTY)
        TEAM_MATCHMAKE_FAIL_GET_PARTY = 11,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.MATCHMAKING_DISABLED)
        MATCHMAKING_DISABLED = 12,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.INVITE_DENIED)
        INVITE_DENIED = 13,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.PARTY_FULL)
        PARTY_FULL = 14,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.MADE_ADMIN)
        MADE_ADMIN = 15,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.NEED_TO_PURCHASE)
        NEED_TO_PURCHASE = 16,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.SIGNON_MESSAGE)
        SIGNON_MESSAGE = 17,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.MATCHMAKING_REGION_OFFLINE)
        MATCHMAKING_REGION_OFFLINE = 19,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_NOT_FOUND)
        TOURNAMENT_GAME_NOT_FOUND = 21,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_HAS_LOBBY_ID)
        TOURNAMENT_GAME_HAS_LOBBY_ID = 22,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_HAS_MATCH_ID)
        TOURNAMENT_GAME_HAS_MATCH_ID = 23,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM)
        TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM = 24,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_HAS_NO_DIRE_TEAM)
        TOURNAMENT_GAME_HAS_NO_DIRE_TEAM = 25,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TOURNAMENT_GAME_SQL_UPDATE_FAILED)
        TOURNAMENT_GAME_SQL_UPDATE_FAILED = 26,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.NOT_LEAGUE_ADMIN)
        NOT_LEAGUE_ADMIN = 27,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.IN_ANOTHER_GAME)
        IN_ANOTHER_GAME = 29,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.PARTY_MEMBER_IN_ANOTHER_GAME)
        PARTY_MEMBER_IN_ANOTHER_GAME = 30,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.PARTY_MEMBER_IN_LOW_PRIORITY)
        PARTY_MEMBER_IN_LOW_PRIORITY = 31,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.CLIENT_OUT_OF_DATE)
        CLIENT_OUT_OF_DATE = 32,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.SAVE_GAME_CORRUPT)
        SAVE_GAME_CORRUPT = 38,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.INSUFFICIENT_INGOTS)
        INSUFFICIENT_INGOTS = 39,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL)
        COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL = 42,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.PARTY_LEADER_JOINED_LOBBY)
        PARTY_LEADER_JOINED_LOBBY = 44,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.WEEKEND_TOURNEY_UNMATCHED)
        WEEKEND_TOURNEY_UNMATCHED = 48,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.POST_MATCH_SURVEY)
        POST_MATCH_SURVEY = 49,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TROPHY_AWARDED)
        TROPHY_AWARDED = 50,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TROPHY_LEVEL_UP)
        TROPHY_LEVEL_UP = 51,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.ALL_HERO_CHALLENGE_PROGRESS)
        ALL_HERO_CHALLENGE_PROGRESS = 52,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.NEED_INITIAL_SKILL)
        NEED_INITIAL_SKILL = 53,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.NEED_INITIAL_SKILL_IN_PARTY)
        NEED_INITIAL_SKILL_IN_PARTY = 54,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.TARGET_ENGINE_MISMATCH)
        TARGET_ENGINE_MISMATCH = 55,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.VAC_NOT_VERIFIED)
        VAC_NOT_VERIFIED = 56,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.KICKED_FROM_QUEUE_EVENT_STARTING)
        KICKED_FROM_QUEUE_EVENT_STARTING = 57,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.KICKED_FROM_QUEUE_EVENT_ENDING)
        KICKED_FROM_QUEUE_EVENT_ENDING = 58,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.LOBBY_FULL)
        LOBBY_FULL = 62,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.EVENT_POINTS_EARNED)
        EVENT_POINTS_EARNED = 63,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.CUSTOM_GAME_INCORRECT_VERSION)
        CUSTOM_GAME_INCORRECT_VERSION = 64,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.LIMITED_USER_CHAT)
        LIMITED_USER_CHAT = 66,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.EVENT_PREMIUM_POINTS_EARNED)
        EVENT_PREMIUM_POINTS_EARNED = 67,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.LOBBY_MVP_AWARDED)
        LOBBY_MVP_AWARDED = 68,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.LOW_BADGE_LEVEL_CHAT)
        LOW_BADGE_LEVEL_CHAT = 71,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.LOW_WINS_CHAT)
        LOW_WINS_CHAT = 72,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.UNVERIFIED_USER_CHAT)
        UNVERIFIED_USER_CHAT = 73,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.PARTY_STARTED_FINDING_EVENT_MATCH)
        PARTY_STARTED_FINDING_EVENT_MATCH = 74,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.GENERIC_INFO)
        GENERIC_INFO = 69,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.GENERIC_ERROR)
        GENERIC_ERROR = 70,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.RANK_TIER_UPDATED)
        RANK_TIER_UPDATED = 75,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.CUSTOM_GAME_COOLDOWN_RESTRICTED)
        CUSTOM_GAME_COOLDOWN_RESTRICTED = 76,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME)
        CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME = 77,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.CUSTOM_GAME_TOO_FEW_GAMES)
        CUSTOM_GAME_TOO_FEW_GAMES = 78,
        // @@protoc_insertion_point(enum_value:CMsgDOTAPopup.PopupID.COMM_SCORE_TOO_LOW)
        COMM_SCORE_TOO_LOW = 79,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for PopupID {
        const NAME: &'static str = "PopupID";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<PopupID> {
            match value {
                -1 => ::std::option::Option::Some(PopupID::NONE),
                0 => ::std::option::Option::Some(PopupID::KICKED_FROM_LOBBY),
                1 => ::std::option::Option::Some(PopupID::KICKED_FROM_PARTY),
                2 => ::std::option::Option::Some(PopupID::KICKED_FROM_TEAM),
                3 => ::std::option::Option::Some(PopupID::TEAM_WAS_DISBANDED),
                4 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_MATCH),
                5 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_FINDING),
                6 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FULL),
                7 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_ADD),
                8 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_ADD_CURRENT),
                9 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAILED_TEAM_MEMBER),
                10 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_GAME),
                11 => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_GET_PARTY),
                12 => ::std::option::Option::Some(PopupID::MATCHMAKING_DISABLED),
                13 => ::std::option::Option::Some(PopupID::INVITE_DENIED),
                14 => ::std::option::Option::Some(PopupID::PARTY_FULL),
                15 => ::std::option::Option::Some(PopupID::MADE_ADMIN),
                16 => ::std::option::Option::Some(PopupID::NEED_TO_PURCHASE),
                17 => ::std::option::Option::Some(PopupID::SIGNON_MESSAGE),
                19 => ::std::option::Option::Some(PopupID::MATCHMAKING_REGION_OFFLINE),
                21 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_NOT_FOUND),
                22 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_LOBBY_ID),
                23 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_MATCH_ID),
                24 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM),
                25 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_NO_DIRE_TEAM),
                26 => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_SQL_UPDATE_FAILED),
                27 => ::std::option::Option::Some(PopupID::NOT_LEAGUE_ADMIN),
                29 => ::std::option::Option::Some(PopupID::IN_ANOTHER_GAME),
                30 => ::std::option::Option::Some(PopupID::PARTY_MEMBER_IN_ANOTHER_GAME),
                31 => ::std::option::Option::Some(PopupID::PARTY_MEMBER_IN_LOW_PRIORITY),
                32 => ::std::option::Option::Some(PopupID::CLIENT_OUT_OF_DATE),
                38 => ::std::option::Option::Some(PopupID::SAVE_GAME_CORRUPT),
                39 => ::std::option::Option::Some(PopupID::INSUFFICIENT_INGOTS),
                42 => ::std::option::Option::Some(PopupID::COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL),
                44 => ::std::option::Option::Some(PopupID::PARTY_LEADER_JOINED_LOBBY),
                48 => ::std::option::Option::Some(PopupID::WEEKEND_TOURNEY_UNMATCHED),
                49 => ::std::option::Option::Some(PopupID::POST_MATCH_SURVEY),
                50 => ::std::option::Option::Some(PopupID::TROPHY_AWARDED),
                51 => ::std::option::Option::Some(PopupID::TROPHY_LEVEL_UP),
                52 => ::std::option::Option::Some(PopupID::ALL_HERO_CHALLENGE_PROGRESS),
                53 => ::std::option::Option::Some(PopupID::NEED_INITIAL_SKILL),
                54 => ::std::option::Option::Some(PopupID::NEED_INITIAL_SKILL_IN_PARTY),
                55 => ::std::option::Option::Some(PopupID::TARGET_ENGINE_MISMATCH),
                56 => ::std::option::Option::Some(PopupID::VAC_NOT_VERIFIED),
                57 => ::std::option::Option::Some(PopupID::KICKED_FROM_QUEUE_EVENT_STARTING),
                58 => ::std::option::Option::Some(PopupID::KICKED_FROM_QUEUE_EVENT_ENDING),
                62 => ::std::option::Option::Some(PopupID::LOBBY_FULL),
                63 => ::std::option::Option::Some(PopupID::EVENT_POINTS_EARNED),
                64 => ::std::option::Option::Some(PopupID::CUSTOM_GAME_INCORRECT_VERSION),
                66 => ::std::option::Option::Some(PopupID::LIMITED_USER_CHAT),
                67 => ::std::option::Option::Some(PopupID::EVENT_PREMIUM_POINTS_EARNED),
                68 => ::std::option::Option::Some(PopupID::LOBBY_MVP_AWARDED),
                71 => ::std::option::Option::Some(PopupID::LOW_BADGE_LEVEL_CHAT),
                72 => ::std::option::Option::Some(PopupID::LOW_WINS_CHAT),
                73 => ::std::option::Option::Some(PopupID::UNVERIFIED_USER_CHAT),
                74 => ::std::option::Option::Some(PopupID::PARTY_STARTED_FINDING_EVENT_MATCH),
                69 => ::std::option::Option::Some(PopupID::GENERIC_INFO),
                70 => ::std::option::Option::Some(PopupID::GENERIC_ERROR),
                75 => ::std::option::Option::Some(PopupID::RANK_TIER_UPDATED),
                76 => ::std::option::Option::Some(PopupID::CUSTOM_GAME_COOLDOWN_RESTRICTED),
                77 => ::std::option::Option::Some(PopupID::CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME),
                78 => ::std::option::Option::Some(PopupID::CUSTOM_GAME_TOO_FEW_GAMES),
                79 => ::std::option::Option::Some(PopupID::COMM_SCORE_TOO_LOW),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<PopupID> {
            match str {
                "NONE" => ::std::option::Option::Some(PopupID::NONE),
                "KICKED_FROM_LOBBY" => ::std::option::Option::Some(PopupID::KICKED_FROM_LOBBY),
                "KICKED_FROM_PARTY" => ::std::option::Option::Some(PopupID::KICKED_FROM_PARTY),
                "KICKED_FROM_TEAM" => ::std::option::Option::Some(PopupID::KICKED_FROM_TEAM),
                "TEAM_WAS_DISBANDED" => ::std::option::Option::Some(PopupID::TEAM_WAS_DISBANDED),
                "TEAM_MATCHMAKE_ALREADY_MATCH" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_MATCH),
                "TEAM_MATCHMAKE_ALREADY_FINDING" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_FINDING),
                "TEAM_MATCHMAKE_FULL" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FULL),
                "TEAM_MATCHMAKE_FAIL_ADD" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_ADD),
                "TEAM_MATCHMAKE_FAIL_ADD_CURRENT" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_ADD_CURRENT),
                "TEAM_MATCHMAKE_FAILED_TEAM_MEMBER" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAILED_TEAM_MEMBER),
                "TEAM_MATCHMAKE_ALREADY_GAME" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_ALREADY_GAME),
                "TEAM_MATCHMAKE_FAIL_GET_PARTY" => ::std::option::Option::Some(PopupID::TEAM_MATCHMAKE_FAIL_GET_PARTY),
                "MATCHMAKING_DISABLED" => ::std::option::Option::Some(PopupID::MATCHMAKING_DISABLED),
                "INVITE_DENIED" => ::std::option::Option::Some(PopupID::INVITE_DENIED),
                "PARTY_FULL" => ::std::option::Option::Some(PopupID::PARTY_FULL),
                "MADE_ADMIN" => ::std::option::Option::Some(PopupID::MADE_ADMIN),
                "NEED_TO_PURCHASE" => ::std::option::Option::Some(PopupID::NEED_TO_PURCHASE),
                "SIGNON_MESSAGE" => ::std::option::Option::Some(PopupID::SIGNON_MESSAGE),
                "MATCHMAKING_REGION_OFFLINE" => ::std::option::Option::Some(PopupID::MATCHMAKING_REGION_OFFLINE),
                "TOURNAMENT_GAME_NOT_FOUND" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_NOT_FOUND),
                "TOURNAMENT_GAME_HAS_LOBBY_ID" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_LOBBY_ID),
                "TOURNAMENT_GAME_HAS_MATCH_ID" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_MATCH_ID),
                "TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM),
                "TOURNAMENT_GAME_HAS_NO_DIRE_TEAM" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_HAS_NO_DIRE_TEAM),
                "TOURNAMENT_GAME_SQL_UPDATE_FAILED" => ::std::option::Option::Some(PopupID::TOURNAMENT_GAME_SQL_UPDATE_FAILED),
                "NOT_LEAGUE_ADMIN" => ::std::option::Option::Some(PopupID::NOT_LEAGUE_ADMIN),
                "IN_ANOTHER_GAME" => ::std::option::Option::Some(PopupID::IN_ANOTHER_GAME),
                "PARTY_MEMBER_IN_ANOTHER_GAME" => ::std::option::Option::Some(PopupID::PARTY_MEMBER_IN_ANOTHER_GAME),
                "PARTY_MEMBER_IN_LOW_PRIORITY" => ::std::option::Option::Some(PopupID::PARTY_MEMBER_IN_LOW_PRIORITY),
                "CLIENT_OUT_OF_DATE" => ::std::option::Option::Some(PopupID::CLIENT_OUT_OF_DATE),
                "SAVE_GAME_CORRUPT" => ::std::option::Option::Some(PopupID::SAVE_GAME_CORRUPT),
                "INSUFFICIENT_INGOTS" => ::std::option::Option::Some(PopupID::INSUFFICIENT_INGOTS),
                "COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL" => ::std::option::Option::Some(PopupID::COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL),
                "PARTY_LEADER_JOINED_LOBBY" => ::std::option::Option::Some(PopupID::PARTY_LEADER_JOINED_LOBBY),
                "WEEKEND_TOURNEY_UNMATCHED" => ::std::option::Option::Some(PopupID::WEEKEND_TOURNEY_UNMATCHED),
                "POST_MATCH_SURVEY" => ::std::option::Option::Some(PopupID::POST_MATCH_SURVEY),
                "TROPHY_AWARDED" => ::std::option::Option::Some(PopupID::TROPHY_AWARDED),
                "TROPHY_LEVEL_UP" => ::std::option::Option::Some(PopupID::TROPHY_LEVEL_UP),
                "ALL_HERO_CHALLENGE_PROGRESS" => ::std::option::Option::Some(PopupID::ALL_HERO_CHALLENGE_PROGRESS),
                "NEED_INITIAL_SKILL" => ::std::option::Option::Some(PopupID::NEED_INITIAL_SKILL),
                "NEED_INITIAL_SKILL_IN_PARTY" => ::std::option::Option::Some(PopupID::NEED_INITIAL_SKILL_IN_PARTY),
                "TARGET_ENGINE_MISMATCH" => ::std::option::Option::Some(PopupID::TARGET_ENGINE_MISMATCH),
                "VAC_NOT_VERIFIED" => ::std::option::Option::Some(PopupID::VAC_NOT_VERIFIED),
                "KICKED_FROM_QUEUE_EVENT_STARTING" => ::std::option::Option::Some(PopupID::KICKED_FROM_QUEUE_EVENT_STARTING),
                "KICKED_FROM_QUEUE_EVENT_ENDING" => ::std::option::Option::Some(PopupID::KICKED_FROM_QUEUE_EVENT_ENDING),
                "LOBBY_FULL" => ::std::option::Option::Some(PopupID::LOBBY_FULL),
                "EVENT_POINTS_EARNED" => ::std::option::Option::Some(PopupID::EVENT_POINTS_EARNED),
                "CUSTOM_GAME_INCORRECT_VERSION" => ::std::option::Option::Some(PopupID::CUSTOM_GAME_INCORRECT_VERSION),
                "LIMITED_USER_CHAT" => ::std::option::Option::Some(PopupID::LIMITED_USER_CHAT),
                "EVENT_PREMIUM_POINTS_EARNED" => ::std::option::Option::Some(PopupID::EVENT_PREMIUM_POINTS_EARNED),
                "LOBBY_MVP_AWARDED" => ::std::option::Option::Some(PopupID::LOBBY_MVP_AWARDED),
                "LOW_BADGE_LEVEL_CHAT" => ::std::option::Option::Some(PopupID::LOW_BADGE_LEVEL_CHAT),
                "LOW_WINS_CHAT" => ::std::option::Option::Some(PopupID::LOW_WINS_CHAT),
                "UNVERIFIED_USER_CHAT" => ::std::option::Option::Some(PopupID::UNVERIFIED_USER_CHAT),
                "PARTY_STARTED_FINDING_EVENT_MATCH" => ::std::option::Option::Some(PopupID::PARTY_STARTED_FINDING_EVENT_MATCH),
                "GENERIC_INFO" => ::std::option::Option::Some(PopupID::GENERIC_INFO),
                "GENERIC_ERROR" => ::std::option::Option::Some(PopupID::GENERIC_ERROR),
                "RANK_TIER_UPDATED" => ::std::option::Option::Some(PopupID::RANK_TIER_UPDATED),
                "CUSTOM_GAME_COOLDOWN_RESTRICTED" => ::std::option::Option::Some(PopupID::CUSTOM_GAME_COOLDOWN_RESTRICTED),
                "CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME" => ::std::option::Option::Some(PopupID::CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME),
                "CUSTOM_GAME_TOO_FEW_GAMES" => ::std::option::Option::Some(PopupID::CUSTOM_GAME_TOO_FEW_GAMES),
                "COMM_SCORE_TOO_LOW" => ::std::option::Option::Some(PopupID::COMM_SCORE_TOO_LOW),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [PopupID] = &[
            PopupID::NONE,
            PopupID::KICKED_FROM_LOBBY,
            PopupID::KICKED_FROM_PARTY,
            PopupID::KICKED_FROM_TEAM,
            PopupID::TEAM_WAS_DISBANDED,
            PopupID::TEAM_MATCHMAKE_ALREADY_MATCH,
            PopupID::TEAM_MATCHMAKE_ALREADY_FINDING,
            PopupID::TEAM_MATCHMAKE_FULL,
            PopupID::TEAM_MATCHMAKE_FAIL_ADD,
            PopupID::TEAM_MATCHMAKE_FAIL_ADD_CURRENT,
            PopupID::TEAM_MATCHMAKE_FAILED_TEAM_MEMBER,
            PopupID::TEAM_MATCHMAKE_ALREADY_GAME,
            PopupID::TEAM_MATCHMAKE_FAIL_GET_PARTY,
            PopupID::MATCHMAKING_DISABLED,
            PopupID::INVITE_DENIED,
            PopupID::PARTY_FULL,
            PopupID::MADE_ADMIN,
            PopupID::NEED_TO_PURCHASE,
            PopupID::SIGNON_MESSAGE,
            PopupID::MATCHMAKING_REGION_OFFLINE,
            PopupID::TOURNAMENT_GAME_NOT_FOUND,
            PopupID::TOURNAMENT_GAME_HAS_LOBBY_ID,
            PopupID::TOURNAMENT_GAME_HAS_MATCH_ID,
            PopupID::TOURNAMENT_GAME_HAS_NO_RADIANT_TEAM,
            PopupID::TOURNAMENT_GAME_HAS_NO_DIRE_TEAM,
            PopupID::TOURNAMENT_GAME_SQL_UPDATE_FAILED,
            PopupID::NOT_LEAGUE_ADMIN,
            PopupID::IN_ANOTHER_GAME,
            PopupID::PARTY_MEMBER_IN_ANOTHER_GAME,
            PopupID::PARTY_MEMBER_IN_LOW_PRIORITY,
            PopupID::CLIENT_OUT_OF_DATE,
            PopupID::SAVE_GAME_CORRUPT,
            PopupID::INSUFFICIENT_INGOTS,
            PopupID::COMPETITIVE_MM_NOT_ENOUGH_PLAY_TIME_PLAY_MORE_CASUAL,
            PopupID::PARTY_LEADER_JOINED_LOBBY,
            PopupID::WEEKEND_TOURNEY_UNMATCHED,
            PopupID::POST_MATCH_SURVEY,
            PopupID::TROPHY_AWARDED,
            PopupID::TROPHY_LEVEL_UP,
            PopupID::ALL_HERO_CHALLENGE_PROGRESS,
            PopupID::NEED_INITIAL_SKILL,
            PopupID::NEED_INITIAL_SKILL_IN_PARTY,
            PopupID::TARGET_ENGINE_MISMATCH,
            PopupID::VAC_NOT_VERIFIED,
            PopupID::KICKED_FROM_QUEUE_EVENT_STARTING,
            PopupID::KICKED_FROM_QUEUE_EVENT_ENDING,
            PopupID::LOBBY_FULL,
            PopupID::EVENT_POINTS_EARNED,
            PopupID::CUSTOM_GAME_INCORRECT_VERSION,
            PopupID::LIMITED_USER_CHAT,
            PopupID::EVENT_PREMIUM_POINTS_EARNED,
            PopupID::LOBBY_MVP_AWARDED,
            PopupID::LOW_BADGE_LEVEL_CHAT,
            PopupID::LOW_WINS_CHAT,
            PopupID::UNVERIFIED_USER_CHAT,
            PopupID::PARTY_STARTED_FINDING_EVENT_MATCH,
            PopupID::GENERIC_INFO,
            PopupID::GENERIC_ERROR,
            PopupID::RANK_TIER_UPDATED,
            PopupID::CUSTOM_GAME_COOLDOWN_RESTRICTED,
            PopupID::CREATE_LOBBY_FAILED_TOO_MUCH_PLAYTIME,
            PopupID::CUSTOM_GAME_TOO_FEW_GAMES,
            PopupID::COMM_SCORE_TOO_LOW,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for PopupID {
        fn default() -> Self {
            PopupID::NONE
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAReportsRemainingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAReportsRemainingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAReportsRemainingRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAReportsRemainingRequest {
    fn default() -> &'a CMsgDOTAReportsRemainingRequest {
        <CMsgDOTAReportsRemainingRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAReportsRemainingRequest {
    pub fn new() -> CMsgDOTAReportsRemainingRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAReportsRemainingRequest {
    const NAME: &'static str = "CMsgDOTAReportsRemainingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAReportsRemainingRequest {
        CMsgDOTAReportsRemainingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAReportsRemainingRequest {
        static instance: CMsgDOTAReportsRemainingRequest = CMsgDOTAReportsRemainingRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAReportsRemainingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAReportsRemainingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_positive_reports_remaining)
    pub num_positive_reports_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_negative_reports_remaining)
    pub num_negative_reports_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_positive_reports_total)
    pub num_positive_reports_total: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_negative_reports_total)
    pub num_negative_reports_total: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_comms_reports_remaining)
    pub num_comms_reports_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAReportsRemainingResponse.num_comms_reports_total)
    pub num_comms_reports_total: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAReportsRemainingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAReportsRemainingResponse {
    fn default() -> &'a CMsgDOTAReportsRemainingResponse {
        <CMsgDOTAReportsRemainingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAReportsRemainingResponse {
    pub fn new() -> CMsgDOTAReportsRemainingResponse {
        ::std::default::Default::default()
    }

    // optional uint32 num_positive_reports_remaining = 1;

    pub fn num_positive_reports_remaining(&self) -> u32 {
        self.num_positive_reports_remaining.unwrap_or(0)
    }

    pub fn clear_num_positive_reports_remaining(&mut self) {
        self.num_positive_reports_remaining = ::std::option::Option::None;
    }

    pub fn has_num_positive_reports_remaining(&self) -> bool {
        self.num_positive_reports_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_positive_reports_remaining(&mut self, v: u32) {
        self.num_positive_reports_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 num_negative_reports_remaining = 2;

    pub fn num_negative_reports_remaining(&self) -> u32 {
        self.num_negative_reports_remaining.unwrap_or(0)
    }

    pub fn clear_num_negative_reports_remaining(&mut self) {
        self.num_negative_reports_remaining = ::std::option::Option::None;
    }

    pub fn has_num_negative_reports_remaining(&self) -> bool {
        self.num_negative_reports_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_negative_reports_remaining(&mut self, v: u32) {
        self.num_negative_reports_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 num_positive_reports_total = 3;

    pub fn num_positive_reports_total(&self) -> u32 {
        self.num_positive_reports_total.unwrap_or(0)
    }

    pub fn clear_num_positive_reports_total(&mut self) {
        self.num_positive_reports_total = ::std::option::Option::None;
    }

    pub fn has_num_positive_reports_total(&self) -> bool {
        self.num_positive_reports_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_positive_reports_total(&mut self, v: u32) {
        self.num_positive_reports_total = ::std::option::Option::Some(v);
    }

    // optional uint32 num_negative_reports_total = 4;

    pub fn num_negative_reports_total(&self) -> u32 {
        self.num_negative_reports_total.unwrap_or(0)
    }

    pub fn clear_num_negative_reports_total(&mut self) {
        self.num_negative_reports_total = ::std::option::Option::None;
    }

    pub fn has_num_negative_reports_total(&self) -> bool {
        self.num_negative_reports_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_negative_reports_total(&mut self, v: u32) {
        self.num_negative_reports_total = ::std::option::Option::Some(v);
    }

    // optional uint32 num_comms_reports_remaining = 5;

    pub fn num_comms_reports_remaining(&self) -> u32 {
        self.num_comms_reports_remaining.unwrap_or(0)
    }

    pub fn clear_num_comms_reports_remaining(&mut self) {
        self.num_comms_reports_remaining = ::std::option::Option::None;
    }

    pub fn has_num_comms_reports_remaining(&self) -> bool {
        self.num_comms_reports_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comms_reports_remaining(&mut self, v: u32) {
        self.num_comms_reports_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 num_comms_reports_total = 6;

    pub fn num_comms_reports_total(&self) -> u32 {
        self.num_comms_reports_total.unwrap_or(0)
    }

    pub fn clear_num_comms_reports_total(&mut self) {
        self.num_comms_reports_total = ::std::option::Option::None;
    }

    pub fn has_num_comms_reports_total(&self) -> bool {
        self.num_comms_reports_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_comms_reports_total(&mut self, v: u32) {
        self.num_comms_reports_total = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAReportsRemainingResponse {
    const NAME: &'static str = "CMsgDOTAReportsRemainingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.num_positive_reports_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.num_negative_reports_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.num_positive_reports_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.num_negative_reports_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.num_comms_reports_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.num_comms_reports_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.num_positive_reports_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.num_negative_reports_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.num_positive_reports_total {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.num_negative_reports_total {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.num_comms_reports_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.num_comms_reports_total {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.num_positive_reports_remaining {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.num_negative_reports_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.num_positive_reports_total {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.num_negative_reports_total {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.num_comms_reports_remaining {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.num_comms_reports_total {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAReportsRemainingResponse {
        CMsgDOTAReportsRemainingResponse::new()
    }

    fn clear(&mut self) {
        self.num_positive_reports_remaining = ::std::option::Option::None;
        self.num_negative_reports_remaining = ::std::option::Option::None;
        self.num_positive_reports_total = ::std::option::Option::None;
        self.num_negative_reports_total = ::std::option::Option::None;
        self.num_comms_reports_remaining = ::std::option::Option::None;
        self.num_comms_reports_total = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAReportsRemainingResponse {
        static instance: CMsgDOTAReportsRemainingResponse = CMsgDOTAReportsRemainingResponse {
            num_positive_reports_remaining: ::std::option::Option::None,
            num_negative_reports_remaining: ::std::option::Option::None,
            num_positive_reports_total: ::std::option::Option::None,
            num_negative_reports_total: ::std::option::Option::None,
            num_comms_reports_remaining: ::std::option::Option::None,
            num_comms_reports_total: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerReport)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerReport {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReport.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReport.report_flags)
    pub report_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReport.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReport.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerReport.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerReport {
    fn default() -> &'a CMsgDOTASubmitPlayerReport {
        <CMsgDOTASubmitPlayerReport as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerReport {
    pub fn new() -> CMsgDOTASubmitPlayerReport {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 report_flags = 2;

    pub fn report_flags(&self) -> u32 {
        self.report_flags.unwrap_or(0)
    }

    pub fn clear_report_flags(&mut self) {
        self.report_flags = ::std::option::Option::None;
    }

    pub fn has_report_flags(&self) -> bool {
        self.report_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_flags(&mut self, v: u32) {
        self.report_flags = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 4;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string comment = 5;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerReport {
    const NAME: &'static str = "CMsgDOTASubmitPlayerReport";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.report_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.report_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerReport {
        CMsgDOTASubmitPlayerReport::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.report_flags = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerReport {
        static instance: CMsgDOTASubmitPlayerReport = CMsgDOTASubmitPlayerReport {
            target_account_id: ::std::option::Option::None,
            report_flags: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerReportResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerReportResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponse.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponse.report_flags)
    pub report_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponse.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponse.enum_result)
    pub enum_result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotasubmit_player_report_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerReportResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerReportResponse {
    fn default() -> &'a CMsgDOTASubmitPlayerReportResponse {
        <CMsgDOTASubmitPlayerReportResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerReportResponse {
    pub fn new() -> CMsgDOTASubmitPlayerReportResponse {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 report_flags = 2;

    pub fn report_flags(&self) -> u32 {
        self.report_flags.unwrap_or(0)
    }

    pub fn clear_report_flags(&mut self) {
        self.report_flags = ::std::option::Option::None;
    }

    pub fn has_report_flags(&self) -> bool {
        self.report_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_flags(&mut self, v: u32) {
        self.report_flags = ::std::option::Option::Some(v);
    }

    // optional string debug_message = 4;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgDOTASubmitPlayerReportResponse.EResult enum_result = 5;

    pub fn enum_result(&self) -> cmsg_dotasubmit_player_report_response::EResult {
        match self.enum_result {
            Some(e) => e.enum_value_or(cmsg_dotasubmit_player_report_response::EResult::k_eInternalError),
            None => cmsg_dotasubmit_player_report_response::EResult::k_eInternalError,
        }
    }

    pub fn clear_enum_result(&mut self) {
        self.enum_result = ::std::option::Option::None;
    }

    pub fn has_enum_result(&self) -> bool {
        self.enum_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enum_result(&mut self, v: cmsg_dotasubmit_player_report_response::EResult) {
        self.enum_result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerReportResponse {
    const NAME: &'static str = "CMsgDOTASubmitPlayerReportResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.report_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.enum_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.report_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enum_result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.report_flags {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enum_result {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerReportResponse {
        CMsgDOTASubmitPlayerReportResponse::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.report_flags = ::std::option::Option::None;
        self.debug_message = ::std::option::Option::None;
        self.enum_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerReportResponse {
        static instance: CMsgDOTASubmitPlayerReportResponse = CMsgDOTASubmitPlayerReportResponse {
            target_account_id: ::std::option::Option::None,
            report_flags: ::std::option::Option::None,
            debug_message: ::std::option::Option::None,
            enum_result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTASubmitPlayerReportResponse`
pub mod cmsg_dotasubmit_player_report_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTASubmitPlayerReportResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eDuplicateReport)
        k_eDuplicateReport = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eMixedReportFlags)
        k_eMixedReportFlags = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eTooLate)
        k_eTooLate = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInvalidPregameReport)
        k_eInvalidPregameReport = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eHasntChatted)
        k_eHasntChatted = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInvalid)
        k_eInvalid = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eOwnership)
        k_eOwnership = 8,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eMissingRequirements)
        k_eMissingRequirements = 9,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInvalidRoleReport)
        k_eInvalidRoleReport = 10,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInvalidCoachReport)
        k_eInvalidCoachReport = 11,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eNoRemainingReports)
        k_eNoRemainingReports = 12,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponse.EResult.k_eInvalidMember)
        k_eInvalidMember = 13,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_eInternalError),
                1 => ::std::option::Option::Some(EResult::k_eSuccess),
                2 => ::std::option::Option::Some(EResult::k_eDuplicateReport),
                3 => ::std::option::Option::Some(EResult::k_eMixedReportFlags),
                4 => ::std::option::Option::Some(EResult::k_eTooLate),
                5 => ::std::option::Option::Some(EResult::k_eInvalidPregameReport),
                6 => ::std::option::Option::Some(EResult::k_eHasntChatted),
                7 => ::std::option::Option::Some(EResult::k_eInvalid),
                8 => ::std::option::Option::Some(EResult::k_eOwnership),
                9 => ::std::option::Option::Some(EResult::k_eMissingRequirements),
                10 => ::std::option::Option::Some(EResult::k_eInvalidRoleReport),
                11 => ::std::option::Option::Some(EResult::k_eInvalidCoachReport),
                12 => ::std::option::Option::Some(EResult::k_eNoRemainingReports),
                13 => ::std::option::Option::Some(EResult::k_eInvalidMember),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResult::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResult::k_eSuccess),
                "k_eDuplicateReport" => ::std::option::Option::Some(EResult::k_eDuplicateReport),
                "k_eMixedReportFlags" => ::std::option::Option::Some(EResult::k_eMixedReportFlags),
                "k_eTooLate" => ::std::option::Option::Some(EResult::k_eTooLate),
                "k_eInvalidPregameReport" => ::std::option::Option::Some(EResult::k_eInvalidPregameReport),
                "k_eHasntChatted" => ::std::option::Option::Some(EResult::k_eHasntChatted),
                "k_eInvalid" => ::std::option::Option::Some(EResult::k_eInvalid),
                "k_eOwnership" => ::std::option::Option::Some(EResult::k_eOwnership),
                "k_eMissingRequirements" => ::std::option::Option::Some(EResult::k_eMissingRequirements),
                "k_eInvalidRoleReport" => ::std::option::Option::Some(EResult::k_eInvalidRoleReport),
                "k_eInvalidCoachReport" => ::std::option::Option::Some(EResult::k_eInvalidCoachReport),
                "k_eNoRemainingReports" => ::std::option::Option::Some(EResult::k_eNoRemainingReports),
                "k_eInvalidMember" => ::std::option::Option::Some(EResult::k_eInvalidMember),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_eInternalError,
            EResult::k_eSuccess,
            EResult::k_eDuplicateReport,
            EResult::k_eMixedReportFlags,
            EResult::k_eTooLate,
            EResult::k_eInvalidPregameReport,
            EResult::k_eHasntChatted,
            EResult::k_eInvalid,
            EResult::k_eOwnership,
            EResult::k_eMissingRequirements,
            EResult::k_eInvalidRoleReport,
            EResult::k_eInvalidCoachReport,
            EResult::k_eNoRemainingReports,
            EResult::k_eInvalidMember,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerAvoidRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerAvoidRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequest.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequest.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequest.user_note)
    pub user_note: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerAvoidRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerAvoidRequest {
    fn default() -> &'a CMsgDOTASubmitPlayerAvoidRequest {
        <CMsgDOTASubmitPlayerAvoidRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerAvoidRequest {
    pub fn new() -> CMsgDOTASubmitPlayerAvoidRequest {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 4;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional string user_note = 5;

    pub fn user_note(&self) -> &str {
        match self.user_note.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_user_note(&mut self) {
        self.user_note = ::std::option::Option::None;
    }

    pub fn has_user_note(&self) -> bool {
        self.user_note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_note(&mut self, v: ::std::string::String) {
        self.user_note = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_note(&mut self) -> &mut ::std::string::String {
        if self.user_note.is_none() {
            self.user_note = ::std::option::Option::Some(::std::string::String::new());
        }
        self.user_note.as_mut().unwrap()
    }

    // Take field
    pub fn take_user_note(&mut self) -> ::std::string::String {
        self.user_note.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerAvoidRequest {
    const NAME: &'static str = "CMsgDOTASubmitPlayerAvoidRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                42 => {
                    self.user_note = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
        }
        if let Some(v) = self.user_note.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.user_note.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerAvoidRequest {
        CMsgDOTASubmitPlayerAvoidRequest::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.user_note = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerAvoidRequest {
        static instance: CMsgDOTASubmitPlayerAvoidRequest = CMsgDOTASubmitPlayerAvoidRequest {
            target_account_id: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            user_note: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerAvoidRequestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerAvoidRequestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequestResponse.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequestResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerAvoidRequestResponse.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerAvoidRequestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerAvoidRequestResponse {
    fn default() -> &'a CMsgDOTASubmitPlayerAvoidRequestResponse {
        <CMsgDOTASubmitPlayerAvoidRequestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerAvoidRequestResponse {
    pub fn new() -> CMsgDOTASubmitPlayerAvoidRequestResponse {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 2;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional string debug_message = 3;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerAvoidRequestResponse {
    const NAME: &'static str = "CMsgDOTASubmitPlayerAvoidRequestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerAvoidRequestResponse {
        CMsgDOTASubmitPlayerAvoidRequestResponse::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.debug_message = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerAvoidRequestResponse {
        static instance: CMsgDOTASubmitPlayerAvoidRequestResponse = CMsgDOTASubmitPlayerAvoidRequestResponse {
            target_account_id: ::std::option::Option::None,
            result: ::std::option::Option::None,
            debug_message: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerReportV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerReportV2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.report_reason)
    pub report_reason: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.game_time)
    pub game_time: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.debug_slot)
    pub debug_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportV2.debug_match_id)
    pub debug_match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerReportV2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerReportV2 {
    fn default() -> &'a CMsgDOTASubmitPlayerReportV2 {
        <CMsgDOTASubmitPlayerReportV2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerReportV2 {
    pub fn new() -> CMsgDOTASubmitPlayerReportV2 {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 3;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional float game_time = 4;

    pub fn game_time(&self) -> f32 {
        self.game_time.unwrap_or(0.)
    }

    pub fn clear_game_time(&mut self) {
        self.game_time = ::std::option::Option::None;
    }

    pub fn has_game_time(&self) -> bool {
        self.game_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_time(&mut self, v: f32) {
        self.game_time = ::std::option::Option::Some(v);
    }

    // optional uint32 debug_slot = 5;

    pub fn debug_slot(&self) -> u32 {
        self.debug_slot.unwrap_or(0)
    }

    pub fn clear_debug_slot(&mut self) {
        self.debug_slot = ::std::option::Option::None;
    }

    pub fn has_debug_slot(&self) -> bool {
        self.debug_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_slot(&mut self, v: u32) {
        self.debug_slot = ::std::option::Option::Some(v);
    }

    // optional fixed64 debug_match_id = 6;

    pub fn debug_match_id(&self) -> u64 {
        self.debug_match_id.unwrap_or(0)
    }

    pub fn clear_debug_match_id(&mut self) {
        self.debug_match_id = ::std::option::Option::None;
    }

    pub fn has_debug_match_id(&self) -> bool {
        self.debug_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_match_id(&mut self, v: u64) {
        self.debug_match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerReportV2 {
    const NAME: &'static str = "CMsgDOTASubmitPlayerReportV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.report_reason)?;
                },
                16 => {
                    self.report_reason.push(is.read_uint32()?);
                },
                24 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                37 => {
                    self.game_time = ::std::option::Option::Some(is.read_float()?);
                },
                40 => {
                    self.debug_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                49 => {
                    self.debug_match_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.report_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.game_time {
            my_size += 1 + 4;
        }
        if let Some(v) = self.debug_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.debug_match_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.report_reason {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.lobby_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.game_time {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.debug_slot {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.debug_match_id {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerReportV2 {
        CMsgDOTASubmitPlayerReportV2::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.report_reason.clear();
        self.lobby_id = ::std::option::Option::None;
        self.game_time = ::std::option::Option::None;
        self.debug_slot = ::std::option::Option::None;
        self.debug_match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerReportV2 {
        static instance: CMsgDOTASubmitPlayerReportV2 = CMsgDOTASubmitPlayerReportV2 {
            target_account_id: ::std::option::Option::None,
            report_reason: ::std::vec::Vec::new(),
            lobby_id: ::std::option::Option::None,
            game_time: ::std::option::Option::None,
            debug_slot: ::std::option::Option::None,
            debug_match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitPlayerReportResponseV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitPlayerReportResponseV2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponseV2.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponseV2.report_reason)
    pub report_reason: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponseV2.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitPlayerReportResponseV2.enum_result)
    pub enum_result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotasubmit_player_report_response_v2::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitPlayerReportResponseV2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitPlayerReportResponseV2 {
    fn default() -> &'a CMsgDOTASubmitPlayerReportResponseV2 {
        <CMsgDOTASubmitPlayerReportResponseV2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitPlayerReportResponseV2 {
    pub fn new() -> CMsgDOTASubmitPlayerReportResponseV2 {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional string debug_message = 4;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CMsgDOTASubmitPlayerReportResponseV2.EResult enum_result = 5;

    pub fn enum_result(&self) -> cmsg_dotasubmit_player_report_response_v2::EResult {
        match self.enum_result {
            Some(e) => e.enum_value_or(cmsg_dotasubmit_player_report_response_v2::EResult::k_eInternalError),
            None => cmsg_dotasubmit_player_report_response_v2::EResult::k_eInternalError,
        }
    }

    pub fn clear_enum_result(&mut self) {
        self.enum_result = ::std::option::Option::None;
    }

    pub fn has_enum_result(&self) -> bool {
        self.enum_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enum_result(&mut self, v: cmsg_dotasubmit_player_report_response_v2::EResult) {
        self.enum_result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitPlayerReportResponseV2 {
    const NAME: &'static str = "CMsgDOTASubmitPlayerReportResponseV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.report_reason)?;
                },
                16 => {
                    self.report_reason.push(is.read_uint32()?);
                },
                34 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.enum_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.report_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.enum_result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.report_reason {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.enum_result {
            os.write_enum(5, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitPlayerReportResponseV2 {
        CMsgDOTASubmitPlayerReportResponseV2::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.report_reason.clear();
        self.debug_message = ::std::option::Option::None;
        self.enum_result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitPlayerReportResponseV2 {
        static instance: CMsgDOTASubmitPlayerReportResponseV2 = CMsgDOTASubmitPlayerReportResponseV2 {
            target_account_id: ::std::option::Option::None,
            report_reason: ::std::vec::Vec::new(),
            debug_message: ::std::option::Option::None,
            enum_result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTASubmitPlayerReportResponseV2`
pub mod cmsg_dotasubmit_player_report_response_v2 {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTASubmitPlayerReportResponseV2.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eDuplicateReport)
        k_eDuplicateReport = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eMixedReportFlags)
        k_eMixedReportFlags = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eTooLate)
        k_eTooLate = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInvalidPregameReport)
        k_eInvalidPregameReport = 5,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eHasntChatted)
        k_eHasntChatted = 6,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInvalid)
        k_eInvalid = 7,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eOwnership)
        k_eOwnership = 8,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eMissingRequirements)
        k_eMissingRequirements = 9,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInvalidRoleReport)
        k_eInvalidRoleReport = 10,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInvalidCoachReport)
        k_eInvalidCoachReport = 11,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eNoRemainingReports)
        k_eNoRemainingReports = 12,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eInvalidMember)
        k_eInvalidMember = 13,
        // @@protoc_insertion_point(enum_value:CMsgDOTASubmitPlayerReportResponseV2.EResult.k_eCannotReportPartyMember)
        k_eCannotReportPartyMember = 14,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::k_eInternalError),
                1 => ::std::option::Option::Some(EResult::k_eSuccess),
                2 => ::std::option::Option::Some(EResult::k_eDuplicateReport),
                3 => ::std::option::Option::Some(EResult::k_eMixedReportFlags),
                4 => ::std::option::Option::Some(EResult::k_eTooLate),
                5 => ::std::option::Option::Some(EResult::k_eInvalidPregameReport),
                6 => ::std::option::Option::Some(EResult::k_eHasntChatted),
                7 => ::std::option::Option::Some(EResult::k_eInvalid),
                8 => ::std::option::Option::Some(EResult::k_eOwnership),
                9 => ::std::option::Option::Some(EResult::k_eMissingRequirements),
                10 => ::std::option::Option::Some(EResult::k_eInvalidRoleReport),
                11 => ::std::option::Option::Some(EResult::k_eInvalidCoachReport),
                12 => ::std::option::Option::Some(EResult::k_eNoRemainingReports),
                13 => ::std::option::Option::Some(EResult::k_eInvalidMember),
                14 => ::std::option::Option::Some(EResult::k_eCannotReportPartyMember),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResult::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResult::k_eSuccess),
                "k_eDuplicateReport" => ::std::option::Option::Some(EResult::k_eDuplicateReport),
                "k_eMixedReportFlags" => ::std::option::Option::Some(EResult::k_eMixedReportFlags),
                "k_eTooLate" => ::std::option::Option::Some(EResult::k_eTooLate),
                "k_eInvalidPregameReport" => ::std::option::Option::Some(EResult::k_eInvalidPregameReport),
                "k_eHasntChatted" => ::std::option::Option::Some(EResult::k_eHasntChatted),
                "k_eInvalid" => ::std::option::Option::Some(EResult::k_eInvalid),
                "k_eOwnership" => ::std::option::Option::Some(EResult::k_eOwnership),
                "k_eMissingRequirements" => ::std::option::Option::Some(EResult::k_eMissingRequirements),
                "k_eInvalidRoleReport" => ::std::option::Option::Some(EResult::k_eInvalidRoleReport),
                "k_eInvalidCoachReport" => ::std::option::Option::Some(EResult::k_eInvalidCoachReport),
                "k_eNoRemainingReports" => ::std::option::Option::Some(EResult::k_eNoRemainingReports),
                "k_eInvalidMember" => ::std::option::Option::Some(EResult::k_eInvalidMember),
                "k_eCannotReportPartyMember" => ::std::option::Option::Some(EResult::k_eCannotReportPartyMember),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::k_eInternalError,
            EResult::k_eSuccess,
            EResult::k_eDuplicateReport,
            EResult::k_eMixedReportFlags,
            EResult::k_eTooLate,
            EResult::k_eInvalidPregameReport,
            EResult::k_eHasntChatted,
            EResult::k_eInvalid,
            EResult::k_eOwnership,
            EResult::k_eMissingRequirements,
            EResult::k_eInvalidRoleReport,
            EResult::k_eInvalidCoachReport,
            EResult::k_eNoRemainingReports,
            EResult::k_eInvalidMember,
            EResult::k_eCannotReportPartyMember,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTASubmitLobbyMVPVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitLobbyMVPVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitLobbyMVPVote.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitLobbyMVPVote.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitLobbyMVPVote {
    fn default() -> &'a CMsgDOTASubmitLobbyMVPVote {
        <CMsgDOTASubmitLobbyMVPVote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitLobbyMVPVote {
    pub fn new() -> CMsgDOTASubmitLobbyMVPVote {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitLobbyMVPVote {
    const NAME: &'static str = "CMsgDOTASubmitLobbyMVPVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitLobbyMVPVote {
        CMsgDOTASubmitLobbyMVPVote::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitLobbyMVPVote {
        static instance: CMsgDOTASubmitLobbyMVPVote = CMsgDOTASubmitLobbyMVPVote {
            target_account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitLobbyMVPVoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitLobbyMVPVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitLobbyMVPVoteResponse.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitLobbyMVPVoteResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitLobbyMVPVoteResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitLobbyMVPVoteResponse {
    fn default() -> &'a CMsgDOTASubmitLobbyMVPVoteResponse {
        <CMsgDOTASubmitLobbyMVPVoteResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitLobbyMVPVoteResponse {
    pub fn new() -> CMsgDOTASubmitLobbyMVPVoteResponse {
        ::std::default::Default::default()
    }

    // optional uint32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitLobbyMVPVoteResponse {
    const NAME: &'static str = "CMsgDOTASubmitLobbyMVPVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitLobbyMVPVoteResponse {
        CMsgDOTASubmitLobbyMVPVoteResponse::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitLobbyMVPVoteResponse {
        static instance: CMsgDOTASubmitLobbyMVPVoteResponse = CMsgDOTASubmitLobbyMVPVoteResponse {
            target_account_id: ::std::option::Option::None,
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTALobbyMVPAwarded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALobbyMVPAwarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALobbyMVPAwarded.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyMVPAwarded.mvp_account_id)
    pub mvp_account_id: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALobbyMVPAwarded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALobbyMVPAwarded {
    fn default() -> &'a CMsgDOTALobbyMVPAwarded {
        <CMsgDOTALobbyMVPAwarded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALobbyMVPAwarded {
    pub fn new() -> CMsgDOTALobbyMVPAwarded {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALobbyMVPAwarded {
    const NAME: &'static str = "CMsgDOTALobbyMVPAwarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.mvp_account_id)?;
                },
                16 => {
                    self.mvp_account_id.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.mvp_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.mvp_account_id {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALobbyMVPAwarded {
        CMsgDOTALobbyMVPAwarded::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.mvp_account_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALobbyMVPAwarded {
        static instance: CMsgDOTALobbyMVPAwarded = CMsgDOTALobbyMVPAwarded {
            match_id: ::std::option::Option::None,
            mvp_account_id: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAKickedFromMatchmakingQueue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAKickedFromMatchmakingQueue {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAKickedFromMatchmakingQueue.match_type)
    pub match_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::MatchType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAKickedFromMatchmakingQueue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAKickedFromMatchmakingQueue {
    fn default() -> &'a CMsgDOTAKickedFromMatchmakingQueue {
        <CMsgDOTAKickedFromMatchmakingQueue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAKickedFromMatchmakingQueue {
    pub fn new() -> CMsgDOTAKickedFromMatchmakingQueue {
        ::std::default::Default::default()
    }

    // optional .MatchType match_type = 1;

    pub fn match_type(&self) -> super::dota_shared_enums::MatchType {
        match self.match_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL),
            None => super::dota_shared_enums::MatchType::MATCH_TYPE_CASUAL,
        }
    }

    pub fn clear_match_type(&mut self) {
        self.match_type = ::std::option::Option::None;
    }

    pub fn has_match_type(&self) -> bool {
        self.match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_type(&mut self, v: super::dota_shared_enums::MatchType) {
        self.match_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAKickedFromMatchmakingQueue {
    const NAME: &'static str = "CMsgDOTAKickedFromMatchmakingQueue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAKickedFromMatchmakingQueue {
        CMsgDOTAKickedFromMatchmakingQueue::new()
    }

    fn clear(&mut self) {
        self.match_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAKickedFromMatchmakingQueue {
        static instance: CMsgDOTAKickedFromMatchmakingQueue = CMsgDOTAKickedFromMatchmakingQueue {
            match_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMatchDetailsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchDetailsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchDetailsRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchDetailsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchDetailsRequest {
    fn default() -> &'a CMsgGCMatchDetailsRequest {
        <CMsgGCMatchDetailsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchDetailsRequest {
    pub fn new() -> CMsgGCMatchDetailsRequest {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMatchDetailsRequest {
    const NAME: &'static str = "CMsgGCMatchDetailsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchDetailsRequest {
        CMsgGCMatchDetailsRequest::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchDetailsRequest {
        static instance: CMsgGCMatchDetailsRequest = CMsgGCMatchDetailsRequest {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCMatchDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCMatchDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCMatchDetailsResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCMatchDetailsResponse.match)
    pub match_: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAMatch>,
    // @@protoc_insertion_point(field:CMsgGCMatchDetailsResponse.vote)
    pub vote: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTAMatchVote>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCMatchDetailsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCMatchDetailsResponse {
    fn default() -> &'a CMsgGCMatchDetailsResponse {
        <CMsgGCMatchDetailsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCMatchDetailsResponse {
    pub fn new() -> CMsgGCMatchDetailsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional .DOTAMatchVote vote = 3;

    pub fn vote(&self) -> super::dota_shared_enums::DOTAMatchVote {
        match self.vote {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTAMatchVote::DOTAMatchVote_INVALID),
            None => super::dota_shared_enums::DOTAMatchVote::DOTAMatchVote_INVALID,
        }
    }

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: super::dota_shared_enums::DOTAMatchVote) {
        self.vote = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCMatchDetailsResponse {
    const NAME: &'static str = "CMsgGCMatchDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_)?;
                },
                24 => {
                    self.vote = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.vote {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.vote {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCMatchDetailsResponse {
        CMsgGCMatchDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.match_.clear();
        self.vote = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCMatchDetailsResponse {
        static instance: CMsgGCMatchDetailsResponse = CMsgGCMatchDetailsResponse {
            result: ::std::option::Option::None,
            match_: ::steam_vent_proto_common::protobuf::MessageField::none(),
            vote: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAProfileTickets)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAProfileTickets {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAProfileTickets.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileTickets.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAProfileTickets.league_passes)
    pub league_passes: ::std::vec::Vec<cmsg_dotaprofile_tickets::LeaguePass>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAProfileTickets.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAProfileTickets {
    fn default() -> &'a CMsgDOTAProfileTickets {
        <CMsgDOTAProfileTickets as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAProfileTickets {
    pub fn new() -> CMsgDOTAProfileTickets {
        ::std::default::Default::default()
    }

    // optional uint32 result = 1;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAProfileTickets {
    const NAME: &'static str = "CMsgDOTAProfileTickets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.league_passes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.league_passes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        for v in &self.league_passes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAProfileTickets {
        CMsgDOTAProfileTickets::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.league_passes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAProfileTickets {
        static instance: CMsgDOTAProfileTickets = CMsgDOTAProfileTickets {
            result: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            league_passes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAProfileTickets`
pub mod cmsg_dotaprofile_tickets {
    // @@protoc_insertion_point(message:CMsgDOTAProfileTickets.LeaguePass)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LeaguePass {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAProfileTickets.LeaguePass.league_id)
        pub league_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAProfileTickets.LeaguePass.item_def)
        pub item_def: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAProfileTickets.LeaguePass.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LeaguePass {
        fn default() -> &'a LeaguePass {
            <LeaguePass as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LeaguePass {
        pub fn new() -> LeaguePass {
            ::std::default::Default::default()
        }

        // optional uint32 league_id = 1;

        pub fn league_id(&self) -> u32 {
            self.league_id.unwrap_or(0)
        }

        pub fn clear_league_id(&mut self) {
            self.league_id = ::std::option::Option::None;
        }

        pub fn has_league_id(&self) -> bool {
            self.league_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_league_id(&mut self, v: u32) {
            self.league_id = ::std::option::Option::Some(v);
        }

        // optional uint32 item_def = 2;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LeaguePass {
        const NAME: &'static str = "LeaguePass";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.league_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.league_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.item_def {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LeaguePass {
            LeaguePass::new()
        }

        fn clear(&mut self) {
            self.league_id = ::std::option::Option::None;
            self.item_def = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LeaguePass {
            static instance: LeaguePass = LeaguePass {
                league_id: ::std::option::Option::None,
                item_def: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetProfileTickets)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetProfileTickets {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetProfileTickets.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetProfileTickets.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetProfileTickets {
    fn default() -> &'a CMsgClientToGCGetProfileTickets {
        <CMsgClientToGCGetProfileTickets as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetProfileTickets {
    pub fn new() -> CMsgClientToGCGetProfileTickets {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetProfileTickets {
    const NAME: &'static str = "CMsgClientToGCGetProfileTickets";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetProfileTickets {
        CMsgClientToGCGetProfileTickets::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetProfileTickets {
        static instance: CMsgClientToGCGetProfileTickets = CMsgClientToGCGetProfileTickets {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPartySearchInvites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPartySearchInvites {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPartySearchInvites.invites)
    pub invites: ::std::vec::Vec<CMsgGCToClientPartySearchInvite>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPartySearchInvites.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPartySearchInvites {
    fn default() -> &'a CMsgGCToClientPartySearchInvites {
        <CMsgGCToClientPartySearchInvites as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPartySearchInvites {
    pub fn new() -> CMsgGCToClientPartySearchInvites {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPartySearchInvites {
    const NAME: &'static str = "CMsgGCToClientPartySearchInvites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.invites.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.invites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.invites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPartySearchInvites {
        CMsgGCToClientPartySearchInvites::new()
    }

    fn clear(&mut self) {
        self.invites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPartySearchInvites {
        static instance: CMsgGCToClientPartySearchInvites = CMsgGCToClientPartySearchInvites {
            invites: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAWelcome)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAWelcome {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.store_item_hash)
    pub store_item_hash: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.timeplayedconsecutively)
    pub timeplayedconsecutively: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.allow_3rd_party_match_history)
    pub allow_3rd_party_match_history: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.last_ip_address)
    pub last_ip_address: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.profile_private)
    pub profile_private: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.currency)
    pub currency: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.should_request_player_origin)
    pub should_request_player_origin: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.gc_socache_file_version)
    pub gc_socache_file_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.is_perfect_world_test_account)
    pub is_perfect_world_test_account: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.extra_messages)
    pub extra_messages: ::std::vec::Vec<cmsg_dotawelcome::CExtraMsg>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.minimum_recent_item_id)
    pub minimum_recent_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.active_event)
    pub active_event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.additional_user_message)
    pub additional_user_message: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.custom_game_whitelist_version)
    pub custom_game_whitelist_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.party_search_friend_invites)
    pub party_search_friend_invites: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientPartySearchInvites>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.remaining_playtime)
    pub remaining_playtime: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.disable_guild_persona_info)
    pub disable_guild_persona_info: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAWelcome.extra_message_blocks)
    pub extra_message_blocks: ::std::vec::Vec<super::gcsdk_gcmessages::CExtraMsgBlock>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAWelcome.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAWelcome {
    fn default() -> &'a CMsgDOTAWelcome {
        <CMsgDOTAWelcome as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAWelcome {
    pub fn new() -> CMsgDOTAWelcome {
        ::std::default::Default::default()
    }

    // optional uint32 store_item_hash = 5;

    pub fn store_item_hash(&self) -> u32 {
        self.store_item_hash.unwrap_or(0)
    }

    pub fn clear_store_item_hash(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
    }

    pub fn has_store_item_hash(&self) -> bool {
        self.store_item_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_store_item_hash(&mut self, v: u32) {
        self.store_item_hash = ::std::option::Option::Some(v);
    }

    // optional uint32 timeplayedconsecutively = 6;

    pub fn timeplayedconsecutively(&self) -> u32 {
        self.timeplayedconsecutively.unwrap_or(0)
    }

    pub fn clear_timeplayedconsecutively(&mut self) {
        self.timeplayedconsecutively = ::std::option::Option::None;
    }

    pub fn has_timeplayedconsecutively(&self) -> bool {
        self.timeplayedconsecutively.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeplayedconsecutively(&mut self, v: u32) {
        self.timeplayedconsecutively = ::std::option::Option::Some(v);
    }

    // optional bool allow_3rd_party_match_history = 7;

    pub fn allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.unwrap_or(false)
    }

    pub fn clear_allow_3rd_party_match_history(&mut self) {
        self.allow_3rd_party_match_history = ::std::option::Option::None;
    }

    pub fn has_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_3rd_party_match_history(&mut self, v: bool) {
        self.allow_3rd_party_match_history = ::std::option::Option::Some(v);
    }

    // optional uint32 last_ip_address = 13;

    pub fn last_ip_address(&self) -> u32 {
        self.last_ip_address.unwrap_or(0)
    }

    pub fn clear_last_ip_address(&mut self) {
        self.last_ip_address = ::std::option::Option::None;
    }

    pub fn has_last_ip_address(&self) -> bool {
        self.last_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_ip_address(&mut self, v: u32) {
        self.last_ip_address = ::std::option::Option::Some(v);
    }

    // optional bool profile_private = 17;

    pub fn profile_private(&self) -> bool {
        self.profile_private.unwrap_or(false)
    }

    pub fn clear_profile_private(&mut self) {
        self.profile_private = ::std::option::Option::None;
    }

    pub fn has_profile_private(&self) -> bool {
        self.profile_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_private(&mut self, v: bool) {
        self.profile_private = ::std::option::Option::Some(v);
    }

    // optional uint32 currency = 18;

    pub fn currency(&self) -> u32 {
        self.currency.unwrap_or(0)
    }

    pub fn clear_currency(&mut self) {
        self.currency = ::std::option::Option::None;
    }

    pub fn has_currency(&self) -> bool {
        self.currency.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: u32) {
        self.currency = ::std::option::Option::Some(v);
    }

    // optional bool should_request_player_origin = 20;

    pub fn should_request_player_origin(&self) -> bool {
        self.should_request_player_origin.unwrap_or(false)
    }

    pub fn clear_should_request_player_origin(&mut self) {
        self.should_request_player_origin = ::std::option::Option::None;
    }

    pub fn has_should_request_player_origin(&self) -> bool {
        self.should_request_player_origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_should_request_player_origin(&mut self, v: bool) {
        self.should_request_player_origin = ::std::option::Option::Some(v);
    }

    // optional uint32 gc_socache_file_version = 22;

    pub fn gc_socache_file_version(&self) -> u32 {
        self.gc_socache_file_version.unwrap_or(0)
    }

    pub fn clear_gc_socache_file_version(&mut self) {
        self.gc_socache_file_version = ::std::option::Option::None;
    }

    pub fn has_gc_socache_file_version(&self) -> bool {
        self.gc_socache_file_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gc_socache_file_version(&mut self, v: u32) {
        self.gc_socache_file_version = ::std::option::Option::Some(v);
    }

    // optional bool is_perfect_world_test_account = 24;

    pub fn is_perfect_world_test_account(&self) -> bool {
        self.is_perfect_world_test_account.unwrap_or(false)
    }

    pub fn clear_is_perfect_world_test_account(&mut self) {
        self.is_perfect_world_test_account = ::std::option::Option::None;
    }

    pub fn has_is_perfect_world_test_account(&self) -> bool {
        self.is_perfect_world_test_account.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_perfect_world_test_account(&mut self, v: bool) {
        self.is_perfect_world_test_account = ::std::option::Option::Some(v);
    }

    // optional uint64 minimum_recent_item_id = 27;

    pub fn minimum_recent_item_id(&self) -> u64 {
        self.minimum_recent_item_id.unwrap_or(0)
    }

    pub fn clear_minimum_recent_item_id(&mut self) {
        self.minimum_recent_item_id = ::std::option::Option::None;
    }

    pub fn has_minimum_recent_item_id(&self) -> bool {
        self.minimum_recent_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minimum_recent_item_id(&mut self, v: u64) {
        self.minimum_recent_item_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent active_event = 28;

    pub fn active_event(&self) -> super::dota_shared_enums::EEvent {
        match self.active_event {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_active_event(&mut self) {
        self.active_event = ::std::option::Option::None;
    }

    pub fn has_active_event(&self) -> bool {
        self.active_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_event(&mut self, v: super::dota_shared_enums::EEvent) {
        self.active_event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 additional_user_message = 29;

    pub fn additional_user_message(&self) -> u32 {
        self.additional_user_message.unwrap_or(0)
    }

    pub fn clear_additional_user_message(&mut self) {
        self.additional_user_message = ::std::option::Option::None;
    }

    pub fn has_additional_user_message(&self) -> bool {
        self.additional_user_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_user_message(&mut self, v: u32) {
        self.additional_user_message = ::std::option::Option::Some(v);
    }

    // optional uint32 custom_game_whitelist_version = 30;

    pub fn custom_game_whitelist_version(&self) -> u32 {
        self.custom_game_whitelist_version.unwrap_or(0)
    }

    pub fn clear_custom_game_whitelist_version(&mut self) {
        self.custom_game_whitelist_version = ::std::option::Option::None;
    }

    pub fn has_custom_game_whitelist_version(&self) -> bool {
        self.custom_game_whitelist_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_whitelist_version(&mut self, v: u32) {
        self.custom_game_whitelist_version = ::std::option::Option::Some(v);
    }

    // optional int32 remaining_playtime = 32;

    pub fn remaining_playtime(&self) -> i32 {
        self.remaining_playtime.unwrap_or(-1i32)
    }

    pub fn clear_remaining_playtime(&mut self) {
        self.remaining_playtime = ::std::option::Option::None;
    }

    pub fn has_remaining_playtime(&self) -> bool {
        self.remaining_playtime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remaining_playtime(&mut self, v: i32) {
        self.remaining_playtime = ::std::option::Option::Some(v);
    }

    // optional bool disable_guild_persona_info = 33;

    pub fn disable_guild_persona_info(&self) -> bool {
        self.disable_guild_persona_info.unwrap_or(false)
    }

    pub fn clear_disable_guild_persona_info(&mut self) {
        self.disable_guild_persona_info = ::std::option::Option::None;
    }

    pub fn has_disable_guild_persona_info(&self) -> bool {
        self.disable_guild_persona_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disable_guild_persona_info(&mut self, v: bool) {
        self.disable_guild_persona_info = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAWelcome {
    const NAME: &'static str = "CMsgDOTAWelcome";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                40 => {
                    self.store_item_hash = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.timeplayedconsecutively = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.allow_3rd_party_match_history = ::std::option::Option::Some(is.read_bool()?);
                },
                104 => {
                    self.last_ip_address = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.profile_private = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.currency = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.should_request_player_origin = ::std::option::Option::Some(is.read_bool()?);
                },
                176 => {
                    self.gc_socache_file_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                192 => {
                    self.is_perfect_world_test_account = ::std::option::Option::Some(is.read_bool()?);
                },
                210 => {
                    self.extra_messages.push(is.read_message()?);
                },
                216 => {
                    self.minimum_recent_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                224 => {
                    self.active_event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                232 => {
                    self.additional_user_message = ::std::option::Option::Some(is.read_uint32()?);
                },
                240 => {
                    self.custom_game_whitelist_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                250 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.party_search_friend_invites)?;
                },
                256 => {
                    self.remaining_playtime = ::std::option::Option::Some(is.read_int32()?);
                },
                264 => {
                    self.disable_guild_persona_info = ::std::option::Option::Some(is.read_bool()?);
                },
                274 => {
                    self.extra_message_blocks.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.store_item_hash {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.timeplayedconsecutively {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.allow_3rd_party_match_history {
            my_size += 1 + 1;
        }
        if let Some(v) = self.last_ip_address {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.profile_private {
            my_size += 2 + 1;
        }
        if let Some(v) = self.currency {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.should_request_player_origin {
            my_size += 2 + 1;
        }
        if let Some(v) = self.gc_socache_file_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
        }
        if let Some(v) = self.is_perfect_world_test_account {
            my_size += 2 + 1;
        }
        for value in &self.extra_messages {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.minimum_recent_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(27, v);
        }
        if let Some(v) = self.active_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(28, v.value());
        }
        if let Some(v) = self.additional_user_message {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(29, v);
        }
        if let Some(v) = self.custom_game_whitelist_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(30, v);
        }
        if let Some(v) = self.party_search_friend_invites.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.remaining_playtime {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(32, v);
        }
        if let Some(v) = self.disable_guild_persona_info {
            my_size += 2 + 1;
        }
        for value in &self.extra_message_blocks {
            let len = value.compute_size();
            my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.store_item_hash {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.timeplayedconsecutively {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.allow_3rd_party_match_history {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.last_ip_address {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.profile_private {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.currency {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.should_request_player_origin {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.gc_socache_file_version {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.is_perfect_world_test_account {
            os.write_bool(24, v)?;
        }
        for v in &self.extra_messages {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(26, v, os)?;
        };
        if let Some(v) = self.minimum_recent_item_id {
            os.write_uint64(27, v)?;
        }
        if let Some(v) = self.active_event {
            os.write_enum(28, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.additional_user_message {
            os.write_uint32(29, v)?;
        }
        if let Some(v) = self.custom_game_whitelist_version {
            os.write_uint32(30, v)?;
        }
        if let Some(v) = self.party_search_friend_invites.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(31, v, os)?;
        }
        if let Some(v) = self.remaining_playtime {
            os.write_int32(32, v)?;
        }
        if let Some(v) = self.disable_guild_persona_info {
            os.write_bool(33, v)?;
        }
        for v in &self.extra_message_blocks {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(34, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAWelcome {
        CMsgDOTAWelcome::new()
    }

    fn clear(&mut self) {
        self.store_item_hash = ::std::option::Option::None;
        self.timeplayedconsecutively = ::std::option::Option::None;
        self.allow_3rd_party_match_history = ::std::option::Option::None;
        self.last_ip_address = ::std::option::Option::None;
        self.profile_private = ::std::option::Option::None;
        self.currency = ::std::option::Option::None;
        self.should_request_player_origin = ::std::option::Option::None;
        self.gc_socache_file_version = ::std::option::Option::None;
        self.is_perfect_world_test_account = ::std::option::Option::None;
        self.extra_messages.clear();
        self.minimum_recent_item_id = ::std::option::Option::None;
        self.active_event = ::std::option::Option::None;
        self.additional_user_message = ::std::option::Option::None;
        self.custom_game_whitelist_version = ::std::option::Option::None;
        self.party_search_friend_invites.clear();
        self.remaining_playtime = ::std::option::Option::None;
        self.disable_guild_persona_info = ::std::option::Option::None;
        self.extra_message_blocks.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAWelcome {
        static instance: CMsgDOTAWelcome = CMsgDOTAWelcome {
            store_item_hash: ::std::option::Option::None,
            timeplayedconsecutively: ::std::option::Option::None,
            allow_3rd_party_match_history: ::std::option::Option::None,
            last_ip_address: ::std::option::Option::None,
            profile_private: ::std::option::Option::None,
            currency: ::std::option::Option::None,
            should_request_player_origin: ::std::option::Option::None,
            gc_socache_file_version: ::std::option::Option::None,
            is_perfect_world_test_account: ::std::option::Option::None,
            extra_messages: ::std::vec::Vec::new(),
            minimum_recent_item_id: ::std::option::Option::None,
            active_event: ::std::option::Option::None,
            additional_user_message: ::std::option::Option::None,
            custom_game_whitelist_version: ::std::option::Option::None,
            party_search_friend_invites: ::steam_vent_proto_common::protobuf::MessageField::none(),
            remaining_playtime: ::std::option::Option::None,
            disable_guild_persona_info: ::std::option::Option::None,
            extra_message_blocks: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAWelcome`
pub mod cmsg_dotawelcome {
    // @@protoc_insertion_point(message:CMsgDOTAWelcome.CExtraMsg)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CExtraMsg {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAWelcome.CExtraMsg.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAWelcome.CExtraMsg.contents)
        pub contents: ::std::option::Option<::std::vec::Vec<u8>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAWelcome.CExtraMsg.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CExtraMsg {
        fn default() -> &'a CExtraMsg {
            <CExtraMsg as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CExtraMsg {
        pub fn new() -> CExtraMsg {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional bytes contents = 2;

        pub fn contents(&self) -> &[u8] {
            match self.contents.as_ref() {
                Some(v) => v,
                None => &[],
            }
        }

        pub fn clear_contents(&mut self) {
            self.contents = ::std::option::Option::None;
        }

        pub fn has_contents(&self) -> bool {
            self.contents.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contents(&mut self, v: ::std::vec::Vec<u8>) {
            self.contents = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_contents(&mut self) -> &mut ::std::vec::Vec<u8> {
            if self.contents.is_none() {
                self.contents = ::std::option::Option::Some(::std::vec::Vec::new());
            }
            self.contents.as_mut().unwrap()
        }

        // Take field
        pub fn take_contents(&mut self) -> ::std::vec::Vec<u8> {
            self.contents.take().unwrap_or_else(|| ::std::vec::Vec::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CExtraMsg {
        const NAME: &'static str = "CExtraMsg";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.contents = ::std::option::Option::Some(is.read_bytes()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.contents.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.contents.as_ref() {
                os.write_bytes(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CExtraMsg {
            CExtraMsg::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.contents = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CExtraMsg {
            static instance: CExtraMsg = CExtraMsg {
                id: ::std::option::Option::None,
                contents: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CSODOTAGameHeroFavorites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CSODOTAGameHeroFavorites {
    // message fields
    // @@protoc_insertion_point(field:CSODOTAGameHeroFavorites.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CSODOTAGameHeroFavorites.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CSODOTAGameHeroFavorites.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CSODOTAGameHeroFavorites {
    fn default() -> &'a CSODOTAGameHeroFavorites {
        <CSODOTAGameHeroFavorites as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CSODOTAGameHeroFavorites {
    pub fn new() -> CSODOTAGameHeroFavorites {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CSODOTAGameHeroFavorites {
    const NAME: &'static str = "CSODOTAGameHeroFavorites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CSODOTAGameHeroFavorites {
        CSODOTAGameHeroFavorites::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CSODOTAGameHeroFavorites {
        static instance: CSODOTAGameHeroFavorites = CSODOTAGameHeroFavorites {
            account_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAMatchVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatchVotes {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAMatchVotes.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchVotes.votes)
    pub votes: ::std::vec::Vec<cmsg_dotamatch_votes::PlayerVote>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMatchVotes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatchVotes {
    fn default() -> &'a CMsgDOTAMatchVotes {
        <CMsgDOTAMatchVotes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatchVotes {
    pub fn new() -> CMsgDOTAMatchVotes {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMatchVotes {
    const NAME: &'static str = "CMsgDOTAMatchVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.votes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.votes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatchVotes {
        CMsgDOTAMatchVotes::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatchVotes {
        static instance: CMsgDOTAMatchVotes = CMsgDOTAMatchVotes {
            match_id: ::std::option::Option::None,
            votes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAMatchVotes`
pub mod cmsg_dotamatch_votes {
    // @@protoc_insertion_point(message:CMsgDOTAMatchVotes.PlayerVote)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerVote {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMatchVotes.PlayerVote.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMatchVotes.PlayerVote.vote)
        pub vote: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMatchVotes.PlayerVote.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerVote {
        fn default() -> &'a PlayerVote {
            <PlayerVote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerVote {
        pub fn new() -> PlayerVote {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 vote = 2;

        pub fn vote(&self) -> u32 {
            self.vote.unwrap_or(0)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: u32) {
            self.vote = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerVote {
        const NAME: &'static str = "PlayerVote";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.vote = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.vote {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerVote {
            PlayerVote::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerVote {
            static instance: PlayerVote = PlayerVote {
                account_id: ::std::option::Option::None,
                vote: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgMatchmakingMatchGroupInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgMatchmakingMatchGroupInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgMatchmakingMatchGroupInfo.players_searching)
    pub players_searching: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingMatchGroupInfo.auto_region_select_ping_penalty)
    pub auto_region_select_ping_penalty: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingMatchGroupInfo.auto_region_select_ping_penalty_custom)
    pub auto_region_select_ping_penalty_custom: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgMatchmakingMatchGroupInfo.status)
    pub status: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EMatchGroupServerStatus>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgMatchmakingMatchGroupInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgMatchmakingMatchGroupInfo {
    fn default() -> &'a CMsgMatchmakingMatchGroupInfo {
        <CMsgMatchmakingMatchGroupInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgMatchmakingMatchGroupInfo {
    pub fn new() -> CMsgMatchmakingMatchGroupInfo {
        ::std::default::Default::default()
    }

    // optional uint32 players_searching = 1;

    pub fn players_searching(&self) -> u32 {
        self.players_searching.unwrap_or(0)
    }

    pub fn clear_players_searching(&mut self) {
        self.players_searching = ::std::option::Option::None;
    }

    pub fn has_players_searching(&self) -> bool {
        self.players_searching.is_some()
    }

    // Param is passed by value, moved
    pub fn set_players_searching(&mut self, v: u32) {
        self.players_searching = ::std::option::Option::Some(v);
    }

    // optional sint32 auto_region_select_ping_penalty = 2;

    pub fn auto_region_select_ping_penalty(&self) -> i32 {
        self.auto_region_select_ping_penalty.unwrap_or(0)
    }

    pub fn clear_auto_region_select_ping_penalty(&mut self) {
        self.auto_region_select_ping_penalty = ::std::option::Option::None;
    }

    pub fn has_auto_region_select_ping_penalty(&self) -> bool {
        self.auto_region_select_ping_penalty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_region_select_ping_penalty(&mut self, v: i32) {
        self.auto_region_select_ping_penalty = ::std::option::Option::Some(v);
    }

    // optional sint32 auto_region_select_ping_penalty_custom = 4;

    pub fn auto_region_select_ping_penalty_custom(&self) -> i32 {
        self.auto_region_select_ping_penalty_custom.unwrap_or(0)
    }

    pub fn clear_auto_region_select_ping_penalty_custom(&mut self) {
        self.auto_region_select_ping_penalty_custom = ::std::option::Option::None;
    }

    pub fn has_auto_region_select_ping_penalty_custom(&self) -> bool {
        self.auto_region_select_ping_penalty_custom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auto_region_select_ping_penalty_custom(&mut self, v: i32) {
        self.auto_region_select_ping_penalty_custom = ::std::option::Option::Some(v);
    }

    // optional .EMatchGroupServerStatus status = 3;

    pub fn status(&self) -> super::dota_shared_enums::EMatchGroupServerStatus {
        match self.status {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK),
            None => super::dota_shared_enums::EMatchGroupServerStatus::k_EMatchGroupServerStatus_OK,
        }
    }

    pub fn clear_status(&mut self) {
        self.status = ::std::option::Option::None;
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: super::dota_shared_enums::EMatchGroupServerStatus) {
        self.status = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgMatchmakingMatchGroupInfo {
    const NAME: &'static str = "CMsgMatchmakingMatchGroupInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.players_searching = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.auto_region_select_ping_penalty = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.auto_region_select_ping_penalty_custom = ::std::option::Option::Some(is.read_sint32()?);
                },
                24 => {
                    self.status = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.players_searching {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.auto_region_select_ping_penalty {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(2, v);
        }
        if let Some(v) = self.auto_region_select_ping_penalty_custom {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(4, v);
        }
        if let Some(v) = self.status {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.players_searching {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.auto_region_select_ping_penalty {
            os.write_sint32(2, v)?;
        }
        if let Some(v) = self.auto_region_select_ping_penalty_custom {
            os.write_sint32(4, v)?;
        }
        if let Some(v) = self.status {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgMatchmakingMatchGroupInfo {
        CMsgMatchmakingMatchGroupInfo::new()
    }

    fn clear(&mut self) {
        self.players_searching = ::std::option::Option::None;
        self.auto_region_select_ping_penalty = ::std::option::Option::None;
        self.auto_region_select_ping_penalty_custom = ::std::option::Option::None;
        self.status = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgMatchmakingMatchGroupInfo {
        static instance: CMsgMatchmakingMatchGroupInfo = CMsgMatchmakingMatchGroupInfo {
            players_searching: ::std::option::Option::None,
            auto_region_select_ping_penalty: ::std::option::Option::None,
            auto_region_select_ping_penalty_custom: ::std::option::Option::None,
            status: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAMatchmakingStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatchmakingStatsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMatchmakingStatsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatchmakingStatsRequest {
    fn default() -> &'a CMsgDOTAMatchmakingStatsRequest {
        <CMsgDOTAMatchmakingStatsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatchmakingStatsRequest {
    pub fn new() -> CMsgDOTAMatchmakingStatsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMatchmakingStatsRequest {
    const NAME: &'static str = "CMsgDOTAMatchmakingStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatchmakingStatsRequest {
        CMsgDOTAMatchmakingStatsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatchmakingStatsRequest {
        static instance: CMsgDOTAMatchmakingStatsRequest = CMsgDOTAMatchmakingStatsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAMatchmakingStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMatchmakingStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAMatchmakingStatsResponse.matchgroups_version)
    pub matchgroups_version: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchmakingStatsResponse.legacy_searching_players_by_group_source2)
    pub legacy_searching_players_by_group_source2: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAMatchmakingStatsResponse.match_groups)
    pub match_groups: ::std::vec::Vec<CMsgMatchmakingMatchGroupInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMatchmakingStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMatchmakingStatsResponse {
    fn default() -> &'a CMsgDOTAMatchmakingStatsResponse {
        <CMsgDOTAMatchmakingStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMatchmakingStatsResponse {
    pub fn new() -> CMsgDOTAMatchmakingStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 matchgroups_version = 1;

    pub fn matchgroups_version(&self) -> u32 {
        self.matchgroups_version.unwrap_or(0)
    }

    pub fn clear_matchgroups_version(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
    }

    pub fn has_matchgroups_version(&self) -> bool {
        self.matchgroups_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matchgroups_version(&mut self, v: u32) {
        self.matchgroups_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMatchmakingStatsResponse {
    const NAME: &'static str = "CMsgDOTAMatchmakingStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.matchgroups_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.legacy_searching_players_by_group_source2)?;
                },
                56 => {
                    self.legacy_searching_players_by_group_source2.push(is.read_uint32()?);
                },
                66 => {
                    self.match_groups.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.matchgroups_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.legacy_searching_players_by_group_source2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, *value);
        };
        for value in &self.match_groups {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.matchgroups_version {
            os.write_uint32(1, v)?;
        }
        for v in &self.legacy_searching_players_by_group_source2 {
            os.write_uint32(7, *v)?;
        };
        for v in &self.match_groups {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMatchmakingStatsResponse {
        CMsgDOTAMatchmakingStatsResponse::new()
    }

    fn clear(&mut self) {
        self.matchgroups_version = ::std::option::Option::None;
        self.legacy_searching_players_by_group_source2.clear();
        self.match_groups.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMatchmakingStatsResponse {
        static instance: CMsgDOTAMatchmakingStatsResponse = CMsgDOTAMatchmakingStatsResponse {
            matchgroups_version: ::std::option::Option::None,
            legacy_searching_players_by_group_source2: ::std::vec::Vec::new(),
            match_groups: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAUpdateMatchmakingStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAUpdateMatchmakingStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAUpdateMatchmakingStats.stats)
    pub stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAMatchmakingStatsResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAUpdateMatchmakingStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAUpdateMatchmakingStats {
    fn default() -> &'a CMsgDOTAUpdateMatchmakingStats {
        <CMsgDOTAUpdateMatchmakingStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAUpdateMatchmakingStats {
    pub fn new() -> CMsgDOTAUpdateMatchmakingStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAUpdateMatchmakingStats {
    const NAME: &'static str = "CMsgDOTAUpdateMatchmakingStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAUpdateMatchmakingStats {
        CMsgDOTAUpdateMatchmakingStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAUpdateMatchmakingStats {
        static instance: CMsgDOTAUpdateMatchmakingStats = CMsgDOTAUpdateMatchmakingStats {
            stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAUpdateMatchManagementStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAUpdateMatchManagementStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAUpdateMatchManagementStats.stats)
    pub stats: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAMatchmakingStatsResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAUpdateMatchManagementStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAUpdateMatchManagementStats {
    fn default() -> &'a CMsgDOTAUpdateMatchManagementStats {
        <CMsgDOTAUpdateMatchManagementStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAUpdateMatchManagementStats {
    pub fn new() -> CMsgDOTAUpdateMatchManagementStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAUpdateMatchManagementStats {
    const NAME: &'static str = "CMsgDOTAUpdateMatchManagementStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAUpdateMatchManagementStats {
        CMsgDOTAUpdateMatchManagementStats::new()
    }

    fn clear(&mut self) {
        self.stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAUpdateMatchManagementStats {
        static instance: CMsgDOTAUpdateMatchManagementStats = CMsgDOTAUpdateMatchManagementStats {
            stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetMatchHistoryAccess)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetMatchHistoryAccess {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetMatchHistoryAccess.allow_3rd_party_match_history)
    pub allow_3rd_party_match_history: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetMatchHistoryAccess.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetMatchHistoryAccess {
    fn default() -> &'a CMsgDOTASetMatchHistoryAccess {
        <CMsgDOTASetMatchHistoryAccess as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetMatchHistoryAccess {
    pub fn new() -> CMsgDOTASetMatchHistoryAccess {
        ::std::default::Default::default()
    }

    // optional bool allow_3rd_party_match_history = 1;

    pub fn allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.unwrap_or(false)
    }

    pub fn clear_allow_3rd_party_match_history(&mut self) {
        self.allow_3rd_party_match_history = ::std::option::Option::None;
    }

    pub fn has_allow_3rd_party_match_history(&self) -> bool {
        self.allow_3rd_party_match_history.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_3rd_party_match_history(&mut self, v: bool) {
        self.allow_3rd_party_match_history = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetMatchHistoryAccess {
    const NAME: &'static str = "CMsgDOTASetMatchHistoryAccess";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.allow_3rd_party_match_history = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_3rd_party_match_history {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.allow_3rd_party_match_history {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetMatchHistoryAccess {
        CMsgDOTASetMatchHistoryAccess::new()
    }

    fn clear(&mut self) {
        self.allow_3rd_party_match_history = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetMatchHistoryAccess {
        static instance: CMsgDOTASetMatchHistoryAccess = CMsgDOTASetMatchHistoryAccess {
            allow_3rd_party_match_history: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetMatchHistoryAccessResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetMatchHistoryAccessResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetMatchHistoryAccessResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetMatchHistoryAccessResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetMatchHistoryAccessResponse {
    fn default() -> &'a CMsgDOTASetMatchHistoryAccessResponse {
        <CMsgDOTASetMatchHistoryAccessResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetMatchHistoryAccessResponse {
    pub fn new() -> CMsgDOTASetMatchHistoryAccessResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetMatchHistoryAccessResponse {
    const NAME: &'static str = "CMsgDOTASetMatchHistoryAccessResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetMatchHistoryAccessResponse {
        CMsgDOTASetMatchHistoryAccessResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetMatchHistoryAccessResponse {
        static instance: CMsgDOTASetMatchHistoryAccessResponse = CMsgDOTASetMatchHistoryAccessResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTANotifyAccountFlagsChange)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTANotifyAccountFlagsChange {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTANotifyAccountFlagsChange.accountid)
    pub accountid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTANotifyAccountFlagsChange.account_flags)
    pub account_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTANotifyAccountFlagsChange.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTANotifyAccountFlagsChange {
    fn default() -> &'a CMsgDOTANotifyAccountFlagsChange {
        <CMsgDOTANotifyAccountFlagsChange as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTANotifyAccountFlagsChange {
    pub fn new() -> CMsgDOTANotifyAccountFlagsChange {
        ::std::default::Default::default()
    }

    // optional uint32 accountid = 1;

    pub fn accountid(&self) -> u32 {
        self.accountid.unwrap_or(0)
    }

    pub fn clear_accountid(&mut self) {
        self.accountid = ::std::option::Option::None;
    }

    pub fn has_accountid(&self) -> bool {
        self.accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_accountid(&mut self, v: u32) {
        self.accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 account_flags = 2;

    pub fn account_flags(&self) -> u32 {
        self.account_flags.unwrap_or(0)
    }

    pub fn clear_account_flags(&mut self) {
        self.account_flags = ::std::option::Option::None;
    }

    pub fn has_account_flags(&self) -> bool {
        self.account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_flags(&mut self, v: u32) {
        self.account_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTANotifyAccountFlagsChange {
    const NAME: &'static str = "CMsgDOTANotifyAccountFlagsChange";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.accountid = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.accountid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.accountid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_flags {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTANotifyAccountFlagsChange {
        CMsgDOTANotifyAccountFlagsChange::new()
    }

    fn clear(&mut self) {
        self.accountid = ::std::option::Option::None;
        self.account_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTANotifyAccountFlagsChange {
        static instance: CMsgDOTANotifyAccountFlagsChange = CMsgDOTANotifyAccountFlagsChange {
            accountid: ::std::option::Option::None,
            account_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetProfilePrivacy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetProfilePrivacy {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetProfilePrivacy.profile_private)
    pub profile_private: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetProfilePrivacy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetProfilePrivacy {
    fn default() -> &'a CMsgDOTASetProfilePrivacy {
        <CMsgDOTASetProfilePrivacy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetProfilePrivacy {
    pub fn new() -> CMsgDOTASetProfilePrivacy {
        ::std::default::Default::default()
    }

    // optional bool profile_private = 1;

    pub fn profile_private(&self) -> bool {
        self.profile_private.unwrap_or(false)
    }

    pub fn clear_profile_private(&mut self) {
        self.profile_private = ::std::option::Option::None;
    }

    pub fn has_profile_private(&self) -> bool {
        self.profile_private.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_private(&mut self, v: bool) {
        self.profile_private = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetProfilePrivacy {
    const NAME: &'static str = "CMsgDOTASetProfilePrivacy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.profile_private = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.profile_private {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.profile_private {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetProfilePrivacy {
        CMsgDOTASetProfilePrivacy::new()
    }

    fn clear(&mut self) {
        self.profile_private = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetProfilePrivacy {
        static instance: CMsgDOTASetProfilePrivacy = CMsgDOTASetProfilePrivacy {
            profile_private: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetProfilePrivacyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetProfilePrivacyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetProfilePrivacyResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetProfilePrivacyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetProfilePrivacyResponse {
    fn default() -> &'a CMsgDOTASetProfilePrivacyResponse {
        <CMsgDOTASetProfilePrivacyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetProfilePrivacyResponse {
    pub fn new() -> CMsgDOTASetProfilePrivacyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(0)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetProfilePrivacyResponse {
    const NAME: &'static str = "CMsgDOTASetProfilePrivacyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetProfilePrivacyResponse {
        CMsgDOTASetProfilePrivacyResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetProfilePrivacyResponse {
        static instance: CMsgDOTASetProfilePrivacyResponse = CMsgDOTASetProfilePrivacyResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpgradeLeagueItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpgradeLeagueItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgUpgradeLeagueItem.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgUpgradeLeagueItem.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpgradeLeagueItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpgradeLeagueItem {
    fn default() -> &'a CMsgUpgradeLeagueItem {
        <CMsgUpgradeLeagueItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUpgradeLeagueItem {
    pub fn new() -> CMsgUpgradeLeagueItem {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 2;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUpgradeLeagueItem {
    const NAME: &'static str = "CMsgUpgradeLeagueItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpgradeLeagueItem {
        CMsgUpgradeLeagueItem::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpgradeLeagueItem {
        static instance: CMsgUpgradeLeagueItem = CMsgUpgradeLeagueItem {
            match_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgUpgradeLeagueItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgUpgradeLeagueItemResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgUpgradeLeagueItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgUpgradeLeagueItemResponse {
    fn default() -> &'a CMsgUpgradeLeagueItemResponse {
        <CMsgUpgradeLeagueItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgUpgradeLeagueItemResponse {
    pub fn new() -> CMsgUpgradeLeagueItemResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgUpgradeLeagueItemResponse {
    const NAME: &'static str = "CMsgUpgradeLeagueItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgUpgradeLeagueItemResponse {
        CMsgUpgradeLeagueItemResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgUpgradeLeagueItemResponse {
        static instance: CMsgUpgradeLeagueItemResponse = CMsgUpgradeLeagueItemResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCWatchDownloadedReplay)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCWatchDownloadedReplay {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCWatchDownloadedReplay.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCWatchDownloadedReplay.watch_type)
    pub watch_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<DOTA_WatchReplayType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCWatchDownloadedReplay.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCWatchDownloadedReplay {
    fn default() -> &'a CMsgGCWatchDownloadedReplay {
        <CMsgGCWatchDownloadedReplay as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCWatchDownloadedReplay {
    pub fn new() -> CMsgGCWatchDownloadedReplay {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional .DOTA_WatchReplayType watch_type = 2;

    pub fn watch_type(&self) -> DOTA_WatchReplayType {
        match self.watch_type {
            Some(e) => e.enum_value_or(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL),
            None => DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL,
        }
    }

    pub fn clear_watch_type(&mut self) {
        self.watch_type = ::std::option::Option::None;
    }

    pub fn has_watch_type(&self) -> bool {
        self.watch_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch_type(&mut self, v: DOTA_WatchReplayType) {
        self.watch_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCWatchDownloadedReplay {
    const NAME: &'static str = "CMsgGCWatchDownloadedReplay";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.watch_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.watch_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.watch_type {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCWatchDownloadedReplay {
        CMsgGCWatchDownloadedReplay::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.watch_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCWatchDownloadedReplay {
        static instance: CMsgGCWatchDownloadedReplay = CMsgGCWatchDownloadedReplay {
            match_id: ::std::option::Option::None,
            watch_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientsRejoinChatChannels)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientsRejoinChatChannels {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientsRejoinChatChannels.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientsRejoinChatChannels {
    fn default() -> &'a CMsgClientsRejoinChatChannels {
        <CMsgClientsRejoinChatChannels as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientsRejoinChatChannels {
    pub fn new() -> CMsgClientsRejoinChatChannels {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientsRejoinChatChannels {
    const NAME: &'static str = "CMsgClientsRejoinChatChannels";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientsRejoinChatChannels {
        CMsgClientsRejoinChatChannels::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientsRejoinChatChannels {
        static instance: CMsgClientsRejoinChatChannels = CMsgClientsRejoinChatChannels {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetHeroStandings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetHeroStandings {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetHeroStandings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetHeroStandings {
    fn default() -> &'a CMsgGCGetHeroStandings {
        <CMsgGCGetHeroStandings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetHeroStandings {
    pub fn new() -> CMsgGCGetHeroStandings {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetHeroStandings {
    const NAME: &'static str = "CMsgGCGetHeroStandings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetHeroStandings {
        CMsgGCGetHeroStandings::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetHeroStandings {
        static instance: CMsgGCGetHeroStandings = CMsgGCGetHeroStandings {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetHeroStandingsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetHeroStandingsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.standings)
    pub standings: ::std::vec::Vec<cmsg_gcget_hero_standings_response::Hero>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetHeroStandingsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetHeroStandingsResponse {
    fn default() -> &'a CMsgGCGetHeroStandingsResponse {
        <CMsgGCGetHeroStandingsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetHeroStandingsResponse {
    pub fn new() -> CMsgGCGetHeroStandingsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetHeroStandingsResponse {
    const NAME: &'static str = "CMsgGCGetHeroStandingsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.standings.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.standings {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.standings {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetHeroStandingsResponse {
        CMsgGCGetHeroStandingsResponse::new()
    }

    fn clear(&mut self) {
        self.standings.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetHeroStandingsResponse {
        static instance: CMsgGCGetHeroStandingsResponse = CMsgGCGetHeroStandingsResponse {
            standings: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCGetHeroStandingsResponse`
pub mod cmsg_gcget_hero_standings_response {
    // @@protoc_insertion_point(message:CMsgGCGetHeroStandingsResponse.Hero)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Hero {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.losses)
        pub losses: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.win_streak)
        pub win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.best_win_streak)
        pub best_win_streak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_kills)
        pub avg_kills: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_deaths)
        pub avg_deaths: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_assists)
        pub avg_assists: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_gpm)
        pub avg_gpm: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_xpm)
        pub avg_xpm: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.best_kills)
        pub best_kills: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.best_assists)
        pub best_assists: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.best_gpm)
        pub best_gpm: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.best_xpm)
        pub best_xpm: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.performance)
        pub performance: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.wins_with_ally)
        pub wins_with_ally: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.losses_with_ally)
        pub losses_with_ally: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.wins_against_enemy)
        pub wins_against_enemy: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.losses_against_enemy)
        pub losses_against_enemy: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.networth_peak)
        pub networth_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.lasthit_peak)
        pub lasthit_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.deny_peak)
        pub deny_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.damage_peak)
        pub damage_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.longest_game_peak)
        pub longest_game_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.healing_peak)
        pub healing_peak: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_lasthits)
        pub avg_lasthits: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroStandingsResponse.Hero.avg_denies)
        pub avg_denies: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCGetHeroStandingsResponse.Hero.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Hero {
        fn default() -> &'a Hero {
            <Hero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Hero {
        pub fn new() -> Hero {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 wins = 2;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 losses = 3;

        pub fn losses(&self) -> u32 {
            self.losses.unwrap_or(0)
        }

        pub fn clear_losses(&mut self) {
            self.losses = ::std::option::Option::None;
        }

        pub fn has_losses(&self) -> bool {
            self.losses.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses(&mut self, v: u32) {
            self.losses = ::std::option::Option::Some(v);
        }

        // optional uint32 win_streak = 4;

        pub fn win_streak(&self) -> u32 {
            self.win_streak.unwrap_or(0)
        }

        pub fn clear_win_streak(&mut self) {
            self.win_streak = ::std::option::Option::None;
        }

        pub fn has_win_streak(&self) -> bool {
            self.win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_streak(&mut self, v: u32) {
            self.win_streak = ::std::option::Option::Some(v);
        }

        // optional uint32 best_win_streak = 5;

        pub fn best_win_streak(&self) -> u32 {
            self.best_win_streak.unwrap_or(0)
        }

        pub fn clear_best_win_streak(&mut self) {
            self.best_win_streak = ::std::option::Option::None;
        }

        pub fn has_best_win_streak(&self) -> bool {
            self.best_win_streak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_win_streak(&mut self, v: u32) {
            self.best_win_streak = ::std::option::Option::Some(v);
        }

        // optional float avg_kills = 6;

        pub fn avg_kills(&self) -> f32 {
            self.avg_kills.unwrap_or(0.)
        }

        pub fn clear_avg_kills(&mut self) {
            self.avg_kills = ::std::option::Option::None;
        }

        pub fn has_avg_kills(&self) -> bool {
            self.avg_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_kills(&mut self, v: f32) {
            self.avg_kills = ::std::option::Option::Some(v);
        }

        // optional float avg_deaths = 7;

        pub fn avg_deaths(&self) -> f32 {
            self.avg_deaths.unwrap_or(0.)
        }

        pub fn clear_avg_deaths(&mut self) {
            self.avg_deaths = ::std::option::Option::None;
        }

        pub fn has_avg_deaths(&self) -> bool {
            self.avg_deaths.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_deaths(&mut self, v: f32) {
            self.avg_deaths = ::std::option::Option::Some(v);
        }

        // optional float avg_assists = 8;

        pub fn avg_assists(&self) -> f32 {
            self.avg_assists.unwrap_or(0.)
        }

        pub fn clear_avg_assists(&mut self) {
            self.avg_assists = ::std::option::Option::None;
        }

        pub fn has_avg_assists(&self) -> bool {
            self.avg_assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_assists(&mut self, v: f32) {
            self.avg_assists = ::std::option::Option::Some(v);
        }

        // optional float avg_gpm = 9;

        pub fn avg_gpm(&self) -> f32 {
            self.avg_gpm.unwrap_or(0.)
        }

        pub fn clear_avg_gpm(&mut self) {
            self.avg_gpm = ::std::option::Option::None;
        }

        pub fn has_avg_gpm(&self) -> bool {
            self.avg_gpm.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_gpm(&mut self, v: f32) {
            self.avg_gpm = ::std::option::Option::Some(v);
        }

        // optional float avg_xpm = 10;

        pub fn avg_xpm(&self) -> f32 {
            self.avg_xpm.unwrap_or(0.)
        }

        pub fn clear_avg_xpm(&mut self) {
            self.avg_xpm = ::std::option::Option::None;
        }

        pub fn has_avg_xpm(&self) -> bool {
            self.avg_xpm.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_xpm(&mut self, v: f32) {
            self.avg_xpm = ::std::option::Option::Some(v);
        }

        // optional uint32 best_kills = 11;

        pub fn best_kills(&self) -> u32 {
            self.best_kills.unwrap_or(0)
        }

        pub fn clear_best_kills(&mut self) {
            self.best_kills = ::std::option::Option::None;
        }

        pub fn has_best_kills(&self) -> bool {
            self.best_kills.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_kills(&mut self, v: u32) {
            self.best_kills = ::std::option::Option::Some(v);
        }

        // optional uint32 best_assists = 12;

        pub fn best_assists(&self) -> u32 {
            self.best_assists.unwrap_or(0)
        }

        pub fn clear_best_assists(&mut self) {
            self.best_assists = ::std::option::Option::None;
        }

        pub fn has_best_assists(&self) -> bool {
            self.best_assists.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_assists(&mut self, v: u32) {
            self.best_assists = ::std::option::Option::Some(v);
        }

        // optional uint32 best_gpm = 13;

        pub fn best_gpm(&self) -> u32 {
            self.best_gpm.unwrap_or(0)
        }

        pub fn clear_best_gpm(&mut self) {
            self.best_gpm = ::std::option::Option::None;
        }

        pub fn has_best_gpm(&self) -> bool {
            self.best_gpm.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_gpm(&mut self, v: u32) {
            self.best_gpm = ::std::option::Option::Some(v);
        }

        // optional uint32 best_xpm = 14;

        pub fn best_xpm(&self) -> u32 {
            self.best_xpm.unwrap_or(0)
        }

        pub fn clear_best_xpm(&mut self) {
            self.best_xpm = ::std::option::Option::None;
        }

        pub fn has_best_xpm(&self) -> bool {
            self.best_xpm.is_some()
        }

        // Param is passed by value, moved
        pub fn set_best_xpm(&mut self, v: u32) {
            self.best_xpm = ::std::option::Option::Some(v);
        }

        // optional float performance = 15;

        pub fn performance(&self) -> f32 {
            self.performance.unwrap_or(0.)
        }

        pub fn clear_performance(&mut self) {
            self.performance = ::std::option::Option::None;
        }

        pub fn has_performance(&self) -> bool {
            self.performance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_performance(&mut self, v: f32) {
            self.performance = ::std::option::Option::Some(v);
        }

        // optional uint32 wins_with_ally = 16;

        pub fn wins_with_ally(&self) -> u32 {
            self.wins_with_ally.unwrap_or(0)
        }

        pub fn clear_wins_with_ally(&mut self) {
            self.wins_with_ally = ::std::option::Option::None;
        }

        pub fn has_wins_with_ally(&self) -> bool {
            self.wins_with_ally.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins_with_ally(&mut self, v: u32) {
            self.wins_with_ally = ::std::option::Option::Some(v);
        }

        // optional uint32 losses_with_ally = 17;

        pub fn losses_with_ally(&self) -> u32 {
            self.losses_with_ally.unwrap_or(0)
        }

        pub fn clear_losses_with_ally(&mut self) {
            self.losses_with_ally = ::std::option::Option::None;
        }

        pub fn has_losses_with_ally(&self) -> bool {
            self.losses_with_ally.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses_with_ally(&mut self, v: u32) {
            self.losses_with_ally = ::std::option::Option::Some(v);
        }

        // optional uint32 wins_against_enemy = 18;

        pub fn wins_against_enemy(&self) -> u32 {
            self.wins_against_enemy.unwrap_or(0)
        }

        pub fn clear_wins_against_enemy(&mut self) {
            self.wins_against_enemy = ::std::option::Option::None;
        }

        pub fn has_wins_against_enemy(&self) -> bool {
            self.wins_against_enemy.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins_against_enemy(&mut self, v: u32) {
            self.wins_against_enemy = ::std::option::Option::Some(v);
        }

        // optional uint32 losses_against_enemy = 19;

        pub fn losses_against_enemy(&self) -> u32 {
            self.losses_against_enemy.unwrap_or(0)
        }

        pub fn clear_losses_against_enemy(&mut self) {
            self.losses_against_enemy = ::std::option::Option::None;
        }

        pub fn has_losses_against_enemy(&self) -> bool {
            self.losses_against_enemy.is_some()
        }

        // Param is passed by value, moved
        pub fn set_losses_against_enemy(&mut self, v: u32) {
            self.losses_against_enemy = ::std::option::Option::Some(v);
        }

        // optional uint32 networth_peak = 20;

        pub fn networth_peak(&self) -> u32 {
            self.networth_peak.unwrap_or(0)
        }

        pub fn clear_networth_peak(&mut self) {
            self.networth_peak = ::std::option::Option::None;
        }

        pub fn has_networth_peak(&self) -> bool {
            self.networth_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_networth_peak(&mut self, v: u32) {
            self.networth_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 lasthit_peak = 21;

        pub fn lasthit_peak(&self) -> u32 {
            self.lasthit_peak.unwrap_or(0)
        }

        pub fn clear_lasthit_peak(&mut self) {
            self.lasthit_peak = ::std::option::Option::None;
        }

        pub fn has_lasthit_peak(&self) -> bool {
            self.lasthit_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lasthit_peak(&mut self, v: u32) {
            self.lasthit_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 deny_peak = 22;

        pub fn deny_peak(&self) -> u32 {
            self.deny_peak.unwrap_or(0)
        }

        pub fn clear_deny_peak(&mut self) {
            self.deny_peak = ::std::option::Option::None;
        }

        pub fn has_deny_peak(&self) -> bool {
            self.deny_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_deny_peak(&mut self, v: u32) {
            self.deny_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 damage_peak = 23;

        pub fn damage_peak(&self) -> u32 {
            self.damage_peak.unwrap_or(0)
        }

        pub fn clear_damage_peak(&mut self) {
            self.damage_peak = ::std::option::Option::None;
        }

        pub fn has_damage_peak(&self) -> bool {
            self.damage_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_damage_peak(&mut self, v: u32) {
            self.damage_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 longest_game_peak = 24;

        pub fn longest_game_peak(&self) -> u32 {
            self.longest_game_peak.unwrap_or(0)
        }

        pub fn clear_longest_game_peak(&mut self) {
            self.longest_game_peak = ::std::option::Option::None;
        }

        pub fn has_longest_game_peak(&self) -> bool {
            self.longest_game_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_longest_game_peak(&mut self, v: u32) {
            self.longest_game_peak = ::std::option::Option::Some(v);
        }

        // optional uint32 healing_peak = 25;

        pub fn healing_peak(&self) -> u32 {
            self.healing_peak.unwrap_or(0)
        }

        pub fn clear_healing_peak(&mut self) {
            self.healing_peak = ::std::option::Option::None;
        }

        pub fn has_healing_peak(&self) -> bool {
            self.healing_peak.is_some()
        }

        // Param is passed by value, moved
        pub fn set_healing_peak(&mut self, v: u32) {
            self.healing_peak = ::std::option::Option::Some(v);
        }

        // optional float avg_lasthits = 26;

        pub fn avg_lasthits(&self) -> f32 {
            self.avg_lasthits.unwrap_or(0.)
        }

        pub fn clear_avg_lasthits(&mut self) {
            self.avg_lasthits = ::std::option::Option::None;
        }

        pub fn has_avg_lasthits(&self) -> bool {
            self.avg_lasthits.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_lasthits(&mut self, v: f32) {
            self.avg_lasthits = ::std::option::Option::Some(v);
        }

        // optional float avg_denies = 27;

        pub fn avg_denies(&self) -> f32 {
            self.avg_denies.unwrap_or(0.)
        }

        pub fn clear_avg_denies(&mut self) {
            self.avg_denies = ::std::option::Option::None;
        }

        pub fn has_avg_denies(&self) -> bool {
            self.avg_denies.is_some()
        }

        // Param is passed by value, moved
        pub fn set_avg_denies(&mut self, v: f32) {
            self.avg_denies = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Hero {
        const NAME: &'static str = "Hero";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.losses = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.best_win_streak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    53 => {
                        self.avg_kills = ::std::option::Option::Some(is.read_float()?);
                    },
                    61 => {
                        self.avg_deaths = ::std::option::Option::Some(is.read_float()?);
                    },
                    69 => {
                        self.avg_assists = ::std::option::Option::Some(is.read_float()?);
                    },
                    77 => {
                        self.avg_gpm = ::std::option::Option::Some(is.read_float()?);
                    },
                    85 => {
                        self.avg_xpm = ::std::option::Option::Some(is.read_float()?);
                    },
                    88 => {
                        self.best_kills = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.best_assists = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.best_gpm = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    112 => {
                        self.best_xpm = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    125 => {
                        self.performance = ::std::option::Option::Some(is.read_float()?);
                    },
                    128 => {
                        self.wins_with_ally = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.losses_with_ally = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.wins_against_enemy = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.losses_against_enemy = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    160 => {
                        self.networth_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    168 => {
                        self.lasthit_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    176 => {
                        self.deny_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    184 => {
                        self.damage_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    192 => {
                        self.longest_game_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    200 => {
                        self.healing_peak = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    213 => {
                        self.avg_lasthits = ::std::option::Option::Some(is.read_float()?);
                    },
                    221 => {
                        self.avg_denies = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.losses {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.win_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.best_win_streak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.avg_kills {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_deaths {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_assists {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_gpm {
                my_size += 1 + 4;
            }
            if let Some(v) = self.avg_xpm {
                my_size += 1 + 4;
            }
            if let Some(v) = self.best_kills {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.best_assists {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.best_gpm {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
            }
            if let Some(v) = self.best_xpm {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
            }
            if let Some(v) = self.performance {
                my_size += 1 + 4;
            }
            if let Some(v) = self.wins_with_ally {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.losses_with_ally {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.wins_against_enemy {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.losses_against_enemy {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.networth_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
            }
            if let Some(v) = self.lasthit_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(21, v);
            }
            if let Some(v) = self.deny_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
            }
            if let Some(v) = self.damage_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
            }
            if let Some(v) = self.longest_game_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(24, v);
            }
            if let Some(v) = self.healing_peak {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(25, v);
            }
            if let Some(v) = self.avg_lasthits {
                my_size += 2 + 4;
            }
            if let Some(v) = self.avg_denies {
                my_size += 2 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.losses {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.win_streak {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.best_win_streak {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.avg_kills {
                os.write_float(6, v)?;
            }
            if let Some(v) = self.avg_deaths {
                os.write_float(7, v)?;
            }
            if let Some(v) = self.avg_assists {
                os.write_float(8, v)?;
            }
            if let Some(v) = self.avg_gpm {
                os.write_float(9, v)?;
            }
            if let Some(v) = self.avg_xpm {
                os.write_float(10, v)?;
            }
            if let Some(v) = self.best_kills {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.best_assists {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.best_gpm {
                os.write_uint32(13, v)?;
            }
            if let Some(v) = self.best_xpm {
                os.write_uint32(14, v)?;
            }
            if let Some(v) = self.performance {
                os.write_float(15, v)?;
            }
            if let Some(v) = self.wins_with_ally {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.losses_with_ally {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.wins_against_enemy {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.losses_against_enemy {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.networth_peak {
                os.write_uint32(20, v)?;
            }
            if let Some(v) = self.lasthit_peak {
                os.write_uint32(21, v)?;
            }
            if let Some(v) = self.deny_peak {
                os.write_uint32(22, v)?;
            }
            if let Some(v) = self.damage_peak {
                os.write_uint32(23, v)?;
            }
            if let Some(v) = self.longest_game_peak {
                os.write_uint32(24, v)?;
            }
            if let Some(v) = self.healing_peak {
                os.write_uint32(25, v)?;
            }
            if let Some(v) = self.avg_lasthits {
                os.write_float(26, v)?;
            }
            if let Some(v) = self.avg_denies {
                os.write_float(27, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Hero {
            Hero::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.losses = ::std::option::Option::None;
            self.win_streak = ::std::option::Option::None;
            self.best_win_streak = ::std::option::Option::None;
            self.avg_kills = ::std::option::Option::None;
            self.avg_deaths = ::std::option::Option::None;
            self.avg_assists = ::std::option::Option::None;
            self.avg_gpm = ::std::option::Option::None;
            self.avg_xpm = ::std::option::Option::None;
            self.best_kills = ::std::option::Option::None;
            self.best_assists = ::std::option::Option::None;
            self.best_gpm = ::std::option::Option::None;
            self.best_xpm = ::std::option::Option::None;
            self.performance = ::std::option::Option::None;
            self.wins_with_ally = ::std::option::Option::None;
            self.losses_with_ally = ::std::option::Option::None;
            self.wins_against_enemy = ::std::option::Option::None;
            self.losses_against_enemy = ::std::option::Option::None;
            self.networth_peak = ::std::option::Option::None;
            self.lasthit_peak = ::std::option::Option::None;
            self.deny_peak = ::std::option::Option::None;
            self.damage_peak = ::std::option::Option::None;
            self.longest_game_peak = ::std::option::Option::None;
            self.healing_peak = ::std::option::Option::None;
            self.avg_lasthits = ::std::option::Option::None;
            self.avg_denies = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Hero {
            static instance: Hero = Hero {
                hero_id: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                losses: ::std::option::Option::None,
                win_streak: ::std::option::Option::None,
                best_win_streak: ::std::option::Option::None,
                avg_kills: ::std::option::Option::None,
                avg_deaths: ::std::option::Option::None,
                avg_assists: ::std::option::Option::None,
                avg_gpm: ::std::option::Option::None,
                avg_xpm: ::std::option::Option::None,
                best_kills: ::std::option::Option::None,
                best_assists: ::std::option::Option::None,
                best_gpm: ::std::option::Option::None,
                best_xpm: ::std::option::Option::None,
                performance: ::std::option::Option::None,
                wins_with_ally: ::std::option::Option::None,
                losses_with_ally: ::std::option::Option::None,
                wins_against_enemy: ::std::option::Option::None,
                losses_against_enemy: ::std::option::Option::None,
                networth_peak: ::std::option::Option::None,
                lasthit_peak: ::std::option::Option::None,
                deny_peak: ::std::option::Option::None,
                damage_peak: ::std::option::Option::None,
                longest_game_peak: ::std::option::Option::None,
                healing_peak: ::std::option::Option::None,
                avg_lasthits: ::std::option::Option::None,
                avg_denies: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMatchPlayerTimedStatAverages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedStatAverages {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.kills)
    pub kills: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.deaths)
    pub deaths: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.assists)
    pub assists: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.net_worth)
    pub net_worth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.last_hits)
    pub last_hits: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.denies)
    pub denies: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.item_value)
    pub item_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.support_gold_spent)
    pub support_gold_spent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.camps_stacked)
    pub camps_stacked: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.wards_placed)
    pub wards_placed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.dewards)
    pub dewards: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.triple_kills)
    pub triple_kills: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatAverages.rampages)
    pub rampages: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerTimedStatAverages.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedStatAverages {
    fn default() -> &'a CMatchPlayerTimedStatAverages {
        <CMatchPlayerTimedStatAverages as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedStatAverages {
    pub fn new() -> CMatchPlayerTimedStatAverages {
        ::std::default::Default::default()
    }

    // optional float kills = 2;

    pub fn kills(&self) -> f32 {
        self.kills.unwrap_or(0.)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: f32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional float deaths = 3;

    pub fn deaths(&self) -> f32 {
        self.deaths.unwrap_or(0.)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: f32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional float assists = 4;

    pub fn assists(&self) -> f32 {
        self.assists.unwrap_or(0.)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: f32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional float net_worth = 5;

    pub fn net_worth(&self) -> f32 {
        self.net_worth.unwrap_or(0.)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: f32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional float last_hits = 6;

    pub fn last_hits(&self) -> f32 {
        self.last_hits.unwrap_or(0.)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: f32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional float denies = 7;

    pub fn denies(&self) -> f32 {
        self.denies.unwrap_or(0.)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: f32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional float item_value = 8;

    pub fn item_value(&self) -> f32 {
        self.item_value.unwrap_or(0.)
    }

    pub fn clear_item_value(&mut self) {
        self.item_value = ::std::option::Option::None;
    }

    pub fn has_item_value(&self) -> bool {
        self.item_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_value(&mut self, v: f32) {
        self.item_value = ::std::option::Option::Some(v);
    }

    // optional float support_gold_spent = 9;

    pub fn support_gold_spent(&self) -> f32 {
        self.support_gold_spent.unwrap_or(0.)
    }

    pub fn clear_support_gold_spent(&mut self) {
        self.support_gold_spent = ::std::option::Option::None;
    }

    pub fn has_support_gold_spent(&self) -> bool {
        self.support_gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold_spent(&mut self, v: f32) {
        self.support_gold_spent = ::std::option::Option::Some(v);
    }

    // optional float camps_stacked = 10;

    pub fn camps_stacked(&self) -> f32 {
        self.camps_stacked.unwrap_or(0.)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: f32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional float wards_placed = 11;

    pub fn wards_placed(&self) -> f32 {
        self.wards_placed.unwrap_or(0.)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: f32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional float dewards = 12;

    pub fn dewards(&self) -> f32 {
        self.dewards.unwrap_or(0.)
    }

    pub fn clear_dewards(&mut self) {
        self.dewards = ::std::option::Option::None;
    }

    pub fn has_dewards(&self) -> bool {
        self.dewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dewards(&mut self, v: f32) {
        self.dewards = ::std::option::Option::Some(v);
    }

    // optional float triple_kills = 13;

    pub fn triple_kills(&self) -> f32 {
        self.triple_kills.unwrap_or(0.)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: f32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional float rampages = 14;

    pub fn rampages(&self) -> f32 {
        self.rampages.unwrap_or(0.)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: f32) {
        self.rampages = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerTimedStatAverages {
    const NAME: &'static str = "CMatchPlayerTimedStatAverages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                21 => {
                    self.kills = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.deaths = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.assists = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.net_worth = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.last_hits = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.denies = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.item_value = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.support_gold_spent = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.dewards = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.rampages = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kills {
            my_size += 1 + 4;
        }
        if let Some(v) = self.deaths {
            my_size += 1 + 4;
        }
        if let Some(v) = self.assists {
            my_size += 1 + 4;
        }
        if let Some(v) = self.net_worth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.last_hits {
            my_size += 1 + 4;
        }
        if let Some(v) = self.denies {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.support_gold_spent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.camps_stacked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.wards_placed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dewards {
            my_size += 1 + 4;
        }
        if let Some(v) = self.triple_kills {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rampages {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.kills {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.denies {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.item_value {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.support_gold_spent {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.dewards {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_float(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedStatAverages {
        CMatchPlayerTimedStatAverages::new()
    }

    fn clear(&mut self) {
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.item_value = ::std::option::Option::None;
        self.support_gold_spent = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.dewards = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedStatAverages {
        static instance: CMatchPlayerTimedStatAverages = CMatchPlayerTimedStatAverages {
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            item_value: ::std::option::Option::None,
            support_gold_spent: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            dewards: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMatchPlayerTimedStatStdDeviations)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMatchPlayerTimedStatStdDeviations {
    // message fields
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.kills)
    pub kills: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.deaths)
    pub deaths: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.assists)
    pub assists: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.net_worth)
    pub net_worth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.last_hits)
    pub last_hits: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.denies)
    pub denies: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.item_value)
    pub item_value: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.support_gold_spent)
    pub support_gold_spent: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.camps_stacked)
    pub camps_stacked: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.wards_placed)
    pub wards_placed: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.dewards)
    pub dewards: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.triple_kills)
    pub triple_kills: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMatchPlayerTimedStatStdDeviations.rampages)
    pub rampages: ::std::option::Option<f32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMatchPlayerTimedStatStdDeviations.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMatchPlayerTimedStatStdDeviations {
    fn default() -> &'a CMatchPlayerTimedStatStdDeviations {
        <CMatchPlayerTimedStatStdDeviations as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMatchPlayerTimedStatStdDeviations {
    pub fn new() -> CMatchPlayerTimedStatStdDeviations {
        ::std::default::Default::default()
    }

    // optional float kills = 2;

    pub fn kills(&self) -> f32 {
        self.kills.unwrap_or(1.0f32)
    }

    pub fn clear_kills(&mut self) {
        self.kills = ::std::option::Option::None;
    }

    pub fn has_kills(&self) -> bool {
        self.kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kills(&mut self, v: f32) {
        self.kills = ::std::option::Option::Some(v);
    }

    // optional float deaths = 3;

    pub fn deaths(&self) -> f32 {
        self.deaths.unwrap_or(1.0f32)
    }

    pub fn clear_deaths(&mut self) {
        self.deaths = ::std::option::Option::None;
    }

    pub fn has_deaths(&self) -> bool {
        self.deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deaths(&mut self, v: f32) {
        self.deaths = ::std::option::Option::Some(v);
    }

    // optional float assists = 4;

    pub fn assists(&self) -> f32 {
        self.assists.unwrap_or(1.0f32)
    }

    pub fn clear_assists(&mut self) {
        self.assists = ::std::option::Option::None;
    }

    pub fn has_assists(&self) -> bool {
        self.assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assists(&mut self, v: f32) {
        self.assists = ::std::option::Option::Some(v);
    }

    // optional float net_worth = 5;

    pub fn net_worth(&self) -> f32 {
        self.net_worth.unwrap_or(1.0f32)
    }

    pub fn clear_net_worth(&mut self) {
        self.net_worth = ::std::option::Option::None;
    }

    pub fn has_net_worth(&self) -> bool {
        self.net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_net_worth(&mut self, v: f32) {
        self.net_worth = ::std::option::Option::Some(v);
    }

    // optional float last_hits = 6;

    pub fn last_hits(&self) -> f32 {
        self.last_hits.unwrap_or(1.0f32)
    }

    pub fn clear_last_hits(&mut self) {
        self.last_hits = ::std::option::Option::None;
    }

    pub fn has_last_hits(&self) -> bool {
        self.last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_hits(&mut self, v: f32) {
        self.last_hits = ::std::option::Option::Some(v);
    }

    // optional float denies = 7;

    pub fn denies(&self) -> f32 {
        self.denies.unwrap_or(1.0f32)
    }

    pub fn clear_denies(&mut self) {
        self.denies = ::std::option::Option::None;
    }

    pub fn has_denies(&self) -> bool {
        self.denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_denies(&mut self, v: f32) {
        self.denies = ::std::option::Option::Some(v);
    }

    // optional float item_value = 8;

    pub fn item_value(&self) -> f32 {
        self.item_value.unwrap_or(1.0f32)
    }

    pub fn clear_item_value(&mut self) {
        self.item_value = ::std::option::Option::None;
    }

    pub fn has_item_value(&self) -> bool {
        self.item_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_value(&mut self, v: f32) {
        self.item_value = ::std::option::Option::Some(v);
    }

    // optional float support_gold_spent = 9;

    pub fn support_gold_spent(&self) -> f32 {
        self.support_gold_spent.unwrap_or(1.0f32)
    }

    pub fn clear_support_gold_spent(&mut self) {
        self.support_gold_spent = ::std::option::Option::None;
    }

    pub fn has_support_gold_spent(&self) -> bool {
        self.support_gold_spent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_gold_spent(&mut self, v: f32) {
        self.support_gold_spent = ::std::option::Option::Some(v);
    }

    // optional float camps_stacked = 10;

    pub fn camps_stacked(&self) -> f32 {
        self.camps_stacked.unwrap_or(1.0f32)
    }

    pub fn clear_camps_stacked(&mut self) {
        self.camps_stacked = ::std::option::Option::None;
    }

    pub fn has_camps_stacked(&self) -> bool {
        self.camps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_camps_stacked(&mut self, v: f32) {
        self.camps_stacked = ::std::option::Option::Some(v);
    }

    // optional float wards_placed = 11;

    pub fn wards_placed(&self) -> f32 {
        self.wards_placed.unwrap_or(1.0f32)
    }

    pub fn clear_wards_placed(&mut self) {
        self.wards_placed = ::std::option::Option::None;
    }

    pub fn has_wards_placed(&self) -> bool {
        self.wards_placed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wards_placed(&mut self, v: f32) {
        self.wards_placed = ::std::option::Option::Some(v);
    }

    // optional float dewards = 12;

    pub fn dewards(&self) -> f32 {
        self.dewards.unwrap_or(1.0f32)
    }

    pub fn clear_dewards(&mut self) {
        self.dewards = ::std::option::Option::None;
    }

    pub fn has_dewards(&self) -> bool {
        self.dewards.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dewards(&mut self, v: f32) {
        self.dewards = ::std::option::Option::Some(v);
    }

    // optional float triple_kills = 13;

    pub fn triple_kills(&self) -> f32 {
        self.triple_kills.unwrap_or(1.0f32)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: f32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional float rampages = 14;

    pub fn rampages(&self) -> f32 {
        self.rampages.unwrap_or(1.0f32)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: f32) {
        self.rampages = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMatchPlayerTimedStatStdDeviations {
    const NAME: &'static str = "CMatchPlayerTimedStatStdDeviations";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                21 => {
                    self.kills = ::std::option::Option::Some(is.read_float()?);
                },
                29 => {
                    self.deaths = ::std::option::Option::Some(is.read_float()?);
                },
                37 => {
                    self.assists = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.net_worth = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.last_hits = ::std::option::Option::Some(is.read_float()?);
                },
                61 => {
                    self.denies = ::std::option::Option::Some(is.read_float()?);
                },
                69 => {
                    self.item_value = ::std::option::Option::Some(is.read_float()?);
                },
                77 => {
                    self.support_gold_spent = ::std::option::Option::Some(is.read_float()?);
                },
                85 => {
                    self.camps_stacked = ::std::option::Option::Some(is.read_float()?);
                },
                93 => {
                    self.wards_placed = ::std::option::Option::Some(is.read_float()?);
                },
                101 => {
                    self.dewards = ::std::option::Option::Some(is.read_float()?);
                },
                109 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_float()?);
                },
                117 => {
                    self.rampages = ::std::option::Option::Some(is.read_float()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.kills {
            my_size += 1 + 4;
        }
        if let Some(v) = self.deaths {
            my_size += 1 + 4;
        }
        if let Some(v) = self.assists {
            my_size += 1 + 4;
        }
        if let Some(v) = self.net_worth {
            my_size += 1 + 4;
        }
        if let Some(v) = self.last_hits {
            my_size += 1 + 4;
        }
        if let Some(v) = self.denies {
            my_size += 1 + 4;
        }
        if let Some(v) = self.item_value {
            my_size += 1 + 4;
        }
        if let Some(v) = self.support_gold_spent {
            my_size += 1 + 4;
        }
        if let Some(v) = self.camps_stacked {
            my_size += 1 + 4;
        }
        if let Some(v) = self.wards_placed {
            my_size += 1 + 4;
        }
        if let Some(v) = self.dewards {
            my_size += 1 + 4;
        }
        if let Some(v) = self.triple_kills {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rampages {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.kills {
            os.write_float(2, v)?;
        }
        if let Some(v) = self.deaths {
            os.write_float(3, v)?;
        }
        if let Some(v) = self.assists {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.net_worth {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.last_hits {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.denies {
            os.write_float(7, v)?;
        }
        if let Some(v) = self.item_value {
            os.write_float(8, v)?;
        }
        if let Some(v) = self.support_gold_spent {
            os.write_float(9, v)?;
        }
        if let Some(v) = self.camps_stacked {
            os.write_float(10, v)?;
        }
        if let Some(v) = self.wards_placed {
            os.write_float(11, v)?;
        }
        if let Some(v) = self.dewards {
            os.write_float(12, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_float(13, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_float(14, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMatchPlayerTimedStatStdDeviations {
        CMatchPlayerTimedStatStdDeviations::new()
    }

    fn clear(&mut self) {
        self.kills = ::std::option::Option::None;
        self.deaths = ::std::option::Option::None;
        self.assists = ::std::option::Option::None;
        self.net_worth = ::std::option::Option::None;
        self.last_hits = ::std::option::Option::None;
        self.denies = ::std::option::Option::None;
        self.item_value = ::std::option::Option::None;
        self.support_gold_spent = ::std::option::Option::None;
        self.camps_stacked = ::std::option::Option::None;
        self.wards_placed = ::std::option::Option::None;
        self.dewards = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMatchPlayerTimedStatStdDeviations {
        static instance: CMatchPlayerTimedStatStdDeviations = CMatchPlayerTimedStatStdDeviations {
            kills: ::std::option::Option::None,
            deaths: ::std::option::Option::None,
            assists: ::std::option::Option::None,
            net_worth: ::std::option::Option::None,
            last_hits: ::std::option::Option::None,
            denies: ::std::option::Option::None,
            item_value: ::std::option::Option::None,
            support_gold_spent: ::std::option::Option::None,
            camps_stacked: ::std::option::Option::None,
            wards_placed: ::std::option::Option::None,
            dewards: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetHeroTimedStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetHeroTimedStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.rank_chunked_stats)
    pub rank_chunked_stats: ::std::vec::Vec<cmsg_gcget_hero_timed_stats_response::RankChunkedStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetHeroTimedStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetHeroTimedStatsResponse {
    fn default() -> &'a CMsgGCGetHeroTimedStatsResponse {
        <CMsgGCGetHeroTimedStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetHeroTimedStatsResponse {
    pub fn new() -> CMsgGCGetHeroTimedStatsResponse {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetHeroTimedStatsResponse {
    const NAME: &'static str = "CMsgGCGetHeroTimedStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.rank_chunked_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.rank_chunked_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        for v in &self.rank_chunked_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetHeroTimedStatsResponse {
        CMsgGCGetHeroTimedStatsResponse::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.rank_chunked_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetHeroTimedStatsResponse {
        static instance: CMsgGCGetHeroTimedStatsResponse = CMsgGCGetHeroTimedStatsResponse {
            hero_id: ::std::option::Option::None,
            rank_chunked_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCGetHeroTimedStatsResponse`
pub mod cmsg_gcget_hero_timed_stats_response {
    // @@protoc_insertion_point(message:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TimedStatsContainer {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.time)
        pub time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.all_stats)
        pub all_stats: ::steam_vent_proto_common::protobuf::MessageField<super::CMatchPlayerTimedStatAverages>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.winning_stats)
        pub winning_stats: ::steam_vent_proto_common::protobuf::MessageField<super::CMatchPlayerTimedStatAverages>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.losing_stats)
        pub losing_stats: ::steam_vent_proto_common::protobuf::MessageField<super::CMatchPlayerTimedStatAverages>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.winning_stddevs)
        pub winning_stddevs: ::steam_vent_proto_common::protobuf::MessageField<super::CMatchPlayerTimedStatStdDeviations>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.losing_stddevs)
        pub losing_stddevs: ::steam_vent_proto_common::protobuf::MessageField<super::CMatchPlayerTimedStatStdDeviations>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCGetHeroTimedStatsResponse.TimedStatsContainer.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TimedStatsContainer {
        fn default() -> &'a TimedStatsContainer {
            <TimedStatsContainer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TimedStatsContainer {
        pub fn new() -> TimedStatsContainer {
            ::std::default::Default::default()
        }

        // optional uint32 time = 1;

        pub fn time(&self) -> u32 {
            self.time.unwrap_or(0)
        }

        pub fn clear_time(&mut self) {
            self.time = ::std::option::Option::None;
        }

        pub fn has_time(&self) -> bool {
            self.time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time(&mut self, v: u32) {
            self.time = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TimedStatsContainer {
        const NAME: &'static str = "TimedStatsContainer";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.all_stats)?;
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.winning_stats)?;
                    },
                    34 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.losing_stats)?;
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.winning_stddevs)?;
                    },
                    50 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.losing_stddevs)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.all_stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.winning_stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.losing_stats.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.winning_stddevs.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.losing_stddevs.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.time {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.all_stats.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            }
            if let Some(v) = self.winning_stats.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            if let Some(v) = self.losing_stats.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            }
            if let Some(v) = self.winning_stddevs.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            if let Some(v) = self.losing_stddevs.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TimedStatsContainer {
            TimedStatsContainer::new()
        }

        fn clear(&mut self) {
            self.time = ::std::option::Option::None;
            self.all_stats.clear();
            self.winning_stats.clear();
            self.losing_stats.clear();
            self.winning_stddevs.clear();
            self.losing_stddevs.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TimedStatsContainer {
            static instance: TimedStatsContainer = TimedStatsContainer {
                time: ::std::option::Option::None,
                all_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
                winning_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
                losing_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
                winning_stddevs: ::steam_vent_proto_common::protobuf::MessageField::none(),
                losing_stddevs: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCGetHeroTimedStatsResponse.RankChunkedStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankChunkedStats {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.RankChunkedStats.rank_chunk)
        pub rank_chunk: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCGetHeroTimedStatsResponse.RankChunkedStats.timed_stats)
        pub timed_stats: ::std::vec::Vec<TimedStatsContainer>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCGetHeroTimedStatsResponse.RankChunkedStats.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankChunkedStats {
        fn default() -> &'a RankChunkedStats {
            <RankChunkedStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RankChunkedStats {
        pub fn new() -> RankChunkedStats {
            ::std::default::Default::default()
        }

        // optional uint32 rank_chunk = 1;

        pub fn rank_chunk(&self) -> u32 {
            self.rank_chunk.unwrap_or(0)
        }

        pub fn clear_rank_chunk(&mut self) {
            self.rank_chunk = ::std::option::Option::None;
        }

        pub fn has_rank_chunk(&self) -> bool {
            self.rank_chunk.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_chunk(&mut self, v: u32) {
            self.rank_chunk = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RankChunkedStats {
        const NAME: &'static str = "RankChunkedStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank_chunk = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.timed_stats.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank_chunk {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.timed_stats {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.rank_chunk {
                os.write_uint32(1, v)?;
            }
            for v in &self.timed_stats {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankChunkedStats {
            RankChunkedStats::new()
        }

        fn clear(&mut self) {
            self.rank_chunk = ::std::option::Option::None;
            self.timed_stats.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankChunkedStats {
            static instance: RankChunkedStats = RankChunkedStats {
                rank_chunk: ::std::option::Option::None,
                timed_stats: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReservationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReservationsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReservationsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReservationsRequest {
    fn default() -> &'a CMsgGCItemEditorReservationsRequest {
        <CMsgGCItemEditorReservationsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReservationsRequest {
    pub fn new() -> CMsgGCItemEditorReservationsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReservationsRequest {
    const NAME: &'static str = "CMsgGCItemEditorReservationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReservationsRequest {
        CMsgGCItemEditorReservationsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReservationsRequest {
        static instance: CMsgGCItemEditorReservationsRequest = CMsgGCItemEditorReservationsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReservation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReservation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReservation.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReservation.name)
    pub name: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReservation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReservation {
    fn default() -> &'a CMsgGCItemEditorReservation {
        <CMsgGCItemEditorReservation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReservation {
    pub fn new() -> CMsgGCItemEditorReservation {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReservation {
    const NAME: &'static str = "CMsgGCItemEditorReservation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReservation {
        CMsgGCItemEditorReservation::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReservation {
        static instance: CMsgGCItemEditorReservation = CMsgGCItemEditorReservation {
            def_index: ::std::option::Option::None,
            name: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReservationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReservationsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReservationsResponse.reservations)
    pub reservations: ::std::vec::Vec<CMsgGCItemEditorReservation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReservationsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReservationsResponse {
    fn default() -> &'a CMsgGCItemEditorReservationsResponse {
        <CMsgGCItemEditorReservationsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReservationsResponse {
    pub fn new() -> CMsgGCItemEditorReservationsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReservationsResponse {
    const NAME: &'static str = "CMsgGCItemEditorReservationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.reservations.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.reservations {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.reservations {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReservationsResponse {
        CMsgGCItemEditorReservationsResponse::new()
    }

    fn clear(&mut self) {
        self.reservations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReservationsResponse {
        static instance: CMsgGCItemEditorReservationsResponse = CMsgGCItemEditorReservationsResponse {
            reservations: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReserveItemDef)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReserveItemDef {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReserveItemDef.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReserveItemDef.username)
    pub username: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReserveItemDef.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReserveItemDef {
    fn default() -> &'a CMsgGCItemEditorReserveItemDef {
        <CMsgGCItemEditorReserveItemDef as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReserveItemDef {
    pub fn new() -> CMsgGCItemEditorReserveItemDef {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string username = 2;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReserveItemDef {
    const NAME: &'static str = "CMsgGCItemEditorReserveItemDef";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReserveItemDef {
        CMsgGCItemEditorReserveItemDef::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.username = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReserveItemDef {
        static instance: CMsgGCItemEditorReserveItemDef = CMsgGCItemEditorReserveItemDef {
            def_index: ::std::option::Option::None,
            username: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReserveItemDefResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReserveItemDefResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReserveItemDefResponse.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReserveItemDefResponse.username)
    pub username: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReserveItemDefResponse.result)
    pub result: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReserveItemDefResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReserveItemDefResponse {
    fn default() -> &'a CMsgGCItemEditorReserveItemDefResponse {
        <CMsgGCItemEditorReserveItemDefResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReserveItemDefResponse {
    pub fn new() -> CMsgGCItemEditorReserveItemDefResponse {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string username = 2;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 result = 3;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(0)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReserveItemDefResponse {
    const NAME: &'static str = "CMsgGCItemEditorReserveItemDefResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReserveItemDefResponse {
        CMsgGCItemEditorReserveItemDefResponse::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.username = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReserveItemDefResponse {
        static instance: CMsgGCItemEditorReserveItemDefResponse = CMsgGCItemEditorReserveItemDefResponse {
            def_index: ::std::option::Option::None,
            username: ::std::option::Option::None,
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReleaseReservation)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReleaseReservation {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReleaseReservation.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReleaseReservation.username)
    pub username: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReleaseReservation.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReleaseReservation {
    fn default() -> &'a CMsgGCItemEditorReleaseReservation {
        <CMsgGCItemEditorReleaseReservation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReleaseReservation {
    pub fn new() -> CMsgGCItemEditorReleaseReservation {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional string username = 2;

    pub fn username(&self) -> &str {
        match self.username.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_username(&mut self) {
        self.username = ::std::option::Option::None;
    }

    pub fn has_username(&self) -> bool {
        self.username.is_some()
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        if self.username.is_none() {
            self.username = ::std::option::Option::Some(::std::string::String::new());
        }
        self.username.as_mut().unwrap()
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        self.username.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReleaseReservation {
    const NAME: &'static str = "CMsgGCItemEditorReleaseReservation";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.username = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.username.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.username.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReleaseReservation {
        CMsgGCItemEditorReleaseReservation::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.username = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReleaseReservation {
        static instance: CMsgGCItemEditorReleaseReservation = CMsgGCItemEditorReleaseReservation {
            def_index: ::std::option::Option::None,
            username: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCItemEditorReleaseReservationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCItemEditorReleaseReservationResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCItemEditorReleaseReservationResponse.def_index)
    pub def_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCItemEditorReleaseReservationResponse.released)
    pub released: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCItemEditorReleaseReservationResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCItemEditorReleaseReservationResponse {
    fn default() -> &'a CMsgGCItemEditorReleaseReservationResponse {
        <CMsgGCItemEditorReleaseReservationResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCItemEditorReleaseReservationResponse {
    pub fn new() -> CMsgGCItemEditorReleaseReservationResponse {
        ::std::default::Default::default()
    }

    // optional uint32 def_index = 1;

    pub fn def_index(&self) -> u32 {
        self.def_index.unwrap_or(0)
    }

    pub fn clear_def_index(&mut self) {
        self.def_index = ::std::option::Option::None;
    }

    pub fn has_def_index(&self) -> bool {
        self.def_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_def_index(&mut self, v: u32) {
        self.def_index = ::std::option::Option::Some(v);
    }

    // optional bool released = 2;

    pub fn released(&self) -> bool {
        self.released.unwrap_or(false)
    }

    pub fn clear_released(&mut self) {
        self.released = ::std::option::Option::None;
    }

    pub fn has_released(&self) -> bool {
        self.released.is_some()
    }

    // Param is passed by value, moved
    pub fn set_released(&mut self, v: bool) {
        self.released = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCItemEditorReleaseReservationResponse {
    const NAME: &'static str = "CMsgGCItemEditorReleaseReservationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.def_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.released = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.released {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.def_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.released {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCItemEditorReleaseReservationResponse {
        CMsgGCItemEditorReleaseReservationResponse::new()
    }

    fn clear(&mut self) {
        self.def_index = ::std::option::Option::None;
        self.released = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCItemEditorReleaseReservationResponse {
        static instance: CMsgGCItemEditorReleaseReservationResponse = CMsgGCItemEditorReleaseReservationResponse {
            def_index: ::std::option::Option::None,
            released: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgFlipLobbyTeams)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgFlipLobbyTeams {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgFlipLobbyTeams.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgFlipLobbyTeams {
    fn default() -> &'a CMsgFlipLobbyTeams {
        <CMsgFlipLobbyTeams as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgFlipLobbyTeams {
    pub fn new() -> CMsgFlipLobbyTeams {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgFlipLobbyTeams {
    const NAME: &'static str = "CMsgFlipLobbyTeams";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgFlipLobbyTeams {
        CMsgFlipLobbyTeams::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgFlipLobbyTeams {
        static instance: CMsgFlipLobbyTeams = CMsgFlipLobbyTeams {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCLobbyUpdateBroadcastChannelInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCLobbyUpdateBroadcastChannelInfo {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCLobbyUpdateBroadcastChannelInfo.channel_id)
    pub channel_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCLobbyUpdateBroadcastChannelInfo.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCLobbyUpdateBroadcastChannelInfo.description)
    pub description: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCLobbyUpdateBroadcastChannelInfo.language_code)
    pub language_code: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCLobbyUpdateBroadcastChannelInfo.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn default() -> &'a CMsgGCLobbyUpdateBroadcastChannelInfo {
        <CMsgGCLobbyUpdateBroadcastChannelInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCLobbyUpdateBroadcastChannelInfo {
    pub fn new() -> CMsgGCLobbyUpdateBroadcastChannelInfo {
        ::std::default::Default::default()
    }

    // optional uint32 channel_id = 1;

    pub fn channel_id(&self) -> u32 {
        self.channel_id.unwrap_or(0)
    }

    pub fn clear_channel_id(&mut self) {
        self.channel_id = ::std::option::Option::None;
    }

    pub fn has_channel_id(&self) -> bool {
        self.channel_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: u32) {
        self.channel_id = ::std::option::Option::Some(v);
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string description = 3;

    pub fn description(&self) -> &str {
        match self.description.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_description(&mut self) {
        self.description = ::std::option::Option::None;
    }

    pub fn has_description(&self) -> bool {
        self.description.is_some()
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        if self.description.is_none() {
            self.description = ::std::option::Option::Some(::std::string::String::new());
        }
        self.description.as_mut().unwrap()
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        self.description.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string language_code = 4;

    pub fn language_code(&self) -> &str {
        match self.language_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_language_code(&mut self) {
        self.language_code = ::std::option::Option::None;
    }

    pub fn has_language_code(&self) -> bool {
        self.language_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language_code(&mut self, v: ::std::string::String) {
        self.language_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_language_code(&mut self) -> &mut ::std::string::String {
        if self.language_code.is_none() {
            self.language_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.language_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_language_code(&mut self) -> ::std::string::String {
        self.language_code.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCLobbyUpdateBroadcastChannelInfo {
    const NAME: &'static str = "CMsgGCLobbyUpdateBroadcastChannelInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.channel_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.description = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    self.language_code = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.channel_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.description.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.language_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.channel_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.description.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.language_code.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCLobbyUpdateBroadcastChannelInfo {
        CMsgGCLobbyUpdateBroadcastChannelInfo::new()
    }

    fn clear(&mut self) {
        self.channel_id = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.description = ::std::option::Option::None;
        self.language_code = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCLobbyUpdateBroadcastChannelInfo {
        static instance: CMsgGCLobbyUpdateBroadcastChannelInfo = CMsgGCLobbyUpdateBroadcastChannelInfo {
            channel_id: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            description: ::std::option::Option::None,
            language_code: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAClaimEventActionData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAClaimEventActionData {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionData.grant_item_gift_data)
    pub grant_item_gift_data: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclaim_event_action_data::GrantItemGiftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAClaimEventActionData {
    fn default() -> &'a CMsgDOTAClaimEventActionData {
        <CMsgDOTAClaimEventActionData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAClaimEventActionData {
    pub fn new() -> CMsgDOTAClaimEventActionData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAClaimEventActionData {
    const NAME: &'static str = "CMsgDOTAClaimEventActionData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.grant_item_gift_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.grant_item_gift_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.grant_item_gift_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAClaimEventActionData {
        CMsgDOTAClaimEventActionData::new()
    }

    fn clear(&mut self) {
        self.grant_item_gift_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAClaimEventActionData {
        static instance: CMsgDOTAClaimEventActionData = CMsgDOTAClaimEventActionData {
            grant_item_gift_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAClaimEventActionData`
pub mod cmsg_dotaclaim_event_action_data {
    // @@protoc_insertion_point(message:CMsgDOTAClaimEventActionData.GrantItemGiftData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GrantItemGiftData {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionData.GrantItemGiftData.give_to_account_id)
        pub give_to_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClaimEventActionData.GrantItemGiftData.gift_message)
        pub gift_message: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventActionData.GrantItemGiftData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GrantItemGiftData {
        fn default() -> &'a GrantItemGiftData {
            <GrantItemGiftData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GrantItemGiftData {
        pub fn new() -> GrantItemGiftData {
            ::std::default::Default::default()
        }

        // optional uint32 give_to_account_id = 1;

        pub fn give_to_account_id(&self) -> u32 {
            self.give_to_account_id.unwrap_or(0)
        }

        pub fn clear_give_to_account_id(&mut self) {
            self.give_to_account_id = ::std::option::Option::None;
        }

        pub fn has_give_to_account_id(&self) -> bool {
            self.give_to_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_give_to_account_id(&mut self, v: u32) {
            self.give_to_account_id = ::std::option::Option::Some(v);
        }

        // optional string gift_message = 2;

        pub fn gift_message(&self) -> &str {
            match self.gift_message.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_gift_message(&mut self) {
            self.gift_message = ::std::option::Option::None;
        }

        pub fn has_gift_message(&self) -> bool {
            self.gift_message.is_some()
        }

        // Param is passed by value, moved
        pub fn set_gift_message(&mut self, v: ::std::string::String) {
            self.gift_message = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_gift_message(&mut self) -> &mut ::std::string::String {
            if self.gift_message.is_none() {
                self.gift_message = ::std::option::Option::Some(::std::string::String::new());
            }
            self.gift_message.as_mut().unwrap()
        }

        // Take field
        pub fn take_gift_message(&mut self) -> ::std::string::String {
            self.gift_message.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GrantItemGiftData {
        const NAME: &'static str = "GrantItemGiftData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.give_to_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.gift_message = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.give_to_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.gift_message.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.give_to_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.gift_message.as_ref() {
                os.write_string(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GrantItemGiftData {
            GrantItemGiftData::new()
        }

        fn clear(&mut self) {
            self.give_to_account_id = ::std::option::Option::None;
            self.gift_message = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GrantItemGiftData {
            static instance: GrantItemGiftData = GrantItemGiftData {
                give_to_account_id: ::std::option::Option::None,
                gift_message: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAClaimEventAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAClaimEventAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventAction.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventAction.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventAction.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAClaimEventAction.data)
    pub data: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAClaimEventActionData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAClaimEventAction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAClaimEventAction {
    fn default() -> &'a CMsgDOTAClaimEventAction {
        <CMsgDOTAClaimEventAction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAClaimEventAction {
    pub fn new() -> CMsgDOTAClaimEventAction {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 3;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAClaimEventAction {
    const NAME: &'static str = "CMsgDOTAClaimEventAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAClaimEventAction {
        CMsgDOTAClaimEventAction::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAClaimEventAction {
        static instance: CMsgDOTAClaimEventAction = CMsgDOTAClaimEventAction {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCClaimEventActionUsingItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimEventActionUsingItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimEventActionUsingItem.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimEventActionUsingItem.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimEventActionUsingItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimEventActionUsingItem.quantity)
    pub quantity: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimEventActionUsingItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimEventActionUsingItem {
    fn default() -> &'a CMsgClientToGCClaimEventActionUsingItem {
        <CMsgClientToGCClaimEventActionUsingItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimEventActionUsingItem {
    pub fn new() -> CMsgClientToGCClaimEventActionUsingItem {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id = 3;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 4;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimEventActionUsingItem {
    const NAME: &'static str = "CMsgClientToGCClaimEventActionUsingItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimEventActionUsingItem {
        CMsgClientToGCClaimEventActionUsingItem::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimEventActionUsingItem {
        static instance: CMsgClientToGCClaimEventActionUsingItem = CMsgClientToGCClaimEventActionUsingItem {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCClaimEventActionUsingItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimEventActionUsingItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimEventActionUsingItemResponse.action_results)
    pub action_results: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAClaimEventActionResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimEventActionUsingItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimEventActionUsingItemResponse {
    fn default() -> &'a CMsgClientToGCClaimEventActionUsingItemResponse {
        <CMsgClientToGCClaimEventActionUsingItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimEventActionUsingItemResponse {
    pub fn new() -> CMsgClientToGCClaimEventActionUsingItemResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimEventActionUsingItemResponse {
    const NAME: &'static str = "CMsgClientToGCClaimEventActionUsingItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.action_results)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action_results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.action_results.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimEventActionUsingItemResponse {
        CMsgClientToGCClaimEventActionUsingItemResponse::new()
    }

    fn clear(&mut self) {
        self.action_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimEventActionUsingItemResponse {
        static instance: CMsgClientToGCClaimEventActionUsingItemResponse = CMsgClientToGCClaimEventActionUsingItemResponse {
            action_results: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientClaimEventActionUsingItemCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientClaimEventActionUsingItemCompleted {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientClaimEventActionUsingItemCompleted.item_id)
    pub item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientClaimEventActionUsingItemCompleted.action_results)
    pub action_results: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgDOTAClaimEventActionResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientClaimEventActionUsingItemCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientClaimEventActionUsingItemCompleted {
    fn default() -> &'a CMsgGCToClientClaimEventActionUsingItemCompleted {
        <CMsgGCToClientClaimEventActionUsingItemCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientClaimEventActionUsingItemCompleted {
    pub fn new() -> CMsgGCToClientClaimEventActionUsingItemCompleted {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientClaimEventActionUsingItemCompleted {
    const NAME: &'static str = "CMsgGCToClientClaimEventActionUsingItemCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.action_results)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.action_results.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.action_results.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientClaimEventActionUsingItemCompleted {
        CMsgGCToClientClaimEventActionUsingItemCompleted::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.action_results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientClaimEventActionUsingItemCompleted {
        static instance: CMsgGCToClientClaimEventActionUsingItemCompleted = CMsgGCToClientClaimEventActionUsingItemCompleted {
            item_id: ::std::option::Option::None,
            action_results: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetEventPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPoints.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPoints.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetEventPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetEventPoints {
    fn default() -> &'a CMsgDOTAGetEventPoints {
        <CMsgDOTAGetEventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetEventPoints {
    pub fn new() -> CMsgDOTAGetEventPoints {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetEventPoints {
    const NAME: &'static str = "CMsgDOTAGetEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetEventPoints {
        CMsgDOTAGetEventPoints::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetEventPoints {
        static instance: CMsgDOTAGetEventPoints = CMsgDOTAGetEventPoints {
            event_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetEventPointsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetEventPointsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.total_points)
    pub total_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.total_premium_points)
    pub total_premium_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.points)
    pub points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.premium_points)
    pub premium_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.completed_actions)
    pub completed_actions: ::std::vec::Vec<cmsg_dotaget_event_points_response::Action>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.owned)
    pub owned: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.audit_action)
    pub audit_action: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.active_season_id)
    pub active_season_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetEventPointsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetEventPointsResponse {
    fn default() -> &'a CMsgDOTAGetEventPointsResponse {
        <CMsgDOTAGetEventPointsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetEventPointsResponse {
    pub fn new() -> CMsgDOTAGetEventPointsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 total_points = 1;

    pub fn total_points(&self) -> u32 {
        self.total_points.unwrap_or(0)
    }

    pub fn clear_total_points(&mut self) {
        self.total_points = ::std::option::Option::None;
    }

    pub fn has_total_points(&self) -> bool {
        self.total_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points(&mut self, v: u32) {
        self.total_points = ::std::option::Option::Some(v);
    }

    // optional uint32 total_premium_points = 2;

    pub fn total_premium_points(&self) -> u32 {
        self.total_premium_points.unwrap_or(0)
    }

    pub fn clear_total_premium_points(&mut self) {
        self.total_premium_points = ::std::option::Option::None;
    }

    pub fn has_total_premium_points(&self) -> bool {
        self.total_premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_premium_points(&mut self, v: u32) {
        self.total_premium_points = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 3;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 points = 4;

    pub fn points(&self) -> u32 {
        self.points.unwrap_or(0)
    }

    pub fn clear_points(&mut self) {
        self.points = ::std::option::Option::None;
    }

    pub fn has_points(&self) -> bool {
        self.points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points(&mut self, v: u32) {
        self.points = ::std::option::Option::Some(v);
    }

    // optional uint32 premium_points = 5;

    pub fn premium_points(&self) -> u32 {
        self.premium_points.unwrap_or(0)
    }

    pub fn clear_premium_points(&mut self) {
        self.premium_points = ::std::option::Option::None;
    }

    pub fn has_premium_points(&self) -> bool {
        self.premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points(&mut self, v: u32) {
        self.premium_points = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 7;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool owned = 8;

    pub fn owned(&self) -> bool {
        self.owned.unwrap_or(false)
    }

    pub fn clear_owned(&mut self) {
        self.owned = ::std::option::Option::None;
    }

    pub fn has_owned(&self) -> bool {
        self.owned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_owned(&mut self, v: bool) {
        self.owned = ::std::option::Option::Some(v);
    }

    // optional uint32 audit_action = 9;

    pub fn audit_action(&self) -> u32 {
        self.audit_action.unwrap_or(0)
    }

    pub fn clear_audit_action(&mut self) {
        self.audit_action = ::std::option::Option::None;
    }

    pub fn has_audit_action(&self) -> bool {
        self.audit_action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audit_action(&mut self, v: u32) {
        self.audit_action = ::std::option::Option::Some(v);
    }

    // optional uint32 active_season_id = 10;

    pub fn active_season_id(&self) -> u32 {
        self.active_season_id.unwrap_or(0)
    }

    pub fn clear_active_season_id(&mut self) {
        self.active_season_id = ::std::option::Option::None;
    }

    pub fn has_active_season_id(&self) -> bool {
        self.active_season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_season_id(&mut self, v: u32) {
        self.active_season_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetEventPointsResponse {
    const NAME: &'static str = "CMsgDOTAGetEventPointsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.total_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.total_premium_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.points = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.premium_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.completed_actions.push(is.read_message()?);
                },
                56 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.owned = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.active_season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.total_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.total_premium_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.premium_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        for value in &self.completed_actions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.owned {
            my_size += 1 + 1;
        }
        if let Some(v) = self.audit_action {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.active_season_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.total_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_premium_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.points {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.premium_points {
            os.write_uint32(5, v)?;
        }
        for v in &self.completed_actions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if let Some(v) = self.account_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.owned {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.audit_action {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.active_season_id {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetEventPointsResponse {
        CMsgDOTAGetEventPointsResponse::new()
    }

    fn clear(&mut self) {
        self.total_points = ::std::option::Option::None;
        self.total_premium_points = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.points = ::std::option::Option::None;
        self.premium_points = ::std::option::Option::None;
        self.completed_actions.clear();
        self.account_id = ::std::option::Option::None;
        self.owned = ::std::option::Option::None;
        self.audit_action = ::std::option::Option::None;
        self.active_season_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetEventPointsResponse {
        static instance: CMsgDOTAGetEventPointsResponse = CMsgDOTAGetEventPointsResponse {
            total_points: ::std::option::Option::None,
            total_premium_points: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            points: ::std::option::Option::None,
            premium_points: ::std::option::Option::None,
            completed_actions: ::std::vec::Vec::new(),
            account_id: ::std::option::Option::None,
            owned: ::std::option::Option::None,
            audit_action: ::std::option::Option::None,
            active_season_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAGetEventPointsResponse`
pub mod cmsg_dotaget_event_points_response {
    // @@protoc_insertion_point(message:CMsgDOTAGetEventPointsResponse.Action)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Action {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.Action.action_id)
        pub action_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetEventPointsResponse.Action.times_completed)
        pub times_completed: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAGetEventPointsResponse.Action.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Action {
        fn default() -> &'a Action {
            <Action as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Action {
        pub fn new() -> Action {
            ::std::default::Default::default()
        }

        // optional uint32 action_id = 1;

        pub fn action_id(&self) -> u32 {
            self.action_id.unwrap_or(0)
        }

        pub fn clear_action_id(&mut self) {
            self.action_id = ::std::option::Option::None;
        }

        pub fn has_action_id(&self) -> bool {
            self.action_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_action_id(&mut self, v: u32) {
            self.action_id = ::std::option::Option::Some(v);
        }

        // optional uint32 times_completed = 2;

        pub fn times_completed(&self) -> u32 {
            self.times_completed.unwrap_or(1u32)
        }

        pub fn clear_times_completed(&mut self) {
            self.times_completed = ::std::option::Option::None;
        }

        pub fn has_times_completed(&self) -> bool {
            self.times_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_times_completed(&mut self, v: u32) {
            self.times_completed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Action {
        const NAME: &'static str = "Action";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.times_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.action_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.times_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.action_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.times_completed {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Action {
            Action::new()
        }

        fn clear(&mut self) {
            self.action_id = ::std::option::Option::None;
            self.times_completed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Action {
            static instance: Action = Action {
                action_id: ::std::option::Option::None,
                times_completed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetPeriodicResource)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetPeriodicResource {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetPeriodicResource.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPeriodicResource.periodic_resource_id)
    pub periodic_resource_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPeriodicResource.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetPeriodicResource.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetPeriodicResource {
    fn default() -> &'a CMsgDOTAGetPeriodicResource {
        <CMsgDOTAGetPeriodicResource as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetPeriodicResource {
    pub fn new() -> CMsgDOTAGetPeriodicResource {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 periodic_resource_id = 2;

    pub fn periodic_resource_id(&self) -> u32 {
        self.periodic_resource_id.unwrap_or(0)
    }

    pub fn clear_periodic_resource_id(&mut self) {
        self.periodic_resource_id = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_id(&self) -> bool {
        self.periodic_resource_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_id(&mut self, v: u32) {
        self.periodic_resource_id = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetPeriodicResource {
    const NAME: &'static str = "CMsgDOTAGetPeriodicResource";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.periodic_resource_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.periodic_resource_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.periodic_resource_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetPeriodicResource {
        CMsgDOTAGetPeriodicResource::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.periodic_resource_id = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetPeriodicResource {
        static instance: CMsgDOTAGetPeriodicResource = CMsgDOTAGetPeriodicResource {
            account_id: ::std::option::Option::None,
            periodic_resource_id: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetPeriodicResourceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetPeriodicResourceResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetPeriodicResourceResponse.periodic_resource_max)
    pub periodic_resource_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPeriodicResourceResponse.periodic_resource_used)
    pub periodic_resource_used: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetPeriodicResourceResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetPeriodicResourceResponse {
    fn default() -> &'a CMsgDOTAGetPeriodicResourceResponse {
        <CMsgDOTAGetPeriodicResourceResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetPeriodicResourceResponse {
    pub fn new() -> CMsgDOTAGetPeriodicResourceResponse {
        ::std::default::Default::default()
    }

    // optional uint32 periodic_resource_max = 1;

    pub fn periodic_resource_max(&self) -> u32 {
        self.periodic_resource_max.unwrap_or(0)
    }

    pub fn clear_periodic_resource_max(&mut self) {
        self.periodic_resource_max = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_max(&self) -> bool {
        self.periodic_resource_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_max(&mut self, v: u32) {
        self.periodic_resource_max = ::std::option::Option::Some(v);
    }

    // optional uint32 periodic_resource_used = 2;

    pub fn periodic_resource_used(&self) -> u32 {
        self.periodic_resource_used.unwrap_or(0)
    }

    pub fn clear_periodic_resource_used(&mut self) {
        self.periodic_resource_used = ::std::option::Option::None;
    }

    pub fn has_periodic_resource_used(&self) -> bool {
        self.periodic_resource_used.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodic_resource_used(&mut self, v: u32) {
        self.periodic_resource_used = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetPeriodicResourceResponse {
    const NAME: &'static str = "CMsgDOTAGetPeriodicResourceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.periodic_resource_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.periodic_resource_used = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.periodic_resource_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.periodic_resource_used {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.periodic_resource_max {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.periodic_resource_used {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetPeriodicResourceResponse {
        CMsgDOTAGetPeriodicResourceResponse::new()
    }

    fn clear(&mut self) {
        self.periodic_resource_max = ::std::option::Option::None;
        self.periodic_resource_used = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetPeriodicResourceResponse {
        static instance: CMsgDOTAGetPeriodicResourceResponse = CMsgDOTAGetPeriodicResourceResponse {
            periodic_resource_max: ::std::option::Option::None,
            periodic_resource_used: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAPeriodicResourceUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPeriodicResourceUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPeriodicResourceUpdated.periodic_resource_key)
    pub periodic_resource_key: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAGetPeriodicResource>,
    // @@protoc_insertion_point(field:CMsgDOTAPeriodicResourceUpdated.periodic_resource_value)
    pub periodic_resource_value: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAGetPeriodicResourceResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPeriodicResourceUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPeriodicResourceUpdated {
    fn default() -> &'a CMsgDOTAPeriodicResourceUpdated {
        <CMsgDOTAPeriodicResourceUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPeriodicResourceUpdated {
    pub fn new() -> CMsgDOTAPeriodicResourceUpdated {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPeriodicResourceUpdated {
    const NAME: &'static str = "CMsgDOTAPeriodicResourceUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.periodic_resource_key)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.periodic_resource_value)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.periodic_resource_key.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.periodic_resource_value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.periodic_resource_key.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.periodic_resource_value.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPeriodicResourceUpdated {
        CMsgDOTAPeriodicResourceUpdated::new()
    }

    fn clear(&mut self) {
        self.periodic_resource_key.clear();
        self.periodic_resource_value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPeriodicResourceUpdated {
        static instance: CMsgDOTAPeriodicResourceUpdated = CMsgDOTAPeriodicResourceUpdated {
            periodic_resource_key: ::steam_vent_proto_common::protobuf::MessageField::none(),
            periodic_resource_value: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACompendiumSelection)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACompendiumSelection {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACompendiumSelection.selection_index)
    pub selection_index: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumSelection.selection)
    pub selection: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumSelection.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACompendiumSelection.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACompendiumSelection {
    fn default() -> &'a CMsgDOTACompendiumSelection {
        <CMsgDOTACompendiumSelection as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACompendiumSelection {
    pub fn new() -> CMsgDOTACompendiumSelection {
        ::std::default::Default::default()
    }

    // optional uint32 selection_index = 1;

    pub fn selection_index(&self) -> u32 {
        self.selection_index.unwrap_or(0)
    }

    pub fn clear_selection_index(&mut self) {
        self.selection_index = ::std::option::Option::None;
    }

    pub fn has_selection_index(&self) -> bool {
        self.selection_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection_index(&mut self, v: u32) {
        self.selection_index = ::std::option::Option::Some(v);
    }

    // optional uint32 selection = 2;

    pub fn selection(&self) -> u32 {
        self.selection.unwrap_or(0)
    }

    pub fn clear_selection(&mut self) {
        self.selection = ::std::option::Option::None;
    }

    pub fn has_selection(&self) -> bool {
        self.selection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selection(&mut self, v: u32) {
        self.selection = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 3;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACompendiumSelection {
    const NAME: &'static str = "CMsgDOTACompendiumSelection";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.selection_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.selection = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.selection_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.selection {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.selection_index {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.selection {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACompendiumSelection {
        CMsgDOTACompendiumSelection::new()
    }

    fn clear(&mut self) {
        self.selection_index = ::std::option::Option::None;
        self.selection = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACompendiumSelection {
        static instance: CMsgDOTACompendiumSelection = CMsgDOTACompendiumSelection {
            selection_index: ::std::option::Option::None,
            selection: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACompendiumSelectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACompendiumSelectionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACompendiumSelectionResponse.eresult)
    pub eresult: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACompendiumSelectionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACompendiumSelectionResponse {
    fn default() -> &'a CMsgDOTACompendiumSelectionResponse {
        <CMsgDOTACompendiumSelectionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACompendiumSelectionResponse {
    pub fn new() -> CMsgDOTACompendiumSelectionResponse {
        ::std::default::Default::default()
    }

    // optional uint32 eresult = 1;

    pub fn eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACompendiumSelectionResponse {
    const NAME: &'static str = "CMsgDOTACompendiumSelectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACompendiumSelectionResponse {
        CMsgDOTACompendiumSelectionResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACompendiumSelectionResponse {
        static instance: CMsgDOTACompendiumSelectionResponse = CMsgDOTACompendiumSelectionResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACompendiumData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACompendiumData {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACompendiumData.selections)
    pub selections: ::std::vec::Vec<CMsgDOTACompendiumSelection>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACompendiumData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACompendiumData {
    fn default() -> &'a CMsgDOTACompendiumData {
        <CMsgDOTACompendiumData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACompendiumData {
    pub fn new() -> CMsgDOTACompendiumData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACompendiumData {
    const NAME: &'static str = "CMsgDOTACompendiumData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.selections.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.selections {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.selections {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACompendiumData {
        CMsgDOTACompendiumData::new()
    }

    fn clear(&mut self) {
        self.selections.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACompendiumData {
        static instance: CMsgDOTACompendiumData = CMsgDOTACompendiumData {
            selections: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACompendiumDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACompendiumDataRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataRequest.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACompendiumDataRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACompendiumDataRequest {
    fn default() -> &'a CMsgDOTACompendiumDataRequest {
        <CMsgDOTACompendiumDataRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACompendiumDataRequest {
    pub fn new() -> CMsgDOTACompendiumDataRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 2;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACompendiumDataRequest {
    const NAME: &'static str = "CMsgDOTACompendiumDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACompendiumDataRequest {
        CMsgDOTACompendiumDataRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACompendiumDataRequest {
        static instance: CMsgDOTACompendiumDataRequest = CMsgDOTACompendiumDataRequest {
            account_id: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACompendiumDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACompendiumDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataResponse.leagueid)
    pub leagueid: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataResponse.result)
    pub result: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACompendiumDataResponse.compendium_data)
    pub compendium_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTACompendiumData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACompendiumDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACompendiumDataResponse {
    fn default() -> &'a CMsgDOTACompendiumDataResponse {
        <CMsgDOTACompendiumDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACompendiumDataResponse {
    pub fn new() -> CMsgDOTACompendiumDataResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 leagueid = 2;

    pub fn leagueid(&self) -> u32 {
        self.leagueid.unwrap_or(0)
    }

    pub fn clear_leagueid(&mut self) {
        self.leagueid = ::std::option::Option::None;
    }

    pub fn has_leagueid(&self) -> bool {
        self.leagueid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_leagueid(&mut self, v: u32) {
        self.leagueid = ::std::option::Option::Some(v);
    }

    // optional uint32 result = 3;

    pub fn result(&self) -> u32 {
        self.result.unwrap_or(2u32)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: u32) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACompendiumDataResponse {
    const NAME: &'static str = "CMsgDOTACompendiumDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.leagueid = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.result = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.compendium_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.leagueid {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.compendium_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.leagueid {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.compendium_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACompendiumDataResponse {
        CMsgDOTACompendiumDataResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.leagueid = ::std::option::Option::None;
        self.result = ::std::option::Option::None;
        self.compendium_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACompendiumDataResponse {
        static instance: CMsgDOTACompendiumDataResponse = CMsgDOTACompendiumDataResponse {
            account_id: ::std::option::Option::None,
            leagueid: ::std::option::Option::None,
            result: ::std::option::Option::None,
            compendium_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetPlayerMatchHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetPlayerMatchHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.start_at_match_id)
    pub start_at_match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.matches_requested)
    pub matches_requested: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.request_id)
    pub request_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.include_practice_matches)
    pub include_practice_matches: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.include_custom_games)
    pub include_custom_games: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistory.include_event_games)
    pub include_event_games: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetPlayerMatchHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetPlayerMatchHistory {
    fn default() -> &'a CMsgDOTAGetPlayerMatchHistory {
        <CMsgDOTAGetPlayerMatchHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetPlayerMatchHistory {
    pub fn new() -> CMsgDOTAGetPlayerMatchHistory {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 start_at_match_id = 2;

    pub fn start_at_match_id(&self) -> u64 {
        self.start_at_match_id.unwrap_or(0)
    }

    pub fn clear_start_at_match_id(&mut self) {
        self.start_at_match_id = ::std::option::Option::None;
    }

    pub fn has_start_at_match_id(&self) -> bool {
        self.start_at_match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_at_match_id(&mut self, v: u64) {
        self.start_at_match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 matches_requested = 3;

    pub fn matches_requested(&self) -> u32 {
        self.matches_requested.unwrap_or(0)
    }

    pub fn clear_matches_requested(&mut self) {
        self.matches_requested = ::std::option::Option::None;
    }

    pub fn has_matches_requested(&self) -> bool {
        self.matches_requested.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_requested(&mut self, v: u32) {
        self.matches_requested = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 4;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 request_id = 5;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }

    // optional bool include_practice_matches = 7;

    pub fn include_practice_matches(&self) -> bool {
        self.include_practice_matches.unwrap_or(false)
    }

    pub fn clear_include_practice_matches(&mut self) {
        self.include_practice_matches = ::std::option::Option::None;
    }

    pub fn has_include_practice_matches(&self) -> bool {
        self.include_practice_matches.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_practice_matches(&mut self, v: bool) {
        self.include_practice_matches = ::std::option::Option::Some(v);
    }

    // optional bool include_custom_games = 8;

    pub fn include_custom_games(&self) -> bool {
        self.include_custom_games.unwrap_or(false)
    }

    pub fn clear_include_custom_games(&mut self) {
        self.include_custom_games = ::std::option::Option::None;
    }

    pub fn has_include_custom_games(&self) -> bool {
        self.include_custom_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_custom_games(&mut self, v: bool) {
        self.include_custom_games = ::std::option::Option::Some(v);
    }

    // optional bool include_event_games = 9;

    pub fn include_event_games(&self) -> bool {
        self.include_event_games.unwrap_or(false)
    }

    pub fn clear_include_event_games(&mut self) {
        self.include_event_games = ::std::option::Option::None;
    }

    pub fn has_include_event_games(&self) -> bool {
        self.include_event_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_include_event_games(&mut self, v: bool) {
        self.include_event_games = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetPlayerMatchHistory {
    const NAME: &'static str = "CMsgDOTAGetPlayerMatchHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.start_at_match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.matches_requested = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.include_practice_matches = ::std::option::Option::Some(is.read_bool()?);
                },
                64 => {
                    self.include_custom_games = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.include_event_games = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.start_at_match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.matches_requested {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.include_practice_matches {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_custom_games {
            my_size += 1 + 1;
        }
        if let Some(v) = self.include_event_games {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.start_at_match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.matches_requested {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.request_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.include_practice_matches {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.include_custom_games {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.include_event_games {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetPlayerMatchHistory {
        CMsgDOTAGetPlayerMatchHistory::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.start_at_match_id = ::std::option::Option::None;
        self.matches_requested = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.request_id = ::std::option::Option::None;
        self.include_practice_matches = ::std::option::Option::None;
        self.include_custom_games = ::std::option::Option::None;
        self.include_event_games = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetPlayerMatchHistory {
        static instance: CMsgDOTAGetPlayerMatchHistory = CMsgDOTAGetPlayerMatchHistory {
            account_id: ::std::option::Option::None,
            start_at_match_id: ::std::option::Option::None,
            matches_requested: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            request_id: ::std::option::Option::None,
            include_practice_matches: ::std::option::Option::None,
            include_custom_games: ::std::option::Option::None,
            include_event_games: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetPlayerMatchHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetPlayerMatchHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.matches)
    pub matches: ::std::vec::Vec<cmsg_dotaget_player_match_history_response::Match>,
    // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.request_id)
    pub request_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetPlayerMatchHistoryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetPlayerMatchHistoryResponse {
    fn default() -> &'a CMsgDOTAGetPlayerMatchHistoryResponse {
        <CMsgDOTAGetPlayerMatchHistoryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetPlayerMatchHistoryResponse {
    pub fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse {
        ::std::default::Default::default()
    }

    // optional uint32 request_id = 2;

    pub fn request_id(&self) -> u32 {
        self.request_id.unwrap_or(0)
    }

    pub fn clear_request_id(&mut self) {
        self.request_id = ::std::option::Option::None;
    }

    pub fn has_request_id(&self) -> bool {
        self.request_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: u32) {
        self.request_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetPlayerMatchHistoryResponse {
    const NAME: &'static str = "CMsgDOTAGetPlayerMatchHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                16 => {
                    self.request_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.request_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.request_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetPlayerMatchHistoryResponse {
        CMsgDOTAGetPlayerMatchHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.request_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetPlayerMatchHistoryResponse {
        static instance: CMsgDOTAGetPlayerMatchHistoryResponse = CMsgDOTAGetPlayerMatchHistoryResponse {
            matches: ::std::vec::Vec::new(),
            request_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAGetPlayerMatchHistoryResponse`
pub mod cmsg_dotaget_player_match_history_response {
    // @@protoc_insertion_point(message:CMsgDOTAGetPlayerMatchHistoryResponse.Match)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Match {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.start_time)
        pub start_time: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.winner)
        pub winner: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.game_mode)
        pub game_mode: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.rank_change)
        pub rank_change: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.previous_rank)
        pub previous_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.lobby_type)
        pub lobby_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.solo_rank)
        pub solo_rank: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.abandon)
        pub abandon: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.duration)
        pub duration: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.engine)
        pub engine: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.active_plus_subscription)
        pub active_plus_subscription: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.seasonal_rank)
        pub seasonal_rank: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.tourney_id)
        pub tourney_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.tourney_round)
        pub tourney_round: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.tourney_tier)
        pub tourney_tier: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.tourney_division)
        pub tourney_division: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.team_id)
        pub team_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.team_name)
        pub team_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.ugc_team_ui_logo)
        pub ugc_team_ui_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.selected_facet)
        pub selected_facet: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAGetPlayerMatchHistoryResponse.Match.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Match {
        fn default() -> &'a Match {
            <Match as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Match {
        pub fn new() -> Match {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 start_time = 2;

        pub fn start_time(&self) -> u32 {
            self.start_time.unwrap_or(0)
        }

        pub fn clear_start_time(&mut self) {
            self.start_time = ::std::option::Option::None;
        }

        pub fn has_start_time(&self) -> bool {
            self.start_time.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_time(&mut self, v: u32) {
            self.start_time = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 3;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional bool winner = 4;

        pub fn winner(&self) -> bool {
            self.winner.unwrap_or(false)
        }

        pub fn clear_winner(&mut self) {
            self.winner = ::std::option::Option::None;
        }

        pub fn has_winner(&self) -> bool {
            self.winner.is_some()
        }

        // Param is passed by value, moved
        pub fn set_winner(&mut self, v: bool) {
            self.winner = ::std::option::Option::Some(v);
        }

        // optional uint32 game_mode = 5;

        pub fn game_mode(&self) -> u32 {
            self.game_mode.unwrap_or(0)
        }

        pub fn clear_game_mode(&mut self) {
            self.game_mode = ::std::option::Option::None;
        }

        pub fn has_game_mode(&self) -> bool {
            self.game_mode.is_some()
        }

        // Param is passed by value, moved
        pub fn set_game_mode(&mut self, v: u32) {
            self.game_mode = ::std::option::Option::Some(v);
        }

        // optional int32 rank_change = 6;

        pub fn rank_change(&self) -> i32 {
            self.rank_change.unwrap_or(0)
        }

        pub fn clear_rank_change(&mut self) {
            self.rank_change = ::std::option::Option::None;
        }

        pub fn has_rank_change(&self) -> bool {
            self.rank_change.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_change(&mut self, v: i32) {
            self.rank_change = ::std::option::Option::Some(v);
        }

        // optional uint32 previous_rank = 7;

        pub fn previous_rank(&self) -> u32 {
            self.previous_rank.unwrap_or(0)
        }

        pub fn clear_previous_rank(&mut self) {
            self.previous_rank = ::std::option::Option::None;
        }

        pub fn has_previous_rank(&self) -> bool {
            self.previous_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_previous_rank(&mut self, v: u32) {
            self.previous_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 lobby_type = 8;

        pub fn lobby_type(&self) -> u32 {
            self.lobby_type.unwrap_or(0)
        }

        pub fn clear_lobby_type(&mut self) {
            self.lobby_type = ::std::option::Option::None;
        }

        pub fn has_lobby_type(&self) -> bool {
            self.lobby_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_lobby_type(&mut self, v: u32) {
            self.lobby_type = ::std::option::Option::Some(v);
        }

        // optional bool solo_rank = 9;

        pub fn solo_rank(&self) -> bool {
            self.solo_rank.unwrap_or(false)
        }

        pub fn clear_solo_rank(&mut self) {
            self.solo_rank = ::std::option::Option::None;
        }

        pub fn has_solo_rank(&self) -> bool {
            self.solo_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_solo_rank(&mut self, v: bool) {
            self.solo_rank = ::std::option::Option::Some(v);
        }

        // optional bool abandon = 10;

        pub fn abandon(&self) -> bool {
            self.abandon.unwrap_or(false)
        }

        pub fn clear_abandon(&mut self) {
            self.abandon = ::std::option::Option::None;
        }

        pub fn has_abandon(&self) -> bool {
            self.abandon.is_some()
        }

        // Param is passed by value, moved
        pub fn set_abandon(&mut self, v: bool) {
            self.abandon = ::std::option::Option::Some(v);
        }

        // optional uint32 duration = 11;

        pub fn duration(&self) -> u32 {
            self.duration.unwrap_or(0)
        }

        pub fn clear_duration(&mut self) {
            self.duration = ::std::option::Option::None;
        }

        pub fn has_duration(&self) -> bool {
            self.duration.is_some()
        }

        // Param is passed by value, moved
        pub fn set_duration(&mut self, v: u32) {
            self.duration = ::std::option::Option::Some(v);
        }

        // optional uint32 engine = 12;

        pub fn engine(&self) -> u32 {
            self.engine.unwrap_or(0)
        }

        pub fn clear_engine(&mut self) {
            self.engine = ::std::option::Option::None;
        }

        pub fn has_engine(&self) -> bool {
            self.engine.is_some()
        }

        // Param is passed by value, moved
        pub fn set_engine(&mut self, v: u32) {
            self.engine = ::std::option::Option::Some(v);
        }

        // optional bool active_plus_subscription = 13;

        pub fn active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.unwrap_or(false)
        }

        pub fn clear_active_plus_subscription(&mut self) {
            self.active_plus_subscription = ::std::option::Option::None;
        }

        pub fn has_active_plus_subscription(&self) -> bool {
            self.active_plus_subscription.is_some()
        }

        // Param is passed by value, moved
        pub fn set_active_plus_subscription(&mut self, v: bool) {
            self.active_plus_subscription = ::std::option::Option::Some(v);
        }

        // optional bool seasonal_rank = 14;

        pub fn seasonal_rank(&self) -> bool {
            self.seasonal_rank.unwrap_or(false)
        }

        pub fn clear_seasonal_rank(&mut self) {
            self.seasonal_rank = ::std::option::Option::None;
        }

        pub fn has_seasonal_rank(&self) -> bool {
            self.seasonal_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_seasonal_rank(&mut self, v: bool) {
            self.seasonal_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 tourney_id = 15;

        pub fn tourney_id(&self) -> u32 {
            self.tourney_id.unwrap_or(0)
        }

        pub fn clear_tourney_id(&mut self) {
            self.tourney_id = ::std::option::Option::None;
        }

        pub fn has_tourney_id(&self) -> bool {
            self.tourney_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tourney_id(&mut self, v: u32) {
            self.tourney_id = ::std::option::Option::Some(v);
        }

        // optional uint32 tourney_round = 16;

        pub fn tourney_round(&self) -> u32 {
            self.tourney_round.unwrap_or(0)
        }

        pub fn clear_tourney_round(&mut self) {
            self.tourney_round = ::std::option::Option::None;
        }

        pub fn has_tourney_round(&self) -> bool {
            self.tourney_round.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tourney_round(&mut self, v: u32) {
            self.tourney_round = ::std::option::Option::Some(v);
        }

        // optional uint32 tourney_tier = 17;

        pub fn tourney_tier(&self) -> u32 {
            self.tourney_tier.unwrap_or(0)
        }

        pub fn clear_tourney_tier(&mut self) {
            self.tourney_tier = ::std::option::Option::None;
        }

        pub fn has_tourney_tier(&self) -> bool {
            self.tourney_tier.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tourney_tier(&mut self, v: u32) {
            self.tourney_tier = ::std::option::Option::Some(v);
        }

        // optional uint32 tourney_division = 18;

        pub fn tourney_division(&self) -> u32 {
            self.tourney_division.unwrap_or(0)
        }

        pub fn clear_tourney_division(&mut self) {
            self.tourney_division = ::std::option::Option::None;
        }

        pub fn has_tourney_division(&self) -> bool {
            self.tourney_division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tourney_division(&mut self, v: u32) {
            self.tourney_division = ::std::option::Option::Some(v);
        }

        // optional uint32 team_id = 19;

        pub fn team_id(&self) -> u32 {
            self.team_id.unwrap_or(0)
        }

        pub fn clear_team_id(&mut self) {
            self.team_id = ::std::option::Option::None;
        }

        pub fn has_team_id(&self) -> bool {
            self.team_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_id(&mut self, v: u32) {
            self.team_id = ::std::option::Option::Some(v);
        }

        // optional string team_name = 20;

        pub fn team_name(&self) -> &str {
            match self.team_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_team_name(&mut self) {
            self.team_name = ::std::option::Option::None;
        }

        pub fn has_team_name(&self) -> bool {
            self.team_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_team_name(&mut self, v: ::std::string::String) {
            self.team_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
            if self.team_name.is_none() {
                self.team_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.team_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_team_name(&mut self) -> ::std::string::String {
            self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 ugc_team_ui_logo = 21;

        pub fn ugc_team_ui_logo(&self) -> u64 {
            self.ugc_team_ui_logo.unwrap_or(0)
        }

        pub fn clear_ugc_team_ui_logo(&mut self) {
            self.ugc_team_ui_logo = ::std::option::Option::None;
        }

        pub fn has_ugc_team_ui_logo(&self) -> bool {
            self.ugc_team_ui_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ugc_team_ui_logo(&mut self, v: u64) {
            self.ugc_team_ui_logo = ::std::option::Option::Some(v);
        }

        // optional uint32 selected_facet = 22;

        pub fn selected_facet(&self) -> u32 {
            self.selected_facet.unwrap_or(0)
        }

        pub fn clear_selected_facet(&mut self) {
            self.selected_facet = ::std::option::Option::None;
        }

        pub fn has_selected_facet(&self) -> bool {
            self.selected_facet.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selected_facet(&mut self, v: u32) {
            self.selected_facet = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Match {
        const NAME: &'static str = "Match";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.winner = ::std::option::Option::Some(is.read_bool()?);
                    },
                    40 => {
                        self.game_mode = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.rank_change = ::std::option::Option::Some(is.read_int32()?);
                    },
                    56 => {
                        self.previous_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    64 => {
                        self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.solo_rank = ::std::option::Option::Some(is.read_bool()?);
                    },
                    80 => {
                        self.abandon = ::std::option::Option::Some(is.read_bool()?);
                    },
                    88 => {
                        self.duration = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    96 => {
                        self.engine = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    104 => {
                        self.active_plus_subscription = ::std::option::Option::Some(is.read_bool()?);
                    },
                    112 => {
                        self.seasonal_rank = ::std::option::Option::Some(is.read_bool()?);
                    },
                    120 => {
                        self.tourney_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    128 => {
                        self.tourney_round = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    136 => {
                        self.tourney_tier = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    144 => {
                        self.tourney_division = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    152 => {
                        self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    162 => {
                        self.team_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    168 => {
                        self.ugc_team_ui_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    176 => {
                        self.selected_facet = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.start_time {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.winner {
                my_size += 1 + 1;
            }
            if let Some(v) = self.game_mode {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.rank_change {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v);
            }
            if let Some(v) = self.previous_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            if let Some(v) = self.lobby_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.solo_rank {
                my_size += 1 + 1;
            }
            if let Some(v) = self.abandon {
                my_size += 1 + 1;
            }
            if let Some(v) = self.duration {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
            }
            if let Some(v) = self.engine {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
            }
            if let Some(v) = self.active_plus_subscription {
                my_size += 1 + 1;
            }
            if let Some(v) = self.seasonal_rank {
                my_size += 1 + 1;
            }
            if let Some(v) = self.tourney_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            if let Some(v) = self.tourney_round {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(16, v);
            }
            if let Some(v) = self.tourney_tier {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
            }
            if let Some(v) = self.tourney_division {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
            }
            if let Some(v) = self.team_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
            }
            if let Some(v) = self.team_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(20, &v);
            }
            if let Some(v) = self.ugc_team_ui_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(21, v);
            }
            if let Some(v) = self.selected_facet {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(22, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.start_time {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.winner {
                os.write_bool(4, v)?;
            }
            if let Some(v) = self.game_mode {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.rank_change {
                os.write_int32(6, v)?;
            }
            if let Some(v) = self.previous_rank {
                os.write_uint32(7, v)?;
            }
            if let Some(v) = self.lobby_type {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.solo_rank {
                os.write_bool(9, v)?;
            }
            if let Some(v) = self.abandon {
                os.write_bool(10, v)?;
            }
            if let Some(v) = self.duration {
                os.write_uint32(11, v)?;
            }
            if let Some(v) = self.engine {
                os.write_uint32(12, v)?;
            }
            if let Some(v) = self.active_plus_subscription {
                os.write_bool(13, v)?;
            }
            if let Some(v) = self.seasonal_rank {
                os.write_bool(14, v)?;
            }
            if let Some(v) = self.tourney_id {
                os.write_uint32(15, v)?;
            }
            if let Some(v) = self.tourney_round {
                os.write_uint32(16, v)?;
            }
            if let Some(v) = self.tourney_tier {
                os.write_uint32(17, v)?;
            }
            if let Some(v) = self.tourney_division {
                os.write_uint32(18, v)?;
            }
            if let Some(v) = self.team_id {
                os.write_uint32(19, v)?;
            }
            if let Some(v) = self.team_name.as_ref() {
                os.write_string(20, v)?;
            }
            if let Some(v) = self.ugc_team_ui_logo {
                os.write_uint64(21, v)?;
            }
            if let Some(v) = self.selected_facet {
                os.write_uint32(22, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Match {
            Match::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.start_time = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.winner = ::std::option::Option::None;
            self.game_mode = ::std::option::Option::None;
            self.rank_change = ::std::option::Option::None;
            self.previous_rank = ::std::option::Option::None;
            self.lobby_type = ::std::option::Option::None;
            self.solo_rank = ::std::option::Option::None;
            self.abandon = ::std::option::Option::None;
            self.duration = ::std::option::Option::None;
            self.engine = ::std::option::Option::None;
            self.active_plus_subscription = ::std::option::Option::None;
            self.seasonal_rank = ::std::option::Option::None;
            self.tourney_id = ::std::option::Option::None;
            self.tourney_round = ::std::option::Option::None;
            self.tourney_tier = ::std::option::Option::None;
            self.tourney_division = ::std::option::Option::None;
            self.team_id = ::std::option::Option::None;
            self.team_name = ::std::option::Option::None;
            self.ugc_team_ui_logo = ::std::option::Option::None;
            self.selected_facet = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Match {
            static instance: Match = Match {
                match_id: ::std::option::Option::None,
                start_time: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                winner: ::std::option::Option::None,
                game_mode: ::std::option::Option::None,
                rank_change: ::std::option::Option::None,
                previous_rank: ::std::option::Option::None,
                lobby_type: ::std::option::Option::None,
                solo_rank: ::std::option::Option::None,
                abandon: ::std::option::Option::None,
                duration: ::std::option::Option::None,
                engine: ::std::option::Option::None,
                active_plus_subscription: ::std::option::Option::None,
                seasonal_rank: ::std::option::Option::None,
                tourney_id: ::std::option::Option::None,
                tourney_round: ::std::option::Option::None,
                tourney_tier: ::std::option::Option::None,
                tourney_division: ::std::option::Option::None,
                team_id: ::std::option::Option::None,
                team_name: ::std::option::Option::None,
                ugc_team_ui_logo: ::std::option::Option::None,
                selected_facet: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCNotificationsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationsRequest {
    fn default() -> &'a CMsgGCNotificationsRequest {
        <CMsgGCNotificationsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationsRequest {
    pub fn new() -> CMsgGCNotificationsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotificationsRequest {
    const NAME: &'static str = "CMsgGCNotificationsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationsRequest {
        CMsgGCNotificationsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationsRequest {
        static instance: CMsgGCNotificationsRequest = CMsgGCNotificationsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNotifications_Notification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotifications_Notification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.id)
    pub id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.type)
    pub type_: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.timestamp)
    pub timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.reference_a)
    pub reference_a: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.reference_b)
    pub reference_b: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.reference_c)
    pub reference_c: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCNotifications_Notification.unread)
    pub unread: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotifications_Notification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotifications_Notification {
    fn default() -> &'a CMsgGCNotifications_Notification {
        <CMsgGCNotifications_Notification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotifications_Notification {
    pub fn new() -> CMsgGCNotifications_Notification {
        ::std::default::Default::default()
    }

    // optional uint64 id = 1;

    pub fn id(&self) -> u64 {
        self.id.unwrap_or(0)
    }

    pub fn clear_id(&mut self) {
        self.id = ::std::option::Option::None;
    }

    pub fn has_id(&self) -> bool {
        self.id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: u64) {
        self.id = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 2;

    pub fn type_(&self) -> u32 {
        self.type_.unwrap_or(0)
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: u32) {
        self.type_ = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp = 3;

    pub fn timestamp(&self) -> u32 {
        self.timestamp.unwrap_or(0)
    }

    pub fn clear_timestamp(&mut self) {
        self.timestamp = ::std::option::Option::None;
    }

    pub fn has_timestamp(&self) -> bool {
        self.timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: u32) {
        self.timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 reference_a = 4;

    pub fn reference_a(&self) -> u32 {
        self.reference_a.unwrap_or(0)
    }

    pub fn clear_reference_a(&mut self) {
        self.reference_a = ::std::option::Option::None;
    }

    pub fn has_reference_a(&self) -> bool {
        self.reference_a.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_a(&mut self, v: u32) {
        self.reference_a = ::std::option::Option::Some(v);
    }

    // optional uint32 reference_b = 5;

    pub fn reference_b(&self) -> u32 {
        self.reference_b.unwrap_or(0)
    }

    pub fn clear_reference_b(&mut self) {
        self.reference_b = ::std::option::Option::None;
    }

    pub fn has_reference_b(&self) -> bool {
        self.reference_b.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_b(&mut self, v: u32) {
        self.reference_b = ::std::option::Option::Some(v);
    }

    // optional uint32 reference_c = 6;

    pub fn reference_c(&self) -> u32 {
        self.reference_c.unwrap_or(0)
    }

    pub fn clear_reference_c(&mut self) {
        self.reference_c = ::std::option::Option::None;
    }

    pub fn has_reference_c(&self) -> bool {
        self.reference_c.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_c(&mut self, v: u32) {
        self.reference_c = ::std::option::Option::Some(v);
    }

    // optional string message = 7;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unread = 8;

    pub fn unread(&self) -> bool {
        self.unread.unwrap_or(false)
    }

    pub fn clear_unread(&mut self) {
        self.unread = ::std::option::Option::None;
    }

    pub fn has_unread(&self) -> bool {
        self.unread.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unread(&mut self, v: bool) {
        self.unread = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotifications_Notification {
    const NAME: &'static str = "CMsgGCNotifications_Notification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.type_ = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.reference_a = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.reference_b = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.reference_c = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                64 => {
                    self.unread = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.type_ {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.reference_a {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.reference_b {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.reference_c {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.unread {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.type_ {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reference_a {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.reference_b {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.reference_c {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.message.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.unread {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotifications_Notification {
        CMsgGCNotifications_Notification::new()
    }

    fn clear(&mut self) {
        self.id = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.timestamp = ::std::option::Option::None;
        self.reference_a = ::std::option::Option::None;
        self.reference_b = ::std::option::Option::None;
        self.reference_c = ::std::option::Option::None;
        self.message = ::std::option::Option::None;
        self.unread = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotifications_Notification {
        static instance: CMsgGCNotifications_Notification = CMsgGCNotifications_Notification {
            id: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            timestamp: ::std::option::Option::None,
            reference_a: ::std::option::Option::None,
            reference_b: ::std::option::Option::None,
            reference_c: ::std::option::Option::None,
            message: ::std::option::Option::None,
            unread: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNotificationsUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationsUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotificationsUpdate.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcnotifications_update::EResult>>,
    // @@protoc_insertion_point(field:CMsgGCNotificationsUpdate.notifications)
    pub notifications: ::std::vec::Vec<CMsgGCNotifications_Notification>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationsUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationsUpdate {
    fn default() -> &'a CMsgGCNotificationsUpdate {
        <CMsgGCNotificationsUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationsUpdate {
    pub fn new() -> CMsgGCNotificationsUpdate {
        ::std::default::Default::default()
    }

    // optional .CMsgGCNotificationsUpdate.EResult result = 1;

    pub fn result(&self) -> cmsg_gcnotifications_update::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcnotifications_update::EResult::SUCCESS),
            None => cmsg_gcnotifications_update::EResult::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcnotifications_update::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotificationsUpdate {
    const NAME: &'static str = "CMsgGCNotificationsUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.notifications.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.notifications {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.notifications {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationsUpdate {
        CMsgGCNotificationsUpdate::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.notifications.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationsUpdate {
        static instance: CMsgGCNotificationsUpdate = CMsgGCNotificationsUpdate {
            result: ::std::option::Option::None,
            notifications: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCNotificationsUpdate`
pub mod cmsg_gcnotifications_update {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCNotificationsUpdate.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgGCNotificationsUpdate.EResult.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCNotificationsUpdate.EResult.ERROR_UNSPECIFIED)
        ERROR_UNSPECIFIED = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::SUCCESS),
                1 => ::std::option::Option::Some(EResult::ERROR_UNSPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResult::SUCCESS),
                "ERROR_UNSPECIFIED" => ::std::option::Option::Some(EResult::ERROR_UNSPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::SUCCESS,
            EResult::ERROR_UNSPECIFIED,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCNotificationsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCNotificationsResponse.update)
    pub update: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCNotificationsUpdate>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationsResponse {
    fn default() -> &'a CMsgGCNotificationsResponse {
        <CMsgGCNotificationsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationsResponse {
    pub fn new() -> CMsgGCNotificationsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotificationsResponse {
    const NAME: &'static str = "CMsgGCNotificationsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.update)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.update.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationsResponse {
        CMsgGCNotificationsResponse::new()
    }

    fn clear(&mut self) {
        self.update.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationsResponse {
        static instance: CMsgGCNotificationsResponse = CMsgGCNotificationsResponse {
            update: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCNotificationsMarkReadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCNotificationsMarkReadRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCNotificationsMarkReadRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCNotificationsMarkReadRequest {
    fn default() -> &'a CMsgGCNotificationsMarkReadRequest {
        <CMsgGCNotificationsMarkReadRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCNotificationsMarkReadRequest {
    pub fn new() -> CMsgGCNotificationsMarkReadRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCNotificationsMarkReadRequest {
    const NAME: &'static str = "CMsgGCNotificationsMarkReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCNotificationsMarkReadRequest {
        CMsgGCNotificationsMarkReadRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCNotificationsMarkReadRequest {
        static instance: CMsgGCNotificationsMarkReadRequest = CMsgGCNotificationsMarkReadRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCPlayerInfoSubmit)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCPlayerInfoSubmit {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmit.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmit.country_code)
    pub country_code: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmit.fantasy_role)
    pub fantasy_role: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmit.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmit.sponsor)
    pub sponsor: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCPlayerInfoSubmit.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCPlayerInfoSubmit {
    fn default() -> &'a CMsgGCPlayerInfoSubmit {
        <CMsgGCPlayerInfoSubmit as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCPlayerInfoSubmit {
    pub fn new() -> CMsgGCPlayerInfoSubmit {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_code = 2;

    pub fn country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_country_code(&mut self) {
        self.country_code = ::std::option::Option::None;
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code = ::std::option::Option::Some(::std::string::String::new());
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 fantasy_role = 3;

    pub fn fantasy_role(&self) -> u32 {
        self.fantasy_role.unwrap_or(0)
    }

    pub fn clear_fantasy_role(&mut self) {
        self.fantasy_role = ::std::option::Option::None;
    }

    pub fn has_fantasy_role(&self) -> bool {
        self.fantasy_role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fantasy_role(&mut self, v: u32) {
        self.fantasy_role = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string sponsor = 5;

    pub fn sponsor(&self) -> &str {
        match self.sponsor.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sponsor(&mut self) {
        self.sponsor = ::std::option::Option::None;
    }

    pub fn has_sponsor(&self) -> bool {
        self.sponsor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sponsor(&mut self, v: ::std::string::String) {
        self.sponsor = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sponsor(&mut self) -> &mut ::std::string::String {
        if self.sponsor.is_none() {
            self.sponsor = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sponsor.as_mut().unwrap()
    }

    // Take field
    pub fn take_sponsor(&mut self) -> ::std::string::String {
        self.sponsor.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCPlayerInfoSubmit {
    const NAME: &'static str = "CMsgGCPlayerInfoSubmit";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.country_code = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.fantasy_role = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                42 => {
                    self.sponsor = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.country_code.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.fantasy_role {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.sponsor.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(5, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.country_code.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.fantasy_role {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.sponsor.as_ref() {
            os.write_string(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCPlayerInfoSubmit {
        CMsgGCPlayerInfoSubmit::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.country_code = ::std::option::Option::None;
        self.fantasy_role = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.sponsor = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCPlayerInfoSubmit {
        static instance: CMsgGCPlayerInfoSubmit = CMsgGCPlayerInfoSubmit {
            name: ::std::option::Option::None,
            country_code: ::std::option::Option::None,
            fantasy_role: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            sponsor: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCPlayerInfoSubmitResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCPlayerInfoSubmitResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCPlayerInfoSubmitResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcplayer_info_submit_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCPlayerInfoSubmitResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCPlayerInfoSubmitResponse {
    fn default() -> &'a CMsgGCPlayerInfoSubmitResponse {
        <CMsgGCPlayerInfoSubmitResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCPlayerInfoSubmitResponse {
    pub fn new() -> CMsgGCPlayerInfoSubmitResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCPlayerInfoSubmitResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_gcplayer_info_submit_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcplayer_info_submit_response::EResult::SUCCESS),
            None => cmsg_gcplayer_info_submit_response::EResult::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcplayer_info_submit_response::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCPlayerInfoSubmitResponse {
    const NAME: &'static str = "CMsgGCPlayerInfoSubmitResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCPlayerInfoSubmitResponse {
        CMsgGCPlayerInfoSubmitResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCPlayerInfoSubmitResponse {
        static instance: CMsgGCPlayerInfoSubmitResponse = CMsgGCPlayerInfoSubmitResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCPlayerInfoSubmitResponse`
pub mod cmsg_gcplayer_info_submit_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCPlayerInfoSubmitResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgGCPlayerInfoSubmitResponse.EResult.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCPlayerInfoSubmitResponse.EResult.ERROR_UNSPECIFIED)
        ERROR_UNSPECIFIED = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCPlayerInfoSubmitResponse.EResult.ERROR_INFO_LOCKED)
        ERROR_INFO_LOCKED = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCPlayerInfoSubmitResponse.EResult.ERROR_NOT_MEMBER_OF_TEAM)
        ERROR_NOT_MEMBER_OF_TEAM = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::SUCCESS),
                1 => ::std::option::Option::Some(EResult::ERROR_UNSPECIFIED),
                2 => ::std::option::Option::Some(EResult::ERROR_INFO_LOCKED),
                3 => ::std::option::Option::Some(EResult::ERROR_NOT_MEMBER_OF_TEAM),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResult::SUCCESS),
                "ERROR_UNSPECIFIED" => ::std::option::Option::Some(EResult::ERROR_UNSPECIFIED),
                "ERROR_INFO_LOCKED" => ::std::option::Option::Some(EResult::ERROR_INFO_LOCKED),
                "ERROR_NOT_MEMBER_OF_TEAM" => ::std::option::Option::Some(EResult::ERROR_NOT_MEMBER_OF_TEAM),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::SUCCESS,
            EResult::ERROR_UNSPECIFIED,
            EResult::ERROR_INFO_LOCKED,
            EResult::ERROR_NOT_MEMBER_OF_TEAM,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAEmoticonAccessSDO)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAEmoticonAccessSDO {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAEmoticonAccessSDO.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAEmoticonAccessSDO.unlocked_emoticons)
    pub unlocked_emoticons: ::std::option::Option<::std::vec::Vec<u8>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAEmoticonAccessSDO.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAEmoticonAccessSDO {
    fn default() -> &'a CMsgDOTAEmoticonAccessSDO {
        <CMsgDOTAEmoticonAccessSDO as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAEmoticonAccessSDO {
    pub fn new() -> CMsgDOTAEmoticonAccessSDO {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bytes unlocked_emoticons = 2;

    pub fn unlocked_emoticons(&self) -> &[u8] {
        match self.unlocked_emoticons.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_unlocked_emoticons(&mut self) {
        self.unlocked_emoticons = ::std::option::Option::None;
    }

    pub fn has_unlocked_emoticons(&self) -> bool {
        self.unlocked_emoticons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unlocked_emoticons(&mut self, v: ::std::vec::Vec<u8>) {
        self.unlocked_emoticons = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_unlocked_emoticons(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.unlocked_emoticons.is_none() {
            self.unlocked_emoticons = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.unlocked_emoticons.as_mut().unwrap()
    }

    // Take field
    pub fn take_unlocked_emoticons(&mut self) -> ::std::vec::Vec<u8> {
        self.unlocked_emoticons.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAEmoticonAccessSDO {
    const NAME: &'static str = "CMsgDOTAEmoticonAccessSDO";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.unlocked_emoticons = ::std::option::Option::Some(is.read_bytes()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.unlocked_emoticons.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.unlocked_emoticons.as_ref() {
            os.write_bytes(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAEmoticonAccessSDO {
        CMsgDOTAEmoticonAccessSDO::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.unlocked_emoticons = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAEmoticonAccessSDO {
        static instance: CMsgDOTAEmoticonAccessSDO = CMsgDOTAEmoticonAccessSDO {
            account_id: ::std::option::Option::None,
            unlocked_emoticons: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCEmoticonDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCEmoticonDataRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCEmoticonDataRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCEmoticonDataRequest {
    fn default() -> &'a CMsgClientToGCEmoticonDataRequest {
        <CMsgClientToGCEmoticonDataRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCEmoticonDataRequest {
    pub fn new() -> CMsgClientToGCEmoticonDataRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCEmoticonDataRequest {
    const NAME: &'static str = "CMsgClientToGCEmoticonDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCEmoticonDataRequest {
        CMsgClientToGCEmoticonDataRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCEmoticonDataRequest {
        static instance: CMsgClientToGCEmoticonDataRequest = CMsgClientToGCEmoticonDataRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientEmoticonData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientEmoticonData {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientEmoticonData.emoticon_access)
    pub emoticon_access: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAEmoticonAccessSDO>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientEmoticonData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientEmoticonData {
    fn default() -> &'a CMsgGCToClientEmoticonData {
        <CMsgGCToClientEmoticonData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientEmoticonData {
    pub fn new() -> CMsgGCToClientEmoticonData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientEmoticonData {
    const NAME: &'static str = "CMsgGCToClientEmoticonData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.emoticon_access)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.emoticon_access.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.emoticon_access.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientEmoticonData {
        CMsgGCToClientEmoticonData::new()
    }

    fn clear(&mut self) {
        self.emoticon_access.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientEmoticonData {
        static instance: CMsgGCToClientEmoticonData = CMsgGCToClientEmoticonData {
            emoticon_access: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientTournamentItemDrop)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientTournamentItemDrop {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientTournamentItemDrop.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientTournamentItemDrop.event_type)
    pub event_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientTournamentItemDrop.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientTournamentItemDrop {
    fn default() -> &'a CMsgGCToClientTournamentItemDrop {
        <CMsgGCToClientTournamentItemDrop as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientTournamentItemDrop {
    pub fn new() -> CMsgGCToClientTournamentItemDrop {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 event_type = 2;

    pub fn event_type(&self) -> u32 {
        self.event_type.unwrap_or(0)
    }

    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: u32) {
        self.event_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientTournamentItemDrop {
    const NAME: &'static str = "CMsgGCToClientTournamentItemDrop";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientTournamentItemDrop {
        CMsgGCToClientTournamentItemDrop::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.event_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientTournamentItemDrop {
        static instance: CMsgGCToClientTournamentItemDrop = CMsgGCToClientTournamentItemDrop {
            item_def: ::std::option::Option::None,
            event_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetAllHeroOrder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAllHeroOrder {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetAllHeroOrder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAllHeroOrder {
    fn default() -> &'a CMsgClientToGCGetAllHeroOrder {
        <CMsgClientToGCGetAllHeroOrder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAllHeroOrder {
    pub fn new() -> CMsgClientToGCGetAllHeroOrder {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetAllHeroOrder {
    const NAME: &'static str = "CMsgClientToGCGetAllHeroOrder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAllHeroOrder {
        CMsgClientToGCGetAllHeroOrder::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAllHeroOrder {
        static instance: CMsgClientToGCGetAllHeroOrder = CMsgClientToGCGetAllHeroOrder {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetAllHeroOrderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAllHeroOrderResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroOrderResponse.hero_ids)
    pub hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetAllHeroOrderResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAllHeroOrderResponse {
    fn default() -> &'a CMsgClientToGCGetAllHeroOrderResponse {
        <CMsgClientToGCGetAllHeroOrderResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAllHeroOrderResponse {
    pub fn new() -> CMsgClientToGCGetAllHeroOrderResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetAllHeroOrderResponse {
    const NAME: &'static str = "CMsgClientToGCGetAllHeroOrderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.hero_ids)?;
                },
                8 => {
                    self.hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.hero_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAllHeroOrderResponse {
        CMsgClientToGCGetAllHeroOrderResponse::new()
    }

    fn clear(&mut self) {
        self.hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAllHeroOrderResponse {
        static instance: CMsgClientToGCGetAllHeroOrderResponse = CMsgClientToGCGetAllHeroOrderResponse {
            hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetAllHeroProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAllHeroProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgress.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetAllHeroProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAllHeroProgress {
    fn default() -> &'a CMsgClientToGCGetAllHeroProgress {
        <CMsgClientToGCGetAllHeroProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAllHeroProgress {
    pub fn new() -> CMsgClientToGCGetAllHeroProgress {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetAllHeroProgress {
    const NAME: &'static str = "CMsgClientToGCGetAllHeroProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAllHeroProgress {
        CMsgClientToGCGetAllHeroProgress::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAllHeroProgress {
        static instance: CMsgClientToGCGetAllHeroProgress = CMsgClientToGCGetAllHeroProgress {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetAllHeroProgressResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetAllHeroProgressResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_hero_id)
    pub curr_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.laps_completed)
    pub laps_completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_hero_games)
    pub curr_hero_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_lap_time_started)
    pub curr_lap_time_started: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_lap_games)
    pub curr_lap_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.best_lap_games)
    pub best_lap_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.best_lap_time)
    pub best_lap_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.lap_heroes_completed)
    pub lap_heroes_completed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.lap_heroes_remaining)
    pub lap_heroes_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.next_hero_id)
    pub next_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.prev_hero_id)
    pub prev_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.prev_hero_games)
    pub prev_hero_games: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.prev_avg_tries)
    pub prev_avg_tries: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_avg_tries)
    pub curr_avg_tries: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.next_avg_tries)
    pub next_avg_tries: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.full_lap_avg_tries)
    pub full_lap_avg_tries: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.curr_lap_avg_tries)
    pub curr_lap_avg_tries: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.profile_name)
    pub profile_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetAllHeroProgressResponse.start_hero_id)
    pub start_hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetAllHeroProgressResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetAllHeroProgressResponse {
    fn default() -> &'a CMsgClientToGCGetAllHeroProgressResponse {
        <CMsgClientToGCGetAllHeroProgressResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetAllHeroProgressResponse {
    pub fn new() -> CMsgClientToGCGetAllHeroProgressResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 curr_hero_id = 2;

    pub fn curr_hero_id(&self) -> i32 {
        self.curr_hero_id.unwrap_or(0)
    }

    pub fn clear_curr_hero_id(&mut self) {
        self.curr_hero_id = ::std::option::Option::None;
    }

    pub fn has_curr_hero_id(&self) -> bool {
        self.curr_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_hero_id(&mut self, v: i32) {
        self.curr_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 laps_completed = 3;

    pub fn laps_completed(&self) -> u32 {
        self.laps_completed.unwrap_or(0)
    }

    pub fn clear_laps_completed(&mut self) {
        self.laps_completed = ::std::option::Option::None;
    }

    pub fn has_laps_completed(&self) -> bool {
        self.laps_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_laps_completed(&mut self, v: u32) {
        self.laps_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 curr_hero_games = 4;

    pub fn curr_hero_games(&self) -> u32 {
        self.curr_hero_games.unwrap_or(0)
    }

    pub fn clear_curr_hero_games(&mut self) {
        self.curr_hero_games = ::std::option::Option::None;
    }

    pub fn has_curr_hero_games(&self) -> bool {
        self.curr_hero_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_hero_games(&mut self, v: u32) {
        self.curr_hero_games = ::std::option::Option::Some(v);
    }

    // optional uint32 curr_lap_time_started = 5;

    pub fn curr_lap_time_started(&self) -> u32 {
        self.curr_lap_time_started.unwrap_or(0)
    }

    pub fn clear_curr_lap_time_started(&mut self) {
        self.curr_lap_time_started = ::std::option::Option::None;
    }

    pub fn has_curr_lap_time_started(&self) -> bool {
        self.curr_lap_time_started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_time_started(&mut self, v: u32) {
        self.curr_lap_time_started = ::std::option::Option::Some(v);
    }

    // optional uint32 curr_lap_games = 6;

    pub fn curr_lap_games(&self) -> u32 {
        self.curr_lap_games.unwrap_or(0)
    }

    pub fn clear_curr_lap_games(&mut self) {
        self.curr_lap_games = ::std::option::Option::None;
    }

    pub fn has_curr_lap_games(&self) -> bool {
        self.curr_lap_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_games(&mut self, v: u32) {
        self.curr_lap_games = ::std::option::Option::Some(v);
    }

    // optional uint32 best_lap_games = 7;

    pub fn best_lap_games(&self) -> u32 {
        self.best_lap_games.unwrap_or(0)
    }

    pub fn clear_best_lap_games(&mut self) {
        self.best_lap_games = ::std::option::Option::None;
    }

    pub fn has_best_lap_games(&self) -> bool {
        self.best_lap_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_lap_games(&mut self, v: u32) {
        self.best_lap_games = ::std::option::Option::Some(v);
    }

    // optional uint32 best_lap_time = 8;

    pub fn best_lap_time(&self) -> u32 {
        self.best_lap_time.unwrap_or(0)
    }

    pub fn clear_best_lap_time(&mut self) {
        self.best_lap_time = ::std::option::Option::None;
    }

    pub fn has_best_lap_time(&self) -> bool {
        self.best_lap_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_best_lap_time(&mut self, v: u32) {
        self.best_lap_time = ::std::option::Option::Some(v);
    }

    // optional uint32 lap_heroes_completed = 9;

    pub fn lap_heroes_completed(&self) -> u32 {
        self.lap_heroes_completed.unwrap_or(0)
    }

    pub fn clear_lap_heroes_completed(&mut self) {
        self.lap_heroes_completed = ::std::option::Option::None;
    }

    pub fn has_lap_heroes_completed(&self) -> bool {
        self.lap_heroes_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lap_heroes_completed(&mut self, v: u32) {
        self.lap_heroes_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 lap_heroes_remaining = 10;

    pub fn lap_heroes_remaining(&self) -> u32 {
        self.lap_heroes_remaining.unwrap_or(0)
    }

    pub fn clear_lap_heroes_remaining(&mut self) {
        self.lap_heroes_remaining = ::std::option::Option::None;
    }

    pub fn has_lap_heroes_remaining(&self) -> bool {
        self.lap_heroes_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lap_heroes_remaining(&mut self, v: u32) {
        self.lap_heroes_remaining = ::std::option::Option::Some(v);
    }

    // optional int32 next_hero_id = 11;

    pub fn next_hero_id(&self) -> i32 {
        self.next_hero_id.unwrap_or(0)
    }

    pub fn clear_next_hero_id(&mut self) {
        self.next_hero_id = ::std::option::Option::None;
    }

    pub fn has_next_hero_id(&self) -> bool {
        self.next_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_hero_id(&mut self, v: i32) {
        self.next_hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 prev_hero_id = 12;

    pub fn prev_hero_id(&self) -> i32 {
        self.prev_hero_id.unwrap_or(0)
    }

    pub fn clear_prev_hero_id(&mut self) {
        self.prev_hero_id = ::std::option::Option::None;
    }

    pub fn has_prev_hero_id(&self) -> bool {
        self.prev_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_hero_id(&mut self, v: i32) {
        self.prev_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 prev_hero_games = 13;

    pub fn prev_hero_games(&self) -> u32 {
        self.prev_hero_games.unwrap_or(0)
    }

    pub fn clear_prev_hero_games(&mut self) {
        self.prev_hero_games = ::std::option::Option::None;
    }

    pub fn has_prev_hero_games(&self) -> bool {
        self.prev_hero_games.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_hero_games(&mut self, v: u32) {
        self.prev_hero_games = ::std::option::Option::Some(v);
    }

    // optional float prev_avg_tries = 14;

    pub fn prev_avg_tries(&self) -> f32 {
        self.prev_avg_tries.unwrap_or(0.)
    }

    pub fn clear_prev_avg_tries(&mut self) {
        self.prev_avg_tries = ::std::option::Option::None;
    }

    pub fn has_prev_avg_tries(&self) -> bool {
        self.prev_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prev_avg_tries(&mut self, v: f32) {
        self.prev_avg_tries = ::std::option::Option::Some(v);
    }

    // optional float curr_avg_tries = 15;

    pub fn curr_avg_tries(&self) -> f32 {
        self.curr_avg_tries.unwrap_or(0.)
    }

    pub fn clear_curr_avg_tries(&mut self) {
        self.curr_avg_tries = ::std::option::Option::None;
    }

    pub fn has_curr_avg_tries(&self) -> bool {
        self.curr_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_avg_tries(&mut self, v: f32) {
        self.curr_avg_tries = ::std::option::Option::Some(v);
    }

    // optional float next_avg_tries = 16;

    pub fn next_avg_tries(&self) -> f32 {
        self.next_avg_tries.unwrap_or(0.)
    }

    pub fn clear_next_avg_tries(&mut self) {
        self.next_avg_tries = ::std::option::Option::None;
    }

    pub fn has_next_avg_tries(&self) -> bool {
        self.next_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_avg_tries(&mut self, v: f32) {
        self.next_avg_tries = ::std::option::Option::Some(v);
    }

    // optional float full_lap_avg_tries = 17;

    pub fn full_lap_avg_tries(&self) -> f32 {
        self.full_lap_avg_tries.unwrap_or(0.)
    }

    pub fn clear_full_lap_avg_tries(&mut self) {
        self.full_lap_avg_tries = ::std::option::Option::None;
    }

    pub fn has_full_lap_avg_tries(&self) -> bool {
        self.full_lap_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_full_lap_avg_tries(&mut self, v: f32) {
        self.full_lap_avg_tries = ::std::option::Option::Some(v);
    }

    // optional float curr_lap_avg_tries = 18;

    pub fn curr_lap_avg_tries(&self) -> f32 {
        self.curr_lap_avg_tries.unwrap_or(0.)
    }

    pub fn clear_curr_lap_avg_tries(&mut self) {
        self.curr_lap_avg_tries = ::std::option::Option::None;
    }

    pub fn has_curr_lap_avg_tries(&self) -> bool {
        self.curr_lap_avg_tries.is_some()
    }

    // Param is passed by value, moved
    pub fn set_curr_lap_avg_tries(&mut self, v: f32) {
        self.curr_lap_avg_tries = ::std::option::Option::Some(v);
    }

    // optional string profile_name = 19;

    pub fn profile_name(&self) -> &str {
        match self.profile_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_profile_name(&mut self) {
        self.profile_name = ::std::option::Option::None;
    }

    pub fn has_profile_name(&self) -> bool {
        self.profile_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile_name(&mut self, v: ::std::string::String) {
        self.profile_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile_name(&mut self) -> &mut ::std::string::String {
        if self.profile_name.is_none() {
            self.profile_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.profile_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile_name(&mut self) -> ::std::string::String {
        self.profile_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 start_hero_id = 20;

    pub fn start_hero_id(&self) -> i32 {
        self.start_hero_id.unwrap_or(0)
    }

    pub fn clear_start_hero_id(&mut self) {
        self.start_hero_id = ::std::option::Option::None;
    }

    pub fn has_start_hero_id(&self) -> bool {
        self.start_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_hero_id(&mut self, v: i32) {
        self.start_hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetAllHeroProgressResponse {
    const NAME: &'static str = "CMsgClientToGCGetAllHeroProgressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.curr_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.laps_completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.curr_hero_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.curr_lap_time_started = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.curr_lap_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.best_lap_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.best_lap_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.lap_heroes_completed = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.lap_heroes_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.next_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                96 => {
                    self.prev_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                104 => {
                    self.prev_hero_games = ::std::option::Option::Some(is.read_uint32()?);
                },
                117 => {
                    self.prev_avg_tries = ::std::option::Option::Some(is.read_float()?);
                },
                125 => {
                    self.curr_avg_tries = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.next_avg_tries = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.full_lap_avg_tries = ::std::option::Option::Some(is.read_float()?);
                },
                149 => {
                    self.curr_lap_avg_tries = ::std::option::Option::Some(is.read_float()?);
                },
                154 => {
                    self.profile_name = ::std::option::Option::Some(is.read_string()?);
                },
                160 => {
                    self.start_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.curr_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.laps_completed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.curr_hero_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.curr_lap_time_started {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.curr_lap_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.best_lap_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.best_lap_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.lap_heroes_completed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.lap_heroes_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.next_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(11, v);
        }
        if let Some(v) = self.prev_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(12, v);
        }
        if let Some(v) = self.prev_hero_games {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.prev_avg_tries {
            my_size += 1 + 4;
        }
        if let Some(v) = self.curr_avg_tries {
            my_size += 1 + 4;
        }
        if let Some(v) = self.next_avg_tries {
            my_size += 2 + 4;
        }
        if let Some(v) = self.full_lap_avg_tries {
            my_size += 2 + 4;
        }
        if let Some(v) = self.curr_lap_avg_tries {
            my_size += 2 + 4;
        }
        if let Some(v) = self.profile_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(19, &v);
        }
        if let Some(v) = self.start_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(20, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.curr_hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.laps_completed {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.curr_hero_games {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.curr_lap_time_started {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.curr_lap_games {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.best_lap_games {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.best_lap_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.lap_heroes_completed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.lap_heroes_remaining {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.next_hero_id {
            os.write_int32(11, v)?;
        }
        if let Some(v) = self.prev_hero_id {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.prev_hero_games {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.prev_avg_tries {
            os.write_float(14, v)?;
        }
        if let Some(v) = self.curr_avg_tries {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.next_avg_tries {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.full_lap_avg_tries {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.curr_lap_avg_tries {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.profile_name.as_ref() {
            os.write_string(19, v)?;
        }
        if let Some(v) = self.start_hero_id {
            os.write_int32(20, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetAllHeroProgressResponse {
        CMsgClientToGCGetAllHeroProgressResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.curr_hero_id = ::std::option::Option::None;
        self.laps_completed = ::std::option::Option::None;
        self.curr_hero_games = ::std::option::Option::None;
        self.curr_lap_time_started = ::std::option::Option::None;
        self.curr_lap_games = ::std::option::Option::None;
        self.best_lap_games = ::std::option::Option::None;
        self.best_lap_time = ::std::option::Option::None;
        self.lap_heroes_completed = ::std::option::Option::None;
        self.lap_heroes_remaining = ::std::option::Option::None;
        self.next_hero_id = ::std::option::Option::None;
        self.prev_hero_id = ::std::option::Option::None;
        self.prev_hero_games = ::std::option::Option::None;
        self.prev_avg_tries = ::std::option::Option::None;
        self.curr_avg_tries = ::std::option::Option::None;
        self.next_avg_tries = ::std::option::Option::None;
        self.full_lap_avg_tries = ::std::option::Option::None;
        self.curr_lap_avg_tries = ::std::option::Option::None;
        self.profile_name = ::std::option::Option::None;
        self.start_hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetAllHeroProgressResponse {
        static instance: CMsgClientToGCGetAllHeroProgressResponse = CMsgClientToGCGetAllHeroProgressResponse {
            account_id: ::std::option::Option::None,
            curr_hero_id: ::std::option::Option::None,
            laps_completed: ::std::option::Option::None,
            curr_hero_games: ::std::option::Option::None,
            curr_lap_time_started: ::std::option::Option::None,
            curr_lap_games: ::std::option::Option::None,
            best_lap_games: ::std::option::Option::None,
            best_lap_time: ::std::option::Option::None,
            lap_heroes_completed: ::std::option::Option::None,
            lap_heroes_remaining: ::std::option::Option::None,
            next_hero_id: ::std::option::Option::None,
            prev_hero_id: ::std::option::Option::None,
            prev_hero_games: ::std::option::Option::None,
            prev_avg_tries: ::std::option::Option::None,
            curr_avg_tries: ::std::option::Option::None,
            next_avg_tries: ::std::option::Option::None,
            full_lap_avg_tries: ::std::option::Option::None,
            curr_lap_avg_tries: ::std::option::Option::None,
            profile_name: ::std::option::Option::None,
            start_hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetTrophyList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetTrophyList {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetTrophyList.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetTrophyList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetTrophyList {
    fn default() -> &'a CMsgClientToGCGetTrophyList {
        <CMsgClientToGCGetTrophyList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetTrophyList {
    pub fn new() -> CMsgClientToGCGetTrophyList {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetTrophyList {
    const NAME: &'static str = "CMsgClientToGCGetTrophyList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetTrophyList {
        CMsgClientToGCGetTrophyList::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetTrophyList {
        static instance: CMsgClientToGCGetTrophyList = CMsgClientToGCGetTrophyList {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetTrophyListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetTrophyListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetTrophyListResponse.trophies)
    pub trophies: ::std::vec::Vec<cmsg_client_to_gcget_trophy_list_response::Trophy>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetTrophyListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetTrophyListResponse {
    fn default() -> &'a CMsgClientToGCGetTrophyListResponse {
        <CMsgClientToGCGetTrophyListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetTrophyListResponse {
    pub fn new() -> CMsgClientToGCGetTrophyListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetTrophyListResponse {
    const NAME: &'static str = "CMsgClientToGCGetTrophyListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.trophies.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.trophies {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.trophies {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetTrophyListResponse {
        CMsgClientToGCGetTrophyListResponse::new()
    }

    fn clear(&mut self) {
        self.trophies.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetTrophyListResponse {
        static instance: CMsgClientToGCGetTrophyListResponse = CMsgClientToGCGetTrophyListResponse {
            trophies: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetTrophyListResponse`
pub mod cmsg_client_to_gcget_trophy_list_response {
    // @@protoc_insertion_point(message:CMsgClientToGCGetTrophyListResponse.Trophy)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Trophy {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetTrophyListResponse.Trophy.trophy_id)
        pub trophy_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetTrophyListResponse.Trophy.trophy_score)
        pub trophy_score: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetTrophyListResponse.Trophy.last_updated)
        pub last_updated: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetTrophyListResponse.Trophy.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Trophy {
        fn default() -> &'a Trophy {
            <Trophy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Trophy {
        pub fn new() -> Trophy {
            ::std::default::Default::default()
        }

        // optional uint32 trophy_id = 1;

        pub fn trophy_id(&self) -> u32 {
            self.trophy_id.unwrap_or(0)
        }

        pub fn clear_trophy_id(&mut self) {
            self.trophy_id = ::std::option::Option::None;
        }

        pub fn has_trophy_id(&self) -> bool {
            self.trophy_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trophy_id(&mut self, v: u32) {
            self.trophy_id = ::std::option::Option::Some(v);
        }

        // optional uint32 trophy_score = 2;

        pub fn trophy_score(&self) -> u32 {
            self.trophy_score.unwrap_or(0)
        }

        pub fn clear_trophy_score(&mut self) {
            self.trophy_score = ::std::option::Option::None;
        }

        pub fn has_trophy_score(&self) -> bool {
            self.trophy_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trophy_score(&mut self, v: u32) {
            self.trophy_score = ::std::option::Option::Some(v);
        }

        // optional uint32 last_updated = 3;

        pub fn last_updated(&self) -> u32 {
            self.last_updated.unwrap_or(0)
        }

        pub fn clear_last_updated(&mut self) {
            self.last_updated = ::std::option::Option::None;
        }

        pub fn has_last_updated(&self) -> bool {
            self.last_updated.is_some()
        }

        // Param is passed by value, moved
        pub fn set_last_updated(&mut self, v: u32) {
            self.last_updated = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Trophy {
        const NAME: &'static str = "Trophy";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.trophy_score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.trophy_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.trophy_score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.last_updated {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.trophy_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.trophy_score {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.last_updated {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Trophy {
            Trophy::new()
        }

        fn clear(&mut self) {
            self.trophy_id = ::std::option::Option::None;
            self.trophy_score = ::std::option::Option::None;
            self.last_updated = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Trophy {
            static instance: Trophy = Trophy {
                trophy_id: ::std::option::Option::None,
                trophy_score: ::std::option::Option::None,
                last_updated: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientTrophyAwarded)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientTrophyAwarded {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientTrophyAwarded.trophy_id)
    pub trophy_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientTrophyAwarded.trophy_score)
    pub trophy_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientTrophyAwarded.trophy_old_score)
    pub trophy_old_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientTrophyAwarded.last_updated)
    pub last_updated: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientTrophyAwarded.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientTrophyAwarded {
    fn default() -> &'a CMsgGCToClientTrophyAwarded {
        <CMsgGCToClientTrophyAwarded as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientTrophyAwarded {
    pub fn new() -> CMsgGCToClientTrophyAwarded {
        ::std::default::Default::default()
    }

    // optional uint32 trophy_id = 1;

    pub fn trophy_id(&self) -> u32 {
        self.trophy_id.unwrap_or(0)
    }

    pub fn clear_trophy_id(&mut self) {
        self.trophy_id = ::std::option::Option::None;
    }

    pub fn has_trophy_id(&self) -> bool {
        self.trophy_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_id(&mut self, v: u32) {
        self.trophy_id = ::std::option::Option::Some(v);
    }

    // optional uint32 trophy_score = 2;

    pub fn trophy_score(&self) -> u32 {
        self.trophy_score.unwrap_or(0)
    }

    pub fn clear_trophy_score(&mut self) {
        self.trophy_score = ::std::option::Option::None;
    }

    pub fn has_trophy_score(&self) -> bool {
        self.trophy_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_score(&mut self, v: u32) {
        self.trophy_score = ::std::option::Option::Some(v);
    }

    // optional uint32 trophy_old_score = 3;

    pub fn trophy_old_score(&self) -> u32 {
        self.trophy_old_score.unwrap_or(0)
    }

    pub fn clear_trophy_old_score(&mut self) {
        self.trophy_old_score = ::std::option::Option::None;
    }

    pub fn has_trophy_old_score(&self) -> bool {
        self.trophy_old_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trophy_old_score(&mut self, v: u32) {
        self.trophy_old_score = ::std::option::Option::Some(v);
    }

    // optional uint32 last_updated = 4;

    pub fn last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientTrophyAwarded {
    const NAME: &'static str = "CMsgGCToClientTrophyAwarded";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trophy_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.trophy_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.trophy_old_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trophy_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.trophy_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.trophy_old_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.last_updated {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.trophy_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.trophy_score {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.trophy_old_score {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.last_updated {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientTrophyAwarded {
        CMsgGCToClientTrophyAwarded::new()
    }

    fn clear(&mut self) {
        self.trophy_id = ::std::option::Option::None;
        self.trophy_score = ::std::option::Option::None;
        self.trophy_old_score = ::std::option::Option::None;
        self.last_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientTrophyAwarded {
        static instance: CMsgGCToClientTrophyAwarded = CMsgGCToClientTrophyAwarded {
            trophy_id: ::std::option::Option::None,
            trophy_score: ::std::option::Option::None,
            trophy_old_score: ::std::option::Option::None,
            last_updated: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRankRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRankRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRankRequest.rank_type)
    pub rank_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ERankType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRankRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRankRequest {
    fn default() -> &'a CMsgClientToGCRankRequest {
        <CMsgClientToGCRankRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRankRequest {
    pub fn new() -> CMsgClientToGCRankRequest {
        ::std::default::Default::default()
    }

    // optional .ERankType rank_type = 1;

    pub fn rank_type(&self) -> super::dota_shared_enums::ERankType {
        match self.rank_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ERankType::k_ERankType_Invalid),
            None => super::dota_shared_enums::ERankType::k_ERankType_Invalid,
        }
    }

    pub fn clear_rank_type(&mut self) {
        self.rank_type = ::std::option::Option::None;
    }

    pub fn has_rank_type(&self) -> bool {
        self.rank_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type(&mut self, v: super::dota_shared_enums::ERankType) {
        self.rank_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRankRequest {
    const NAME: &'static str = "CMsgClientToGCRankRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rank_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rank_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rank_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRankRequest {
        CMsgClientToGCRankRequest::new()
    }

    fn clear(&mut self) {
        self.rank_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRankRequest {
        static instance: CMsgClientToGCRankRequest = CMsgClientToGCRankRequest {
            rank_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRankResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRankResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRankResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_rank_response::EResultCode>>,
    // @@protoc_insertion_point(field:CMsgGCToClientRankResponse.rank_value)
    pub rank_value: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientRankResponse.rank_data1)
    pub rank_data1: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientRankResponse.rank_data2)
    pub rank_data2: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientRankResponse.rank_data3)
    pub rank_data3: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRankResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRankResponse {
    fn default() -> &'a CMsgGCToClientRankResponse {
        <CMsgGCToClientRankResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRankResponse {
    pub fn new() -> CMsgGCToClientRankResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientRankResponse.EResultCode result = 1;

    pub fn result(&self) -> cmsg_gcto_client_rank_response::EResultCode {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcto_client_rank_response::EResultCode::k_Succeeded),
            None => cmsg_gcto_client_rank_response::EResultCode::k_Succeeded,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcto_client_rank_response::EResultCode) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 rank_value = 2;

    pub fn rank_value(&self) -> u32 {
        self.rank_value.unwrap_or(0)
    }

    pub fn clear_rank_value(&mut self) {
        self.rank_value = ::std::option::Option::None;
    }

    pub fn has_rank_value(&self) -> bool {
        self.rank_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_value(&mut self, v: u32) {
        self.rank_value = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_data1 = 3;

    pub fn rank_data1(&self) -> u32 {
        self.rank_data1.unwrap_or(0)
    }

    pub fn clear_rank_data1(&mut self) {
        self.rank_data1 = ::std::option::Option::None;
    }

    pub fn has_rank_data1(&self) -> bool {
        self.rank_data1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_data1(&mut self, v: u32) {
        self.rank_data1 = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_data2 = 4;

    pub fn rank_data2(&self) -> u32 {
        self.rank_data2.unwrap_or(0)
    }

    pub fn clear_rank_data2(&mut self) {
        self.rank_data2 = ::std::option::Option::None;
    }

    pub fn has_rank_data2(&self) -> bool {
        self.rank_data2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_data2(&mut self, v: u32) {
        self.rank_data2 = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_data3 = 5;

    pub fn rank_data3(&self) -> u32 {
        self.rank_data3.unwrap_or(0)
    }

    pub fn clear_rank_data3(&mut self) {
        self.rank_data3 = ::std::option::Option::None;
    }

    pub fn has_rank_data3(&self) -> bool {
        self.rank_data3.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_data3(&mut self, v: u32) {
        self.rank_data3 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRankResponse {
    const NAME: &'static str = "CMsgGCToClientRankResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.rank_value = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.rank_data1 = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.rank_data2 = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.rank_data3 = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rank_value {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.rank_data1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.rank_data2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.rank_data3 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rank_value {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.rank_data1 {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.rank_data2 {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rank_data3 {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRankResponse {
        CMsgGCToClientRankResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.rank_value = ::std::option::Option::None;
        self.rank_data1 = ::std::option::Option::None;
        self.rank_data2 = ::std::option::Option::None;
        self.rank_data3 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRankResponse {
        static instance: CMsgGCToClientRankResponse = CMsgGCToClientRankResponse {
            result: ::std::option::Option::None,
            rank_value: ::std::option::Option::None,
            rank_data1: ::std::option::Option::None,
            rank_data2: ::std::option::Option::None,
            rank_data3: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientRankResponse`
pub mod cmsg_gcto_client_rank_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientRankResponse.EResultCode)
    pub enum EResultCode {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRankResponse.EResultCode.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRankResponse.EResultCode.k_Failed)
        k_Failed = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRankResponse.EResultCode.k_InvalidRankType)
        k_InvalidRankType = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResultCode {
        const NAME: &'static str = "EResultCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResultCode> {
            match value {
                0 => ::std::option::Option::Some(EResultCode::k_Succeeded),
                1 => ::std::option::Option::Some(EResultCode::k_Failed),
                2 => ::std::option::Option::Some(EResultCode::k_InvalidRankType),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResultCode> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResultCode::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResultCode::k_Failed),
                "k_InvalidRankType" => ::std::option::Option::Some(EResultCode::k_InvalidRankType),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResultCode] = &[
            EResultCode::k_Succeeded,
            EResultCode::k_Failed,
            EResultCode::k_InvalidRankType,
        ];
    }

    impl ::std::default::Default for EResultCode {
        fn default() -> Self {
            EResultCode::k_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientRankUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRankUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRankUpdate.rank_type)
    pub rank_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ERankType>>,
    // @@protoc_insertion_point(field:CMsgGCToClientRankUpdate.rank_info)
    pub rank_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientRankResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRankUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRankUpdate {
    fn default() -> &'a CMsgGCToClientRankUpdate {
        <CMsgGCToClientRankUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRankUpdate {
    pub fn new() -> CMsgGCToClientRankUpdate {
        ::std::default::Default::default()
    }

    // optional .ERankType rank_type = 1;

    pub fn rank_type(&self) -> super::dota_shared_enums::ERankType {
        match self.rank_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ERankType::k_ERankType_Invalid),
            None => super::dota_shared_enums::ERankType::k_ERankType_Invalid,
        }
    }

    pub fn clear_rank_type(&mut self) {
        self.rank_type = ::std::option::Option::None;
    }

    pub fn has_rank_type(&self) -> bool {
        self.rank_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_type(&mut self, v: super::dota_shared_enums::ERankType) {
        self.rank_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRankUpdate {
    const NAME: &'static str = "CMsgGCToClientRankUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.rank_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.rank_info)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.rank_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.rank_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.rank_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.rank_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRankUpdate {
        CMsgGCToClientRankUpdate::new()
    }

    fn clear(&mut self) {
        self.rank_type = ::std::option::Option::None;
        self.rank_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRankUpdate {
        static instance: CMsgGCToClientRankUpdate = CMsgGCToClientRankUpdate {
            rank_type: ::std::option::Option::None,
            rank_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetProfileCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetProfileCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetProfileCard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetProfileCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetProfileCard {
    fn default() -> &'a CMsgClientToGCGetProfileCard {
        <CMsgClientToGCGetProfileCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetProfileCard {
    pub fn new() -> CMsgClientToGCGetProfileCard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetProfileCard {
    const NAME: &'static str = "CMsgClientToGCGetProfileCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetProfileCard {
        CMsgClientToGCGetProfileCard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetProfileCard {
        static instance: CMsgClientToGCGetProfileCard = CMsgClientToGCGetProfileCard {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetProfileCardSlots)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetProfileCardSlots {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetProfileCardSlots.slots)
    pub slots: ::std::vec::Vec<cmsg_client_to_gcset_profile_card_slots::CardSlot>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetProfileCardSlots.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetProfileCardSlots {
    fn default() -> &'a CMsgClientToGCSetProfileCardSlots {
        <CMsgClientToGCSetProfileCardSlots as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetProfileCardSlots {
    pub fn new() -> CMsgClientToGCSetProfileCardSlots {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetProfileCardSlots {
    const NAME: &'static str = "CMsgClientToGCSetProfileCardSlots";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slots.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetProfileCardSlots {
        CMsgClientToGCSetProfileCardSlots::new()
    }

    fn clear(&mut self) {
        self.slots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetProfileCardSlots {
        static instance: CMsgClientToGCSetProfileCardSlots = CMsgClientToGCSetProfileCardSlots {
            slots: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetProfileCardSlots`
pub mod cmsg_client_to_gcset_profile_card_slots {
    // @@protoc_insertion_point(message:CMsgClientToGCSetProfileCardSlots.CardSlot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CardSlot {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCSetProfileCardSlots.CardSlot.slot_id)
        pub slot_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCSetProfileCardSlots.CardSlot.slot_type)
        pub slot_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EProfileCardSlotType>>,
        // @@protoc_insertion_point(field:CMsgClientToGCSetProfileCardSlots.CardSlot.slot_value)
        pub slot_value: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCSetProfileCardSlots.CardSlot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CardSlot {
        fn default() -> &'a CardSlot {
            <CardSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CardSlot {
        pub fn new() -> CardSlot {
            ::std::default::Default::default()
        }

        // optional uint32 slot_id = 1;

        pub fn slot_id(&self) -> u32 {
            self.slot_id.unwrap_or(0)
        }

        pub fn clear_slot_id(&mut self) {
            self.slot_id = ::std::option::Option::None;
        }

        pub fn has_slot_id(&self) -> bool {
            self.slot_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_id(&mut self, v: u32) {
            self.slot_id = ::std::option::Option::Some(v);
        }

        // optional .EProfileCardSlotType slot_type = 2;

        pub fn slot_type(&self) -> super::super::dota_shared_enums::EProfileCardSlotType {
            match self.slot_type {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EProfileCardSlotType::k_EProfileCardSlotType_Empty),
                None => super::super::dota_shared_enums::EProfileCardSlotType::k_EProfileCardSlotType_Empty,
            }
        }

        pub fn clear_slot_type(&mut self) {
            self.slot_type = ::std::option::Option::None;
        }

        pub fn has_slot_type(&self) -> bool {
            self.slot_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_type(&mut self, v: super::super::dota_shared_enums::EProfileCardSlotType) {
            self.slot_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint64 slot_value = 3;

        pub fn slot_value(&self) -> u64 {
            self.slot_value.unwrap_or(0)
        }

        pub fn clear_slot_value(&mut self) {
            self.slot_value = ::std::option::Option::None;
        }

        pub fn has_slot_value(&self) -> bool {
            self.slot_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot_value(&mut self, v: u64) {
            self.slot_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CardSlot {
        const NAME: &'static str = "CardSlot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.slot_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    24 => {
                        self.slot_value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.slot_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.slot_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            if let Some(v) = self.slot_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.slot_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.slot_type {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.slot_value {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CardSlot {
            CardSlot::new()
        }

        fn clear(&mut self) {
            self.slot_id = ::std::option::Option::None;
            self.slot_type = ::std::option::Option::None;
            self.slot_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CardSlot {
            static instance: CardSlot = CardSlot {
                slot_id: ::std::option::Option::None,
                slot_type: ::std::option::Option::None,
                slot_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetProfileCardStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetProfileCardStats {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetProfileCardStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetProfileCardStats {
    fn default() -> &'a CMsgClientToGCGetProfileCardStats {
        <CMsgClientToGCGetProfileCardStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetProfileCardStats {
    pub fn new() -> CMsgClientToGCGetProfileCardStats {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetProfileCardStats {
    const NAME: &'static str = "CMsgClientToGCGetProfileCardStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetProfileCardStats {
        CMsgClientToGCGetProfileCardStats::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetProfileCardStats {
        static instance: CMsgClientToGCGetProfileCardStats = CMsgClientToGCGetProfileCardStats {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateHeroStatue)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateHeroStatue {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.source_item_id)
    pub source_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.sequence_name)
    pub sequence_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.cycle)
    pub cycle: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.wearables)
    pub wearables: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.inscription)
    pub inscription: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.styles)
    pub styles: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.reforger_item_id)
    pub reforger_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateHeroStatue.tournament_drop)
    pub tournament_drop: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateHeroStatue.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateHeroStatue {
    fn default() -> &'a CMsgClientToGCCreateHeroStatue {
        <CMsgClientToGCCreateHeroStatue as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateHeroStatue {
    pub fn new() -> CMsgClientToGCCreateHeroStatue {
        ::std::default::Default::default()
    }

    // optional uint64 source_item_id = 1;

    pub fn source_item_id(&self) -> u64 {
        self.source_item_id.unwrap_or(0)
    }

    pub fn clear_source_item_id(&mut self) {
        self.source_item_id = ::std::option::Option::None;
    }

    pub fn has_source_item_id(&self) -> bool {
        self.source_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source_item_id(&mut self, v: u64) {
        self.source_item_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 3;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional string sequence_name = 4;

    pub fn sequence_name(&self) -> &str {
        match self.sequence_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_sequence_name(&mut self) {
        self.sequence_name = ::std::option::Option::None;
    }

    pub fn has_sequence_name(&self) -> bool {
        self.sequence_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence_name(&mut self, v: ::std::string::String) {
        self.sequence_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence_name(&mut self) -> &mut ::std::string::String {
        if self.sequence_name.is_none() {
            self.sequence_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.sequence_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence_name(&mut self) -> ::std::string::String {
        self.sequence_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional float cycle = 5;

    pub fn cycle(&self) -> f32 {
        self.cycle.unwrap_or(0.)
    }

    pub fn clear_cycle(&mut self) {
        self.cycle = ::std::option::Option::None;
    }

    pub fn has_cycle(&self) -> bool {
        self.cycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cycle(&mut self, v: f32) {
        self.cycle = ::std::option::Option::Some(v);
    }

    // optional string inscription = 7;

    pub fn inscription(&self) -> &str {
        match self.inscription.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_inscription(&mut self) {
        self.inscription = ::std::option::Option::None;
    }

    pub fn has_inscription(&self) -> bool {
        self.inscription.is_some()
    }

    // Param is passed by value, moved
    pub fn set_inscription(&mut self, v: ::std::string::String) {
        self.inscription = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inscription(&mut self) -> &mut ::std::string::String {
        if self.inscription.is_none() {
            self.inscription = ::std::option::Option::Some(::std::string::String::new());
        }
        self.inscription.as_mut().unwrap()
    }

    // Take field
    pub fn take_inscription(&mut self) -> ::std::string::String {
        self.inscription.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 reforger_item_id = 9;

    pub fn reforger_item_id(&self) -> u64 {
        self.reforger_item_id.unwrap_or(0)
    }

    pub fn clear_reforger_item_id(&mut self) {
        self.reforger_item_id = ::std::option::Option::None;
    }

    pub fn has_reforger_item_id(&self) -> bool {
        self.reforger_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reforger_item_id(&mut self, v: u64) {
        self.reforger_item_id = ::std::option::Option::Some(v);
    }

    // optional bool tournament_drop = 10;

    pub fn tournament_drop(&self) -> bool {
        self.tournament_drop.unwrap_or(false)
    }

    pub fn clear_tournament_drop(&mut self) {
        self.tournament_drop = ::std::option::Option::None;
    }

    pub fn has_tournament_drop(&self) -> bool {
        self.tournament_drop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tournament_drop(&mut self, v: bool) {
        self.tournament_drop = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateHeroStatue {
    const NAME: &'static str = "CMsgClientToGCCreateHeroStatue";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.source_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.sequence_name = ::std::option::Option::Some(is.read_string()?);
                },
                45 => {
                    self.cycle = ::std::option::Option::Some(is.read_float()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.wearables)?;
                },
                48 => {
                    self.wearables.push(is.read_uint32()?);
                },
                58 => {
                    self.inscription = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.styles)?;
                },
                64 => {
                    self.styles.push(is.read_uint32()?);
                },
                72 => {
                    self.reforger_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                80 => {
                    self.tournament_drop = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.source_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.sequence_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.cycle {
            my_size += 1 + 4;
        }
        for value in &self.wearables {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
        };
        if let Some(v) = self.inscription.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(7, &v);
        }
        for value in &self.styles {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, *value);
        };
        if let Some(v) = self.reforger_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        if let Some(v) = self.tournament_drop {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.source_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.sequence_name.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.cycle {
            os.write_float(5, v)?;
        }
        for v in &self.wearables {
            os.write_uint32(6, *v)?;
        };
        if let Some(v) = self.inscription.as_ref() {
            os.write_string(7, v)?;
        }
        for v in &self.styles {
            os.write_uint32(8, *v)?;
        };
        if let Some(v) = self.reforger_item_id {
            os.write_uint64(9, v)?;
        }
        if let Some(v) = self.tournament_drop {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateHeroStatue {
        CMsgClientToGCCreateHeroStatue::new()
    }

    fn clear(&mut self) {
        self.source_item_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.sequence_name = ::std::option::Option::None;
        self.cycle = ::std::option::Option::None;
        self.wearables.clear();
        self.inscription = ::std::option::Option::None;
        self.styles.clear();
        self.reforger_item_id = ::std::option::Option::None;
        self.tournament_drop = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateHeroStatue {
        static instance: CMsgClientToGCCreateHeroStatue = CMsgClientToGCCreateHeroStatue {
            source_item_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            sequence_name: ::std::option::Option::None,
            cycle: ::std::option::Option::None,
            wearables: ::std::vec::Vec::new(),
            inscription: ::std::option::Option::None,
            styles: ::std::vec::Vec::new(),
            reforger_item_id: ::std::option::Option::None,
            tournament_drop: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientHeroStatueCreateResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientHeroStatueCreateResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientHeroStatueCreateResult.resulting_item_id)
    pub resulting_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientHeroStatueCreateResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientHeroStatueCreateResult {
    fn default() -> &'a CMsgGCToClientHeroStatueCreateResult {
        <CMsgGCToClientHeroStatueCreateResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientHeroStatueCreateResult {
    pub fn new() -> CMsgGCToClientHeroStatueCreateResult {
        ::std::default::Default::default()
    }

    // optional uint64 resulting_item_id = 1;

    pub fn resulting_item_id(&self) -> u64 {
        self.resulting_item_id.unwrap_or(0)
    }

    pub fn clear_resulting_item_id(&mut self) {
        self.resulting_item_id = ::std::option::Option::None;
    }

    pub fn has_resulting_item_id(&self) -> bool {
        self.resulting_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resulting_item_id(&mut self, v: u64) {
        self.resulting_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientHeroStatueCreateResult {
    const NAME: &'static str = "CMsgGCToClientHeroStatueCreateResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.resulting_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.resulting_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.resulting_item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientHeroStatueCreateResult {
        CMsgGCToClientHeroStatueCreateResult::new()
    }

    fn clear(&mut self) {
        self.resulting_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientHeroStatueCreateResult {
        static instance: CMsgGCToClientHeroStatueCreateResult = CMsgGCToClientHeroStatueCreateResult {
            resulting_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPlayerStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlayerStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerStatsRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlayerStatsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlayerStatsRequest {
    fn default() -> &'a CMsgClientToGCPlayerStatsRequest {
        <CMsgClientToGCPlayerStatsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlayerStatsRequest {
    pub fn new() -> CMsgClientToGCPlayerStatsRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlayerStatsRequest {
    const NAME: &'static str = "CMsgClientToGCPlayerStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlayerStatsRequest {
        CMsgClientToGCPlayerStatsRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlayerStatsRequest {
        static instance: CMsgClientToGCPlayerStatsRequest = CMsgClientToGCPlayerStatsRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPlayerStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPlayerStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.player_stats)
    pub player_stats: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.match_count)
    pub match_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_gpm)
    pub mean_gpm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_xppm)
    pub mean_xppm: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_lasthits)
    pub mean_lasthits: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.rampages)
    pub rampages: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.triple_kills)
    pub triple_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.first_blood_claimed)
    pub first_blood_claimed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.first_blood_given)
    pub first_blood_given: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.couriers_killed)
    pub couriers_killed: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.aegises_snatched)
    pub aegises_snatched: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.cheeses_eaten)
    pub cheeses_eaten: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.creeps_stacked)
    pub creeps_stacked: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.fight_score)
    pub fight_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.farm_score)
    pub farm_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.support_score)
    pub support_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.push_score)
    pub push_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.versatility_score)
    pub versatility_score: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_networth)
    pub mean_networth: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_damage)
    pub mean_damage: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.mean_heals)
    pub mean_heals: ::std::option::Option<f32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerStatsResponse.rapiers_purchased)
    pub rapiers_purchased: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPlayerStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPlayerStatsResponse {
    fn default() -> &'a CMsgGCToClientPlayerStatsResponse {
        <CMsgGCToClientPlayerStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPlayerStatsResponse {
    pub fn new() -> CMsgGCToClientPlayerStatsResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 match_count = 3;

    pub fn match_count(&self) -> u32 {
        self.match_count.unwrap_or(0)
    }

    pub fn clear_match_count(&mut self) {
        self.match_count = ::std::option::Option::None;
    }

    pub fn has_match_count(&self) -> bool {
        self.match_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_count(&mut self, v: u32) {
        self.match_count = ::std::option::Option::Some(v);
    }

    // optional float mean_gpm = 4;

    pub fn mean_gpm(&self) -> f32 {
        self.mean_gpm.unwrap_or(0.)
    }

    pub fn clear_mean_gpm(&mut self) {
        self.mean_gpm = ::std::option::Option::None;
    }

    pub fn has_mean_gpm(&self) -> bool {
        self.mean_gpm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_gpm(&mut self, v: f32) {
        self.mean_gpm = ::std::option::Option::Some(v);
    }

    // optional float mean_xppm = 5;

    pub fn mean_xppm(&self) -> f32 {
        self.mean_xppm.unwrap_or(0.)
    }

    pub fn clear_mean_xppm(&mut self) {
        self.mean_xppm = ::std::option::Option::None;
    }

    pub fn has_mean_xppm(&self) -> bool {
        self.mean_xppm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_xppm(&mut self, v: f32) {
        self.mean_xppm = ::std::option::Option::Some(v);
    }

    // optional float mean_lasthits = 6;

    pub fn mean_lasthits(&self) -> f32 {
        self.mean_lasthits.unwrap_or(0.)
    }

    pub fn clear_mean_lasthits(&mut self) {
        self.mean_lasthits = ::std::option::Option::None;
    }

    pub fn has_mean_lasthits(&self) -> bool {
        self.mean_lasthits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_lasthits(&mut self, v: f32) {
        self.mean_lasthits = ::std::option::Option::Some(v);
    }

    // optional uint32 rampages = 7;

    pub fn rampages(&self) -> u32 {
        self.rampages.unwrap_or(0)
    }

    pub fn clear_rampages(&mut self) {
        self.rampages = ::std::option::Option::None;
    }

    pub fn has_rampages(&self) -> bool {
        self.rampages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rampages(&mut self, v: u32) {
        self.rampages = ::std::option::Option::Some(v);
    }

    // optional uint32 triple_kills = 8;

    pub fn triple_kills(&self) -> u32 {
        self.triple_kills.unwrap_or(0)
    }

    pub fn clear_triple_kills(&mut self) {
        self.triple_kills = ::std::option::Option::None;
    }

    pub fn has_triple_kills(&self) -> bool {
        self.triple_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triple_kills(&mut self, v: u32) {
        self.triple_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_claimed = 9;

    pub fn first_blood_claimed(&self) -> u32 {
        self.first_blood_claimed.unwrap_or(0)
    }

    pub fn clear_first_blood_claimed(&mut self) {
        self.first_blood_claimed = ::std::option::Option::None;
    }

    pub fn has_first_blood_claimed(&self) -> bool {
        self.first_blood_claimed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_claimed(&mut self, v: u32) {
        self.first_blood_claimed = ::std::option::Option::Some(v);
    }

    // optional uint32 first_blood_given = 10;

    pub fn first_blood_given(&self) -> u32 {
        self.first_blood_given.unwrap_or(0)
    }

    pub fn clear_first_blood_given(&mut self) {
        self.first_blood_given = ::std::option::Option::None;
    }

    pub fn has_first_blood_given(&self) -> bool {
        self.first_blood_given.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_blood_given(&mut self, v: u32) {
        self.first_blood_given = ::std::option::Option::Some(v);
    }

    // optional uint32 couriers_killed = 11;

    pub fn couriers_killed(&self) -> u32 {
        self.couriers_killed.unwrap_or(0)
    }

    pub fn clear_couriers_killed(&mut self) {
        self.couriers_killed = ::std::option::Option::None;
    }

    pub fn has_couriers_killed(&self) -> bool {
        self.couriers_killed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_couriers_killed(&mut self, v: u32) {
        self.couriers_killed = ::std::option::Option::Some(v);
    }

    // optional uint32 aegises_snatched = 12;

    pub fn aegises_snatched(&self) -> u32 {
        self.aegises_snatched.unwrap_or(0)
    }

    pub fn clear_aegises_snatched(&mut self) {
        self.aegises_snatched = ::std::option::Option::None;
    }

    pub fn has_aegises_snatched(&self) -> bool {
        self.aegises_snatched.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aegises_snatched(&mut self, v: u32) {
        self.aegises_snatched = ::std::option::Option::Some(v);
    }

    // optional uint32 cheeses_eaten = 13;

    pub fn cheeses_eaten(&self) -> u32 {
        self.cheeses_eaten.unwrap_or(0)
    }

    pub fn clear_cheeses_eaten(&mut self) {
        self.cheeses_eaten = ::std::option::Option::None;
    }

    pub fn has_cheeses_eaten(&self) -> bool {
        self.cheeses_eaten.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheeses_eaten(&mut self, v: u32) {
        self.cheeses_eaten = ::std::option::Option::Some(v);
    }

    // optional uint32 creeps_stacked = 14;

    pub fn creeps_stacked(&self) -> u32 {
        self.creeps_stacked.unwrap_or(0)
    }

    pub fn clear_creeps_stacked(&mut self) {
        self.creeps_stacked = ::std::option::Option::None;
    }

    pub fn has_creeps_stacked(&self) -> bool {
        self.creeps_stacked.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creeps_stacked(&mut self, v: u32) {
        self.creeps_stacked = ::std::option::Option::Some(v);
    }

    // optional float fight_score = 15;

    pub fn fight_score(&self) -> f32 {
        self.fight_score.unwrap_or(0.)
    }

    pub fn clear_fight_score(&mut self) {
        self.fight_score = ::std::option::Option::None;
    }

    pub fn has_fight_score(&self) -> bool {
        self.fight_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fight_score(&mut self, v: f32) {
        self.fight_score = ::std::option::Option::Some(v);
    }

    // optional float farm_score = 16;

    pub fn farm_score(&self) -> f32 {
        self.farm_score.unwrap_or(0.)
    }

    pub fn clear_farm_score(&mut self) {
        self.farm_score = ::std::option::Option::None;
    }

    pub fn has_farm_score(&self) -> bool {
        self.farm_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_farm_score(&mut self, v: f32) {
        self.farm_score = ::std::option::Option::Some(v);
    }

    // optional float support_score = 17;

    pub fn support_score(&self) -> f32 {
        self.support_score.unwrap_or(0.)
    }

    pub fn clear_support_score(&mut self) {
        self.support_score = ::std::option::Option::None;
    }

    pub fn has_support_score(&self) -> bool {
        self.support_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_support_score(&mut self, v: f32) {
        self.support_score = ::std::option::Option::Some(v);
    }

    // optional float push_score = 18;

    pub fn push_score(&self) -> f32 {
        self.push_score.unwrap_or(0.)
    }

    pub fn clear_push_score(&mut self) {
        self.push_score = ::std::option::Option::None;
    }

    pub fn has_push_score(&self) -> bool {
        self.push_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_push_score(&mut self, v: f32) {
        self.push_score = ::std::option::Option::Some(v);
    }

    // optional float versatility_score = 19;

    pub fn versatility_score(&self) -> f32 {
        self.versatility_score.unwrap_or(0.)
    }

    pub fn clear_versatility_score(&mut self) {
        self.versatility_score = ::std::option::Option::None;
    }

    pub fn has_versatility_score(&self) -> bool {
        self.versatility_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_versatility_score(&mut self, v: f32) {
        self.versatility_score = ::std::option::Option::Some(v);
    }

    // optional float mean_networth = 20;

    pub fn mean_networth(&self) -> f32 {
        self.mean_networth.unwrap_or(0.)
    }

    pub fn clear_mean_networth(&mut self) {
        self.mean_networth = ::std::option::Option::None;
    }

    pub fn has_mean_networth(&self) -> bool {
        self.mean_networth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_networth(&mut self, v: f32) {
        self.mean_networth = ::std::option::Option::Some(v);
    }

    // optional float mean_damage = 21;

    pub fn mean_damage(&self) -> f32 {
        self.mean_damage.unwrap_or(0.)
    }

    pub fn clear_mean_damage(&mut self) {
        self.mean_damage = ::std::option::Option::None;
    }

    pub fn has_mean_damage(&self) -> bool {
        self.mean_damage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_damage(&mut self, v: f32) {
        self.mean_damage = ::std::option::Option::Some(v);
    }

    // optional float mean_heals = 22;

    pub fn mean_heals(&self) -> f32 {
        self.mean_heals.unwrap_or(0.)
    }

    pub fn clear_mean_heals(&mut self) {
        self.mean_heals = ::std::option::Option::None;
    }

    pub fn has_mean_heals(&self) -> bool {
        self.mean_heals.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mean_heals(&mut self, v: f32) {
        self.mean_heals = ::std::option::Option::Some(v);
    }

    // optional uint32 rapiers_purchased = 23;

    pub fn rapiers_purchased(&self) -> u32 {
        self.rapiers_purchased.unwrap_or(0)
    }

    pub fn clear_rapiers_purchased(&mut self) {
        self.rapiers_purchased = ::std::option::Option::None;
    }

    pub fn has_rapiers_purchased(&self) -> bool {
        self.rapiers_purchased.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rapiers_purchased(&mut self, v: u32) {
        self.rapiers_purchased = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPlayerStatsResponse {
    const NAME: &'static str = "CMsgGCToClientPlayerStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_float_into(&mut self.player_stats)?;
                },
                21 => {
                    self.player_stats.push(is.read_float()?);
                },
                24 => {
                    self.match_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                37 => {
                    self.mean_gpm = ::std::option::Option::Some(is.read_float()?);
                },
                45 => {
                    self.mean_xppm = ::std::option::Option::Some(is.read_float()?);
                },
                53 => {
                    self.mean_lasthits = ::std::option::Option::Some(is.read_float()?);
                },
                56 => {
                    self.rampages = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.triple_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.first_blood_claimed = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.first_blood_given = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.couriers_killed = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.aegises_snatched = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.cheeses_eaten = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.creeps_stacked = ::std::option::Option::Some(is.read_uint32()?);
                },
                125 => {
                    self.fight_score = ::std::option::Option::Some(is.read_float()?);
                },
                133 => {
                    self.farm_score = ::std::option::Option::Some(is.read_float()?);
                },
                141 => {
                    self.support_score = ::std::option::Option::Some(is.read_float()?);
                },
                149 => {
                    self.push_score = ::std::option::Option::Some(is.read_float()?);
                },
                157 => {
                    self.versatility_score = ::std::option::Option::Some(is.read_float()?);
                },
                165 => {
                    self.mean_networth = ::std::option::Option::Some(is.read_float()?);
                },
                173 => {
                    self.mean_damage = ::std::option::Option::Some(is.read_float()?);
                },
                181 => {
                    self.mean_heals = ::std::option::Option::Some(is.read_float()?);
                },
                184 => {
                    self.rapiers_purchased = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += 5 * self.player_stats.len() as u64;
        if let Some(v) = self.match_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.mean_gpm {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mean_xppm {
            my_size += 1 + 4;
        }
        if let Some(v) = self.mean_lasthits {
            my_size += 1 + 4;
        }
        if let Some(v) = self.rampages {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.triple_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.first_blood_claimed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.first_blood_given {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.couriers_killed {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.aegises_snatched {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.cheeses_eaten {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        if let Some(v) = self.creeps_stacked {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.fight_score {
            my_size += 1 + 4;
        }
        if let Some(v) = self.farm_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.support_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.push_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.versatility_score {
            my_size += 2 + 4;
        }
        if let Some(v) = self.mean_networth {
            my_size += 2 + 4;
        }
        if let Some(v) = self.mean_damage {
            my_size += 2 + 4;
        }
        if let Some(v) = self.mean_heals {
            my_size += 2 + 4;
        }
        if let Some(v) = self.rapiers_purchased {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(23, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.player_stats {
            os.write_float(2, *v)?;
        };
        if let Some(v) = self.match_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.mean_gpm {
            os.write_float(4, v)?;
        }
        if let Some(v) = self.mean_xppm {
            os.write_float(5, v)?;
        }
        if let Some(v) = self.mean_lasthits {
            os.write_float(6, v)?;
        }
        if let Some(v) = self.rampages {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.triple_kills {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.first_blood_claimed {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.first_blood_given {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.couriers_killed {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.aegises_snatched {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.cheeses_eaten {
            os.write_uint32(13, v)?;
        }
        if let Some(v) = self.creeps_stacked {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.fight_score {
            os.write_float(15, v)?;
        }
        if let Some(v) = self.farm_score {
            os.write_float(16, v)?;
        }
        if let Some(v) = self.support_score {
            os.write_float(17, v)?;
        }
        if let Some(v) = self.push_score {
            os.write_float(18, v)?;
        }
        if let Some(v) = self.versatility_score {
            os.write_float(19, v)?;
        }
        if let Some(v) = self.mean_networth {
            os.write_float(20, v)?;
        }
        if let Some(v) = self.mean_damage {
            os.write_float(21, v)?;
        }
        if let Some(v) = self.mean_heals {
            os.write_float(22, v)?;
        }
        if let Some(v) = self.rapiers_purchased {
            os.write_uint32(23, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPlayerStatsResponse {
        CMsgGCToClientPlayerStatsResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.player_stats.clear();
        self.match_count = ::std::option::Option::None;
        self.mean_gpm = ::std::option::Option::None;
        self.mean_xppm = ::std::option::Option::None;
        self.mean_lasthits = ::std::option::Option::None;
        self.rampages = ::std::option::Option::None;
        self.triple_kills = ::std::option::Option::None;
        self.first_blood_claimed = ::std::option::Option::None;
        self.first_blood_given = ::std::option::Option::None;
        self.couriers_killed = ::std::option::Option::None;
        self.aegises_snatched = ::std::option::Option::None;
        self.cheeses_eaten = ::std::option::Option::None;
        self.creeps_stacked = ::std::option::Option::None;
        self.fight_score = ::std::option::Option::None;
        self.farm_score = ::std::option::Option::None;
        self.support_score = ::std::option::Option::None;
        self.push_score = ::std::option::Option::None;
        self.versatility_score = ::std::option::Option::None;
        self.mean_networth = ::std::option::Option::None;
        self.mean_damage = ::std::option::Option::None;
        self.mean_heals = ::std::option::Option::None;
        self.rapiers_purchased = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPlayerStatsResponse {
        static instance: CMsgGCToClientPlayerStatsResponse = CMsgGCToClientPlayerStatsResponse {
            account_id: ::std::option::Option::None,
            player_stats: ::std::vec::Vec::new(),
            match_count: ::std::option::Option::None,
            mean_gpm: ::std::option::Option::None,
            mean_xppm: ::std::option::Option::None,
            mean_lasthits: ::std::option::Option::None,
            rampages: ::std::option::Option::None,
            triple_kills: ::std::option::Option::None,
            first_blood_claimed: ::std::option::Option::None,
            first_blood_given: ::std::option::Option::None,
            couriers_killed: ::std::option::Option::None,
            aegises_snatched: ::std::option::Option::None,
            cheeses_eaten: ::std::option::Option::None,
            creeps_stacked: ::std::option::Option::None,
            fight_score: ::std::option::Option::None,
            farm_score: ::std::option::Option::None,
            support_score: ::std::option::Option::None,
            push_score: ::std::option::Option::None,
            versatility_score: ::std::option::Option::None,
            mean_networth: ::std::option::Option::None,
            mean_damage: ::std::option::Option::None,
            mean_heals: ::std::option::Option::None,
            rapiers_purchased: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCustomGamesFriendsPlayedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCustomGamesFriendsPlayedRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCustomGamesFriendsPlayedRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn default() -> &'a CMsgClientToGCCustomGamesFriendsPlayedRequest {
        <CMsgClientToGCCustomGamesFriendsPlayedRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCustomGamesFriendsPlayedRequest {
    pub fn new() -> CMsgClientToGCCustomGamesFriendsPlayedRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    const NAME: &'static str = "CMsgClientToGCCustomGamesFriendsPlayedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCustomGamesFriendsPlayedRequest {
        CMsgClientToGCCustomGamesFriendsPlayedRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCustomGamesFriendsPlayedRequest {
        static instance: CMsgClientToGCCustomGamesFriendsPlayedRequest = CMsgClientToGCCustomGamesFriendsPlayedRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientCustomGamesFriendsPlayedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCustomGamesFriendsPlayedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCustomGamesFriendsPlayedResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientCustomGamesFriendsPlayedResponse.games)
    pub games: ::std::vec::Vec<cmsg_gcto_client_custom_games_friends_played_response::CustomGame>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCustomGamesFriendsPlayedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn default() -> &'a CMsgGCToClientCustomGamesFriendsPlayedResponse {
        <CMsgGCToClientCustomGamesFriendsPlayedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCustomGamesFriendsPlayedResponse {
    pub fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    const NAME: &'static str = "CMsgGCToClientCustomGamesFriendsPlayedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.games.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.games {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.games {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCustomGamesFriendsPlayedResponse {
        CMsgGCToClientCustomGamesFriendsPlayedResponse::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.games.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCustomGamesFriendsPlayedResponse {
        static instance: CMsgGCToClientCustomGamesFriendsPlayedResponse = CMsgGCToClientCustomGamesFriendsPlayedResponse {
            account_id: ::std::option::Option::None,
            games: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientCustomGamesFriendsPlayedResponse`
pub mod cmsg_gcto_client_custom_games_friends_played_response {
    // @@protoc_insertion_point(message:CMsgGCToClientCustomGamesFriendsPlayedResponse.CustomGame)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CustomGame {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientCustomGamesFriendsPlayedResponse.CustomGame.custom_game_id)
        pub custom_game_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgGCToClientCustomGamesFriendsPlayedResponse.CustomGame.account_ids)
        pub account_ids: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientCustomGamesFriendsPlayedResponse.CustomGame.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CustomGame {
        fn default() -> &'a CustomGame {
            <CustomGame as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CustomGame {
        pub fn new() -> CustomGame {
            ::std::default::Default::default()
        }

        // optional uint64 custom_game_id = 1;

        pub fn custom_game_id(&self) -> u64 {
            self.custom_game_id.unwrap_or(0)
        }

        pub fn clear_custom_game_id(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
        }

        pub fn has_custom_game_id(&self) -> bool {
            self.custom_game_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_custom_game_id(&mut self, v: u64) {
            self.custom_game_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CustomGame {
        const NAME: &'static str = "CustomGame";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    18 => {
                        is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                    },
                    16 => {
                        self.account_ids.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.custom_game_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            for value in &self.account_ids {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.custom_game_id {
                os.write_uint64(1, v)?;
            }
            for v in &self.account_ids {
                os.write_uint32(2, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CustomGame {
            CustomGame::new()
        }

        fn clear(&mut self) {
            self.custom_game_id = ::std::option::Option::None;
            self.account_ids.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CustomGame {
            static instance: CustomGame = CustomGame {
                custom_game_id: ::std::option::Option::None,
                account_ids: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSocialFeedPostCommentRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSocialFeedPostCommentRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSocialFeedPostCommentRequest.event_id)
    pub event_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSocialFeedPostCommentRequest.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSocialFeedPostCommentRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSocialFeedPostCommentRequest {
    fn default() -> &'a CMsgClientToGCSocialFeedPostCommentRequest {
        <CMsgClientToGCSocialFeedPostCommentRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSocialFeedPostCommentRequest {
    pub fn new() -> CMsgClientToGCSocialFeedPostCommentRequest {
        ::std::default::Default::default()
    }

    // optional uint64 event_id = 1;

    pub fn event_id(&self) -> u64 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u64) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional string comment = 2;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSocialFeedPostCommentRequest {
    const NAME: &'static str = "CMsgClientToGCSocialFeedPostCommentRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSocialFeedPostCommentRequest {
        CMsgClientToGCSocialFeedPostCommentRequest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSocialFeedPostCommentRequest {
        static instance: CMsgClientToGCSocialFeedPostCommentRequest = CMsgClientToGCSocialFeedPostCommentRequest {
            event_id: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientSocialFeedPostCommentResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientSocialFeedPostCommentResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientSocialFeedPostCommentResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientSocialFeedPostCommentResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSocialFeedPostCommentResponse {
    fn default() -> &'a CMsgGCToClientSocialFeedPostCommentResponse {
        <CMsgGCToClientSocialFeedPostCommentResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSocialFeedPostCommentResponse {
    pub fn new() -> CMsgGCToClientSocialFeedPostCommentResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientSocialFeedPostCommentResponse {
    const NAME: &'static str = "CMsgGCToClientSocialFeedPostCommentResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientSocialFeedPostCommentResponse {
        CMsgGCToClientSocialFeedPostCommentResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientSocialFeedPostCommentResponse {
        static instance: CMsgGCToClientSocialFeedPostCommentResponse = CMsgGCToClientSocialFeedPostCommentResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSocialFeedPostMessageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSocialFeedPostMessageRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSocialFeedPostMessageRequest.message)
    pub message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCSocialFeedPostMessageRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSocialFeedPostMessageRequest.match_timestamp)
    pub match_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSocialFeedPostMessageRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSocialFeedPostMessageRequest {
    fn default() -> &'a CMsgClientToGCSocialFeedPostMessageRequest {
        <CMsgClientToGCSocialFeedPostMessageRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSocialFeedPostMessageRequest {
    pub fn new() -> CMsgClientToGCSocialFeedPostMessageRequest {
        ::std::default::Default::default()
    }

    // optional string message = 1;

    pub fn message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_message(&mut self) {
        self.message = ::std::option::Option::None;
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 match_timestamp = 3;

    pub fn match_timestamp(&self) -> u32 {
        self.match_timestamp.unwrap_or(0)
    }

    pub fn clear_match_timestamp(&mut self) {
        self.match_timestamp = ::std::option::Option::None;
    }

    pub fn has_match_timestamp(&self) -> bool {
        self.match_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_timestamp(&mut self, v: u32) {
        self.match_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSocialFeedPostMessageRequest {
    const NAME: &'static str = "CMsgClientToGCSocialFeedPostMessageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.message = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.match_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.match_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.message.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.match_timestamp {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSocialFeedPostMessageRequest {
        CMsgClientToGCSocialFeedPostMessageRequest::new()
    }

    fn clear(&mut self) {
        self.message = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.match_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSocialFeedPostMessageRequest {
        static instance: CMsgClientToGCSocialFeedPostMessageRequest = CMsgClientToGCSocialFeedPostMessageRequest {
            message: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            match_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientSocialFeedPostMessageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientSocialFeedPostMessageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientSocialFeedPostMessageResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientSocialFeedPostMessageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientSocialFeedPostMessageResponse {
    fn default() -> &'a CMsgGCToClientSocialFeedPostMessageResponse {
        <CMsgGCToClientSocialFeedPostMessageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientSocialFeedPostMessageResponse {
    pub fn new() -> CMsgGCToClientSocialFeedPostMessageResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientSocialFeedPostMessageResponse {
    const NAME: &'static str = "CMsgGCToClientSocialFeedPostMessageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientSocialFeedPostMessageResponse {
        CMsgGCToClientSocialFeedPostMessageResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientSocialFeedPostMessageResponse {
        static instance: CMsgGCToClientSocialFeedPostMessageResponse = CMsgGCToClientSocialFeedPostMessageResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCFriendsPlayedCustomGameRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCFriendsPlayedCustomGameRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCFriendsPlayedCustomGameRequest.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCFriendsPlayedCustomGameRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn default() -> &'a CMsgClientToGCFriendsPlayedCustomGameRequest {
        <CMsgClientToGCFriendsPlayedCustomGameRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCFriendsPlayedCustomGameRequest {
    pub fn new() -> CMsgClientToGCFriendsPlayedCustomGameRequest {
        ::std::default::Default::default()
    }

    // optional uint64 custom_game_id = 1;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCFriendsPlayedCustomGameRequest {
    const NAME: &'static str = "CMsgClientToGCFriendsPlayedCustomGameRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCFriendsPlayedCustomGameRequest {
        CMsgClientToGCFriendsPlayedCustomGameRequest::new()
    }

    fn clear(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCFriendsPlayedCustomGameRequest {
        static instance: CMsgClientToGCFriendsPlayedCustomGameRequest = CMsgClientToGCFriendsPlayedCustomGameRequest {
            custom_game_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientFriendsPlayedCustomGameResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientFriendsPlayedCustomGameResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientFriendsPlayedCustomGameResponse.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGCToClientFriendsPlayedCustomGameResponse.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientFriendsPlayedCustomGameResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn default() -> &'a CMsgGCToClientFriendsPlayedCustomGameResponse {
        <CMsgGCToClientFriendsPlayedCustomGameResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientFriendsPlayedCustomGameResponse {
    pub fn new() -> CMsgGCToClientFriendsPlayedCustomGameResponse {
        ::std::default::Default::default()
    }

    // optional uint64 custom_game_id = 1;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientFriendsPlayedCustomGameResponse {
    const NAME: &'static str = "CMsgGCToClientFriendsPlayedCustomGameResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.account_ids)?;
                },
                16 => {
                    self.account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.custom_game_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientFriendsPlayedCustomGameResponse {
        CMsgGCToClientFriendsPlayedCustomGameResponse::new()
    }

    fn clear(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientFriendsPlayedCustomGameResponse {
        static instance: CMsgGCToClientFriendsPlayedCustomGameResponse = CMsgGCToClientFriendsPlayedCustomGameResponse {
            custom_game_id: ::std::option::Option::None,
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAPartyRichPresence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPartyRichPresence {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.party_state)
    pub party_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common_match_management::csodotaparty::State>>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.open)
    pub open: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.low_priority)
    pub low_priority: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.team_name)
    pub team_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.ugc_team_ui_logo)
    pub ugc_team_ui_logo: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.members)
    pub members: ::std::vec::Vec<cmsg_dotaparty_rich_presence::Member>,
    // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.weekend_tourney)
    pub weekend_tourney: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaparty_rich_presence::WeekendTourney>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPartyRichPresence.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPartyRichPresence {
    fn default() -> &'a CMsgDOTAPartyRichPresence {
        <CMsgDOTAPartyRichPresence as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPartyRichPresence {
    pub fn new() -> CMsgDOTAPartyRichPresence {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional .CSODOTAParty.State party_state = 2;

    pub fn party_state(&self) -> super::dota_gcmessages_common_match_management::csodotaparty::State {
        match self.party_state {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_match_management::csodotaparty::State::UI),
            None => super::dota_gcmessages_common_match_management::csodotaparty::State::UI,
        }
    }

    pub fn clear_party_state(&mut self) {
        self.party_state = ::std::option::Option::None;
    }

    pub fn has_party_state(&self) -> bool {
        self.party_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_state(&mut self, v: super::dota_gcmessages_common_match_management::csodotaparty::State) {
        self.party_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool open = 3;

    pub fn open(&self) -> bool {
        self.open.unwrap_or(false)
    }

    pub fn clear_open(&mut self) {
        self.open = ::std::option::Option::None;
    }

    pub fn has_open(&self) -> bool {
        self.open.is_some()
    }

    // Param is passed by value, moved
    pub fn set_open(&mut self, v: bool) {
        self.open = ::std::option::Option::Some(v);
    }

    // optional bool low_priority = 5;

    pub fn low_priority(&self) -> bool {
        self.low_priority.unwrap_or(false)
    }

    pub fn clear_low_priority(&mut self) {
        self.low_priority = ::std::option::Option::None;
    }

    pub fn has_low_priority(&self) -> bool {
        self.low_priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_low_priority(&mut self, v: bool) {
        self.low_priority = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 7;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional string team_name = 8;

    pub fn team_name(&self) -> &str {
        match self.team_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_team_name(&mut self) {
        self.team_name = ::std::option::Option::None;
    }

    pub fn has_team_name(&self) -> bool {
        self.team_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_name(&mut self, v: ::std::string::String) {
        self.team_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_team_name(&mut self) -> &mut ::std::string::String {
        if self.team_name.is_none() {
            self.team_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.team_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_team_name(&mut self) -> ::std::string::String {
        self.team_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 ugc_team_ui_logo = 9;

    pub fn ugc_team_ui_logo(&self) -> u64 {
        self.ugc_team_ui_logo.unwrap_or(0)
    }

    pub fn clear_ugc_team_ui_logo(&mut self) {
        self.ugc_team_ui_logo = ::std::option::Option::None;
    }

    pub fn has_ugc_team_ui_logo(&self) -> bool {
        self.ugc_team_ui_logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ugc_team_ui_logo(&mut self, v: u64) {
        self.ugc_team_ui_logo = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPartyRichPresence {
    const NAME: &'static str = "CMsgDOTAPartyRichPresence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.party_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.open = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.low_priority = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                66 => {
                    self.team_name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.ugc_team_ui_logo = ::std::option::Option::Some(is.read_uint64()?);
                },
                34 => {
                    self.members.push(is.read_message()?);
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.weekend_tourney)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.party_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.open {
            my_size += 1 + 1;
        }
        if let Some(v) = self.low_priority {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.team_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.ugc_team_ui_logo {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(9, v);
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.weekend_tourney.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.party_state {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.open {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.low_priority {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.team_name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.ugc_team_ui_logo {
            os.write_uint64(9, v)?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.weekend_tourney.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPartyRichPresence {
        CMsgDOTAPartyRichPresence::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.party_state = ::std::option::Option::None;
        self.open = ::std::option::Option::None;
        self.low_priority = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.team_name = ::std::option::Option::None;
        self.ugc_team_ui_logo = ::std::option::Option::None;
        self.members.clear();
        self.weekend_tourney.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPartyRichPresence {
        static instance: CMsgDOTAPartyRichPresence = CMsgDOTAPartyRichPresence {
            party_id: ::std::option::Option::None,
            party_state: ::std::option::Option::None,
            open: ::std::option::Option::None,
            low_priority: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            team_name: ::std::option::Option::None,
            ugc_team_ui_logo: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            weekend_tourney: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAPartyRichPresence`
pub mod cmsg_dotaparty_rich_presence {
    // @@protoc_insertion_point(message:CMsgDOTAPartyRichPresence.Member)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Member {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.Member.steam_id)
        pub steam_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.Member.coach)
        pub coach: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAPartyRichPresence.Member.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Member {
        fn default() -> &'a Member {
            <Member as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Member {
        pub fn new() -> Member {
            ::std::default::Default::default()
        }

        // optional fixed64 steam_id = 1;

        pub fn steam_id(&self) -> u64 {
            self.steam_id.unwrap_or(0)
        }

        pub fn clear_steam_id(&mut self) {
            self.steam_id = ::std::option::Option::None;
        }

        pub fn has_steam_id(&self) -> bool {
            self.steam_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_steam_id(&mut self, v: u64) {
            self.steam_id = ::std::option::Option::Some(v);
        }

        // optional bool coach = 2;

        pub fn coach(&self) -> bool {
            self.coach.unwrap_or(false)
        }

        pub fn clear_coach(&mut self) {
            self.coach = ::std::option::Option::None;
        }

        pub fn has_coach(&self) -> bool {
            self.coach.is_some()
        }

        // Param is passed by value, moved
        pub fn set_coach(&mut self, v: bool) {
            self.coach = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Member {
        const NAME: &'static str = "Member";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    9 => {
                        self.steam_id = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    16 => {
                        self.coach = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.steam_id {
                my_size += 1 + 8;
            }
            if let Some(v) = self.coach {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.steam_id {
                os.write_fixed64(1, v)?;
            }
            if let Some(v) = self.coach {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Member {
            Member::new()
        }

        fn clear(&mut self) {
            self.steam_id = ::std::option::Option::None;
            self.coach = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Member {
            static instance: Member = Member {
                steam_id: ::std::option::Option::None,
                coach: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgDOTAPartyRichPresence.WeekendTourney)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeekendTourney {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.division)
        pub division: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.skill_level)
        pub skill_level: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.round)
        pub round: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.tournament_id)
        pub tournament_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.state_seq_num)
        pub state_seq_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.event)
        pub event: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::EWeekendTourneyRichPresenceEvent>>,
        // @@protoc_insertion_point(field:CMsgDOTAPartyRichPresence.WeekendTourney.event_round)
        pub event_round: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAPartyRichPresence.WeekendTourney.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeekendTourney {
        fn default() -> &'a WeekendTourney {
            <WeekendTourney as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WeekendTourney {
        pub fn new() -> WeekendTourney {
            ::std::default::Default::default()
        }

        // optional uint32 division = 1;

        pub fn division(&self) -> u32 {
            self.division.unwrap_or(0)
        }

        pub fn clear_division(&mut self) {
            self.division = ::std::option::Option::None;
        }

        pub fn has_division(&self) -> bool {
            self.division.is_some()
        }

        // Param is passed by value, moved
        pub fn set_division(&mut self, v: u32) {
            self.division = ::std::option::Option::Some(v);
        }

        // optional uint32 skill_level = 2;

        pub fn skill_level(&self) -> u32 {
            self.skill_level.unwrap_or(0)
        }

        pub fn clear_skill_level(&mut self) {
            self.skill_level = ::std::option::Option::None;
        }

        pub fn has_skill_level(&self) -> bool {
            self.skill_level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_skill_level(&mut self, v: u32) {
            self.skill_level = ::std::option::Option::Some(v);
        }

        // optional uint32 round = 3;

        pub fn round(&self) -> u32 {
            self.round.unwrap_or(0)
        }

        pub fn clear_round(&mut self) {
            self.round = ::std::option::Option::None;
        }

        pub fn has_round(&self) -> bool {
            self.round.is_some()
        }

        // Param is passed by value, moved
        pub fn set_round(&mut self, v: u32) {
            self.round = ::std::option::Option::Some(v);
        }

        // optional uint32 tournament_id = 4;

        pub fn tournament_id(&self) -> u32 {
            self.tournament_id.unwrap_or(0)
        }

        pub fn clear_tournament_id(&mut self) {
            self.tournament_id = ::std::option::Option::None;
        }

        pub fn has_tournament_id(&self) -> bool {
            self.tournament_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tournament_id(&mut self, v: u32) {
            self.tournament_id = ::std::option::Option::Some(v);
        }

        // optional uint32 state_seq_num = 5;

        pub fn state_seq_num(&self) -> u32 {
            self.state_seq_num.unwrap_or(0)
        }

        pub fn clear_state_seq_num(&mut self) {
            self.state_seq_num = ::std::option::Option::None;
        }

        pub fn has_state_seq_num(&self) -> bool {
            self.state_seq_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_state_seq_num(&mut self, v: u32) {
            self.state_seq_num = ::std::option::Option::Some(v);
        }

        // optional .EWeekendTourneyRichPresenceEvent event = 6;

        pub fn event(&self) -> super::EWeekendTourneyRichPresenceEvent {
            match self.event {
                Some(e) => e.enum_value_or(super::EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None),
                None => super::EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None,
            }
        }

        pub fn clear_event(&mut self) {
            self.event = ::std::option::Option::None;
        }

        pub fn has_event(&self) -> bool {
            self.event.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event(&mut self, v: super::EWeekendTourneyRichPresenceEvent) {
            self.event = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 event_round = 7;

        pub fn event_round(&self) -> u32 {
            self.event_round.unwrap_or(0)
        }

        pub fn clear_event_round(&mut self) {
            self.event_round = ::std::option::Option::None;
        }

        pub fn has_event_round(&self) -> bool {
            self.event_round.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_round(&mut self, v: u32) {
            self.event_round = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WeekendTourney {
        const NAME: &'static str = "WeekendTourney";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.division = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.skill_level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.round = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.tournament_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.state_seq_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.event = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    56 => {
                        self.event_round = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.division {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.skill_level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.round {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.tournament_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.state_seq_num {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.event {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
            }
            if let Some(v) = self.event_round {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.division {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.skill_level {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.round {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.tournament_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.state_seq_num {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.event {
                os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.event_round {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeekendTourney {
            WeekendTourney::new()
        }

        fn clear(&mut self) {
            self.division = ::std::option::Option::None;
            self.skill_level = ::std::option::Option::None;
            self.round = ::std::option::Option::None;
            self.tournament_id = ::std::option::Option::None;
            self.state_seq_num = ::std::option::Option::None;
            self.event = ::std::option::Option::None;
            self.event_round = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeekendTourney {
            static instance: WeekendTourney = WeekendTourney {
                division: ::std::option::Option::None,
                skill_level: ::std::option::Option::None,
                round: ::std::option::Option::None,
                tournament_id: ::std::option::Option::None,
                state_seq_num: ::std::option::Option::None,
                event: ::std::option::Option::None,
                event_round: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTALobbyRichPresence)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTALobbyRichPresence {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.lobby_state)
    pub lobby_state: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common_lobby::csodotalobby::State>>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.password)
    pub password: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.game_mode)
    pub game_mode: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTA_GameMode>>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.member_count)
    pub member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.max_member_count)
    pub max_member_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTALobbyRichPresence.lobby_type)
    pub lobby_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTALobbyRichPresence.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTALobbyRichPresence {
    fn default() -> &'a CMsgDOTALobbyRichPresence {
        <CMsgDOTALobbyRichPresence as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTALobbyRichPresence {
    pub fn new() -> CMsgDOTALobbyRichPresence {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional .CSODOTALobby.State lobby_state = 2;

    pub fn lobby_state(&self) -> super::dota_gcmessages_common_lobby::csodotalobby::State {
        match self.lobby_state {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common_lobby::csodotalobby::State::UI),
            None => super::dota_gcmessages_common_lobby::csodotalobby::State::UI,
        }
    }

    pub fn clear_lobby_state(&mut self) {
        self.lobby_state = ::std::option::Option::None;
    }

    pub fn has_lobby_state(&self) -> bool {
        self.lobby_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_state(&mut self, v: super::dota_gcmessages_common_lobby::csodotalobby::State) {
        self.lobby_state = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool password = 3;

    pub fn password(&self) -> bool {
        self.password.unwrap_or(false)
    }

    pub fn clear_password(&mut self) {
        self.password = ::std::option::Option::None;
    }

    pub fn has_password(&self) -> bool {
        self.password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: bool) {
        self.password = ::std::option::Option::Some(v);
    }

    // optional .DOTA_GameMode game_mode = 4;

    pub fn game_mode(&self) -> super::dota_shared_enums::DOTA_GameMode {
        match self.game_mode {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE),
            None => super::dota_shared_enums::DOTA_GameMode::DOTA_GAMEMODE_NONE,
        }
    }

    pub fn clear_game_mode(&mut self) {
        self.game_mode = ::std::option::Option::None;
    }

    pub fn has_game_mode(&self) -> bool {
        self.game_mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_mode(&mut self, v: super::dota_shared_enums::DOTA_GameMode) {
        self.game_mode = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 member_count = 5;

    pub fn member_count(&self) -> u32 {
        self.member_count.unwrap_or(0)
    }

    pub fn clear_member_count(&mut self) {
        self.member_count = ::std::option::Option::None;
    }

    pub fn has_member_count(&self) -> bool {
        self.member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_member_count(&mut self, v: u32) {
        self.member_count = ::std::option::Option::Some(v);
    }

    // optional uint32 max_member_count = 6;

    pub fn max_member_count(&self) -> u32 {
        self.max_member_count.unwrap_or(0)
    }

    pub fn clear_max_member_count(&mut self) {
        self.max_member_count = ::std::option::Option::None;
    }

    pub fn has_max_member_count(&self) -> bool {
        self.max_member_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_member_count(&mut self, v: u32) {
        self.max_member_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 custom_game_id = 7;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional string name = 8;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 lobby_type = 9;

    pub fn lobby_type(&self) -> u32 {
        self.lobby_type.unwrap_or(0)
    }

    pub fn clear_lobby_type(&mut self) {
        self.lobby_type = ::std::option::Option::None;
    }

    pub fn has_lobby_type(&self) -> bool {
        self.lobby_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_type(&mut self, v: u32) {
        self.lobby_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTALobbyRichPresence {
    const NAME: &'static str = "CMsgDOTALobbyRichPresence";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.lobby_state = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.password = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.game_mode = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.max_member_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                57 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                66 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.lobby_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.lobby_state {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.password {
            my_size += 1 + 1;
        }
        if let Some(v) = self.game_mode {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.member_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.max_member_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.custom_game_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.lobby_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.lobby_state {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.password {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.game_mode {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.member_count {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.max_member_count {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_fixed64(7, v)?;
        }
        if let Some(v) = self.name.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.lobby_type {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTALobbyRichPresence {
        CMsgDOTALobbyRichPresence::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.lobby_state = ::std::option::Option::None;
        self.password = ::std::option::Option::None;
        self.game_mode = ::std::option::Option::None;
        self.member_count = ::std::option::Option::None;
        self.max_member_count = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.name = ::std::option::Option::None;
        self.lobby_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTALobbyRichPresence {
        static instance: CMsgDOTALobbyRichPresence = CMsgDOTALobbyRichPresence {
            lobby_id: ::std::option::Option::None,
            lobby_state: ::std::option::Option::None,
            password: ::std::option::Option::None,
            game_mode: ::std::option::Option::None,
            member_count: ::std::option::Option::None,
            max_member_count: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            name: ::std::option::Option::None,
            lobby_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACustomGameListenServerStartedLoading)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACustomGameListenServerStartedLoading {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACustomGameListenServerStartedLoading.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameListenServerStartedLoading.custom_game_id)
    pub custom_game_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameListenServerStartedLoading.lobby_members)
    pub lobby_members: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameListenServerStartedLoading.start_time)
    pub start_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACustomGameListenServerStartedLoading.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACustomGameListenServerStartedLoading {
    fn default() -> &'a CMsgDOTACustomGameListenServerStartedLoading {
        <CMsgDOTACustomGameListenServerStartedLoading as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACustomGameListenServerStartedLoading {
    pub fn new() -> CMsgDOTACustomGameListenServerStartedLoading {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint64 custom_game_id = 2;

    pub fn custom_game_id(&self) -> u64 {
        self.custom_game_id.unwrap_or(0)
    }

    pub fn clear_custom_game_id(&mut self) {
        self.custom_game_id = ::std::option::Option::None;
    }

    pub fn has_custom_game_id(&self) -> bool {
        self.custom_game_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_custom_game_id(&mut self, v: u64) {
        self.custom_game_id = ::std::option::Option::Some(v);
    }

    // optional uint32 start_time = 4;

    pub fn start_time(&self) -> u32 {
        self.start_time.unwrap_or(0)
    }

    pub fn clear_start_time(&mut self) {
        self.start_time = ::std::option::Option::None;
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: u32) {
        self.start_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACustomGameListenServerStartedLoading {
    const NAME: &'static str = "CMsgDOTACustomGameListenServerStartedLoading";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.custom_game_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.lobby_members)?;
                },
                24 => {
                    self.lobby_members.push(is.read_uint32()?);
                },
                32 => {
                    self.start_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.custom_game_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.lobby_members {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        if let Some(v) = self.start_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.custom_game_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.lobby_members {
            os.write_uint32(3, *v)?;
        };
        if let Some(v) = self.start_time {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACustomGameListenServerStartedLoading {
        CMsgDOTACustomGameListenServerStartedLoading::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.custom_game_id = ::std::option::Option::None;
        self.lobby_members.clear();
        self.start_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACustomGameListenServerStartedLoading {
        static instance: CMsgDOTACustomGameListenServerStartedLoading = CMsgDOTACustomGameListenServerStartedLoading {
            lobby_id: ::std::option::Option::None,
            custom_game_id: ::std::option::Option::None,
            lobby_members: ::std::vec::Vec::new(),
            start_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTACustomGameClientFinishedLoading)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTACustomGameClientFinishedLoading {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.loading_duration)
    pub loading_duration: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.result_code)
    pub result_code: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.result_string)
    pub result_string: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.signon_states)
    pub signon_states: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTACustomGameClientFinishedLoading.comment)
    pub comment: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTACustomGameClientFinishedLoading.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTACustomGameClientFinishedLoading {
    fn default() -> &'a CMsgDOTACustomGameClientFinishedLoading {
        <CMsgDOTACustomGameClientFinishedLoading as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTACustomGameClientFinishedLoading {
    pub fn new() -> CMsgDOTACustomGameClientFinishedLoading {
        ::std::default::Default::default()
    }

    // optional fixed64 lobby_id = 1;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }

    // optional uint32 loading_duration = 2;

    pub fn loading_duration(&self) -> u32 {
        self.loading_duration.unwrap_or(0)
    }

    pub fn clear_loading_duration(&mut self) {
        self.loading_duration = ::std::option::Option::None;
    }

    pub fn has_loading_duration(&self) -> bool {
        self.loading_duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loading_duration(&mut self, v: u32) {
        self.loading_duration = ::std::option::Option::Some(v);
    }

    // optional sint32 result_code = 3;

    pub fn result_code(&self) -> i32 {
        self.result_code.unwrap_or(0)
    }

    pub fn clear_result_code(&mut self) {
        self.result_code = ::std::option::Option::None;
    }

    pub fn has_result_code(&self) -> bool {
        self.result_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_code(&mut self, v: i32) {
        self.result_code = ::std::option::Option::Some(v);
    }

    // optional string result_string = 4;

    pub fn result_string(&self) -> &str {
        match self.result_string.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_result_string(&mut self) {
        self.result_string = ::std::option::Option::None;
    }

    pub fn has_result_string(&self) -> bool {
        self.result_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result_string(&mut self, v: ::std::string::String) {
        self.result_string = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result_string(&mut self) -> &mut ::std::string::String {
        if self.result_string.is_none() {
            self.result_string = ::std::option::Option::Some(::std::string::String::new());
        }
        self.result_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_result_string(&mut self) -> ::std::string::String {
        self.result_string.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 signon_states = 5;

    pub fn signon_states(&self) -> u32 {
        self.signon_states.unwrap_or(0)
    }

    pub fn clear_signon_states(&mut self) {
        self.signon_states = ::std::option::Option::None;
    }

    pub fn has_signon_states(&self) -> bool {
        self.signon_states.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signon_states(&mut self, v: u32) {
        self.signon_states = ::std::option::Option::Some(v);
    }

    // optional string comment = 6;

    pub fn comment(&self) -> &str {
        match self.comment.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_comment(&mut self) {
        self.comment = ::std::option::Option::None;
    }

    pub fn has_comment(&self) -> bool {
        self.comment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment(&mut self, v: ::std::string::String) {
        self.comment = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comment(&mut self) -> &mut ::std::string::String {
        if self.comment.is_none() {
            self.comment = ::std::option::Option::Some(::std::string::String::new());
        }
        self.comment.as_mut().unwrap()
    }

    // Take field
    pub fn take_comment(&mut self) -> ::std::string::String {
        self.comment.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTACustomGameClientFinishedLoading {
    const NAME: &'static str = "CMsgDOTACustomGameClientFinishedLoading";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                16 => {
                    self.loading_duration = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.result_code = ::std::option::Option::Some(is.read_sint32()?);
                },
                34 => {
                    self.result_string = ::std::option::Option::Some(is.read_string()?);
                },
                40 => {
                    self.signon_states = ::std::option::Option::Some(is.read_uint32()?);
                },
                50 => {
                    self.comment = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.loading_duration {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.result_code {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.result_string.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.signon_states {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.comment.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(6, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.lobby_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.loading_duration {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.result_code {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.result_string.as_ref() {
            os.write_string(4, v)?;
        }
        if let Some(v) = self.signon_states {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.comment.as_ref() {
            os.write_string(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTACustomGameClientFinishedLoading {
        CMsgDOTACustomGameClientFinishedLoading::new()
    }

    fn clear(&mut self) {
        self.lobby_id = ::std::option::Option::None;
        self.loading_duration = ::std::option::Option::None;
        self.result_code = ::std::option::Option::None;
        self.result_string = ::std::option::Option::None;
        self.signon_states = ::std::option::Option::None;
        self.comment = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTACustomGameClientFinishedLoading {
        static instance: CMsgDOTACustomGameClientFinishedLoading = CMsgDOTACustomGameClientFinishedLoading {
            lobby_id: ::std::option::Option::None,
            loading_duration: ::std::option::Option::None,
            result_code: ::std::option::Option::None,
            result_string: ::std::option::Option::None,
            signon_states: ::std::option::Option::None,
            comment: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCApplyGemCombiner)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCApplyGemCombiner {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCApplyGemCombiner.item_id_1)
    pub item_id_1: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCApplyGemCombiner.item_id_2)
    pub item_id_2: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCApplyGemCombiner.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCApplyGemCombiner {
    fn default() -> &'a CMsgClientToGCApplyGemCombiner {
        <CMsgClientToGCApplyGemCombiner as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCApplyGemCombiner {
    pub fn new() -> CMsgClientToGCApplyGemCombiner {
        ::std::default::Default::default()
    }

    // optional uint64 item_id_1 = 1;

    pub fn item_id_1(&self) -> u64 {
        self.item_id_1.unwrap_or(0)
    }

    pub fn clear_item_id_1(&mut self) {
        self.item_id_1 = ::std::option::Option::None;
    }

    pub fn has_item_id_1(&self) -> bool {
        self.item_id_1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id_1(&mut self, v: u64) {
        self.item_id_1 = ::std::option::Option::Some(v);
    }

    // optional uint64 item_id_2 = 2;

    pub fn item_id_2(&self) -> u64 {
        self.item_id_2.unwrap_or(0)
    }

    pub fn clear_item_id_2(&mut self) {
        self.item_id_2 = ::std::option::Option::None;
    }

    pub fn has_item_id_2(&self) -> bool {
        self.item_id_2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id_2(&mut self, v: u64) {
        self.item_id_2 = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCApplyGemCombiner {
    const NAME: &'static str = "CMsgClientToGCApplyGemCombiner";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id_1 = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.item_id_2 = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id_1 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.item_id_2 {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id_1 {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.item_id_2 {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCApplyGemCombiner {
        CMsgClientToGCApplyGemCombiner::new()
    }

    fn clear(&mut self) {
        self.item_id_1 = ::std::option::Option::None;
        self.item_id_2 = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCApplyGemCombiner {
        static instance: CMsgClientToGCApplyGemCombiner = CMsgClientToGCApplyGemCombiner {
            item_id_1: ::std::option::Option::None,
            item_id_2: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCH264Unsupported)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCH264Unsupported {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCH264Unsupported.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCH264Unsupported {
    fn default() -> &'a CMsgClientToGCH264Unsupported {
        <CMsgClientToGCH264Unsupported as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCH264Unsupported {
    pub fn new() -> CMsgClientToGCH264Unsupported {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCH264Unsupported {
    const NAME: &'static str = "CMsgClientToGCH264Unsupported";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCH264Unsupported {
        CMsgClientToGCH264Unsupported::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCH264Unsupported {
        static instance: CMsgClientToGCH264Unsupported = CMsgClientToGCH264Unsupported {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetQuestProgress)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetQuestProgress {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgress.quest_ids)
    pub quest_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetQuestProgress.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetQuestProgress {
    fn default() -> &'a CMsgClientToGCGetQuestProgress {
        <CMsgClientToGCGetQuestProgress as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetQuestProgress {
    pub fn new() -> CMsgClientToGCGetQuestProgress {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetQuestProgress {
    const NAME: &'static str = "CMsgClientToGCGetQuestProgress";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint32_into(&mut self.quest_ids)?;
                },
                8 => {
                    self.quest_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.quest_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.quest_ids {
            os.write_uint32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetQuestProgress {
        CMsgClientToGCGetQuestProgress::new()
    }

    fn clear(&mut self) {
        self.quest_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetQuestProgress {
        static instance: CMsgClientToGCGetQuestProgress = CMsgClientToGCGetQuestProgress {
            quest_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetQuestProgressResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetQuestProgressResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.quests)
    pub quests: ::std::vec::Vec<cmsg_client_to_gcget_quest_progress_response::Quest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetQuestProgressResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetQuestProgressResponse {
    fn default() -> &'a CMsgClientToGCGetQuestProgressResponse {
        <CMsgClientToGCGetQuestProgressResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetQuestProgressResponse {
    pub fn new() -> CMsgClientToGCGetQuestProgressResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetQuestProgressResponse {
    const NAME: &'static str = "CMsgClientToGCGetQuestProgressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.quests.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        for value in &self.quests {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.quests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetQuestProgressResponse {
        CMsgClientToGCGetQuestProgressResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.quests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetQuestProgressResponse {
        static instance: CMsgClientToGCGetQuestProgressResponse = CMsgClientToGCGetQuestProgressResponse {
            success: ::std::option::Option::None,
            quests: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetQuestProgressResponse`
pub mod cmsg_client_to_gcget_quest_progress_response {
    // @@protoc_insertion_point(message:CMsgClientToGCGetQuestProgressResponse.Challenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Challenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.challenge_id)
        pub challenge_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.time_completed)
        pub time_completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.attempts)
        pub attempts: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.template_id)
        pub template_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Challenge.quest_rank)
        pub quest_rank: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetQuestProgressResponse.Challenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Challenge {
        fn default() -> &'a Challenge {
            <Challenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Challenge {
        pub fn new() -> Challenge {
            ::std::default::Default::default()
        }

        // optional uint32 challenge_id = 1;

        pub fn challenge_id(&self) -> u32 {
            self.challenge_id.unwrap_or(0)
        }

        pub fn clear_challenge_id(&mut self) {
            self.challenge_id = ::std::option::Option::None;
        }

        pub fn has_challenge_id(&self) -> bool {
            self.challenge_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id(&mut self, v: u32) {
            self.challenge_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_completed = 2;

        pub fn time_completed(&self) -> u32 {
            self.time_completed.unwrap_or(0)
        }

        pub fn clear_time_completed(&mut self) {
            self.time_completed = ::std::option::Option::None;
        }

        pub fn has_time_completed(&self) -> bool {
            self.time_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_completed(&mut self, v: u32) {
            self.time_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 attempts = 3;

        pub fn attempts(&self) -> u32 {
            self.attempts.unwrap_or(0)
        }

        pub fn clear_attempts(&mut self) {
            self.attempts = ::std::option::Option::None;
        }

        pub fn has_attempts(&self) -> bool {
            self.attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attempts(&mut self, v: u32) {
            self.attempts = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 4;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 template_id = 5;

        pub fn template_id(&self) -> u32 {
            self.template_id.unwrap_or(0)
        }

        pub fn clear_template_id(&mut self) {
            self.template_id = ::std::option::Option::None;
        }

        pub fn has_template_id(&self) -> bool {
            self.template_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_template_id(&mut self, v: u32) {
            self.template_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quest_rank = 6;

        pub fn quest_rank(&self) -> u32 {
            self.quest_rank.unwrap_or(0)
        }

        pub fn clear_quest_rank(&mut self) {
            self.quest_rank = ::std::option::Option::None;
        }

        pub fn has_quest_rank(&self) -> bool {
            self.quest_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_rank(&mut self, v: u32) {
            self.quest_rank = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Challenge {
        const NAME: &'static str = "Challenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.time_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.attempts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.template_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.challenge_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.attempts {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.template_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.quest_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.challenge_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_completed {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.attempts {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.template_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.quest_rank {
                os.write_uint32(6, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Challenge {
            Challenge::new()
        }

        fn clear(&mut self) {
            self.challenge_id = ::std::option::Option::None;
            self.time_completed = ::std::option::Option::None;
            self.attempts = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.template_id = ::std::option::Option::None;
            self.quest_rank = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Challenge {
            static instance: Challenge = Challenge {
                challenge_id: ::std::option::Option::None,
                time_completed: ::std::option::Option::None,
                attempts: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                template_id: ::std::option::Option::None,
                quest_rank: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCGetQuestProgressResponse.Quest)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Quest {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Quest.quest_id)
        pub quest_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetQuestProgressResponse.Quest.completed_challenges)
        pub completed_challenges: ::std::vec::Vec<Challenge>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetQuestProgressResponse.Quest.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Quest {
        fn default() -> &'a Quest {
            <Quest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Quest {
        pub fn new() -> Quest {
            ::std::default::Default::default()
        }

        // optional uint32 quest_id = 1;

        pub fn quest_id(&self) -> u32 {
            self.quest_id.unwrap_or(0)
        }

        pub fn clear_quest_id(&mut self) {
            self.quest_id = ::std::option::Option::None;
        }

        pub fn has_quest_id(&self) -> bool {
            self.quest_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_id(&mut self, v: u32) {
            self.quest_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Quest {
        const NAME: &'static str = "Quest";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.completed_challenges.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.quest_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.completed_challenges {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.quest_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.completed_challenges {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Quest {
            Quest::new()
        }

        fn clear(&mut self) {
            self.quest_id = ::std::option::Option::None;
            self.completed_challenges.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Quest {
            static instance: Quest = Quest {
                quest_id: ::std::option::Option::None,
                completed_challenges: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientMatchSignedOut)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientMatchSignedOut {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientMatchSignedOut.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientMatchSignedOut.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientMatchSignedOut {
    fn default() -> &'a CMsgGCToClientMatchSignedOut {
        <CMsgGCToClientMatchSignedOut as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientMatchSignedOut {
    pub fn new() -> CMsgGCToClientMatchSignedOut {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientMatchSignedOut {
    const NAME: &'static str = "CMsgGCToClientMatchSignedOut";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientMatchSignedOut {
        CMsgGCToClientMatchSignedOut::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientMatchSignedOut {
        static instance: CMsgGCToClientMatchSignedOut = CMsgGCToClientMatchSignedOut {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetHeroStatsHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetHeroStatsHistory {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetHeroStatsHistory.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetHeroStatsHistory.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetHeroStatsHistory {
    fn default() -> &'a CMsgGCGetHeroStatsHistory {
        <CMsgGCGetHeroStatsHistory as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetHeroStatsHistory {
    pub fn new() -> CMsgGCGetHeroStatsHistory {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetHeroStatsHistory {
    const NAME: &'static str = "CMsgGCGetHeroStatsHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetHeroStatsHistory {
        CMsgGCGetHeroStatsHistory::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetHeroStatsHistory {
        static instance: CMsgGCGetHeroStatsHistory = CMsgGCGetHeroStatsHistory {
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCGetHeroStatsHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCGetHeroStatsHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCGetHeroStatsHistoryResponse.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCGetHeroStatsHistoryResponse.records)
    pub records: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTASDOHeroStatsHistory>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCGetHeroStatsHistoryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCGetHeroStatsHistoryResponse {
    fn default() -> &'a CMsgGCGetHeroStatsHistoryResponse {
        <CMsgGCGetHeroStatsHistoryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCGetHeroStatsHistoryResponse {
    pub fn new() -> CMsgGCGetHeroStatsHistoryResponse {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCGetHeroStatsHistoryResponse {
    const NAME: &'static str = "CMsgGCGetHeroStatsHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.records.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.records {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        for v in &self.records {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCGetHeroStatsHistoryResponse {
        CMsgGCGetHeroStatsHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.records.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCGetHeroStatsHistoryResponse {
        static instance: CMsgGCGetHeroStatsHistoryResponse = CMsgGCGetHeroStatsHistoryResponse {
            hero_id: ::std::option::Option::None,
            records: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerConductScorecardRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerConductScorecardRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerConductScorecardRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerConductScorecardRequest {
    fn default() -> &'a CMsgPlayerConductScorecardRequest {
        <CMsgPlayerConductScorecardRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerConductScorecardRequest {
    pub fn new() -> CMsgPlayerConductScorecardRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerConductScorecardRequest {
    const NAME: &'static str = "CMsgPlayerConductScorecardRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerConductScorecardRequest {
        CMsgPlayerConductScorecardRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerConductScorecardRequest {
        static instance: CMsgPlayerConductScorecardRequest = CMsgPlayerConductScorecardRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPlayerConductScorecard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPlayerConductScorecard {
    // message fields
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.seq_num)
    pub seq_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.reasons)
    pub reasons: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.matches_in_report)
    pub matches_in_report: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.matches_clean)
    pub matches_clean: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.matches_reported)
    pub matches_reported: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.matches_abandoned)
    pub matches_abandoned: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.reports_count)
    pub reports_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.reports_parties)
    pub reports_parties: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.commend_count)
    pub commend_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.date)
    pub date: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.raw_behavior_score)
    pub raw_behavior_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.old_raw_behavior_score)
    pub old_raw_behavior_score: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.comms_reports)
    pub comms_reports: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.comms_parties)
    pub comms_parties: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPlayerConductScorecard.behavior_rating)
    pub behavior_rating: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_player_conduct_scorecard::EBehaviorRating>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPlayerConductScorecard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPlayerConductScorecard {
    fn default() -> &'a CMsgPlayerConductScorecard {
        <CMsgPlayerConductScorecard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPlayerConductScorecard {
    pub fn new() -> CMsgPlayerConductScorecard {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 seq_num = 3;

    pub fn seq_num(&self) -> u32 {
        self.seq_num.unwrap_or(0)
    }

    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: u32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // optional uint32 reasons = 4;

    pub fn reasons(&self) -> u32 {
        self.reasons.unwrap_or(0)
    }

    pub fn clear_reasons(&mut self) {
        self.reasons = ::std::option::Option::None;
    }

    pub fn has_reasons(&self) -> bool {
        self.reasons.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reasons(&mut self, v: u32) {
        self.reasons = ::std::option::Option::Some(v);
    }

    // optional uint32 matches_in_report = 5;

    pub fn matches_in_report(&self) -> u32 {
        self.matches_in_report.unwrap_or(0)
    }

    pub fn clear_matches_in_report(&mut self) {
        self.matches_in_report = ::std::option::Option::None;
    }

    pub fn has_matches_in_report(&self) -> bool {
        self.matches_in_report.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_in_report(&mut self, v: u32) {
        self.matches_in_report = ::std::option::Option::Some(v);
    }

    // optional uint32 matches_clean = 6;

    pub fn matches_clean(&self) -> u32 {
        self.matches_clean.unwrap_or(0)
    }

    pub fn clear_matches_clean(&mut self) {
        self.matches_clean = ::std::option::Option::None;
    }

    pub fn has_matches_clean(&self) -> bool {
        self.matches_clean.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_clean(&mut self, v: u32) {
        self.matches_clean = ::std::option::Option::Some(v);
    }

    // optional uint32 matches_reported = 7;

    pub fn matches_reported(&self) -> u32 {
        self.matches_reported.unwrap_or(0)
    }

    pub fn clear_matches_reported(&mut self) {
        self.matches_reported = ::std::option::Option::None;
    }

    pub fn has_matches_reported(&self) -> bool {
        self.matches_reported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_reported(&mut self, v: u32) {
        self.matches_reported = ::std::option::Option::Some(v);
    }

    // optional uint32 matches_abandoned = 8;

    pub fn matches_abandoned(&self) -> u32 {
        self.matches_abandoned.unwrap_or(0)
    }

    pub fn clear_matches_abandoned(&mut self) {
        self.matches_abandoned = ::std::option::Option::None;
    }

    pub fn has_matches_abandoned(&self) -> bool {
        self.matches_abandoned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_matches_abandoned(&mut self, v: u32) {
        self.matches_abandoned = ::std::option::Option::Some(v);
    }

    // optional uint32 reports_count = 9;

    pub fn reports_count(&self) -> u32 {
        self.reports_count.unwrap_or(0)
    }

    pub fn clear_reports_count(&mut self) {
        self.reports_count = ::std::option::Option::None;
    }

    pub fn has_reports_count(&self) -> bool {
        self.reports_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_count(&mut self, v: u32) {
        self.reports_count = ::std::option::Option::Some(v);
    }

    // optional uint32 reports_parties = 10;

    pub fn reports_parties(&self) -> u32 {
        self.reports_parties.unwrap_or(0)
    }

    pub fn clear_reports_parties(&mut self) {
        self.reports_parties = ::std::option::Option::None;
    }

    pub fn has_reports_parties(&self) -> bool {
        self.reports_parties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reports_parties(&mut self, v: u32) {
        self.reports_parties = ::std::option::Option::Some(v);
    }

    // optional uint32 commend_count = 11;

    pub fn commend_count(&self) -> u32 {
        self.commend_count.unwrap_or(0)
    }

    pub fn clear_commend_count(&mut self) {
        self.commend_count = ::std::option::Option::None;
    }

    pub fn has_commend_count(&self) -> bool {
        self.commend_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commend_count(&mut self, v: u32) {
        self.commend_count = ::std::option::Option::Some(v);
    }

    // optional uint32 date = 14;

    pub fn date(&self) -> u32 {
        self.date.unwrap_or(0)
    }

    pub fn clear_date(&mut self) {
        self.date = ::std::option::Option::None;
    }

    pub fn has_date(&self) -> bool {
        self.date.is_some()
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: u32) {
        self.date = ::std::option::Option::Some(v);
    }

    // optional uint32 raw_behavior_score = 17;

    pub fn raw_behavior_score(&self) -> u32 {
        self.raw_behavior_score.unwrap_or(0)
    }

    pub fn clear_raw_behavior_score(&mut self) {
        self.raw_behavior_score = ::std::option::Option::None;
    }

    pub fn has_raw_behavior_score(&self) -> bool {
        self.raw_behavior_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_raw_behavior_score(&mut self, v: u32) {
        self.raw_behavior_score = ::std::option::Option::Some(v);
    }

    // optional uint32 old_raw_behavior_score = 18;

    pub fn old_raw_behavior_score(&self) -> u32 {
        self.old_raw_behavior_score.unwrap_or(0)
    }

    pub fn clear_old_raw_behavior_score(&mut self) {
        self.old_raw_behavior_score = ::std::option::Option::None;
    }

    pub fn has_old_raw_behavior_score(&self) -> bool {
        self.old_raw_behavior_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_raw_behavior_score(&mut self, v: u32) {
        self.old_raw_behavior_score = ::std::option::Option::Some(v);
    }

    // optional uint32 comms_reports = 19;

    pub fn comms_reports(&self) -> u32 {
        self.comms_reports.unwrap_or(0)
    }

    pub fn clear_comms_reports(&mut self) {
        self.comms_reports = ::std::option::Option::None;
    }

    pub fn has_comms_reports(&self) -> bool {
        self.comms_reports.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comms_reports(&mut self, v: u32) {
        self.comms_reports = ::std::option::Option::Some(v);
    }

    // optional uint32 comms_parties = 20;

    pub fn comms_parties(&self) -> u32 {
        self.comms_parties.unwrap_or(0)
    }

    pub fn clear_comms_parties(&mut self) {
        self.comms_parties = ::std::option::Option::None;
    }

    pub fn has_comms_parties(&self) -> bool {
        self.comms_parties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comms_parties(&mut self, v: u32) {
        self.comms_parties = ::std::option::Option::Some(v);
    }

    // optional .CMsgPlayerConductScorecard.EBehaviorRating behavior_rating = 21;

    pub fn behavior_rating(&self) -> cmsg_player_conduct_scorecard::EBehaviorRating {
        match self.behavior_rating {
            Some(e) => e.enum_value_or(cmsg_player_conduct_scorecard::EBehaviorRating::k_eBehaviorGood),
            None => cmsg_player_conduct_scorecard::EBehaviorRating::k_eBehaviorGood,
        }
    }

    pub fn clear_behavior_rating(&mut self) {
        self.behavior_rating = ::std::option::Option::None;
    }

    pub fn has_behavior_rating(&self) -> bool {
        self.behavior_rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_behavior_rating(&mut self, v: cmsg_player_conduct_scorecard::EBehaviorRating) {
        self.behavior_rating = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPlayerConductScorecard {
    const NAME: &'static str = "CMsgPlayerConductScorecard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.seq_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.reasons = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.matches_in_report = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.matches_clean = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.matches_reported = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.matches_abandoned = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.reports_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.reports_parties = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.commend_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                112 => {
                    self.date = ::std::option::Option::Some(is.read_uint32()?);
                },
                136 => {
                    self.raw_behavior_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                144 => {
                    self.old_raw_behavior_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                152 => {
                    self.comms_reports = ::std::option::Option::Some(is.read_uint32()?);
                },
                160 => {
                    self.comms_parties = ::std::option::Option::Some(is.read_uint32()?);
                },
                168 => {
                    self.behavior_rating = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.seq_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.reasons {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.matches_in_report {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.matches_clean {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.matches_reported {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.matches_abandoned {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.reports_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.reports_parties {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.commend_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.date {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(14, v);
        }
        if let Some(v) = self.raw_behavior_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(17, v);
        }
        if let Some(v) = self.old_raw_behavior_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(18, v);
        }
        if let Some(v) = self.comms_reports {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(19, v);
        }
        if let Some(v) = self.comms_parties {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(20, v);
        }
        if let Some(v) = self.behavior_rating {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(21, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.reasons {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.matches_in_report {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.matches_clean {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.matches_reported {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.matches_abandoned {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.reports_count {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.reports_parties {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.commend_count {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.date {
            os.write_uint32(14, v)?;
        }
        if let Some(v) = self.raw_behavior_score {
            os.write_uint32(17, v)?;
        }
        if let Some(v) = self.old_raw_behavior_score {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.comms_reports {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.comms_parties {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.behavior_rating {
            os.write_enum(21, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPlayerConductScorecard {
        CMsgPlayerConductScorecard::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.seq_num = ::std::option::Option::None;
        self.reasons = ::std::option::Option::None;
        self.matches_in_report = ::std::option::Option::None;
        self.matches_clean = ::std::option::Option::None;
        self.matches_reported = ::std::option::Option::None;
        self.matches_abandoned = ::std::option::Option::None;
        self.reports_count = ::std::option::Option::None;
        self.reports_parties = ::std::option::Option::None;
        self.commend_count = ::std::option::Option::None;
        self.date = ::std::option::Option::None;
        self.raw_behavior_score = ::std::option::Option::None;
        self.old_raw_behavior_score = ::std::option::Option::None;
        self.comms_reports = ::std::option::Option::None;
        self.comms_parties = ::std::option::Option::None;
        self.behavior_rating = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPlayerConductScorecard {
        static instance: CMsgPlayerConductScorecard = CMsgPlayerConductScorecard {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            seq_num: ::std::option::Option::None,
            reasons: ::std::option::Option::None,
            matches_in_report: ::std::option::Option::None,
            matches_clean: ::std::option::Option::None,
            matches_reported: ::std::option::Option::None,
            matches_abandoned: ::std::option::Option::None,
            reports_count: ::std::option::Option::None,
            reports_parties: ::std::option::Option::None,
            commend_count: ::std::option::Option::None,
            date: ::std::option::Option::None,
            raw_behavior_score: ::std::option::Option::None,
            old_raw_behavior_score: ::std::option::Option::None,
            comms_reports: ::std::option::Option::None,
            comms_parties: ::std::option::Option::None,
            behavior_rating: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPlayerConductScorecard`
pub mod cmsg_player_conduct_scorecard {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgPlayerConductScorecard.EBehaviorRating)
    pub enum EBehaviorRating {
        // @@protoc_insertion_point(enum_value:CMsgPlayerConductScorecard.EBehaviorRating.k_eBehaviorGood)
        k_eBehaviorGood = 0,
        // @@protoc_insertion_point(enum_value:CMsgPlayerConductScorecard.EBehaviorRating.k_eBehaviorWarning)
        k_eBehaviorWarning = 1,
        // @@protoc_insertion_point(enum_value:CMsgPlayerConductScorecard.EBehaviorRating.k_eBehaviorBad)
        k_eBehaviorBad = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EBehaviorRating {
        const NAME: &'static str = "EBehaviorRating";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EBehaviorRating> {
            match value {
                0 => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorGood),
                1 => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorWarning),
                2 => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorBad),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EBehaviorRating> {
            match str {
                "k_eBehaviorGood" => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorGood),
                "k_eBehaviorWarning" => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorWarning),
                "k_eBehaviorBad" => ::std::option::Option::Some(EBehaviorRating::k_eBehaviorBad),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EBehaviorRating] = &[
            EBehaviorRating::k_eBehaviorGood,
            EBehaviorRating::k_eBehaviorWarning,
            EBehaviorRating::k_eBehaviorBad,
        ];
    }

    impl ::std::default::Default for EBehaviorRating {
        fn default() -> Self {
            EBehaviorRating::k_eBehaviorGood
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCWageringRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCWageringRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCWageringRequest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCWageringRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCWageringRequest {
    fn default() -> &'a CMsgClientToGCWageringRequest {
        <CMsgClientToGCWageringRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCWageringRequest {
    pub fn new() -> CMsgClientToGCWageringRequest {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCWageringRequest {
    const NAME: &'static str = "CMsgClientToGCWageringRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCWageringRequest {
        CMsgClientToGCWageringRequest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCWageringRequest {
        static instance: CMsgClientToGCWageringRequest = CMsgClientToGCWageringRequest {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientWageringResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientWageringResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.coins_remaining)
    pub coins_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.total_points_won)
    pub total_points_won: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.total_points_wagered)
    pub total_points_wagered: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.total_points_tipped)
    pub total_points_tipped: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.success_rate)
    pub success_rate: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.total_games_wagered)
    pub total_games_wagered: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.coins_max)
    pub coins_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.rank_wagers_remaining)
    pub rank_wagers_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.rank_wagers_max)
    pub rank_wagers_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.prediction_tokens_remaining)
    pub prediction_tokens_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.prediction_tokens_max)
    pub prediction_tokens_max: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.bounties_remaining)
    pub bounties_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringResponse.bounties_max)
    pub bounties_max: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientWageringResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientWageringResponse {
    fn default() -> &'a CMsgGCToClientWageringResponse {
        <CMsgGCToClientWageringResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientWageringResponse {
    pub fn new() -> CMsgGCToClientWageringResponse {
        ::std::default::Default::default()
    }

    // optional uint32 coins_remaining = 1;

    pub fn coins_remaining(&self) -> u32 {
        self.coins_remaining.unwrap_or(0)
    }

    pub fn clear_coins_remaining(&mut self) {
        self.coins_remaining = ::std::option::Option::None;
    }

    pub fn has_coins_remaining(&self) -> bool {
        self.coins_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coins_remaining(&mut self, v: u32) {
        self.coins_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 total_points_won = 2;

    pub fn total_points_won(&self) -> u32 {
        self.total_points_won.unwrap_or(0)
    }

    pub fn clear_total_points_won(&mut self) {
        self.total_points_won = ::std::option::Option::None;
    }

    pub fn has_total_points_won(&self) -> bool {
        self.total_points_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_won(&mut self, v: u32) {
        self.total_points_won = ::std::option::Option::Some(v);
    }

    // optional uint32 total_points_wagered = 3;

    pub fn total_points_wagered(&self) -> u32 {
        self.total_points_wagered.unwrap_or(0)
    }

    pub fn clear_total_points_wagered(&mut self) {
        self.total_points_wagered = ::std::option::Option::None;
    }

    pub fn has_total_points_wagered(&self) -> bool {
        self.total_points_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_wagered(&mut self, v: u32) {
        self.total_points_wagered = ::std::option::Option::Some(v);
    }

    // optional uint32 total_points_tipped = 4;

    pub fn total_points_tipped(&self) -> u32 {
        self.total_points_tipped.unwrap_or(0)
    }

    pub fn clear_total_points_tipped(&mut self) {
        self.total_points_tipped = ::std::option::Option::None;
    }

    pub fn has_total_points_tipped(&self) -> bool {
        self.total_points_tipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_points_tipped(&mut self, v: u32) {
        self.total_points_tipped = ::std::option::Option::Some(v);
    }

    // optional uint32 success_rate = 5;

    pub fn success_rate(&self) -> u32 {
        self.success_rate.unwrap_or(0)
    }

    pub fn clear_success_rate(&mut self) {
        self.success_rate = ::std::option::Option::None;
    }

    pub fn has_success_rate(&self) -> bool {
        self.success_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success_rate(&mut self, v: u32) {
        self.success_rate = ::std::option::Option::Some(v);
    }

    // optional uint32 total_games_wagered = 6;

    pub fn total_games_wagered(&self) -> u32 {
        self.total_games_wagered.unwrap_or(0)
    }

    pub fn clear_total_games_wagered(&mut self) {
        self.total_games_wagered = ::std::option::Option::None;
    }

    pub fn has_total_games_wagered(&self) -> bool {
        self.total_games_wagered.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_games_wagered(&mut self, v: u32) {
        self.total_games_wagered = ::std::option::Option::Some(v);
    }

    // optional uint32 coins_max = 7;

    pub fn coins_max(&self) -> u32 {
        self.coins_max.unwrap_or(0)
    }

    pub fn clear_coins_max(&mut self) {
        self.coins_max = ::std::option::Option::None;
    }

    pub fn has_coins_max(&self) -> bool {
        self.coins_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_coins_max(&mut self, v: u32) {
        self.coins_max = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_wagers_remaining = 8;

    pub fn rank_wagers_remaining(&self) -> u32 {
        self.rank_wagers_remaining.unwrap_or(0)
    }

    pub fn clear_rank_wagers_remaining(&mut self) {
        self.rank_wagers_remaining = ::std::option::Option::None;
    }

    pub fn has_rank_wagers_remaining(&self) -> bool {
        self.rank_wagers_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wagers_remaining(&mut self, v: u32) {
        self.rank_wagers_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_wagers_max = 9;

    pub fn rank_wagers_max(&self) -> u32 {
        self.rank_wagers_max.unwrap_or(0)
    }

    pub fn clear_rank_wagers_max(&mut self) {
        self.rank_wagers_max = ::std::option::Option::None;
    }

    pub fn has_rank_wagers_max(&self) -> bool {
        self.rank_wagers_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_wagers_max(&mut self, v: u32) {
        self.rank_wagers_max = ::std::option::Option::Some(v);
    }

    // optional uint32 prediction_tokens_remaining = 10;

    pub fn prediction_tokens_remaining(&self) -> u32 {
        self.prediction_tokens_remaining.unwrap_or(0)
    }

    pub fn clear_prediction_tokens_remaining(&mut self) {
        self.prediction_tokens_remaining = ::std::option::Option::None;
    }

    pub fn has_prediction_tokens_remaining(&self) -> bool {
        self.prediction_tokens_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_tokens_remaining(&mut self, v: u32) {
        self.prediction_tokens_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 prediction_tokens_max = 11;

    pub fn prediction_tokens_max(&self) -> u32 {
        self.prediction_tokens_max.unwrap_or(0)
    }

    pub fn clear_prediction_tokens_max(&mut self) {
        self.prediction_tokens_max = ::std::option::Option::None;
    }

    pub fn has_prediction_tokens_max(&self) -> bool {
        self.prediction_tokens_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prediction_tokens_max(&mut self, v: u32) {
        self.prediction_tokens_max = ::std::option::Option::Some(v);
    }

    // optional uint32 bounties_remaining = 12;

    pub fn bounties_remaining(&self) -> u32 {
        self.bounties_remaining.unwrap_or(0)
    }

    pub fn clear_bounties_remaining(&mut self) {
        self.bounties_remaining = ::std::option::Option::None;
    }

    pub fn has_bounties_remaining(&self) -> bool {
        self.bounties_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounties_remaining(&mut self, v: u32) {
        self.bounties_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 bounties_max = 13;

    pub fn bounties_max(&self) -> u32 {
        self.bounties_max.unwrap_or(0)
    }

    pub fn clear_bounties_max(&mut self) {
        self.bounties_max = ::std::option::Option::None;
    }

    pub fn has_bounties_max(&self) -> bool {
        self.bounties_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bounties_max(&mut self, v: u32) {
        self.bounties_max = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientWageringResponse {
    const NAME: &'static str = "CMsgGCToClientWageringResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.coins_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.total_points_won = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.total_points_wagered = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.total_points_tipped = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.total_games_wagered = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.coins_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.rank_wagers_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.rank_wagers_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.prediction_tokens_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.prediction_tokens_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                96 => {
                    self.bounties_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                104 => {
                    self.bounties_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.coins_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.total_points_won {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.total_points_wagered {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.total_points_tipped {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.success_rate {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.total_games_wagered {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.coins_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.rank_wagers_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.rank_wagers_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.prediction_tokens_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.prediction_tokens_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        if let Some(v) = self.bounties_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(12, v);
        }
        if let Some(v) = self.bounties_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(13, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.coins_remaining {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.total_points_won {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.total_points_wagered {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.total_points_tipped {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.success_rate {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.total_games_wagered {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.coins_max {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.rank_wagers_remaining {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rank_wagers_max {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.prediction_tokens_remaining {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.prediction_tokens_max {
            os.write_uint32(11, v)?;
        }
        if let Some(v) = self.bounties_remaining {
            os.write_uint32(12, v)?;
        }
        if let Some(v) = self.bounties_max {
            os.write_uint32(13, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientWageringResponse {
        CMsgGCToClientWageringResponse::new()
    }

    fn clear(&mut self) {
        self.coins_remaining = ::std::option::Option::None;
        self.total_points_won = ::std::option::Option::None;
        self.total_points_wagered = ::std::option::Option::None;
        self.total_points_tipped = ::std::option::Option::None;
        self.success_rate = ::std::option::Option::None;
        self.total_games_wagered = ::std::option::Option::None;
        self.coins_max = ::std::option::Option::None;
        self.rank_wagers_remaining = ::std::option::Option::None;
        self.rank_wagers_max = ::std::option::Option::None;
        self.prediction_tokens_remaining = ::std::option::Option::None;
        self.prediction_tokens_max = ::std::option::Option::None;
        self.bounties_remaining = ::std::option::Option::None;
        self.bounties_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientWageringResponse {
        static instance: CMsgGCToClientWageringResponse = CMsgGCToClientWageringResponse {
            coins_remaining: ::std::option::Option::None,
            total_points_won: ::std::option::Option::None,
            total_points_wagered: ::std::option::Option::None,
            total_points_tipped: ::std::option::Option::None,
            success_rate: ::std::option::Option::None,
            total_games_wagered: ::std::option::Option::None,
            coins_max: ::std::option::Option::None,
            rank_wagers_remaining: ::std::option::Option::None,
            rank_wagers_max: ::std::option::Option::None,
            prediction_tokens_remaining: ::std::option::Option::None,
            prediction_tokens_max: ::std::option::Option::None,
            bounties_remaining: ::std::option::Option::None,
            bounties_max: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientWageringUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientWageringUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientWageringUpdate.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientWageringUpdate.wagering_info)
    pub wagering_info: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientWageringResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientWageringUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientWageringUpdate {
    fn default() -> &'a CMsgGCToClientWageringUpdate {
        <CMsgGCToClientWageringUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientWageringUpdate {
    pub fn new() -> CMsgGCToClientWageringUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientWageringUpdate {
    const NAME: &'static str = "CMsgGCToClientWageringUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering_info)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.wagering_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.wagering_info.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientWageringUpdate {
        CMsgGCToClientWageringUpdate::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.wagering_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientWageringUpdate {
        static instance: CMsgGCToClientWageringUpdate = CMsgGCToClientWageringUpdate {
            event_id: ::std::option::Option::None,
            wagering_info: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientArcanaVotesUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientArcanaVotesUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientArcanaVotesUpdate.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientArcanaVotesUpdate.arcana_votes)
    pub arcana_votes: ::steam_vent_proto_common::protobuf::MessageField<CMsgClientToGCRequestArcanaVotesRemainingResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientArcanaVotesUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientArcanaVotesUpdate {
    fn default() -> &'a CMsgGCToClientArcanaVotesUpdate {
        <CMsgGCToClientArcanaVotesUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientArcanaVotesUpdate {
    pub fn new() -> CMsgGCToClientArcanaVotesUpdate {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientArcanaVotesUpdate {
    const NAME: &'static str = "CMsgGCToClientArcanaVotesUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.arcana_votes)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.arcana_votes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.arcana_votes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientArcanaVotesUpdate {
        CMsgGCToClientArcanaVotesUpdate::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.arcana_votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientArcanaVotesUpdate {
        static instance: CMsgGCToClientArcanaVotesUpdate = CMsgGCToClientArcanaVotesUpdate {
            event_id: ::std::option::Option::None,
            arcana_votes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetEventGoals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetEventGoals {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetEventGoals.event_ids)
    pub event_ids: ::std::vec::Vec<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetEventGoals.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetEventGoals {
    fn default() -> &'a CMsgClientToGCGetEventGoals {
        <CMsgClientToGCGetEventGoals as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetEventGoals {
    pub fn new() -> CMsgClientToGCGetEventGoals {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetEventGoals {
    const NAME: &'static str = "CMsgClientToGCGetEventGoals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_ids.push(is.read_enum_or_unknown()?);
                },
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.event_ids)?
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.event_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, value.value());
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.event_ids {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(v))?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetEventGoals {
        CMsgClientToGCGetEventGoals::new()
    }

    fn clear(&mut self) {
        self.event_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetEventGoals {
        static instance: CMsgClientToGCGetEventGoals = CMsgClientToGCGetEventGoals {
            event_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEventGoals)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEventGoals {
    // message fields
    // @@protoc_insertion_point(field:CMsgEventGoals.event_goals)
    pub event_goals: ::std::vec::Vec<cmsg_event_goals::EventGoal>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEventGoals.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEventGoals {
    fn default() -> &'a CMsgEventGoals {
        <CMsgEventGoals as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEventGoals {
    pub fn new() -> CMsgEventGoals {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEventGoals {
    const NAME: &'static str = "CMsgEventGoals";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_goals.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.event_goals {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.event_goals {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEventGoals {
        CMsgEventGoals::new()
    }

    fn clear(&mut self) {
        self.event_goals.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEventGoals {
        static instance: CMsgEventGoals = CMsgEventGoals {
            event_goals: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgEventGoals`
pub mod cmsg_event_goals {
    // @@protoc_insertion_point(message:CMsgEventGoals.EventGoal)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventGoal {
        // message fields
        // @@protoc_insertion_point(field:CMsgEventGoals.EventGoal.event_id)
        pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EEvent>>,
        // @@protoc_insertion_point(field:CMsgEventGoals.EventGoal.goal_id)
        pub goal_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgEventGoals.EventGoal.value)
        pub value: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgEventGoals.EventGoal.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventGoal {
        fn default() -> &'a EventGoal {
            <EventGoal as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EventGoal {
        pub fn new() -> EventGoal {
            ::std::default::Default::default()
        }

        // optional .EEvent event_id = 1;

        pub fn event_id(&self) -> super::super::dota_shared_enums::EEvent {
            match self.event_id {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EEvent::EVENT_ID_NONE),
                None => super::super::dota_shared_enums::EEvent::EVENT_ID_NONE,
            }
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: super::super::dota_shared_enums::EEvent) {
            self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 goal_id = 2;

        pub fn goal_id(&self) -> u32 {
            self.goal_id.unwrap_or(0)
        }

        pub fn clear_goal_id(&mut self) {
            self.goal_id = ::std::option::Option::None;
        }

        pub fn has_goal_id(&self) -> bool {
            self.goal_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_goal_id(&mut self, v: u32) {
            self.goal_id = ::std::option::Option::Some(v);
        }

        // optional uint64 value = 3;

        pub fn value(&self) -> u64 {
            self.value.unwrap_or(0)
        }

        pub fn clear_value(&mut self) {
            self.value = ::std::option::Option::None;
        }

        pub fn has_value(&self) -> bool {
            self.value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_value(&mut self, v: u64) {
            self.value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EventGoal {
        const NAME: &'static str = "EventGoal";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.goal_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.value = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.goal_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.goal_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.value {
                os.write_uint64(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventGoal {
            EventGoal::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.goal_id = ::std::option::Option::None;
            self.value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventGoal {
            static instance: EventGoal = EventGoal {
                event_id: ::std::option::Option::None,
                goal_id: ::std::option::Option::None,
                value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToGCLeaguePredictions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToGCLeaguePredictions {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToGCLeaguePredictions.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToGCLeaguePredictions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToGCLeaguePredictions {
    fn default() -> &'a CMsgGCToGCLeaguePredictions {
        <CMsgGCToGCLeaguePredictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToGCLeaguePredictions {
    pub fn new() -> CMsgGCToGCLeaguePredictions {
        ::std::default::Default::default()
    }

    // optional uint32 league_id = 1;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToGCLeaguePredictions {
    const NAME: &'static str = "CMsgGCToGCLeaguePredictions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.league_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToGCLeaguePredictions {
        CMsgGCToGCLeaguePredictions::new()
    }

    fn clear(&mut self) {
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToGCLeaguePredictions {
        static instance: CMsgGCToGCLeaguePredictions = CMsgGCToGCLeaguePredictions {
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPredictionRankings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPredictionRankings {
    // message fields
    // @@protoc_insertion_point(field:CMsgPredictionRankings.predictions)
    pub predictions: ::std::vec::Vec<cmsg_prediction_rankings::Prediction>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPredictionRankings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPredictionRankings {
    fn default() -> &'a CMsgPredictionRankings {
        <CMsgPredictionRankings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPredictionRankings {
    pub fn new() -> CMsgPredictionRankings {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPredictionRankings {
    const NAME: &'static str = "CMsgPredictionRankings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.predictions.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPredictionRankings {
        CMsgPredictionRankings::new()
    }

    fn clear(&mut self) {
        self.predictions.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPredictionRankings {
        static instance: CMsgPredictionRankings = CMsgPredictionRankings {
            predictions: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPredictionRankings`
pub mod cmsg_prediction_rankings {
    // @@protoc_insertion_point(message:CMsgPredictionRankings.PredictionLine)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PredictionLine {
        // message fields
        // @@protoc_insertion_point(field:CMsgPredictionRankings.PredictionLine.answer_id)
        pub answer_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPredictionRankings.PredictionLine.answer_name)
        pub answer_name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgPredictionRankings.PredictionLine.answer_logo)
        pub answer_logo: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgPredictionRankings.PredictionLine.answer_value)
        pub answer_value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPredictionRankings.PredictionLine.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PredictionLine {
        fn default() -> &'a PredictionLine {
            <PredictionLine as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PredictionLine {
        pub fn new() -> PredictionLine {
            ::std::default::Default::default()
        }

        // optional uint32 answer_id = 1;

        pub fn answer_id(&self) -> u32 {
            self.answer_id.unwrap_or(0)
        }

        pub fn clear_answer_id(&mut self) {
            self.answer_id = ::std::option::Option::None;
        }

        pub fn has_answer_id(&self) -> bool {
            self.answer_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_id(&mut self, v: u32) {
            self.answer_id = ::std::option::Option::Some(v);
        }

        // optional string answer_name = 2;

        pub fn answer_name(&self) -> &str {
            match self.answer_name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_answer_name(&mut self) {
            self.answer_name = ::std::option::Option::None;
        }

        pub fn has_answer_name(&self) -> bool {
            self.answer_name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_name(&mut self, v: ::std::string::String) {
            self.answer_name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_answer_name(&mut self) -> &mut ::std::string::String {
            if self.answer_name.is_none() {
                self.answer_name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.answer_name.as_mut().unwrap()
        }

        // Take field
        pub fn take_answer_name(&mut self) -> ::std::string::String {
            self.answer_name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint64 answer_logo = 3;

        pub fn answer_logo(&self) -> u64 {
            self.answer_logo.unwrap_or(0)
        }

        pub fn clear_answer_logo(&mut self) {
            self.answer_logo = ::std::option::Option::None;
        }

        pub fn has_answer_logo(&self) -> bool {
            self.answer_logo.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_logo(&mut self, v: u64) {
            self.answer_logo = ::std::option::Option::Some(v);
        }

        // optional float answer_value = 4;

        pub fn answer_value(&self) -> f32 {
            self.answer_value.unwrap_or(0.)
        }

        pub fn clear_answer_value(&mut self) {
            self.answer_value = ::std::option::Option::None;
        }

        pub fn has_answer_value(&self) -> bool {
            self.answer_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_value(&mut self, v: f32) {
            self.answer_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PredictionLine {
        const NAME: &'static str = "PredictionLine";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.answer_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.answer_name = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.answer_logo = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    37 => {
                        self.answer_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.answer_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.answer_name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.answer_logo {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.answer_value {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.answer_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.answer_name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.answer_logo {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.answer_value {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PredictionLine {
            PredictionLine::new()
        }

        fn clear(&mut self) {
            self.answer_id = ::std::option::Option::None;
            self.answer_name = ::std::option::Option::None;
            self.answer_logo = ::std::option::Option::None;
            self.answer_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PredictionLine {
            static instance: PredictionLine = PredictionLine {
                answer_id: ::std::option::Option::None,
                answer_name: ::std::option::Option::None,
                answer_logo: ::std::option::Option::None,
                answer_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgPredictionRankings.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:CMsgPredictionRankings.Prediction.selection_id)
        pub selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPredictionRankings.Prediction.prediction_lines)
        pub prediction_lines: ::std::vec::Vec<PredictionLine>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPredictionRankings.Prediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 selection_id = 1;

        pub fn selection_id(&self) -> u32 {
            self.selection_id.unwrap_or(0)
        }

        pub fn clear_selection_id(&mut self) {
            self.selection_id = ::std::option::Option::None;
        }

        pub fn has_selection_id(&self) -> bool {
            self.selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selection_id(&mut self, v: u32) {
            self.selection_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.prediction_lines.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.selection_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.prediction_lines {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.selection_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.prediction_lines {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.selection_id = ::std::option::Option::None;
            self.prediction_lines.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                selection_id: ::std::option::Option::None,
                prediction_lines: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPredictionResults)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPredictionResults {
    // message fields
    // @@protoc_insertion_point(field:CMsgPredictionResults.results)
    pub results: ::std::vec::Vec<cmsg_prediction_results::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPredictionResults.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPredictionResults {
    fn default() -> &'a CMsgPredictionResults {
        <CMsgPredictionResults as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPredictionResults {
    pub fn new() -> CMsgPredictionResults {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPredictionResults {
    const NAME: &'static str = "CMsgPredictionResults";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPredictionResults {
        CMsgPredictionResults::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPredictionResults {
        static instance: CMsgPredictionResults = CMsgPredictionResults {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPredictionResults`
pub mod cmsg_prediction_results {
    // @@protoc_insertion_point(message:CMsgPredictionResults.ResultBreakdown)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ResultBreakdown {
        // message fields
        // @@protoc_insertion_point(field:CMsgPredictionResults.ResultBreakdown.answer_selection)
        pub answer_selection: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPredictionResults.ResultBreakdown.answer_value)
        pub answer_value: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPredictionResults.ResultBreakdown.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ResultBreakdown {
        fn default() -> &'a ResultBreakdown {
            <ResultBreakdown as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ResultBreakdown {
        pub fn new() -> ResultBreakdown {
            ::std::default::Default::default()
        }

        // optional uint32 answer_selection = 2;

        pub fn answer_selection(&self) -> u32 {
            self.answer_selection.unwrap_or(0)
        }

        pub fn clear_answer_selection(&mut self) {
            self.answer_selection = ::std::option::Option::None;
        }

        pub fn has_answer_selection(&self) -> bool {
            self.answer_selection.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_selection(&mut self, v: u32) {
            self.answer_selection = ::std::option::Option::Some(v);
        }

        // optional float answer_value = 3;

        pub fn answer_value(&self) -> f32 {
            self.answer_value.unwrap_or(0.)
        }

        pub fn clear_answer_value(&mut self) {
            self.answer_value = ::std::option::Option::None;
        }

        pub fn has_answer_value(&self) -> bool {
            self.answer_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_answer_value(&mut self, v: f32) {
            self.answer_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ResultBreakdown {
        const NAME: &'static str = "ResultBreakdown";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.answer_selection = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    29 => {
                        self.answer_value = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.answer_selection {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.answer_value {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.answer_selection {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.answer_value {
                os.write_float(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ResultBreakdown {
            ResultBreakdown::new()
        }

        fn clear(&mut self) {
            self.answer_selection = ::std::option::Option::None;
            self.answer_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ResultBreakdown {
            static instance: ResultBreakdown = ResultBreakdown {
                answer_selection: ::std::option::Option::None,
                answer_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgPredictionResults.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgPredictionResults.Result.selection_id)
        pub selection_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgPredictionResults.Result.result_breakdown)
        pub result_breakdown: ::std::vec::Vec<ResultBreakdown>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgPredictionResults.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional uint32 selection_id = 1;

        pub fn selection_id(&self) -> u32 {
            self.selection_id.unwrap_or(0)
        }

        pub fn clear_selection_id(&mut self) {
            self.selection_id = ::std::option::Option::None;
        }

        pub fn has_selection_id(&self) -> bool {
            self.selection_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_selection_id(&mut self, v: u32) {
            self.selection_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.selection_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.result_breakdown.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.selection_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.result_breakdown {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.selection_id {
                os.write_uint32(1, v)?;
            }
            for v in &self.result_breakdown {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.selection_id = ::std::option::Option::None;
            self.result_breakdown.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                selection_id: ::std::option::Option::None,
                result_breakdown: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCHasPlayerVotedForMVP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCHasPlayerVotedForMVP {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCHasPlayerVotedForMVP.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCHasPlayerVotedForMVP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCHasPlayerVotedForMVP {
    fn default() -> &'a CMsgClientToGCHasPlayerVotedForMVP {
        <CMsgClientToGCHasPlayerVotedForMVP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCHasPlayerVotedForMVP {
    pub fn new() -> CMsgClientToGCHasPlayerVotedForMVP {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCHasPlayerVotedForMVP {
    const NAME: &'static str = "CMsgClientToGCHasPlayerVotedForMVP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCHasPlayerVotedForMVP {
        CMsgClientToGCHasPlayerVotedForMVP::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCHasPlayerVotedForMVP {
        static instance: CMsgClientToGCHasPlayerVotedForMVP = CMsgClientToGCHasPlayerVotedForMVP {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCHasPlayerVotedForMVPResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCHasPlayerVotedForMVPResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCHasPlayerVotedForMVPResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCHasPlayerVotedForMVPResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn default() -> &'a CMsgClientToGCHasPlayerVotedForMVPResponse {
        <CMsgClientToGCHasPlayerVotedForMVPResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCHasPlayerVotedForMVPResponse {
    pub fn new() -> CMsgClientToGCHasPlayerVotedForMVPResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCHasPlayerVotedForMVPResponse {
    const NAME: &'static str = "CMsgClientToGCHasPlayerVotedForMVPResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCHasPlayerVotedForMVPResponse {
        CMsgClientToGCHasPlayerVotedForMVPResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCHasPlayerVotedForMVPResponse {
        static instance: CMsgClientToGCHasPlayerVotedForMVPResponse = CMsgClientToGCHasPlayerVotedForMVPResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCVoteForMVP)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCVoteForMVP {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCVoteForMVP.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCVoteForMVP.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCVoteForMVP.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCVoteForMVP {
    fn default() -> &'a CMsgClientToGCVoteForMVP {
        <CMsgClientToGCVoteForMVP as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCVoteForMVP {
    pub fn new() -> CMsgClientToGCVoteForMVP {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCVoteForMVP {
    const NAME: &'static str = "CMsgClientToGCVoteForMVP";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCVoteForMVP {
        CMsgClientToGCVoteForMVP::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCVoteForMVP {
        static instance: CMsgClientToGCVoteForMVP = CMsgClientToGCVoteForMVP {
            match_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCVoteForMVPResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCVoteForMVPResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCVoteForMVPResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCVoteForMVPResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCVoteForMVPResponse {
    fn default() -> &'a CMsgClientToGCVoteForMVPResponse {
        <CMsgClientToGCVoteForMVPResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCVoteForMVPResponse {
    pub fn new() -> CMsgClientToGCVoteForMVPResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCVoteForMVPResponse {
    const NAME: &'static str = "CMsgClientToGCVoteForMVPResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCVoteForMVPResponse {
        CMsgClientToGCVoteForMVPResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCVoteForMVPResponse {
        static instance: CMsgClientToGCVoteForMVPResponse = CMsgClientToGCVoteForMVPResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCMVPVoteTimeout)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCMVPVoteTimeout {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCMVPVoteTimeout.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCMVPVoteTimeout.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCMVPVoteTimeout {
    fn default() -> &'a CMsgClientToGCMVPVoteTimeout {
        <CMsgClientToGCMVPVoteTimeout as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCMVPVoteTimeout {
    pub fn new() -> CMsgClientToGCMVPVoteTimeout {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCMVPVoteTimeout {
    const NAME: &'static str = "CMsgClientToGCMVPVoteTimeout";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCMVPVoteTimeout {
        CMsgClientToGCMVPVoteTimeout::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCMVPVoteTimeout {
        static instance: CMsgClientToGCMVPVoteTimeout = CMsgClientToGCMVPVoteTimeout {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCMVPVoteTimeoutResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCMVPVoteTimeoutResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCMVPVoteTimeoutResponse.result)
    pub result: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCMVPVoteTimeoutResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCMVPVoteTimeoutResponse {
    fn default() -> &'a CMsgClientToGCMVPVoteTimeoutResponse {
        <CMsgClientToGCMVPVoteTimeoutResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCMVPVoteTimeoutResponse {
    pub fn new() -> CMsgClientToGCMVPVoteTimeoutResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCMVPVoteTimeoutResponse {
    const NAME: &'static str = "CMsgClientToGCMVPVoteTimeoutResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCMVPVoteTimeoutResponse {
        CMsgClientToGCMVPVoteTimeoutResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCMVPVoteTimeoutResponse {
        static instance: CMsgClientToGCMVPVoteTimeoutResponse = CMsgClientToGCMVPVoteTimeoutResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCTeammateStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCTeammateStatsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCTeammateStatsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCTeammateStatsRequest {
    fn default() -> &'a CMsgClientToGCTeammateStatsRequest {
        <CMsgClientToGCTeammateStatsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCTeammateStatsRequest {
    pub fn new() -> CMsgClientToGCTeammateStatsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCTeammateStatsRequest {
    const NAME: &'static str = "CMsgClientToGCTeammateStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCTeammateStatsRequest {
        CMsgClientToGCTeammateStatsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCTeammateStatsRequest {
        static instance: CMsgClientToGCTeammateStatsRequest = CMsgClientToGCTeammateStatsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCTeammateStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCTeammateStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.success)
    pub success: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.teammate_stats)
    pub teammate_stats: ::std::vec::Vec<cmsg_client_to_gcteammate_stats_response::TeammateStat>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCTeammateStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCTeammateStatsResponse {
    fn default() -> &'a CMsgClientToGCTeammateStatsResponse {
        <CMsgClientToGCTeammateStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCTeammateStatsResponse {
    pub fn new() -> CMsgClientToGCTeammateStatsResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCTeammateStatsResponse {
    const NAME: &'static str = "CMsgClientToGCTeammateStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.teammate_stats.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        for value in &self.teammate_stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        for v in &self.teammate_stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCTeammateStatsResponse {
        CMsgClientToGCTeammateStatsResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.teammate_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCTeammateStatsResponse {
        static instance: CMsgClientToGCTeammateStatsResponse = CMsgClientToGCTeammateStatsResponse {
            success: ::std::option::Option::None,
            teammate_stats: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCTeammateStatsResponse`
pub mod cmsg_client_to_gcteammate_stats_response {
    // @@protoc_insertion_point(message:CMsgClientToGCTeammateStatsResponse.TeammateStat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TeammateStat {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.games)
        pub games: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.most_recent_game_timestamp)
        pub most_recent_game_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.most_recent_game_match_id)
        pub most_recent_game_match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCTeammateStatsResponse.TeammateStat.performance)
        pub performance: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCTeammateStatsResponse.TeammateStat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TeammateStat {
        fn default() -> &'a TeammateStat {
            <TeammateStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TeammateStat {
        pub fn new() -> TeammateStat {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 games = 2;

        pub fn games(&self) -> u32 {
            self.games.unwrap_or(0)
        }

        pub fn clear_games(&mut self) {
            self.games = ::std::option::Option::None;
        }

        pub fn has_games(&self) -> bool {
            self.games.is_some()
        }

        // Param is passed by value, moved
        pub fn set_games(&mut self, v: u32) {
            self.games = ::std::option::Option::Some(v);
        }

        // optional uint32 wins = 3;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 most_recent_game_timestamp = 4;

        pub fn most_recent_game_timestamp(&self) -> u32 {
            self.most_recent_game_timestamp.unwrap_or(0)
        }

        pub fn clear_most_recent_game_timestamp(&mut self) {
            self.most_recent_game_timestamp = ::std::option::Option::None;
        }

        pub fn has_most_recent_game_timestamp(&self) -> bool {
            self.most_recent_game_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_most_recent_game_timestamp(&mut self, v: u32) {
            self.most_recent_game_timestamp = ::std::option::Option::Some(v);
        }

        // optional uint64 most_recent_game_match_id = 5;

        pub fn most_recent_game_match_id(&self) -> u64 {
            self.most_recent_game_match_id.unwrap_or(0)
        }

        pub fn clear_most_recent_game_match_id(&mut self) {
            self.most_recent_game_match_id = ::std::option::Option::None;
        }

        pub fn has_most_recent_game_match_id(&self) -> bool {
            self.most_recent_game_match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_most_recent_game_match_id(&mut self, v: u64) {
            self.most_recent_game_match_id = ::std::option::Option::Some(v);
        }

        // optional float performance = 100;

        pub fn performance(&self) -> f32 {
            self.performance.unwrap_or(0.)
        }

        pub fn clear_performance(&mut self) {
            self.performance = ::std::option::Option::None;
        }

        pub fn has_performance(&self) -> bool {
            self.performance.is_some()
        }

        // Param is passed by value, moved
        pub fn set_performance(&mut self, v: f32) {
            self.performance = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TeammateStat {
        const NAME: &'static str = "TeammateStat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.games = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.most_recent_game_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.most_recent_game_match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    805 => {
                        self.performance = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.games {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.most_recent_game_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.most_recent_game_match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(5, v);
            }
            if let Some(v) = self.performance {
                my_size += 2 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.games {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.wins {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.most_recent_game_timestamp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.most_recent_game_match_id {
                os.write_uint64(5, v)?;
            }
            if let Some(v) = self.performance {
                os.write_float(100, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TeammateStat {
            TeammateStat::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.games = ::std::option::Option::None;
            self.wins = ::std::option::Option::None;
            self.most_recent_game_timestamp = ::std::option::Option::None;
            self.most_recent_game_match_id = ::std::option::Option::None;
            self.performance = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TeammateStat {
            static instance: TeammateStat = TeammateStat {
                account_id: ::std::option::Option::None,
                games: ::std::option::Option::None,
                wins: ::std::option::Option::None,
                most_recent_game_timestamp: ::std::option::Option::None,
                most_recent_game_match_id: ::std::option::Option::None,
                performance: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCVoteForArcana)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCVoteForArcana {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCVoteForArcana.matches)
    pub matches: ::std::vec::Vec<super::dota_gcmessages_common::CMsgArcanaVoteMatchVotes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCVoteForArcana.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCVoteForArcana {
    fn default() -> &'a CMsgClientToGCVoteForArcana {
        <CMsgClientToGCVoteForArcana as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCVoteForArcana {
    pub fn new() -> CMsgClientToGCVoteForArcana {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCVoteForArcana {
    const NAME: &'static str = "CMsgClientToGCVoteForArcana";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.matches.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCVoteForArcana {
        CMsgClientToGCVoteForArcana::new()
    }

    fn clear(&mut self) {
        self.matches.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCVoteForArcana {
        static instance: CMsgClientToGCVoteForArcana = CMsgClientToGCVoteForArcana {
            matches: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCVoteForArcanaResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCVoteForArcanaResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCVoteForArcanaResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcvote_for_arcana_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCVoteForArcanaResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCVoteForArcanaResponse {
    fn default() -> &'a CMsgClientToGCVoteForArcanaResponse {
        <CMsgClientToGCVoteForArcanaResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCVoteForArcanaResponse {
    pub fn new() -> CMsgClientToGCVoteForArcanaResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCVoteForArcanaResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gcvote_for_arcana_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcvote_for_arcana_response::Result::SUCCEEDED),
            None => cmsg_client_to_gcvote_for_arcana_response::Result::SUCCEEDED,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcvote_for_arcana_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCVoteForArcanaResponse {
    const NAME: &'static str = "CMsgClientToGCVoteForArcanaResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCVoteForArcanaResponse {
        CMsgClientToGCVoteForArcanaResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCVoteForArcanaResponse {
        static instance: CMsgClientToGCVoteForArcanaResponse = CMsgClientToGCVoteForArcanaResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCVoteForArcanaResponse`
pub mod cmsg_client_to_gcvote_for_arcana_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCVoteForArcanaResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCVoteForArcanaResponse.Result.SUCCEEDED)
        SUCCEEDED = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCVoteForArcanaResponse.Result.VOTING_NOT_ENABLED_FOR_ROUND)
        VOTING_NOT_ENABLED_FOR_ROUND = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCVoteForArcanaResponse.Result.UNKNOWN_FAILURE)
        UNKNOWN_FAILURE = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCEEDED),
                1 => ::std::option::Option::Some(Result::VOTING_NOT_ENABLED_FOR_ROUND),
                2 => ::std::option::Option::Some(Result::UNKNOWN_FAILURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCEEDED" => ::std::option::Option::Some(Result::SUCCEEDED),
                "VOTING_NOT_ENABLED_FOR_ROUND" => ::std::option::Option::Some(Result::VOTING_NOT_ENABLED_FOR_ROUND),
                "UNKNOWN_FAILURE" => ::std::option::Option::Some(Result::UNKNOWN_FAILURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCEEDED,
            Result::VOTING_NOT_ENABLED_FOR_ROUND,
            Result::UNKNOWN_FAILURE,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCEEDED
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestArcanaVotesRemaining)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestArcanaVotesRemaining {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestArcanaVotesRemaining.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestArcanaVotesRemaining {
    fn default() -> &'a CMsgClientToGCRequestArcanaVotesRemaining {
        <CMsgClientToGCRequestArcanaVotesRemaining as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestArcanaVotesRemaining {
    pub fn new() -> CMsgClientToGCRequestArcanaVotesRemaining {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestArcanaVotesRemaining {
    const NAME: &'static str = "CMsgClientToGCRequestArcanaVotesRemaining";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestArcanaVotesRemaining {
        CMsgClientToGCRequestArcanaVotesRemaining::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestArcanaVotesRemaining {
        static instance: CMsgClientToGCRequestArcanaVotesRemaining = CMsgClientToGCRequestArcanaVotesRemaining {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestArcanaVotesRemainingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestArcanaVotesRemainingResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestArcanaVotesRemainingResponse.result)
    pub result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestArcanaVotesRemainingResponse.votes_remaining)
    pub votes_remaining: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestArcanaVotesRemainingResponse.votes_total)
    pub votes_total: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestArcanaVotesRemainingResponse.matches_previously_voted_for)
    pub matches_previously_voted_for: ::std::vec::Vec<super::dota_gcmessages_common::CMsgArcanaVoteMatchVotes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestArcanaVotesRemainingResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn default() -> &'a CMsgClientToGCRequestArcanaVotesRemainingResponse {
        <CMsgClientToGCRequestArcanaVotesRemainingResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestArcanaVotesRemainingResponse {
    pub fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional uint32 votes_remaining = 2;

    pub fn votes_remaining(&self) -> u32 {
        self.votes_remaining.unwrap_or(0)
    }

    pub fn clear_votes_remaining(&mut self) {
        self.votes_remaining = ::std::option::Option::None;
    }

    pub fn has_votes_remaining(&self) -> bool {
        self.votes_remaining.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_remaining(&mut self, v: u32) {
        self.votes_remaining = ::std::option::Option::Some(v);
    }

    // optional uint32 votes_total = 3;

    pub fn votes_total(&self) -> u32 {
        self.votes_total.unwrap_or(0)
    }

    pub fn clear_votes_total(&mut self) {
        self.votes_total = ::std::option::Option::None;
    }

    pub fn has_votes_total(&self) -> bool {
        self.votes_total.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votes_total(&mut self, v: u32) {
        self.votes_total = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    const NAME: &'static str = "CMsgClientToGCRequestArcanaVotesRemainingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.votes_remaining = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.votes_total = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    self.matches_previously_voted_for.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        if let Some(v) = self.votes_remaining {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.votes_total {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        for value in &self.matches_previously_voted_for {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.votes_remaining {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.votes_total {
            os.write_uint32(3, v)?;
        }
        for v in &self.matches_previously_voted_for {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestArcanaVotesRemainingResponse {
        CMsgClientToGCRequestArcanaVotesRemainingResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.votes_remaining = ::std::option::Option::None;
        self.votes_total = ::std::option::Option::None;
        self.matches_previously_voted_for.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestArcanaVotesRemainingResponse {
        static instance: CMsgClientToGCRequestArcanaVotesRemainingResponse = CMsgClientToGCRequestArcanaVotesRemainingResponse {
            result: ::std::option::Option::None,
            votes_remaining: ::std::option::Option::None,
            votes_total: ::std::option::Option::None,
            matches_previously_voted_for: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestEventPointLogV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestEventPointLogV2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogV2.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestEventPointLogV2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestEventPointLogV2 {
    fn default() -> &'a CMsgClientToGCRequestEventPointLogV2 {
        <CMsgClientToGCRequestEventPointLogV2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestEventPointLogV2 {
    pub fn new() -> CMsgClientToGCRequestEventPointLogV2 {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestEventPointLogV2 {
    const NAME: &'static str = "CMsgClientToGCRequestEventPointLogV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestEventPointLogV2 {
        CMsgClientToGCRequestEventPointLogV2::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogV2 {
        static instance: CMsgClientToGCRequestEventPointLogV2 = CMsgClientToGCRequestEventPointLogV2 {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestEventPointLogResponseV2)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestEventPointLogResponseV2 {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.result)
    pub result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.log_entries)
    pub log_entries: ::std::vec::Vec<cmsg_client_to_gcrequest_event_point_log_response_v2::LogEntry>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestEventPointLogResponseV2.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestEventPointLogResponseV2 {
    fn default() -> &'a CMsgClientToGCRequestEventPointLogResponseV2 {
        <CMsgClientToGCRequestEventPointLogResponseV2 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestEventPointLogResponseV2 {
    pub fn new() -> CMsgClientToGCRequestEventPointLogResponseV2 {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestEventPointLogResponseV2 {
    const NAME: &'static str = "CMsgClientToGCRequestEventPointLogResponseV2";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.log_entries.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        for value in &self.log_entries {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.log_entries {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestEventPointLogResponseV2 {
        CMsgClientToGCRequestEventPointLogResponseV2::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.log_entries.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestEventPointLogResponseV2 {
        static instance: CMsgClientToGCRequestEventPointLogResponseV2 = CMsgClientToGCRequestEventPointLogResponseV2 {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            log_entries: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestEventPointLogResponseV2`
pub mod cmsg_client_to_gcrequest_event_point_log_response_v2 {
    // @@protoc_insertion_point(message:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LogEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry.audit_action)
        pub audit_action: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry.event_points)
        pub event_points: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry.audit_data)
        pub audit_data: ::std::option::Option<u64>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCRequestEventPointLogResponseV2.LogEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LogEntry {
        fn default() -> &'a LogEntry {
            <LogEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LogEntry {
        pub fn new() -> LogEntry {
            ::std::default::Default::default()
        }

        // optional uint32 timestamp = 1;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 audit_action = 2;

        pub fn audit_action(&self) -> u32 {
            self.audit_action.unwrap_or(0)
        }

        pub fn clear_audit_action(&mut self) {
            self.audit_action = ::std::option::Option::None;
        }

        pub fn has_audit_action(&self) -> bool {
            self.audit_action.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_action(&mut self, v: u32) {
            self.audit_action = ::std::option::Option::Some(v);
        }

        // optional int32 event_points = 3;

        pub fn event_points(&self) -> i32 {
            self.event_points.unwrap_or(0)
        }

        pub fn clear_event_points(&mut self) {
            self.event_points = ::std::option::Option::None;
        }

        pub fn has_event_points(&self) -> bool {
            self.event_points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_points(&mut self, v: i32) {
            self.event_points = ::std::option::Option::Some(v);
        }

        // optional uint64 audit_data = 4;

        pub fn audit_data(&self) -> u64 {
            self.audit_data.unwrap_or(0)
        }

        pub fn clear_audit_data(&mut self) {
            self.audit_data = ::std::option::Option::None;
        }

        pub fn has_audit_data(&self) -> bool {
            self.audit_data.is_some()
        }

        // Param is passed by value, moved
        pub fn set_audit_data(&mut self, v: u64) {
            self.audit_data = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LogEntry {
        const NAME: &'static str = "LogEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.audit_action = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.event_points = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.audit_data = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.audit_action {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.event_points {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            if let Some(v) = self.audit_data {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.timestamp {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.audit_action {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.event_points {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.audit_data {
                os.write_uint64(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LogEntry {
            LogEntry::new()
        }

        fn clear(&mut self) {
            self.timestamp = ::std::option::Option::None;
            self.audit_action = ::std::option::Option::None;
            self.event_points = ::std::option::Option::None;
            self.audit_data = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LogEntry {
            static instance: LogEntry = LogEntry {
                timestamp: ::std::option::Option::None,
                audit_action: ::std::option::Option::None,
                event_points: ::std::option::Option::None,
                audit_data: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPublishUserStat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPublishUserStat {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPublishUserStat.user_stats_event)
    pub user_stats_event: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCPublishUserStat.reference_data)
    pub reference_data: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPublishUserStat.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPublishUserStat {
    fn default() -> &'a CMsgClientToGCPublishUserStat {
        <CMsgClientToGCPublishUserStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPublishUserStat {
    pub fn new() -> CMsgClientToGCPublishUserStat {
        ::std::default::Default::default()
    }

    // optional uint32 user_stats_event = 1;

    pub fn user_stats_event(&self) -> u32 {
        self.user_stats_event.unwrap_or(0)
    }

    pub fn clear_user_stats_event(&mut self) {
        self.user_stats_event = ::std::option::Option::None;
    }

    pub fn has_user_stats_event(&self) -> bool {
        self.user_stats_event.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user_stats_event(&mut self, v: u32) {
        self.user_stats_event = ::std::option::Option::Some(v);
    }

    // optional uint64 reference_data = 2;

    pub fn reference_data(&self) -> u64 {
        self.reference_data.unwrap_or(0)
    }

    pub fn clear_reference_data(&mut self) {
        self.reference_data = ::std::option::Option::None;
    }

    pub fn has_reference_data(&self) -> bool {
        self.reference_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference_data(&mut self, v: u64) {
        self.reference_data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPublishUserStat {
    const NAME: &'static str = "CMsgClientToGCPublishUserStat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.user_stats_event = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.reference_data = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.user_stats_event {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.reference_data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.user_stats_event {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reference_data {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPublishUserStat {
        CMsgClientToGCPublishUserStat::new()
    }

    fn clear(&mut self) {
        self.user_stats_event = ::std::option::Option::None;
        self.reference_data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPublishUserStat {
        static instance: CMsgClientToGCPublishUserStat = CMsgClientToGCPublishUserStat {
            user_stats_event: ::std::option::Option::None,
            reference_data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestSlarkGameResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSlarkGameResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSlarkGameResult.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSlarkGameResult.slot_chosen)
    pub slot_chosen: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSlarkGameResult.week)
    pub week: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestSlarkGameResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSlarkGameResult {
    fn default() -> &'a CMsgClientToGCRequestSlarkGameResult {
        <CMsgClientToGCRequestSlarkGameResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSlarkGameResult {
    pub fn new() -> CMsgClientToGCRequestSlarkGameResult {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 slot_chosen = 2;

    pub fn slot_chosen(&self) -> u32 {
        self.slot_chosen.unwrap_or(0)
    }

    pub fn clear_slot_chosen(&mut self) {
        self.slot_chosen = ::std::option::Option::None;
    }

    pub fn has_slot_chosen(&self) -> bool {
        self.slot_chosen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_chosen(&mut self, v: u32) {
        self.slot_chosen = ::std::option::Option::Some(v);
    }

    // optional uint32 week = 3;

    pub fn week(&self) -> u32 {
        self.week.unwrap_or(0)
    }

    pub fn clear_week(&mut self) {
        self.week = ::std::option::Option::None;
    }

    pub fn has_week(&self) -> bool {
        self.week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_week(&mut self, v: u32) {
        self.week = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestSlarkGameResult {
    const NAME: &'static str = "CMsgClientToGCRequestSlarkGameResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.slot_chosen = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.week = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.slot_chosen {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.week {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.slot_chosen {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.week {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSlarkGameResult {
        CMsgClientToGCRequestSlarkGameResult::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_chosen = ::std::option::Option::None;
        self.week = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSlarkGameResult {
        static instance: CMsgClientToGCRequestSlarkGameResult = CMsgClientToGCRequestSlarkGameResult {
            event_id: ::std::option::Option::None,
            slot_chosen: ::std::option::Option::None,
            week: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestSlarkGameResultResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestSlarkGameResultResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSlarkGameResultResponse.points_won)
    pub points_won: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestSlarkGameResultResponse.aura_won)
    pub aura_won: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestSlarkGameResultResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestSlarkGameResultResponse {
    fn default() -> &'a CMsgClientToGCRequestSlarkGameResultResponse {
        <CMsgClientToGCRequestSlarkGameResultResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestSlarkGameResultResponse {
    pub fn new() -> CMsgClientToGCRequestSlarkGameResultResponse {
        ::std::default::Default::default()
    }

    // optional uint32 points_won = 1;

    pub fn points_won(&self) -> u32 {
        self.points_won.unwrap_or(0)
    }

    pub fn clear_points_won(&mut self) {
        self.points_won = ::std::option::Option::None;
    }

    pub fn has_points_won(&self) -> bool {
        self.points_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_points_won(&mut self, v: u32) {
        self.points_won = ::std::option::Option::Some(v);
    }

    // optional bool aura_won = 2;

    pub fn aura_won(&self) -> bool {
        self.aura_won.unwrap_or(false)
    }

    pub fn clear_aura_won(&mut self) {
        self.aura_won = ::std::option::Option::None;
    }

    pub fn has_aura_won(&self) -> bool {
        self.aura_won.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aura_won(&mut self, v: bool) {
        self.aura_won = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestSlarkGameResultResponse {
    const NAME: &'static str = "CMsgClientToGCRequestSlarkGameResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.points_won = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.aura_won = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.points_won {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.aura_won {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.points_won {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.aura_won {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestSlarkGameResultResponse {
        CMsgClientToGCRequestSlarkGameResultResponse::new()
    }

    fn clear(&mut self) {
        self.points_won = ::std::option::Option::None;
        self.aura_won = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestSlarkGameResultResponse {
        static instance: CMsgClientToGCRequestSlarkGameResultResponse = CMsgClientToGCRequestSlarkGameResultResponse {
            points_won: ::std::option::Option::None,
            aura_won: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientQuestProgressUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientQuestProgressUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.completed_challenges)
    pub completed_challenges: ::std::vec::Vec<cmsg_gcto_client_quest_progress_updated::Challenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientQuestProgressUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientQuestProgressUpdated {
    fn default() -> &'a CMsgGCToClientQuestProgressUpdated {
        <CMsgGCToClientQuestProgressUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientQuestProgressUpdated {
    pub fn new() -> CMsgGCToClientQuestProgressUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientQuestProgressUpdated {
    const NAME: &'static str = "CMsgGCToClientQuestProgressUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.completed_challenges.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.completed_challenges {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.completed_challenges {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientQuestProgressUpdated {
        CMsgGCToClientQuestProgressUpdated::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.completed_challenges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientQuestProgressUpdated {
        static instance: CMsgGCToClientQuestProgressUpdated = CMsgGCToClientQuestProgressUpdated {
            quest_id: ::std::option::Option::None,
            completed_challenges: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientQuestProgressUpdated`
pub mod cmsg_gcto_client_quest_progress_updated {
    // @@protoc_insertion_point(message:CMsgGCToClientQuestProgressUpdated.Challenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Challenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.challenge_id)
        pub challenge_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.time_completed)
        pub time_completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.attempts)
        pub attempts: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.template_id)
        pub template_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.quest_rank)
        pub quest_rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientQuestProgressUpdated.Challenge.max_quest_rank)
        pub max_quest_rank: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientQuestProgressUpdated.Challenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Challenge {
        fn default() -> &'a Challenge {
            <Challenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Challenge {
        pub fn new() -> Challenge {
            ::std::default::Default::default()
        }

        // optional uint32 challenge_id = 1;

        pub fn challenge_id(&self) -> u32 {
            self.challenge_id.unwrap_or(0)
        }

        pub fn clear_challenge_id(&mut self) {
            self.challenge_id = ::std::option::Option::None;
        }

        pub fn has_challenge_id(&self) -> bool {
            self.challenge_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_challenge_id(&mut self, v: u32) {
            self.challenge_id = ::std::option::Option::Some(v);
        }

        // optional uint32 time_completed = 2;

        pub fn time_completed(&self) -> u32 {
            self.time_completed.unwrap_or(0)
        }

        pub fn clear_time_completed(&mut self) {
            self.time_completed = ::std::option::Option::None;
        }

        pub fn has_time_completed(&self) -> bool {
            self.time_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_completed(&mut self, v: u32) {
            self.time_completed = ::std::option::Option::Some(v);
        }

        // optional uint32 attempts = 3;

        pub fn attempts(&self) -> u32 {
            self.attempts.unwrap_or(0)
        }

        pub fn clear_attempts(&mut self) {
            self.attempts = ::std::option::Option::None;
        }

        pub fn has_attempts(&self) -> bool {
            self.attempts.is_some()
        }

        // Param is passed by value, moved
        pub fn set_attempts(&mut self, v: u32) {
            self.attempts = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 4;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 template_id = 5;

        pub fn template_id(&self) -> u32 {
            self.template_id.unwrap_or(0)
        }

        pub fn clear_template_id(&mut self) {
            self.template_id = ::std::option::Option::None;
        }

        pub fn has_template_id(&self) -> bool {
            self.template_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_template_id(&mut self, v: u32) {
            self.template_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quest_rank = 6;

        pub fn quest_rank(&self) -> u32 {
            self.quest_rank.unwrap_or(0)
        }

        pub fn clear_quest_rank(&mut self) {
            self.quest_rank = ::std::option::Option::None;
        }

        pub fn has_quest_rank(&self) -> bool {
            self.quest_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quest_rank(&mut self, v: u32) {
            self.quest_rank = ::std::option::Option::Some(v);
        }

        // optional uint32 max_quest_rank = 7;

        pub fn max_quest_rank(&self) -> u32 {
            self.max_quest_rank.unwrap_or(0)
        }

        pub fn clear_max_quest_rank(&mut self) {
            self.max_quest_rank = ::std::option::Option::None;
        }

        pub fn has_max_quest_rank(&self) -> bool {
            self.max_quest_rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_max_quest_rank(&mut self, v: u32) {
            self.max_quest_rank = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Challenge {
        const NAME: &'static str = "Challenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.challenge_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.time_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.attempts = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.template_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.max_quest_rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.challenge_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.time_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.attempts {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.template_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.quest_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.max_quest_rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.challenge_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.time_completed {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.attempts {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.template_id {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.quest_rank {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.max_quest_rank {
                os.write_uint32(7, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Challenge {
            Challenge::new()
        }

        fn clear(&mut self) {
            self.challenge_id = ::std::option::Option::None;
            self.time_completed = ::std::option::Option::None;
            self.attempts = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.template_id = ::std::option::Option::None;
            self.quest_rank = ::std::option::Option::None;
            self.max_quest_rank = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Challenge {
            static instance: Challenge = Challenge {
                challenge_id: ::std::option::Option::None,
                time_completed: ::std::option::Option::None,
                attempts: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                template_id: ::std::option::Option::None,
                quest_rank: ::std::option::Option::None,
                max_quest_rank: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTARedeemItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARedeemItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTARedeemItem.currency_id)
    pub currency_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgDOTARedeemItem.purchase_def)
    pub purchase_def: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTARedeemItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARedeemItem {
    fn default() -> &'a CMsgDOTARedeemItem {
        <CMsgDOTARedeemItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARedeemItem {
    pub fn new() -> CMsgDOTARedeemItem {
        ::std::default::Default::default()
    }

    // optional uint64 currency_id = 1;

    pub fn currency_id(&self) -> u64 {
        self.currency_id.unwrap_or(0)
    }

    pub fn clear_currency_id(&mut self) {
        self.currency_id = ::std::option::Option::None;
    }

    pub fn has_currency_id(&self) -> bool {
        self.currency_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_currency_id(&mut self, v: u64) {
        self.currency_id = ::std::option::Option::Some(v);
    }

    // optional uint32 purchase_def = 2;

    pub fn purchase_def(&self) -> u32 {
        self.purchase_def.unwrap_or(0)
    }

    pub fn clear_purchase_def(&mut self) {
        self.purchase_def = ::std::option::Option::None;
    }

    pub fn has_purchase_def(&self) -> bool {
        self.purchase_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_purchase_def(&mut self, v: u32) {
        self.purchase_def = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTARedeemItem {
    const NAME: &'static str = "CMsgDOTARedeemItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.currency_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.purchase_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.currency_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.purchase_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.currency_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.purchase_def {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARedeemItem {
        CMsgDOTARedeemItem::new()
    }

    fn clear(&mut self) {
        self.currency_id = ::std::option::Option::None;
        self.purchase_def = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARedeemItem {
        static instance: CMsgDOTARedeemItem = CMsgDOTARedeemItem {
            currency_id: ::std::option::Option::None,
            purchase_def: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTARedeemItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTARedeemItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTARedeemItemResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotaredeem_item_response::EResultCode>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTARedeemItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTARedeemItemResponse {
    fn default() -> &'a CMsgDOTARedeemItemResponse {
        <CMsgDOTARedeemItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTARedeemItemResponse {
    pub fn new() -> CMsgDOTARedeemItemResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTARedeemItemResponse.EResultCode response = 1;

    pub fn response(&self) -> cmsg_dotaredeem_item_response::EResultCode {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_dotaredeem_item_response::EResultCode::k_Succeeded),
            None => cmsg_dotaredeem_item_response::EResultCode::k_Succeeded,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_dotaredeem_item_response::EResultCode) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTARedeemItemResponse {
    const NAME: &'static str = "CMsgDOTARedeemItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTARedeemItemResponse {
        CMsgDOTARedeemItemResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTARedeemItemResponse {
        static instance: CMsgDOTARedeemItemResponse = CMsgDOTARedeemItemResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTARedeemItemResponse`
pub mod cmsg_dotaredeem_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTARedeemItemResponse.EResultCode)
    pub enum EResultCode {
        // @@protoc_insertion_point(enum_value:CMsgDOTARedeemItemResponse.EResultCode.k_Succeeded)
        k_Succeeded = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTARedeemItemResponse.EResultCode.k_Failed)
        k_Failed = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResultCode {
        const NAME: &'static str = "EResultCode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResultCode> {
            match value {
                0 => ::std::option::Option::Some(EResultCode::k_Succeeded),
                1 => ::std::option::Option::Some(EResultCode::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResultCode> {
            match str {
                "k_Succeeded" => ::std::option::Option::Some(EResultCode::k_Succeeded),
                "k_Failed" => ::std::option::Option::Some(EResultCode::k_Failed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResultCode] = &[
            EResultCode::k_Succeeded,
            EResultCode::k_Failed,
        ];
    }

    impl ::std::default::Default for EResultCode {
        fn default() -> Self {
            EResultCode::k_Succeeded
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSelectCompendiumInGamePrediction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectCompendiumInGamePrediction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePrediction.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePrediction.predictions)
    pub predictions: ::std::vec::Vec<cmsg_client_to_gcselect_compendium_in_game_prediction::Prediction>,
    // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePrediction.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSelectCompendiumInGamePrediction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectCompendiumInGamePrediction {
    fn default() -> &'a CMsgClientToGCSelectCompendiumInGamePrediction {
        <CMsgClientToGCSelectCompendiumInGamePrediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectCompendiumInGamePrediction {
    pub fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 3;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSelectCompendiumInGamePrediction {
    const NAME: &'static str = "CMsgClientToGCSelectCompendiumInGamePrediction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    self.predictions.push(is.read_message()?);
                },
                24 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.predictions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.predictions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.league_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectCompendiumInGamePrediction {
        CMsgClientToGCSelectCompendiumInGamePrediction::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.predictions.clear();
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectCompendiumInGamePrediction {
        static instance: CMsgClientToGCSelectCompendiumInGamePrediction = CMsgClientToGCSelectCompendiumInGamePrediction {
            match_id: ::std::option::Option::None,
            predictions: ::std::vec::Vec::new(),
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSelectCompendiumInGamePrediction`
pub mod cmsg_client_to_gcselect_compendium_in_game_prediction {
    // @@protoc_insertion_point(message:CMsgClientToGCSelectCompendiumInGamePrediction.Prediction)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Prediction {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePrediction.Prediction.prediction_id)
        pub prediction_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePrediction.Prediction.prediction_value)
        pub prediction_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCSelectCompendiumInGamePrediction.Prediction.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Prediction {
        fn default() -> &'a Prediction {
            <Prediction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Prediction {
        pub fn new() -> Prediction {
            ::std::default::Default::default()
        }

        // optional uint32 prediction_id = 1;

        pub fn prediction_id(&self) -> u32 {
            self.prediction_id.unwrap_or(0)
        }

        pub fn clear_prediction_id(&mut self) {
            self.prediction_id = ::std::option::Option::None;
        }

        pub fn has_prediction_id(&self) -> bool {
            self.prediction_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_id(&mut self, v: u32) {
            self.prediction_id = ::std::option::Option::Some(v);
        }

        // optional uint32 prediction_value = 2;

        pub fn prediction_value(&self) -> u32 {
            self.prediction_value.unwrap_or(0)
        }

        pub fn clear_prediction_value(&mut self) {
            self.prediction_value = ::std::option::Option::None;
        }

        pub fn has_prediction_value(&self) -> bool {
            self.prediction_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_prediction_value(&mut self, v: u32) {
            self.prediction_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Prediction {
        const NAME: &'static str = "Prediction";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.prediction_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.prediction_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.prediction_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.prediction_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.prediction_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.prediction_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Prediction {
            Prediction::new()
        }

        fn clear(&mut self) {
            self.prediction_id = ::std::option::Option::None;
            self.prediction_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Prediction {
            static instance: Prediction = Prediction {
                prediction_id: ::std::option::Option::None,
                prediction_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSelectCompendiumInGamePredictionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSelectCompendiumInGamePredictionResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcselect_compendium_in_game_prediction_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSelectCompendiumInGamePredictionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn default() -> &'a CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        <CMsgClientToGCSelectCompendiumInGamePredictionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    pub fn new() -> CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult result = 1;

    pub fn result(&self) -> cmsg_client_to_gcselect_compendium_in_game_prediction_response::EResult {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcselect_compendium_in_game_prediction_response::EResult::SUCCESS),
            None => cmsg_client_to_gcselect_compendium_in_game_prediction_response::EResult::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcselect_compendium_in_game_prediction_response::EResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    const NAME: &'static str = "CMsgClientToGCSelectCompendiumInGamePredictionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        CMsgClientToGCSelectCompendiumInGamePredictionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectCompendiumInGamePredictionResponse {
        static instance: CMsgClientToGCSelectCompendiumInGamePredictionResponse = CMsgClientToGCSelectCompendiumInGamePredictionResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSelectCompendiumInGamePredictionResponse`
pub mod cmsg_client_to_gcselect_compendium_in_game_prediction_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult.INVALID_MATCH)
        INVALID_MATCH = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult.PREDICTIONS_ARE_CLOSED)
        PREDICTIONS_ARE_CLOSED = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectCompendiumInGamePredictionResponse.EResult.OTHER_ERROR)
        OTHER_ERROR = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::SUCCESS),
                1 => ::std::option::Option::Some(EResult::INVALID_MATCH),
                2 => ::std::option::Option::Some(EResult::PREDICTIONS_ARE_CLOSED),
                3 => ::std::option::Option::Some(EResult::OTHER_ERROR),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResult::SUCCESS),
                "INVALID_MATCH" => ::std::option::Option::Some(EResult::INVALID_MATCH),
                "PREDICTIONS_ARE_CLOSED" => ::std::option::Option::Some(EResult::PREDICTIONS_ARE_CLOSED),
                "OTHER_ERROR" => ::std::option::Option::Some(EResult::OTHER_ERROR),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::SUCCESS,
            EResult::INVALID_MATCH,
            EResult::PREDICTIONS_ARE_CLOSED,
            EResult::OTHER_ERROR,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOpenPlayerCardPack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOpenPlayerCardPack {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPack.player_card_pack_item_id)
    pub player_card_pack_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPack.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPack.deprecated_league_id)
    pub deprecated_league_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPack.region)
    pub region: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::ELeagueRegion>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOpenPlayerCardPack.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOpenPlayerCardPack {
    fn default() -> &'a CMsgClientToGCOpenPlayerCardPack {
        <CMsgClientToGCOpenPlayerCardPack as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOpenPlayerCardPack {
    pub fn new() -> CMsgClientToGCOpenPlayerCardPack {
        ::std::default::Default::default()
    }

    // optional uint64 player_card_pack_item_id = 1;

    pub fn player_card_pack_item_id(&self) -> u64 {
        self.player_card_pack_item_id.unwrap_or(0)
    }

    pub fn clear_player_card_pack_item_id(&mut self) {
        self.player_card_pack_item_id = ::std::option::Option::None;
    }

    pub fn has_player_card_pack_item_id(&self) -> bool {
        self.player_card_pack_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_card_pack_item_id(&mut self, v: u64) {
        self.player_card_pack_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 2;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 deprecated_league_id = 3;

    pub fn deprecated_league_id(&self) -> u32 {
        self.deprecated_league_id.unwrap_or(0)
    }

    pub fn clear_deprecated_league_id(&mut self) {
        self.deprecated_league_id = ::std::option::Option::None;
    }

    pub fn has_deprecated_league_id(&self) -> bool {
        self.deprecated_league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated_league_id(&mut self, v: u32) {
        self.deprecated_league_id = ::std::option::Option::Some(v);
    }

    // optional .ELeagueRegion region = 4;

    pub fn region(&self) -> super::dota_shared_enums::ELeagueRegion {
        match self.region {
            Some(e) => e.enum_value_or(super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET),
            None => super::dota_shared_enums::ELeagueRegion::LEAGUE_REGION_UNSET,
        }
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: super::dota_shared_enums::ELeagueRegion) {
        self.region = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOpenPlayerCardPack {
    const NAME: &'static str = "CMsgClientToGCOpenPlayerCardPack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_card_pack_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.deprecated_league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.region = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_card_pack_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.deprecated_league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.region {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_card_pack_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.deprecated_league_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.region {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOpenPlayerCardPack {
        CMsgClientToGCOpenPlayerCardPack::new()
    }

    fn clear(&mut self) {
        self.player_card_pack_item_id = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.deprecated_league_id = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOpenPlayerCardPack {
        static instance: CMsgClientToGCOpenPlayerCardPack = CMsgClientToGCOpenPlayerCardPack {
            player_card_pack_item_id: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            deprecated_league_id: ::std::option::Option::None,
            region: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOpenPlayerCardPackResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOpenPlayerCardPackResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPackResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcopen_player_card_pack_response::Result>>,
    // @@protoc_insertion_point(field:CMsgClientToGCOpenPlayerCardPackResponse.player_card_item_ids)
    pub player_card_item_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOpenPlayerCardPackResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOpenPlayerCardPackResponse {
    fn default() -> &'a CMsgClientToGCOpenPlayerCardPackResponse {
        <CMsgClientToGCOpenPlayerCardPackResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOpenPlayerCardPackResponse {
    pub fn new() -> CMsgClientToGCOpenPlayerCardPackResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOpenPlayerCardPackResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gcopen_player_card_pack_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcopen_player_card_pack_response::Result::SUCCESS),
            None => cmsg_client_to_gcopen_player_card_pack_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcopen_player_card_pack_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOpenPlayerCardPackResponse {
    const NAME: &'static str = "CMsgClientToGCOpenPlayerCardPackResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_card_item_ids)?;
                },
                16 => {
                    self.player_card_item_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.player_card_item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.player_card_item_ids {
            os.write_uint64(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOpenPlayerCardPackResponse {
        CMsgClientToGCOpenPlayerCardPackResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_card_item_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOpenPlayerCardPackResponse {
        static instance: CMsgClientToGCOpenPlayerCardPackResponse = CMsgClientToGCOpenPlayerCardPackResponse {
            result: ::std::option::Option::None,
            player_card_item_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOpenPlayerCardPackResponse`
pub mod cmsg_client_to_gcopen_player_card_pack_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOpenPlayerCardPackResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_INTERNAL)
        ERROR_INTERNAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_FAILED_TO_FIND_PACK)
        ERROR_FAILED_TO_FIND_PACK = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_ITEM_NOT_CARD_PACK)
        ERROR_ITEM_NOT_CARD_PACK = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_FAILED_CARD_CREATE)
        ERROR_FAILED_CARD_CREATE = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_INVALID_TEAM_ID_ATTRIBUTE)
        ERROR_INVALID_TEAM_ID_ATTRIBUTE = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOpenPlayerCardPackResponse.Result.ERROR_INVALID_TEAM_ID)
        ERROR_INVALID_TEAM_ID = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                1 => ::std::option::Option::Some(Result::SUCCESS),
                2 => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                3 => ::std::option::Option::Some(Result::ERROR_FAILED_TO_FIND_PACK),
                4 => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_CARD_PACK),
                5 => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_CREATE),
                6 => ::std::option::Option::Some(Result::ERROR_INVALID_TEAM_ID_ATTRIBUTE),
                7 => ::std::option::Option::Some(Result::ERROR_INVALID_TEAM_ID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_INTERNAL" => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                "ERROR_FAILED_TO_FIND_PACK" => ::std::option::Option::Some(Result::ERROR_FAILED_TO_FIND_PACK),
                "ERROR_ITEM_NOT_CARD_PACK" => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_CARD_PACK),
                "ERROR_FAILED_CARD_CREATE" => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_CREATE),
                "ERROR_INVALID_TEAM_ID_ATTRIBUTE" => ::std::option::Option::Some(Result::ERROR_INVALID_TEAM_ID_ATTRIBUTE),
                "ERROR_INVALID_TEAM_ID" => ::std::option::Option::Some(Result::ERROR_INVALID_TEAM_ID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_INTERNAL,
            Result::ERROR_FAILED_TO_FIND_PACK,
            Result::ERROR_ITEM_NOT_CARD_PACK,
            Result::ERROR_FAILED_CARD_CREATE,
            Result::ERROR_INVALID_TEAM_ID_ATTRIBUTE,
            Result::ERROR_INVALID_TEAM_ID,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRecyclePlayerCard)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRecyclePlayerCard {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRecyclePlayerCard.player_card_item_ids)
    pub player_card_item_ids: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCRecyclePlayerCard.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRecyclePlayerCard.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRecyclePlayerCard {
    fn default() -> &'a CMsgClientToGCRecyclePlayerCard {
        <CMsgClientToGCRecyclePlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRecyclePlayerCard {
    pub fn new() -> CMsgClientToGCRecyclePlayerCard {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRecyclePlayerCard {
    const NAME: &'static str = "CMsgClientToGCRecyclePlayerCard";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.player_card_item_ids)?;
                },
                24 => {
                    self.player_card_item_ids.push(is.read_uint64()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.player_card_item_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, *value);
        };
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.player_card_item_ids {
            os.write_uint64(3, *v)?;
        };
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRecyclePlayerCard {
        CMsgClientToGCRecyclePlayerCard::new()
    }

    fn clear(&mut self) {
        self.player_card_item_ids.clear();
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRecyclePlayerCard {
        static instance: CMsgClientToGCRecyclePlayerCard = CMsgClientToGCRecyclePlayerCard {
            player_card_item_ids: ::std::vec::Vec::new(),
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRecyclePlayerCardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRecyclePlayerCardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRecyclePlayerCardResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrecycle_player_card_response::Result>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRecyclePlayerCardResponse.dust_amount)
    pub dust_amount: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRecyclePlayerCardResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRecyclePlayerCardResponse {
    fn default() -> &'a CMsgClientToGCRecyclePlayerCardResponse {
        <CMsgClientToGCRecyclePlayerCardResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRecyclePlayerCardResponse {
    pub fn new() -> CMsgClientToGCRecyclePlayerCardResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRecyclePlayerCardResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrecycle_player_card_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrecycle_player_card_response::Result::SUCCESS),
            None => cmsg_client_to_gcrecycle_player_card_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrecycle_player_card_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 dust_amount = 2;

    pub fn dust_amount(&self) -> u32 {
        self.dust_amount.unwrap_or(0)
    }

    pub fn clear_dust_amount(&mut self) {
        self.dust_amount = ::std::option::Option::None;
    }

    pub fn has_dust_amount(&self) -> bool {
        self.dust_amount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dust_amount(&mut self, v: u32) {
        self.dust_amount = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRecyclePlayerCardResponse {
    const NAME: &'static str = "CMsgClientToGCRecyclePlayerCardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.dust_amount = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.dust_amount {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.dust_amount {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRecyclePlayerCardResponse {
        CMsgClientToGCRecyclePlayerCardResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.dust_amount = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRecyclePlayerCardResponse {
        static instance: CMsgClientToGCRecyclePlayerCardResponse = CMsgClientToGCRecyclePlayerCardResponse {
            result: ::std::option::Option::None,
            dust_amount: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRecyclePlayerCardResponse`
pub mod cmsg_client_to_gcrecycle_player_card_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRecyclePlayerCardResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_INTERNAL)
        ERROR_INTERNAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_FAILED_TO_FIND_PLAYER_CARD)
        ERROR_FAILED_TO_FIND_PLAYER_CARD = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_ITEM_NOT_PLAYER_CARD)
        ERROR_ITEM_NOT_PLAYER_CARD = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_FAILED_DUST_CARD_CREATE)
        ERROR_FAILED_DUST_CARD_CREATE = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_CARD_LOCKED)
        ERROR_CARD_LOCKED = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecyclePlayerCardResponse.Result.ERROR_NO_CARDS_SPECIFIED)
        ERROR_NO_CARDS_SPECIFIED = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                1 => ::std::option::Option::Some(Result::SUCCESS),
                2 => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                3 => ::std::option::Option::Some(Result::ERROR_FAILED_TO_FIND_PLAYER_CARD),
                4 => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_PLAYER_CARD),
                5 => ::std::option::Option::Some(Result::ERROR_FAILED_DUST_CARD_CREATE),
                6 => ::std::option::Option::Some(Result::ERROR_CARD_LOCKED),
                7 => ::std::option::Option::Some(Result::ERROR_NO_CARDS_SPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_INTERNAL" => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                "ERROR_FAILED_TO_FIND_PLAYER_CARD" => ::std::option::Option::Some(Result::ERROR_FAILED_TO_FIND_PLAYER_CARD),
                "ERROR_ITEM_NOT_PLAYER_CARD" => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_PLAYER_CARD),
                "ERROR_FAILED_DUST_CARD_CREATE" => ::std::option::Option::Some(Result::ERROR_FAILED_DUST_CARD_CREATE),
                "ERROR_CARD_LOCKED" => ::std::option::Option::Some(Result::ERROR_CARD_LOCKED),
                "ERROR_NO_CARDS_SPECIFIED" => ::std::option::Option::Some(Result::ERROR_NO_CARDS_SPECIFIED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_INTERNAL,
            Result::ERROR_FAILED_TO_FIND_PLAYER_CARD,
            Result::ERROR_ITEM_NOT_PLAYER_CARD,
            Result::ERROR_FAILED_DUST_CARD_CREATE,
            Result::ERROR_CARD_LOCKED,
            Result::ERROR_NO_CARDS_SPECIFIED,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCreatePlayerCardPack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreatePlayerCardPack {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreatePlayerCardPack.card_dust_item_id)
    pub card_dust_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreatePlayerCardPack.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreatePlayerCardPack.premium_pack)
    pub premium_pack: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreatePlayerCardPack.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreatePlayerCardPack {
    fn default() -> &'a CMsgClientToGCCreatePlayerCardPack {
        <CMsgClientToGCCreatePlayerCardPack as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreatePlayerCardPack {
    pub fn new() -> CMsgClientToGCCreatePlayerCardPack {
        ::std::default::Default::default()
    }

    // optional uint64 card_dust_item_id = 1;

    pub fn card_dust_item_id(&self) -> u64 {
        self.card_dust_item_id.unwrap_or(0)
    }

    pub fn clear_card_dust_item_id(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
    }

    pub fn has_card_dust_item_id(&self) -> bool {
        self.card_dust_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_card_dust_item_id(&mut self, v: u64) {
        self.card_dust_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional bool premium_pack = 3;

    pub fn premium_pack(&self) -> bool {
        self.premium_pack.unwrap_or(false)
    }

    pub fn clear_premium_pack(&mut self) {
        self.premium_pack = ::std::option::Option::None;
    }

    pub fn has_premium_pack(&self) -> bool {
        self.premium_pack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_pack(&mut self, v: bool) {
        self.premium_pack = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreatePlayerCardPack {
    const NAME: &'static str = "CMsgClientToGCCreatePlayerCardPack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.card_dust_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.premium_pack = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.card_dust_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.premium_pack {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.card_dust_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_pack {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreatePlayerCardPack {
        CMsgClientToGCCreatePlayerCardPack::new()
    }

    fn clear(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.premium_pack = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreatePlayerCardPack {
        static instance: CMsgClientToGCCreatePlayerCardPack = CMsgClientToGCCreatePlayerCardPack {
            card_dust_item_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            premium_pack: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreatePlayerCardPackResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreatePlayerCardPackResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreatePlayerCardPackResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_player_card_pack_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreatePlayerCardPackResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreatePlayerCardPackResponse {
    fn default() -> &'a CMsgClientToGCCreatePlayerCardPackResponse {
        <CMsgClientToGCCreatePlayerCardPackResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreatePlayerCardPackResponse {
    pub fn new() -> CMsgClientToGCCreatePlayerCardPackResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCreatePlayerCardPackResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccreate_player_card_pack_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_player_card_pack_response::Result::SUCCESS),
            None => cmsg_client_to_gccreate_player_card_pack_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccreate_player_card_pack_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreatePlayerCardPackResponse {
    const NAME: &'static str = "CMsgClientToGCCreatePlayerCardPackResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreatePlayerCardPackResponse {
        CMsgClientToGCCreatePlayerCardPackResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreatePlayerCardPackResponse {
        static instance: CMsgClientToGCCreatePlayerCardPackResponse = CMsgClientToGCCreatePlayerCardPackResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreatePlayerCardPackResponse`
pub mod cmsg_client_to_gccreate_player_card_pack_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCreatePlayerCardPackResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_INTERNAL)
        ERROR_INTERNAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_INSUFFICIENT_DUST)
        ERROR_INSUFFICIENT_DUST = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_ITEM_NOT_DUST_ITEM)
        ERROR_ITEM_NOT_DUST_ITEM = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_FAILED_CARD_PACK_CREATE)
        ERROR_FAILED_CARD_PACK_CREATE = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_NO_CARD_PACK)
        ERROR_NO_CARD_PACK = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreatePlayerCardPackResponse.Result.ERROR_NOT_AVAILABLE)
        ERROR_NOT_AVAILABLE = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                1 => ::std::option::Option::Some(Result::SUCCESS),
                2 => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                3 => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                4 => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                5 => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                6 => ::std::option::Option::Some(Result::ERROR_NO_CARD_PACK),
                7 => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_INTERNAL" => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                "ERROR_INSUFFICIENT_DUST" => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                "ERROR_ITEM_NOT_DUST_ITEM" => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                "ERROR_FAILED_CARD_PACK_CREATE" => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                "ERROR_NO_CARD_PACK" => ::std::option::Option::Some(Result::ERROR_NO_CARD_PACK),
                "ERROR_NOT_AVAILABLE" => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_INTERNAL,
            Result::ERROR_INSUFFICIENT_DUST,
            Result::ERROR_ITEM_NOT_DUST_ITEM,
            Result::ERROR_FAILED_CARD_PACK_CREATE,
            Result::ERROR_NO_CARD_PACK,
            Result::ERROR_NOT_AVAILABLE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCreateTeamPlayerCardPack)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateTeamPlayerCardPack {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateTeamPlayerCardPack.card_dust_item_id)
    pub card_dust_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateTeamPlayerCardPack.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateTeamPlayerCardPack.premium_pack)
    pub premium_pack: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateTeamPlayerCardPack.team_id)
    pub team_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateTeamPlayerCardPack.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateTeamPlayerCardPack {
    fn default() -> &'a CMsgClientToGCCreateTeamPlayerCardPack {
        <CMsgClientToGCCreateTeamPlayerCardPack as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateTeamPlayerCardPack {
    pub fn new() -> CMsgClientToGCCreateTeamPlayerCardPack {
        ::std::default::Default::default()
    }

    // optional uint64 card_dust_item_id = 1;

    pub fn card_dust_item_id(&self) -> u64 {
        self.card_dust_item_id.unwrap_or(0)
    }

    pub fn clear_card_dust_item_id(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
    }

    pub fn has_card_dust_item_id(&self) -> bool {
        self.card_dust_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_card_dust_item_id(&mut self, v: u64) {
        self.card_dust_item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional bool premium_pack = 3;

    pub fn premium_pack(&self) -> bool {
        self.premium_pack.unwrap_or(false)
    }

    pub fn clear_premium_pack(&mut self) {
        self.premium_pack = ::std::option::Option::None;
    }

    pub fn has_premium_pack(&self) -> bool {
        self.premium_pack.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_pack(&mut self, v: bool) {
        self.premium_pack = ::std::option::Option::Some(v);
    }

    // optional uint32 team_id = 4;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateTeamPlayerCardPack {
    const NAME: &'static str = "CMsgClientToGCCreateTeamPlayerCardPack";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.card_dust_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.premium_pack = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.card_dust_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.premium_pack {
            my_size += 1 + 1;
        }
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.card_dust_item_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_pack {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.team_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateTeamPlayerCardPack {
        CMsgClientToGCCreateTeamPlayerCardPack::new()
    }

    fn clear(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.premium_pack = ::std::option::Option::None;
        self.team_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateTeamPlayerCardPack {
        static instance: CMsgClientToGCCreateTeamPlayerCardPack = CMsgClientToGCCreateTeamPlayerCardPack {
            card_dust_item_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            premium_pack: ::std::option::Option::None,
            team_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateTeamPlayerCardPackResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateTeamPlayerCardPackResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateTeamPlayerCardPackResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_team_player_card_pack_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateTeamPlayerCardPackResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateTeamPlayerCardPackResponse {
    fn default() -> &'a CMsgClientToGCCreateTeamPlayerCardPackResponse {
        <CMsgClientToGCCreateTeamPlayerCardPackResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateTeamPlayerCardPackResponse {
    pub fn new() -> CMsgClientToGCCreateTeamPlayerCardPackResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCreateTeamPlayerCardPackResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccreate_team_player_card_pack_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_team_player_card_pack_response::Result::SUCCESS),
            None => cmsg_client_to_gccreate_team_player_card_pack_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccreate_team_player_card_pack_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateTeamPlayerCardPackResponse {
    const NAME: &'static str = "CMsgClientToGCCreateTeamPlayerCardPackResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateTeamPlayerCardPackResponse {
        CMsgClientToGCCreateTeamPlayerCardPackResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateTeamPlayerCardPackResponse {
        static instance: CMsgClientToGCCreateTeamPlayerCardPackResponse = CMsgClientToGCCreateTeamPlayerCardPackResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreateTeamPlayerCardPackResponse`
pub mod cmsg_client_to_gccreate_team_player_card_pack_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_INTERNAL)
        ERROR_INTERNAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_INSUFFICIENT_DUST)
        ERROR_INSUFFICIENT_DUST = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_ITEM_NOT_DUST_ITEM)
        ERROR_ITEM_NOT_DUST_ITEM = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_FAILED_CARD_PACK_CREATE)
        ERROR_FAILED_CARD_PACK_CREATE = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_NO_CARD_PACK)
        ERROR_NO_CARD_PACK = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateTeamPlayerCardPackResponse.Result.ERROR_NOT_AVAILABLE)
        ERROR_NOT_AVAILABLE = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                1 => ::std::option::Option::Some(Result::SUCCESS),
                2 => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                3 => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                4 => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                5 => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                6 => ::std::option::Option::Some(Result::ERROR_NO_CARD_PACK),
                7 => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_INTERNAL" => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                "ERROR_INSUFFICIENT_DUST" => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                "ERROR_ITEM_NOT_DUST_ITEM" => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                "ERROR_FAILED_CARD_PACK_CREATE" => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                "ERROR_NO_CARD_PACK" => ::std::option::Option::Some(Result::ERROR_NO_CARD_PACK),
                "ERROR_NOT_AVAILABLE" => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_INTERNAL,
            Result::ERROR_INSUFFICIENT_DUST,
            Result::ERROR_ITEM_NOT_DUST_ITEM,
            Result::ERROR_FAILED_CARD_PACK_CREATE,
            Result::ERROR_NO_CARD_PACK,
            Result::ERROR_NOT_AVAILABLE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_International2016 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.questlines)
    pub questlines: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_international2016::Questlines>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.wagering)
    pub wagering: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::Wagering>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.achievements)
    pub achievements: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::Achievements>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.battle_cup)
    pub battle_cup: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::BattleCup>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.predictions)
    pub predictions: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::Predictions>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.bracket)
    pub bracket: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::Bracket>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.player_cards)
    pub player_cards: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_international2016::PlayerCard>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.fantasy_challenge)
    pub fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_international2016::FantasyChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_International2016 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_International2016 {
        <CMsgGCToClientBattlePassRollup_International2016 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_International2016 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_International2016 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_International2016 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_International2016";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.questlines.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.achievements)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_cup)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bracket)?;
                },
                66 => {
                    self.player_cards.push(is.read_message()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fantasy_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.wagering.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.achievements.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.predictions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bracket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.player_cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_International2016 {
        CMsgGCToClientBattlePassRollup_International2016::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.questlines.clear();
        self.wagering.clear();
        self.achievements.clear();
        self.battle_cup.clear();
        self.predictions.clear();
        self.bracket.clear();
        self.player_cards.clear();
        self.fantasy_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_International2016 {
        static instance: CMsgGCToClientBattlePassRollup_International2016 = CMsgGCToClientBattlePassRollup_International2016 {
            battle_pass_level: ::std::option::Option::None,
            questlines: ::std::vec::Vec::new(),
            wagering: ::steam_vent_proto_common::protobuf::MessageField::none(),
            achievements: ::steam_vent_proto_common::protobuf::MessageField::none(),
            battle_cup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            predictions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bracket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_cards: ::std::vec::Vec::new(),
            fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollup_International2016`
pub mod cmsg_gcto_client_battle_pass_rollup_international2016 {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.Questlines)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Questlines {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Questlines.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Questlines.onestar)
        pub onestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Questlines.twostar)
        pub twostar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Questlines.threestar)
        pub threestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Questlines.total)
        pub total: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.Questlines.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Questlines {
        fn default() -> &'a Questlines {
            <Questlines as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Questlines {
        pub fn new() -> Questlines {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 onestar = 2;

        pub fn onestar(&self) -> u32 {
            self.onestar.unwrap_or(0)
        }

        pub fn clear_onestar(&mut self) {
            self.onestar = ::std::option::Option::None;
        }

        pub fn has_onestar(&self) -> bool {
            self.onestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_onestar(&mut self, v: u32) {
            self.onestar = ::std::option::Option::Some(v);
        }

        // optional uint32 twostar = 3;

        pub fn twostar(&self) -> u32 {
            self.twostar.unwrap_or(0)
        }

        pub fn clear_twostar(&mut self) {
            self.twostar = ::std::option::Option::None;
        }

        pub fn has_twostar(&self) -> bool {
            self.twostar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_twostar(&mut self, v: u32) {
            self.twostar = ::std::option::Option::Some(v);
        }

        // optional uint32 threestar = 4;

        pub fn threestar(&self) -> u32 {
            self.threestar.unwrap_or(0)
        }

        pub fn clear_threestar(&mut self) {
            self.threestar = ::std::option::Option::None;
        }

        pub fn has_threestar(&self) -> bool {
            self.threestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_threestar(&mut self, v: u32) {
            self.threestar = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 5;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Questlines {
        const NAME: &'static str = "Questlines";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.onestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.twostar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.threestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.onestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.twostar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.threestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.onestar {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.twostar {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.threestar {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Questlines {
            Questlines::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.onestar = ::std::option::Option::None;
            self.twostar = ::std::option::Option::None;
            self.threestar = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Questlines {
            static instance: Questlines = Questlines {
                name: ::std::option::Option::None,
                onestar: ::std::option::Option::None,
                twostar: ::std::option::Option::None,
                threestar: ::std::option::Option::None,
                total: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.Wagering)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wagering {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Wagering.total_wagered)
        pub total_wagered: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Wagering.total_won)
        pub total_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Wagering.average_won)
        pub average_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Wagering.success_rate)
        pub success_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Wagering.total_tips)
        pub total_tips: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.Wagering.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wagering {
        fn default() -> &'a Wagering {
            <Wagering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Wagering {
        pub fn new() -> Wagering {
            ::std::default::Default::default()
        }

        // optional uint32 total_wagered = 1;

        pub fn total_wagered(&self) -> u32 {
            self.total_wagered.unwrap_or(0)
        }

        pub fn clear_total_wagered(&mut self) {
            self.total_wagered = ::std::option::Option::None;
        }

        pub fn has_total_wagered(&self) -> bool {
            self.total_wagered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_wagered(&mut self, v: u32) {
            self.total_wagered = ::std::option::Option::Some(v);
        }

        // optional uint32 total_won = 2;

        pub fn total_won(&self) -> u32 {
            self.total_won.unwrap_or(0)
        }

        pub fn clear_total_won(&mut self) {
            self.total_won = ::std::option::Option::None;
        }

        pub fn has_total_won(&self) -> bool {
            self.total_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_won(&mut self, v: u32) {
            self.total_won = ::std::option::Option::Some(v);
        }

        // optional uint32 average_won = 3;

        pub fn average_won(&self) -> u32 {
            self.average_won.unwrap_or(0)
        }

        pub fn clear_average_won(&mut self) {
            self.average_won = ::std::option::Option::None;
        }

        pub fn has_average_won(&self) -> bool {
            self.average_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_won(&mut self, v: u32) {
            self.average_won = ::std::option::Option::Some(v);
        }

        // optional uint32 success_rate = 4;

        pub fn success_rate(&self) -> u32 {
            self.success_rate.unwrap_or(0)
        }

        pub fn clear_success_rate(&mut self) {
            self.success_rate = ::std::option::Option::None;
        }

        pub fn has_success_rate(&self) -> bool {
            self.success_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_success_rate(&mut self, v: u32) {
            self.success_rate = ::std::option::Option::Some(v);
        }

        // optional uint32 total_tips = 5;

        pub fn total_tips(&self) -> u32 {
            self.total_tips.unwrap_or(0)
        }

        pub fn clear_total_tips(&mut self) {
            self.total_tips = ::std::option::Option::None;
        }

        pub fn has_total_tips(&self) -> bool {
            self.total_tips.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_tips(&mut self, v: u32) {
            self.total_tips = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Wagering {
        const NAME: &'static str = "Wagering";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_wagered = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.average_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total_tips = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_wagered {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.average_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.success_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total_tips {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_wagered {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_won {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.average_won {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.success_rate {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total_tips {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wagering {
            Wagering::new()
        }

        fn clear(&mut self) {
            self.total_wagered = ::std::option::Option::None;
            self.total_won = ::std::option::Option::None;
            self.average_won = ::std::option::Option::None;
            self.success_rate = ::std::option::Option::None;
            self.total_tips = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wagering {
            static instance: Wagering = Wagering {
                total_wagered: ::std::option::Option::None,
                total_won: ::std::option::Option::None,
                average_won: ::std::option::Option::None,
                success_rate: ::std::option::Option::None,
                total_tips: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.Achievements)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievements {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Achievements.completed)
        pub completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Achievements.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Achievements.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.Achievements.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievements {
        fn default() -> &'a Achievements {
            <Achievements as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Achievements {
        pub fn new() -> Achievements {
            ::std::default::Default::default()
        }

        // optional uint32 completed = 1;

        pub fn completed(&self) -> u32 {
            self.completed.unwrap_or(0)
        }

        pub fn clear_completed(&mut self) {
            self.completed = ::std::option::Option::None;
        }

        pub fn has_completed(&self) -> bool {
            self.completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed(&mut self, v: u32) {
            self.completed = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Achievements {
        const NAME: &'static str = "Achievements";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievements {
            Achievements::new()
        }

        fn clear(&mut self) {
            self.completed = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievements {
            static instance: Achievements = Achievements {
                completed: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.BattleCup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BattleCup {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.BattleCup.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.BattleCup.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.BattleCup.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BattleCup {
        fn default() -> &'a BattleCup {
            <BattleCup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BattleCup {
        pub fn new() -> BattleCup {
            ::std::default::Default::default()
        }

        // optional uint32 wins = 1;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BattleCup {
        const NAME: &'static str = "BattleCup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.wins {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BattleCup {
            BattleCup::new()
        }

        fn clear(&mut self) {
            self.wins = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BattleCup {
            static instance: BattleCup = BattleCup {
                wins: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.Predictions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Predictions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Predictions.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Predictions.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Predictions.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.Predictions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Predictions {
        fn default() -> &'a Predictions {
            <Predictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Predictions {
        pub fn new() -> Predictions {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Predictions {
        const NAME: &'static str = "Predictions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Predictions {
            Predictions::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Predictions {
            static instance: Predictions = Predictions {
                correct: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.Bracket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bracket {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Bracket.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.Bracket.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.Bracket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bracket {
        fn default() -> &'a Bracket {
            <Bracket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bracket {
        pub fn new() -> Bracket {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 2;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bracket {
        const NAME: &'static str = "Bracket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bracket {
            Bracket::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bracket {
            static instance: Bracket = Bracket {
                correct: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.PlayerCard)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCard {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.PlayerCard.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.PlayerCard.quality)
        pub quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.PlayerCard.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCard {
        fn default() -> &'a PlayerCard {
            <PlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCard {
        pub fn new() -> PlayerCard {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCard {
        const NAME: &'static str = "PlayerCard";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCard {
            PlayerCard::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCard {
            static instance: PlayerCard = PlayerCard {
                account_id: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_International2016.FantasyChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.FantasyChallenge.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_International2016.FantasyChallenge.percentile)
        pub percentile: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_International2016.FantasyChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyChallenge {
        fn default() -> &'a FantasyChallenge {
            <FantasyChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FantasyChallenge {
        pub fn new() -> FantasyChallenge {
            ::std::default::Default::default()
        }

        // optional float total_score = 1;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional float percentile = 2;

        pub fn percentile(&self) -> f32 {
            self.percentile.unwrap_or(0.)
        }

        pub fn clear_percentile(&mut self) {
            self.percentile = ::std::option::Option::None;
        }

        pub fn has_percentile(&self) -> bool {
            self.percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentile(&mut self, v: f32) {
            self.percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FantasyChallenge {
        const NAME: &'static str = "FantasyChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.percentile = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.percentile {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.percentile {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyChallenge {
            FantasyChallenge::new()
        }

        fn clear(&mut self) {
            self.total_score = ::std::option::Option::None;
            self.percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyChallenge {
            static instance: FantasyChallenge = FantasyChallenge {
                total_score: ::std::option::Option::None,
                percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_Fall2016 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.questlines)
    pub questlines: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_fall2016::Questlines>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.wagering)
    pub wagering: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::Wagering>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.achievements)
    pub achievements: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::Achievements>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.battle_cup)
    pub battle_cup: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::BattleCup>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.predictions)
    pub predictions: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::Predictions>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.bracket)
    pub bracket: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::Bracket>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.player_cards)
    pub player_cards: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_fall2016::PlayerCard>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.fantasy_challenge)
    pub fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_fall2016::FantasyChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_Fall2016 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_Fall2016 {
        <CMsgGCToClientBattlePassRollup_Fall2016 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_Fall2016 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Fall2016 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_Fall2016 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_Fall2016";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.questlines.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.achievements)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_cup)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bracket)?;
                },
                66 => {
                    self.player_cards.push(is.read_message()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fantasy_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.wagering.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.achievements.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.predictions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bracket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.player_cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_Fall2016 {
        CMsgGCToClientBattlePassRollup_Fall2016::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.questlines.clear();
        self.wagering.clear();
        self.achievements.clear();
        self.battle_cup.clear();
        self.predictions.clear();
        self.bracket.clear();
        self.player_cards.clear();
        self.fantasy_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Fall2016 {
        static instance: CMsgGCToClientBattlePassRollup_Fall2016 = CMsgGCToClientBattlePassRollup_Fall2016 {
            battle_pass_level: ::std::option::Option::None,
            questlines: ::std::vec::Vec::new(),
            wagering: ::steam_vent_proto_common::protobuf::MessageField::none(),
            achievements: ::steam_vent_proto_common::protobuf::MessageField::none(),
            battle_cup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            predictions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bracket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_cards: ::std::vec::Vec::new(),
            fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollup_Fall2016`
pub mod cmsg_gcto_client_battle_pass_rollup_fall2016 {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.Questlines)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Questlines {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.onestar)
        pub onestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.twostar)
        pub twostar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.threestar)
        pub threestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.total)
        pub total: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.Questlines.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Questlines {
        fn default() -> &'a Questlines {
            <Questlines as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Questlines {
        pub fn new() -> Questlines {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 onestar = 2;

        pub fn onestar(&self) -> u32 {
            self.onestar.unwrap_or(0)
        }

        pub fn clear_onestar(&mut self) {
            self.onestar = ::std::option::Option::None;
        }

        pub fn has_onestar(&self) -> bool {
            self.onestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_onestar(&mut self, v: u32) {
            self.onestar = ::std::option::Option::Some(v);
        }

        // optional uint32 twostar = 3;

        pub fn twostar(&self) -> u32 {
            self.twostar.unwrap_or(0)
        }

        pub fn clear_twostar(&mut self) {
            self.twostar = ::std::option::Option::None;
        }

        pub fn has_twostar(&self) -> bool {
            self.twostar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_twostar(&mut self, v: u32) {
            self.twostar = ::std::option::Option::Some(v);
        }

        // optional uint32 threestar = 4;

        pub fn threestar(&self) -> u32 {
            self.threestar.unwrap_or(0)
        }

        pub fn clear_threestar(&mut self) {
            self.threestar = ::std::option::Option::None;
        }

        pub fn has_threestar(&self) -> bool {
            self.threestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_threestar(&mut self, v: u32) {
            self.threestar = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 5;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Questlines {
        const NAME: &'static str = "Questlines";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.onestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.twostar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.threestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.onestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.twostar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.threestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.onestar {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.twostar {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.threestar {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Questlines {
            Questlines::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.onestar = ::std::option::Option::None;
            self.twostar = ::std::option::Option::None;
            self.threestar = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Questlines {
            static instance: Questlines = Questlines {
                name: ::std::option::Option::None,
                onestar: ::std::option::Option::None,
                twostar: ::std::option::Option::None,
                threestar: ::std::option::Option::None,
                total: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.Wagering)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wagering {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.total_wagered)
        pub total_wagered: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.total_won)
        pub total_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.average_won)
        pub average_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.success_rate)
        pub success_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.total_tips)
        pub total_tips: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.Wagering.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wagering {
        fn default() -> &'a Wagering {
            <Wagering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Wagering {
        pub fn new() -> Wagering {
            ::std::default::Default::default()
        }

        // optional uint32 total_wagered = 1;

        pub fn total_wagered(&self) -> u32 {
            self.total_wagered.unwrap_or(0)
        }

        pub fn clear_total_wagered(&mut self) {
            self.total_wagered = ::std::option::Option::None;
        }

        pub fn has_total_wagered(&self) -> bool {
            self.total_wagered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_wagered(&mut self, v: u32) {
            self.total_wagered = ::std::option::Option::Some(v);
        }

        // optional uint32 total_won = 2;

        pub fn total_won(&self) -> u32 {
            self.total_won.unwrap_or(0)
        }

        pub fn clear_total_won(&mut self) {
            self.total_won = ::std::option::Option::None;
        }

        pub fn has_total_won(&self) -> bool {
            self.total_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_won(&mut self, v: u32) {
            self.total_won = ::std::option::Option::Some(v);
        }

        // optional uint32 average_won = 3;

        pub fn average_won(&self) -> u32 {
            self.average_won.unwrap_or(0)
        }

        pub fn clear_average_won(&mut self) {
            self.average_won = ::std::option::Option::None;
        }

        pub fn has_average_won(&self) -> bool {
            self.average_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_won(&mut self, v: u32) {
            self.average_won = ::std::option::Option::Some(v);
        }

        // optional uint32 success_rate = 4;

        pub fn success_rate(&self) -> u32 {
            self.success_rate.unwrap_or(0)
        }

        pub fn clear_success_rate(&mut self) {
            self.success_rate = ::std::option::Option::None;
        }

        pub fn has_success_rate(&self) -> bool {
            self.success_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_success_rate(&mut self, v: u32) {
            self.success_rate = ::std::option::Option::Some(v);
        }

        // optional uint32 total_tips = 5;

        pub fn total_tips(&self) -> u32 {
            self.total_tips.unwrap_or(0)
        }

        pub fn clear_total_tips(&mut self) {
            self.total_tips = ::std::option::Option::None;
        }

        pub fn has_total_tips(&self) -> bool {
            self.total_tips.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_tips(&mut self, v: u32) {
            self.total_tips = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Wagering {
        const NAME: &'static str = "Wagering";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_wagered = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.average_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total_tips = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_wagered {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.average_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.success_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total_tips {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_wagered {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_won {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.average_won {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.success_rate {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total_tips {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wagering {
            Wagering::new()
        }

        fn clear(&mut self) {
            self.total_wagered = ::std::option::Option::None;
            self.total_won = ::std::option::Option::None;
            self.average_won = ::std::option::Option::None;
            self.success_rate = ::std::option::Option::None;
            self.total_tips = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wagering {
            static instance: Wagering = Wagering {
                total_wagered: ::std::option::Option::None,
                total_won: ::std::option::Option::None,
                average_won: ::std::option::Option::None,
                success_rate: ::std::option::Option::None,
                total_tips: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.Achievements)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievements {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Achievements.completed)
        pub completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Achievements.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Achievements.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.Achievements.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievements {
        fn default() -> &'a Achievements {
            <Achievements as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Achievements {
        pub fn new() -> Achievements {
            ::std::default::Default::default()
        }

        // optional uint32 completed = 1;

        pub fn completed(&self) -> u32 {
            self.completed.unwrap_or(0)
        }

        pub fn clear_completed(&mut self) {
            self.completed = ::std::option::Option::None;
        }

        pub fn has_completed(&self) -> bool {
            self.completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed(&mut self, v: u32) {
            self.completed = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Achievements {
        const NAME: &'static str = "Achievements";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievements {
            Achievements::new()
        }

        fn clear(&mut self) {
            self.completed = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievements {
            static instance: Achievements = Achievements {
                completed: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.BattleCup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BattleCup {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.BattleCup.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.BattleCup.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.BattleCup.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BattleCup {
        fn default() -> &'a BattleCup {
            <BattleCup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BattleCup {
        pub fn new() -> BattleCup {
            ::std::default::Default::default()
        }

        // optional uint32 wins = 1;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BattleCup {
        const NAME: &'static str = "BattleCup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.wins {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BattleCup {
            BattleCup::new()
        }

        fn clear(&mut self) {
            self.wins = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BattleCup {
            static instance: BattleCup = BattleCup {
                wins: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.Predictions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Predictions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Predictions.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Predictions.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Predictions.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.Predictions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Predictions {
        fn default() -> &'a Predictions {
            <Predictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Predictions {
        pub fn new() -> Predictions {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Predictions {
        const NAME: &'static str = "Predictions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Predictions {
            Predictions::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Predictions {
            static instance: Predictions = Predictions {
                correct: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.Bracket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bracket {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Bracket.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.Bracket.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.Bracket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bracket {
        fn default() -> &'a Bracket {
            <Bracket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bracket {
        pub fn new() -> Bracket {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 2;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bracket {
        const NAME: &'static str = "Bracket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bracket {
            Bracket::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bracket {
            static instance: Bracket = Bracket {
                correct: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.PlayerCard)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCard {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.PlayerCard.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.PlayerCard.quality)
        pub quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.PlayerCard.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCard {
        fn default() -> &'a PlayerCard {
            <PlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCard {
        pub fn new() -> PlayerCard {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCard {
        const NAME: &'static str = "PlayerCard";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCard {
            PlayerCard::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCard {
            static instance: PlayerCard = PlayerCard {
                account_id: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Fall2016.FantasyChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.FantasyChallenge.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Fall2016.FantasyChallenge.percentile)
        pub percentile: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Fall2016.FantasyChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyChallenge {
        fn default() -> &'a FantasyChallenge {
            <FantasyChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FantasyChallenge {
        pub fn new() -> FantasyChallenge {
            ::std::default::Default::default()
        }

        // optional float total_score = 1;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional float percentile = 2;

        pub fn percentile(&self) -> f32 {
            self.percentile.unwrap_or(0.)
        }

        pub fn clear_percentile(&mut self) {
            self.percentile = ::std::option::Option::None;
        }

        pub fn has_percentile(&self) -> bool {
            self.percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentile(&mut self, v: f32) {
            self.percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FantasyChallenge {
        const NAME: &'static str = "FantasyChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.percentile = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.percentile {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.percentile {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyChallenge {
            FantasyChallenge::new()
        }

        fn clear(&mut self) {
            self.total_score = ::std::option::Option::None;
            self.percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyChallenge {
            static instance: FantasyChallenge = FantasyChallenge {
                total_score: ::std::option::Option::None,
                percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_Winter2017 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.questlines)
    pub questlines: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_winter2017::Questlines>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.wagering)
    pub wagering: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::Wagering>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.achievements)
    pub achievements: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::Achievements>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.battle_cup)
    pub battle_cup: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::BattleCup>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.predictions)
    pub predictions: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::Predictions>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.bracket)
    pub bracket: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::Bracket>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.player_cards)
    pub player_cards: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_winter2017::PlayerCard>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.fantasy_challenge)
    pub fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_winter2017::FantasyChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_Winter2017 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_Winter2017 {
        <CMsgGCToClientBattlePassRollup_Winter2017 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_Winter2017 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_Winter2017 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_Winter2017 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_Winter2017";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.questlines.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.achievements)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_cup)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bracket)?;
                },
                66 => {
                    self.player_cards.push(is.read_message()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fantasy_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.wagering.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.achievements.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.predictions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bracket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.player_cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_Winter2017 {
        CMsgGCToClientBattlePassRollup_Winter2017::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.questlines.clear();
        self.wagering.clear();
        self.achievements.clear();
        self.battle_cup.clear();
        self.predictions.clear();
        self.bracket.clear();
        self.player_cards.clear();
        self.fantasy_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_Winter2017 {
        static instance: CMsgGCToClientBattlePassRollup_Winter2017 = CMsgGCToClientBattlePassRollup_Winter2017 {
            battle_pass_level: ::std::option::Option::None,
            questlines: ::std::vec::Vec::new(),
            wagering: ::steam_vent_proto_common::protobuf::MessageField::none(),
            achievements: ::steam_vent_proto_common::protobuf::MessageField::none(),
            battle_cup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            predictions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bracket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_cards: ::std::vec::Vec::new(),
            fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollup_Winter2017`
pub mod cmsg_gcto_client_battle_pass_rollup_winter2017 {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.Questlines)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Questlines {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.onestar)
        pub onestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.twostar)
        pub twostar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.threestar)
        pub threestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.total)
        pub total: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.Questlines.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Questlines {
        fn default() -> &'a Questlines {
            <Questlines as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Questlines {
        pub fn new() -> Questlines {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 onestar = 2;

        pub fn onestar(&self) -> u32 {
            self.onestar.unwrap_or(0)
        }

        pub fn clear_onestar(&mut self) {
            self.onestar = ::std::option::Option::None;
        }

        pub fn has_onestar(&self) -> bool {
            self.onestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_onestar(&mut self, v: u32) {
            self.onestar = ::std::option::Option::Some(v);
        }

        // optional uint32 twostar = 3;

        pub fn twostar(&self) -> u32 {
            self.twostar.unwrap_or(0)
        }

        pub fn clear_twostar(&mut self) {
            self.twostar = ::std::option::Option::None;
        }

        pub fn has_twostar(&self) -> bool {
            self.twostar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_twostar(&mut self, v: u32) {
            self.twostar = ::std::option::Option::Some(v);
        }

        // optional uint32 threestar = 4;

        pub fn threestar(&self) -> u32 {
            self.threestar.unwrap_or(0)
        }

        pub fn clear_threestar(&mut self) {
            self.threestar = ::std::option::Option::None;
        }

        pub fn has_threestar(&self) -> bool {
            self.threestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_threestar(&mut self, v: u32) {
            self.threestar = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 5;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Questlines {
        const NAME: &'static str = "Questlines";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.onestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.twostar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.threestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.onestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.twostar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.threestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.onestar {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.twostar {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.threestar {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Questlines {
            Questlines::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.onestar = ::std::option::Option::None;
            self.twostar = ::std::option::Option::None;
            self.threestar = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Questlines {
            static instance: Questlines = Questlines {
                name: ::std::option::Option::None,
                onestar: ::std::option::Option::None,
                twostar: ::std::option::Option::None,
                threestar: ::std::option::Option::None,
                total: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.Wagering)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wagering {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.total_wagered)
        pub total_wagered: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.total_won)
        pub total_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.average_won)
        pub average_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.success_rate)
        pub success_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.total_tips)
        pub total_tips: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.Wagering.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wagering {
        fn default() -> &'a Wagering {
            <Wagering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Wagering {
        pub fn new() -> Wagering {
            ::std::default::Default::default()
        }

        // optional uint32 total_wagered = 1;

        pub fn total_wagered(&self) -> u32 {
            self.total_wagered.unwrap_or(0)
        }

        pub fn clear_total_wagered(&mut self) {
            self.total_wagered = ::std::option::Option::None;
        }

        pub fn has_total_wagered(&self) -> bool {
            self.total_wagered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_wagered(&mut self, v: u32) {
            self.total_wagered = ::std::option::Option::Some(v);
        }

        // optional uint32 total_won = 2;

        pub fn total_won(&self) -> u32 {
            self.total_won.unwrap_or(0)
        }

        pub fn clear_total_won(&mut self) {
            self.total_won = ::std::option::Option::None;
        }

        pub fn has_total_won(&self) -> bool {
            self.total_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_won(&mut self, v: u32) {
            self.total_won = ::std::option::Option::Some(v);
        }

        // optional uint32 average_won = 3;

        pub fn average_won(&self) -> u32 {
            self.average_won.unwrap_or(0)
        }

        pub fn clear_average_won(&mut self) {
            self.average_won = ::std::option::Option::None;
        }

        pub fn has_average_won(&self) -> bool {
            self.average_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_won(&mut self, v: u32) {
            self.average_won = ::std::option::Option::Some(v);
        }

        // optional uint32 success_rate = 4;

        pub fn success_rate(&self) -> u32 {
            self.success_rate.unwrap_or(0)
        }

        pub fn clear_success_rate(&mut self) {
            self.success_rate = ::std::option::Option::None;
        }

        pub fn has_success_rate(&self) -> bool {
            self.success_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_success_rate(&mut self, v: u32) {
            self.success_rate = ::std::option::Option::Some(v);
        }

        // optional uint32 total_tips = 5;

        pub fn total_tips(&self) -> u32 {
            self.total_tips.unwrap_or(0)
        }

        pub fn clear_total_tips(&mut self) {
            self.total_tips = ::std::option::Option::None;
        }

        pub fn has_total_tips(&self) -> bool {
            self.total_tips.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_tips(&mut self, v: u32) {
            self.total_tips = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Wagering {
        const NAME: &'static str = "Wagering";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_wagered = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.average_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total_tips = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_wagered {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.average_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.success_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total_tips {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_wagered {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_won {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.average_won {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.success_rate {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total_tips {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wagering {
            Wagering::new()
        }

        fn clear(&mut self) {
            self.total_wagered = ::std::option::Option::None;
            self.total_won = ::std::option::Option::None;
            self.average_won = ::std::option::Option::None;
            self.success_rate = ::std::option::Option::None;
            self.total_tips = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wagering {
            static instance: Wagering = Wagering {
                total_wagered: ::std::option::Option::None,
                total_won: ::std::option::Option::None,
                average_won: ::std::option::Option::None,
                success_rate: ::std::option::Option::None,
                total_tips: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.Achievements)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievements {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Achievements.completed)
        pub completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Achievements.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Achievements.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.Achievements.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievements {
        fn default() -> &'a Achievements {
            <Achievements as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Achievements {
        pub fn new() -> Achievements {
            ::std::default::Default::default()
        }

        // optional uint32 completed = 1;

        pub fn completed(&self) -> u32 {
            self.completed.unwrap_or(0)
        }

        pub fn clear_completed(&mut self) {
            self.completed = ::std::option::Option::None;
        }

        pub fn has_completed(&self) -> bool {
            self.completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed(&mut self, v: u32) {
            self.completed = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Achievements {
        const NAME: &'static str = "Achievements";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievements {
            Achievements::new()
        }

        fn clear(&mut self) {
            self.completed = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievements {
            static instance: Achievements = Achievements {
                completed: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.BattleCup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BattleCup {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.BattleCup.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.BattleCup.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.BattleCup.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BattleCup {
        fn default() -> &'a BattleCup {
            <BattleCup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BattleCup {
        pub fn new() -> BattleCup {
            ::std::default::Default::default()
        }

        // optional uint32 wins = 1;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BattleCup {
        const NAME: &'static str = "BattleCup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.wins {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BattleCup {
            BattleCup::new()
        }

        fn clear(&mut self) {
            self.wins = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BattleCup {
            static instance: BattleCup = BattleCup {
                wins: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.Predictions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Predictions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Predictions.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Predictions.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Predictions.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.Predictions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Predictions {
        fn default() -> &'a Predictions {
            <Predictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Predictions {
        pub fn new() -> Predictions {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Predictions {
        const NAME: &'static str = "Predictions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Predictions {
            Predictions::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Predictions {
            static instance: Predictions = Predictions {
                correct: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.Bracket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bracket {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Bracket.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.Bracket.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.Bracket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bracket {
        fn default() -> &'a Bracket {
            <Bracket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bracket {
        pub fn new() -> Bracket {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 2;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bracket {
        const NAME: &'static str = "Bracket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bracket {
            Bracket::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bracket {
            static instance: Bracket = Bracket {
                correct: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.PlayerCard)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCard {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.PlayerCard.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.PlayerCard.quality)
        pub quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.PlayerCard.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCard {
        fn default() -> &'a PlayerCard {
            <PlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCard {
        pub fn new() -> PlayerCard {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCard {
        const NAME: &'static str = "PlayerCard";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCard {
            PlayerCard::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCard {
            static instance: PlayerCard = PlayerCard {
                account_id: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_Winter2017.FantasyChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.FantasyChallenge.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_Winter2017.FantasyChallenge.percentile)
        pub percentile: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_Winter2017.FantasyChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyChallenge {
        fn default() -> &'a FantasyChallenge {
            <FantasyChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FantasyChallenge {
        pub fn new() -> FantasyChallenge {
            ::std::default::Default::default()
        }

        // optional float total_score = 1;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional float percentile = 2;

        pub fn percentile(&self) -> f32 {
            self.percentile.unwrap_or(0.)
        }

        pub fn clear_percentile(&mut self) {
            self.percentile = ::std::option::Option::None;
        }

        pub fn has_percentile(&self) -> bool {
            self.percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentile(&mut self, v: f32) {
            self.percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FantasyChallenge {
        const NAME: &'static str = "FantasyChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.percentile = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.percentile {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.percentile {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyChallenge {
            FantasyChallenge::new()
        }

        fn clear(&mut self) {
            self.total_score = ::std::option::Option::None;
            self.percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyChallenge {
            static instance: FantasyChallenge = FantasyChallenge {
                total_score: ::std::option::Option::None,
                percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_TI7 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.questlines)
    pub questlines: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_ti7::Questlines>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.wagering)
    pub wagering: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::Wagering>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.achievements)
    pub achievements: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::Achievements>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.battle_cup)
    pub battle_cup: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::BattleCup>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.predictions)
    pub predictions: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::Predictions>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.bracket)
    pub bracket: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::Bracket>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.player_cards)
    pub player_cards: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_ti7::PlayerCard>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.fantasy_challenge)
    pub fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti7::FantasyChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_TI7 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_TI7 {
        <CMsgGCToClientBattlePassRollup_TI7 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_TI7 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_TI7 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_TI7 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_TI7";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.questlines.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.achievements)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.battle_cup)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bracket)?;
                },
                66 => {
                    self.player_cards.push(is.read_message()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fantasy_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.questlines {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        for v in &self.questlines {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.wagering.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.achievements.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.battle_cup.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.predictions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bracket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.player_cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_TI7 {
        CMsgGCToClientBattlePassRollup_TI7::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.questlines.clear();
        self.wagering.clear();
        self.achievements.clear();
        self.battle_cup.clear();
        self.predictions.clear();
        self.bracket.clear();
        self.player_cards.clear();
        self.fantasy_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_TI7 {
        static instance: CMsgGCToClientBattlePassRollup_TI7 = CMsgGCToClientBattlePassRollup_TI7 {
            battle_pass_level: ::std::option::Option::None,
            questlines: ::std::vec::Vec::new(),
            wagering: ::steam_vent_proto_common::protobuf::MessageField::none(),
            achievements: ::steam_vent_proto_common::protobuf::MessageField::none(),
            battle_cup: ::steam_vent_proto_common::protobuf::MessageField::none(),
            predictions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bracket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_cards: ::std::vec::Vec::new(),
            fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollup_TI7`
pub mod cmsg_gcto_client_battle_pass_rollup_ti7 {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.Questlines)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Questlines {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Questlines.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Questlines.onestar)
        pub onestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Questlines.twostar)
        pub twostar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Questlines.threestar)
        pub threestar: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Questlines.total)
        pub total: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.Questlines.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Questlines {
        fn default() -> &'a Questlines {
            <Questlines as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Questlines {
        pub fn new() -> Questlines {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional uint32 onestar = 2;

        pub fn onestar(&self) -> u32 {
            self.onestar.unwrap_or(0)
        }

        pub fn clear_onestar(&mut self) {
            self.onestar = ::std::option::Option::None;
        }

        pub fn has_onestar(&self) -> bool {
            self.onestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_onestar(&mut self, v: u32) {
            self.onestar = ::std::option::Option::Some(v);
        }

        // optional uint32 twostar = 3;

        pub fn twostar(&self) -> u32 {
            self.twostar.unwrap_or(0)
        }

        pub fn clear_twostar(&mut self) {
            self.twostar = ::std::option::Option::None;
        }

        pub fn has_twostar(&self) -> bool {
            self.twostar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_twostar(&mut self, v: u32) {
            self.twostar = ::std::option::Option::Some(v);
        }

        // optional uint32 threestar = 4;

        pub fn threestar(&self) -> u32 {
            self.threestar.unwrap_or(0)
        }

        pub fn clear_threestar(&mut self) {
            self.threestar = ::std::option::Option::None;
        }

        pub fn has_threestar(&self) -> bool {
            self.threestar.is_some()
        }

        // Param is passed by value, moved
        pub fn set_threestar(&mut self, v: u32) {
            self.threestar = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 5;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Questlines {
        const NAME: &'static str = "Questlines";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.onestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.twostar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.threestar = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
            }
            if let Some(v) = self.onestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.twostar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.threestar {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.onestar {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.twostar {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.threestar {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Questlines {
            Questlines::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.onestar = ::std::option::Option::None;
            self.twostar = ::std::option::Option::None;
            self.threestar = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Questlines {
            static instance: Questlines = Questlines {
                name: ::std::option::Option::None,
                onestar: ::std::option::Option::None,
                twostar: ::std::option::Option::None,
                threestar: ::std::option::Option::None,
                total: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.Wagering)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wagering {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Wagering.total_wagered)
        pub total_wagered: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Wagering.total_won)
        pub total_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Wagering.average_won)
        pub average_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Wagering.success_rate)
        pub success_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Wagering.total_tips)
        pub total_tips: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.Wagering.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wagering {
        fn default() -> &'a Wagering {
            <Wagering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Wagering {
        pub fn new() -> Wagering {
            ::std::default::Default::default()
        }

        // optional uint32 total_wagered = 1;

        pub fn total_wagered(&self) -> u32 {
            self.total_wagered.unwrap_or(0)
        }

        pub fn clear_total_wagered(&mut self) {
            self.total_wagered = ::std::option::Option::None;
        }

        pub fn has_total_wagered(&self) -> bool {
            self.total_wagered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_wagered(&mut self, v: u32) {
            self.total_wagered = ::std::option::Option::Some(v);
        }

        // optional uint32 total_won = 2;

        pub fn total_won(&self) -> u32 {
            self.total_won.unwrap_or(0)
        }

        pub fn clear_total_won(&mut self) {
            self.total_won = ::std::option::Option::None;
        }

        pub fn has_total_won(&self) -> bool {
            self.total_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_won(&mut self, v: u32) {
            self.total_won = ::std::option::Option::Some(v);
        }

        // optional uint32 average_won = 3;

        pub fn average_won(&self) -> u32 {
            self.average_won.unwrap_or(0)
        }

        pub fn clear_average_won(&mut self) {
            self.average_won = ::std::option::Option::None;
        }

        pub fn has_average_won(&self) -> bool {
            self.average_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_won(&mut self, v: u32) {
            self.average_won = ::std::option::Option::Some(v);
        }

        // optional uint32 success_rate = 4;

        pub fn success_rate(&self) -> u32 {
            self.success_rate.unwrap_or(0)
        }

        pub fn clear_success_rate(&mut self) {
            self.success_rate = ::std::option::Option::None;
        }

        pub fn has_success_rate(&self) -> bool {
            self.success_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_success_rate(&mut self, v: u32) {
            self.success_rate = ::std::option::Option::Some(v);
        }

        // optional uint32 total_tips = 5;

        pub fn total_tips(&self) -> u32 {
            self.total_tips.unwrap_or(0)
        }

        pub fn clear_total_tips(&mut self) {
            self.total_tips = ::std::option::Option::None;
        }

        pub fn has_total_tips(&self) -> bool {
            self.total_tips.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_tips(&mut self, v: u32) {
            self.total_tips = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Wagering {
        const NAME: &'static str = "Wagering";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_wagered = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.average_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total_tips = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_wagered {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.average_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.success_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total_tips {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_wagered {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_won {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.average_won {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.success_rate {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total_tips {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wagering {
            Wagering::new()
        }

        fn clear(&mut self) {
            self.total_wagered = ::std::option::Option::None;
            self.total_won = ::std::option::Option::None;
            self.average_won = ::std::option::Option::None;
            self.success_rate = ::std::option::Option::None;
            self.total_tips = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wagering {
            static instance: Wagering = Wagering {
                total_wagered: ::std::option::Option::None,
                total_won: ::std::option::Option::None,
                average_won: ::std::option::Option::None,
                success_rate: ::std::option::Option::None,
                total_tips: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.Achievements)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievements {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Achievements.completed)
        pub completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Achievements.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Achievements.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.Achievements.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievements {
        fn default() -> &'a Achievements {
            <Achievements as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Achievements {
        pub fn new() -> Achievements {
            ::std::default::Default::default()
        }

        // optional uint32 completed = 1;

        pub fn completed(&self) -> u32 {
            self.completed.unwrap_or(0)
        }

        pub fn clear_completed(&mut self) {
            self.completed = ::std::option::Option::None;
        }

        pub fn has_completed(&self) -> bool {
            self.completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed(&mut self, v: u32) {
            self.completed = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Achievements {
        const NAME: &'static str = "Achievements";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievements {
            Achievements::new()
        }

        fn clear(&mut self) {
            self.completed = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievements {
            static instance: Achievements = Achievements {
                completed: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.BattleCup)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct BattleCup {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.BattleCup.wins)
        pub wins: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.BattleCup.score)
        pub score: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.BattleCup.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a BattleCup {
        fn default() -> &'a BattleCup {
            <BattleCup as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl BattleCup {
        pub fn new() -> BattleCup {
            ::std::default::Default::default()
        }

        // optional uint32 wins = 1;

        pub fn wins(&self) -> u32 {
            self.wins.unwrap_or(0)
        }

        pub fn clear_wins(&mut self) {
            self.wins = ::std::option::Option::None;
        }

        pub fn has_wins(&self) -> bool {
            self.wins.is_some()
        }

        // Param is passed by value, moved
        pub fn set_wins(&mut self, v: u32) {
            self.wins = ::std::option::Option::Some(v);
        }

        // optional uint32 score = 2;

        pub fn score(&self) -> u32 {
            self.score.unwrap_or(0)
        }

        pub fn clear_score(&mut self) {
            self.score = ::std::option::Option::None;
        }

        pub fn has_score(&self) -> bool {
            self.score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_score(&mut self, v: u32) {
            self.score = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for BattleCup {
        const NAME: &'static str = "BattleCup";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.wins = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.score = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.wins {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.score {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.wins {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.score {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> BattleCup {
            BattleCup::new()
        }

        fn clear(&mut self) {
            self.wins = ::std::option::Option::None;
            self.score = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static BattleCup {
            static instance: BattleCup = BattleCup {
                wins: ::std::option::Option::None,
                score: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.Predictions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Predictions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Predictions.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Predictions.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Predictions.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.Predictions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Predictions {
        fn default() -> &'a Predictions {
            <Predictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Predictions {
        pub fn new() -> Predictions {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Predictions {
        const NAME: &'static str = "Predictions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Predictions {
            Predictions::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Predictions {
            static instance: Predictions = Predictions {
                correct: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.Bracket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bracket {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Bracket.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.Bracket.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.Bracket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bracket {
        fn default() -> &'a Bracket {
            <Bracket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bracket {
        pub fn new() -> Bracket {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 2;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bracket {
        const NAME: &'static str = "Bracket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bracket {
            Bracket::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bracket {
            static instance: Bracket = Bracket {
                correct: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.PlayerCard)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCard {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.PlayerCard.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.PlayerCard.quality)
        pub quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.PlayerCard.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCard {
        fn default() -> &'a PlayerCard {
            <PlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCard {
        pub fn new() -> PlayerCard {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCard {
        const NAME: &'static str = "PlayerCard";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCard {
            PlayerCard::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCard {
            static instance: PlayerCard = PlayerCard {
                account_id: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI7.FantasyChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.FantasyChallenge.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI7.FantasyChallenge.percentile)
        pub percentile: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI7.FantasyChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyChallenge {
        fn default() -> &'a FantasyChallenge {
            <FantasyChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FantasyChallenge {
        pub fn new() -> FantasyChallenge {
            ::std::default::Default::default()
        }

        // optional float total_score = 1;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional float percentile = 2;

        pub fn percentile(&self) -> f32 {
            self.percentile.unwrap_or(0.)
        }

        pub fn clear_percentile(&mut self) {
            self.percentile = ::std::option::Option::None;
        }

        pub fn has_percentile(&self) -> bool {
            self.percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentile(&mut self, v: f32) {
            self.percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FantasyChallenge {
        const NAME: &'static str = "FantasyChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.percentile = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.percentile {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.percentile {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyChallenge {
            FantasyChallenge::new()
        }

        fn clear(&mut self) {
            self.total_score = ::std::option::Option::None;
            self.percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyChallenge {
            static instance: FantasyChallenge = FantasyChallenge {
                total_score: ::std::option::Option::None,
                percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_TI8 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.cavern_crawl)
    pub cavern_crawl: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::CavernCrawl>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.wagering)
    pub wagering: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::Wagering>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.achievements)
    pub achievements: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::Achievements>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.predictions)
    pub predictions: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::Predictions>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.bracket)
    pub bracket: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::Bracket>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.player_cards)
    pub player_cards: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_ti8::PlayerCard>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.fantasy_challenge)
    pub fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField<cmsg_gcto_client_battle_pass_rollup_ti8::FantasyChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_TI8 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_TI8 {
        <CMsgGCToClientBattlePassRollup_TI8 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_TI8 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_TI8 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_TI8 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_TI8";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.cavern_crawl)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.wagering)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.achievements)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.predictions)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.bracket)?;
                },
                66 => {
                    self.player_cards.push(is.read_message()?);
                },
                74 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.fantasy_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.cavern_crawl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.wagering.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.achievements.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.predictions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.bracket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.player_cards {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.cavern_crawl.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.wagering.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.achievements.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.predictions.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.bracket.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.player_cards {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.fantasy_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_TI8 {
        CMsgGCToClientBattlePassRollup_TI8::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.cavern_crawl.clear();
        self.wagering.clear();
        self.achievements.clear();
        self.predictions.clear();
        self.bracket.clear();
        self.player_cards.clear();
        self.fantasy_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_TI8 {
        static instance: CMsgGCToClientBattlePassRollup_TI8 = CMsgGCToClientBattlePassRollup_TI8 {
            battle_pass_level: ::std::option::Option::None,
            cavern_crawl: ::steam_vent_proto_common::protobuf::MessageField::none(),
            wagering: ::steam_vent_proto_common::protobuf::MessageField::none(),
            achievements: ::steam_vent_proto_common::protobuf::MessageField::none(),
            predictions: ::steam_vent_proto_common::protobuf::MessageField::none(),
            bracket: ::steam_vent_proto_common::protobuf::MessageField::none(),
            player_cards: ::std::vec::Vec::new(),
            fantasy_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollup_TI8`
pub mod cmsg_gcto_client_battle_pass_rollup_ti8 {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CavernCrawl {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl.rooms_cleared)
        pub rooms_cleared: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl.carry_completed)
        pub carry_completed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl.support_completed)
        pub support_completed: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl.utility_completed)
        pub utility_completed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.CavernCrawl.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CavernCrawl {
        fn default() -> &'a CavernCrawl {
            <CavernCrawl as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CavernCrawl {
        pub fn new() -> CavernCrawl {
            ::std::default::Default::default()
        }

        // optional uint32 rooms_cleared = 1;

        pub fn rooms_cleared(&self) -> u32 {
            self.rooms_cleared.unwrap_or(0)
        }

        pub fn clear_rooms_cleared(&mut self) {
            self.rooms_cleared = ::std::option::Option::None;
        }

        pub fn has_rooms_cleared(&self) -> bool {
            self.rooms_cleared.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rooms_cleared(&mut self, v: u32) {
            self.rooms_cleared = ::std::option::Option::Some(v);
        }

        // optional bool carry_completed = 2;

        pub fn carry_completed(&self) -> bool {
            self.carry_completed.unwrap_or(false)
        }

        pub fn clear_carry_completed(&mut self) {
            self.carry_completed = ::std::option::Option::None;
        }

        pub fn has_carry_completed(&self) -> bool {
            self.carry_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_carry_completed(&mut self, v: bool) {
            self.carry_completed = ::std::option::Option::Some(v);
        }

        // optional bool support_completed = 3;

        pub fn support_completed(&self) -> bool {
            self.support_completed.unwrap_or(false)
        }

        pub fn clear_support_completed(&mut self) {
            self.support_completed = ::std::option::Option::None;
        }

        pub fn has_support_completed(&self) -> bool {
            self.support_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_support_completed(&mut self, v: bool) {
            self.support_completed = ::std::option::Option::Some(v);
        }

        // optional bool utility_completed = 4;

        pub fn utility_completed(&self) -> bool {
            self.utility_completed.unwrap_or(false)
        }

        pub fn clear_utility_completed(&mut self) {
            self.utility_completed = ::std::option::Option::None;
        }

        pub fn has_utility_completed(&self) -> bool {
            self.utility_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_utility_completed(&mut self, v: bool) {
            self.utility_completed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CavernCrawl {
        const NAME: &'static str = "CavernCrawl";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rooms_cleared = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.carry_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.support_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.utility_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rooms_cleared {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.carry_completed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.support_completed {
                my_size += 1 + 1;
            }
            if let Some(v) = self.utility_completed {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.rooms_cleared {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.carry_completed {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.support_completed {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.utility_completed {
                os.write_bool(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CavernCrawl {
            CavernCrawl::new()
        }

        fn clear(&mut self) {
            self.rooms_cleared = ::std::option::Option::None;
            self.carry_completed = ::std::option::Option::None;
            self.support_completed = ::std::option::Option::None;
            self.utility_completed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CavernCrawl {
            static instance: CavernCrawl = CavernCrawl {
                rooms_cleared: ::std::option::Option::None,
                carry_completed: ::std::option::Option::None,
                support_completed: ::std::option::Option::None,
                utility_completed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.Wagering)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Wagering {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Wagering.total_wagered)
        pub total_wagered: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Wagering.total_won)
        pub total_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Wagering.average_won)
        pub average_won: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Wagering.success_rate)
        pub success_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Wagering.total_tips)
        pub total_tips: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.Wagering.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Wagering {
        fn default() -> &'a Wagering {
            <Wagering as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Wagering {
        pub fn new() -> Wagering {
            ::std::default::Default::default()
        }

        // optional uint32 total_wagered = 1;

        pub fn total_wagered(&self) -> u32 {
            self.total_wagered.unwrap_or(0)
        }

        pub fn clear_total_wagered(&mut self) {
            self.total_wagered = ::std::option::Option::None;
        }

        pub fn has_total_wagered(&self) -> bool {
            self.total_wagered.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_wagered(&mut self, v: u32) {
            self.total_wagered = ::std::option::Option::Some(v);
        }

        // optional uint32 total_won = 2;

        pub fn total_won(&self) -> u32 {
            self.total_won.unwrap_or(0)
        }

        pub fn clear_total_won(&mut self) {
            self.total_won = ::std::option::Option::None;
        }

        pub fn has_total_won(&self) -> bool {
            self.total_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_won(&mut self, v: u32) {
            self.total_won = ::std::option::Option::Some(v);
        }

        // optional uint32 average_won = 3;

        pub fn average_won(&self) -> u32 {
            self.average_won.unwrap_or(0)
        }

        pub fn clear_average_won(&mut self) {
            self.average_won = ::std::option::Option::None;
        }

        pub fn has_average_won(&self) -> bool {
            self.average_won.is_some()
        }

        // Param is passed by value, moved
        pub fn set_average_won(&mut self, v: u32) {
            self.average_won = ::std::option::Option::Some(v);
        }

        // optional uint32 success_rate = 4;

        pub fn success_rate(&self) -> u32 {
            self.success_rate.unwrap_or(0)
        }

        pub fn clear_success_rate(&mut self) {
            self.success_rate = ::std::option::Option::None;
        }

        pub fn has_success_rate(&self) -> bool {
            self.success_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_success_rate(&mut self, v: u32) {
            self.success_rate = ::std::option::Option::Some(v);
        }

        // optional uint32 total_tips = 5;

        pub fn total_tips(&self) -> u32 {
            self.total_tips.unwrap_or(0)
        }

        pub fn clear_total_tips(&mut self) {
            self.total_tips = ::std::option::Option::None;
        }

        pub fn has_total_tips(&self) -> bool {
            self.total_tips.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_tips(&mut self, v: u32) {
            self.total_tips = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Wagering {
        const NAME: &'static str = "Wagering";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.total_wagered = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.average_won = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.success_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.total_tips = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_wagered {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.average_won {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.success_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.total_tips {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_wagered {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total_won {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.average_won {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.success_rate {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.total_tips {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Wagering {
            Wagering::new()
        }

        fn clear(&mut self) {
            self.total_wagered = ::std::option::Option::None;
            self.total_won = ::std::option::Option::None;
            self.average_won = ::std::option::Option::None;
            self.success_rate = ::std::option::Option::None;
            self.total_tips = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Wagering {
            static instance: Wagering = Wagering {
                total_wagered: ::std::option::Option::None,
                total_won: ::std::option::Option::None,
                average_won: ::std::option::Option::None,
                success_rate: ::std::option::Option::None,
                total_tips: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.Achievements)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Achievements {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Achievements.completed)
        pub completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Achievements.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Achievements.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.Achievements.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Achievements {
        fn default() -> &'a Achievements {
            <Achievements as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Achievements {
        pub fn new() -> Achievements {
            ::std::default::Default::default()
        }

        // optional uint32 completed = 1;

        pub fn completed(&self) -> u32 {
            self.completed.unwrap_or(0)
        }

        pub fn clear_completed(&mut self) {
            self.completed = ::std::option::Option::None;
        }

        pub fn has_completed(&self) -> bool {
            self.completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed(&mut self, v: u32) {
            self.completed = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Achievements {
        const NAME: &'static str = "Achievements";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Achievements {
            Achievements::new()
        }

        fn clear(&mut self) {
            self.completed = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Achievements {
            static instance: Achievements = Achievements {
                completed: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.Predictions)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Predictions {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Predictions.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Predictions.total)
        pub total: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Predictions.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.Predictions.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Predictions {
        fn default() -> &'a Predictions {
            <Predictions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Predictions {
        pub fn new() -> Predictions {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 total = 2;

        pub fn total(&self) -> u32 {
            self.total.unwrap_or(0)
        }

        pub fn clear_total(&mut self) {
            self.total = ::std::option::Option::None;
        }

        pub fn has_total(&self) -> bool {
            self.total.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total(&mut self, v: u32) {
            self.total = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 3;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Predictions {
        const NAME: &'static str = "Predictions";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.total = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.total {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.total {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Predictions {
            Predictions::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.total = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Predictions {
            static instance: Predictions = Predictions {
                correct: ::std::option::Option::None,
                total: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.Bracket)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Bracket {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Bracket.correct)
        pub correct: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.Bracket.points)
        pub points: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.Bracket.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Bracket {
        fn default() -> &'a Bracket {
            <Bracket as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Bracket {
        pub fn new() -> Bracket {
            ::std::default::Default::default()
        }

        // optional uint32 correct = 1;

        pub fn correct(&self) -> u32 {
            self.correct.unwrap_or(0)
        }

        pub fn clear_correct(&mut self) {
            self.correct = ::std::option::Option::None;
        }

        pub fn has_correct(&self) -> bool {
            self.correct.is_some()
        }

        // Param is passed by value, moved
        pub fn set_correct(&mut self, v: u32) {
            self.correct = ::std::option::Option::Some(v);
        }

        // optional uint32 points = 2;

        pub fn points(&self) -> u32 {
            self.points.unwrap_or(0)
        }

        pub fn clear_points(&mut self) {
            self.points = ::std::option::Option::None;
        }

        pub fn has_points(&self) -> bool {
            self.points.is_some()
        }

        // Param is passed by value, moved
        pub fn set_points(&mut self, v: u32) {
            self.points = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Bracket {
        const NAME: &'static str = "Bracket";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.correct = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.points = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.correct {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.points {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.correct {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.points {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Bracket {
            Bracket::new()
        }

        fn clear(&mut self) {
            self.correct = ::std::option::Option::None;
            self.points = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Bracket {
            static instance: Bracket = Bracket {
                correct: ::std::option::Option::None,
                points: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.PlayerCard)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct PlayerCard {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.PlayerCard.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.PlayerCard.quality)
        pub quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.PlayerCard.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a PlayerCard {
        fn default() -> &'a PlayerCard {
            <PlayerCard as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl PlayerCard {
        pub fn new() -> PlayerCard {
            ::std::default::Default::default()
        }

        // optional uint32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 quality = 2;

        pub fn quality(&self) -> u32 {
            self.quality.unwrap_or(0)
        }

        pub fn clear_quality(&mut self) {
            self.quality = ::std::option::Option::None;
        }

        pub fn has_quality(&self) -> bool {
            self.quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_quality(&mut self, v: u32) {
            self.quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for PlayerCard {
        const NAME: &'static str = "PlayerCard";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.quality {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> PlayerCard {
            PlayerCard::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static PlayerCard {
            static instance: PlayerCard = PlayerCard {
                account_id: ::std::option::Option::None,
                quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI8.FantasyChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FantasyChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.FantasyChallenge.total_score)
        pub total_score: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI8.FantasyChallenge.percentile)
        pub percentile: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI8.FantasyChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FantasyChallenge {
        fn default() -> &'a FantasyChallenge {
            <FantasyChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FantasyChallenge {
        pub fn new() -> FantasyChallenge {
            ::std::default::Default::default()
        }

        // optional float total_score = 1;

        pub fn total_score(&self) -> f32 {
            self.total_score.unwrap_or(0.)
        }

        pub fn clear_total_score(&mut self) {
            self.total_score = ::std::option::Option::None;
        }

        pub fn has_total_score(&self) -> bool {
            self.total_score.is_some()
        }

        // Param is passed by value, moved
        pub fn set_total_score(&mut self, v: f32) {
            self.total_score = ::std::option::Option::Some(v);
        }

        // optional float percentile = 2;

        pub fn percentile(&self) -> f32 {
            self.percentile.unwrap_or(0.)
        }

        pub fn clear_percentile(&mut self) {
            self.percentile = ::std::option::Option::None;
        }

        pub fn has_percentile(&self) -> bool {
            self.percentile.is_some()
        }

        // Param is passed by value, moved
        pub fn set_percentile(&mut self, v: f32) {
            self.percentile = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FantasyChallenge {
        const NAME: &'static str = "FantasyChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.total_score = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.percentile = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.total_score {
                my_size += 1 + 4;
            }
            if let Some(v) = self.percentile {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.total_score {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.percentile {
                os.write_float(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FantasyChallenge {
            FantasyChallenge::new()
        }

        fn clear(&mut self) {
            self.total_score = ::std::option::Option::None;
            self.percentile = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FantasyChallenge {
            static instance: FantasyChallenge = FantasyChallenge {
                total_score: ::std::option::Option::None,
                percentile: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI9)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_TI9 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI9.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI9.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_TI9 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_TI9 {
        <CMsgGCToClientBattlePassRollup_TI9 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_TI9 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_TI9 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_TI9 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_TI9";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_TI9 {
        CMsgGCToClientBattlePassRollup_TI9::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_TI9 {
        static instance: CMsgGCToClientBattlePassRollup_TI9 = CMsgGCToClientBattlePassRollup_TI9 {
            battle_pass_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollup_TI10)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollup_TI10 {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollup_TI10.battle_pass_level)
    pub battle_pass_level: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollup_TI10.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollup_TI10 {
    fn default() -> &'a CMsgGCToClientBattlePassRollup_TI10 {
        <CMsgGCToClientBattlePassRollup_TI10 as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollup_TI10 {
    pub fn new() -> CMsgGCToClientBattlePassRollup_TI10 {
        ::std::default::Default::default()
    }

    // optional uint32 battle_pass_level = 1;

    pub fn battle_pass_level(&self) -> u32 {
        self.battle_pass_level.unwrap_or(0)
    }

    pub fn clear_battle_pass_level(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
    }

    pub fn has_battle_pass_level(&self) -> bool {
        self.battle_pass_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_battle_pass_level(&mut self, v: u32) {
        self.battle_pass_level = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollup_TI10 {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollup_TI10";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.battle_pass_level = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.battle_pass_level {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.battle_pass_level {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollup_TI10 {
        CMsgGCToClientBattlePassRollup_TI10::new()
    }

    fn clear(&mut self) {
        self.battle_pass_level = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollup_TI10 {
        static instance: CMsgGCToClientBattlePassRollup_TI10 = CMsgGCToClientBattlePassRollup_TI10 {
            battle_pass_level: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollupRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollupRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupRequest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollupRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollupRequest {
    fn default() -> &'a CMsgGCToClientBattlePassRollupRequest {
        <CMsgGCToClientBattlePassRollupRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollupRequest {
    pub fn new() -> CMsgGCToClientBattlePassRollupRequest {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollupRequest {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollupRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollupRequest {
        CMsgGCToClientBattlePassRollupRequest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollupRequest {
        static instance: CMsgGCToClientBattlePassRollupRequest = CMsgGCToClientBattlePassRollupRequest {
            event_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollupResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollupResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_ti6)
    pub event_ti6: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_International2016>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_fall2016)
    pub event_fall2016: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_Fall2016>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_winter2017)
    pub event_winter2017: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_Winter2017>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_ti7)
    pub event_ti7: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_TI7>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_ti8)
    pub event_ti8: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_TI8>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_ti9)
    pub event_ti9: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_TI9>,
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupResponse.event_ti10)
    pub event_ti10: ::steam_vent_proto_common::protobuf::MessageField<CMsgGCToClientBattlePassRollup_TI10>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollupResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollupResponse {
    fn default() -> &'a CMsgGCToClientBattlePassRollupResponse {
        <CMsgGCToClientBattlePassRollupResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollupResponse {
    pub fn new() -> CMsgGCToClientBattlePassRollupResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollupResponse {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollupResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_ti6)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_fall2016)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_winter2017)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_ti7)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_ti8)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_ti9)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_ti10)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_ti6.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_fall2016.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_winter2017.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_ti7.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_ti8.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_ti9.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.event_ti10.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_ti6.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.event_fall2016.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.event_winter2017.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.event_ti7.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.event_ti8.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.event_ti9.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.event_ti10.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollupResponse {
        CMsgGCToClientBattlePassRollupResponse::new()
    }

    fn clear(&mut self) {
        self.event_ti6.clear();
        self.event_fall2016.clear();
        self.event_winter2017.clear();
        self.event_ti7.clear();
        self.event_ti8.clear();
        self.event_ti9.clear();
        self.event_ti10.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollupResponse {
        static instance: CMsgGCToClientBattlePassRollupResponse = CMsgGCToClientBattlePassRollupResponse {
            event_ti6: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_fall2016: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_winter2017: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_ti7: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_ti8: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_ti9: ::steam_vent_proto_common::protobuf::MessageField::none(),
            event_ti10: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollupListRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollupListRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupListRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollupListRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollupListRequest {
    fn default() -> &'a CMsgGCToClientBattlePassRollupListRequest {
        <CMsgGCToClientBattlePassRollupListRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollupListRequest {
    pub fn new() -> CMsgGCToClientBattlePassRollupListRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollupListRequest {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollupListRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollupListRequest {
        CMsgGCToClientBattlePassRollupListRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollupListRequest {
        static instance: CMsgGCToClientBattlePassRollupListRequest = CMsgGCToClientBattlePassRollupListRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollupListResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientBattlePassRollupListResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupListResponse.event_info)
    pub event_info: ::std::vec::Vec<cmsg_gcto_client_battle_pass_rollup_list_response::EventInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollupListResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientBattlePassRollupListResponse {
    fn default() -> &'a CMsgGCToClientBattlePassRollupListResponse {
        <CMsgGCToClientBattlePassRollupListResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientBattlePassRollupListResponse {
    pub fn new() -> CMsgGCToClientBattlePassRollupListResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientBattlePassRollupListResponse {
    const NAME: &'static str = "CMsgGCToClientBattlePassRollupListResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.event_info.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.event_info {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.event_info {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientBattlePassRollupListResponse {
        CMsgGCToClientBattlePassRollupListResponse::new()
    }

    fn clear(&mut self) {
        self.event_info.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientBattlePassRollupListResponse {
        static instance: CMsgGCToClientBattlePassRollupListResponse = CMsgGCToClientBattlePassRollupListResponse {
            event_info: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientBattlePassRollupListResponse`
pub mod cmsg_gcto_client_battle_pass_rollup_list_response {
    // @@protoc_insertion_point(message:CMsgGCToClientBattlePassRollupListResponse.EventInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EventInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupListResponse.EventInfo.event_id)
        pub event_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientBattlePassRollupListResponse.EventInfo.level)
        pub level: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientBattlePassRollupListResponse.EventInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EventInfo {
        fn default() -> &'a EventInfo {
            <EventInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl EventInfo {
        pub fn new() -> EventInfo {
            ::std::default::Default::default()
        }

        // optional uint32 event_id = 1;

        pub fn event_id(&self) -> u32 {
            self.event_id.unwrap_or(0)
        }

        pub fn clear_event_id(&mut self) {
            self.event_id = ::std::option::Option::None;
        }

        pub fn has_event_id(&self) -> bool {
            self.event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_id(&mut self, v: u32) {
            self.event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 level = 2;

        pub fn level(&self) -> u32 {
            self.level.unwrap_or(0)
        }

        pub fn clear_level(&mut self) {
            self.level = ::std::option::Option::None;
        }

        pub fn has_level(&self) -> bool {
            self.level.is_some()
        }

        // Param is passed by value, moved
        pub fn set_level(&mut self, v: u32) {
            self.level = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for EventInfo {
        const NAME: &'static str = "EventInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.level = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.level {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.event_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.level {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EventInfo {
            EventInfo::new()
        }

        fn clear(&mut self) {
            self.event_id = ::std::option::Option::None;
            self.level = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EventInfo {
            static instance: EventInfo = EventInfo {
                event_id: ::std::option::Option::None,
                level: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCTransferSeasonalMMRRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCTransferSeasonalMMRRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCTransferSeasonalMMRRequest.is_party)
    pub is_party: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCTransferSeasonalMMRRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCTransferSeasonalMMRRequest {
    fn default() -> &'a CMsgClientToGCTransferSeasonalMMRRequest {
        <CMsgClientToGCTransferSeasonalMMRRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCTransferSeasonalMMRRequest {
    pub fn new() -> CMsgClientToGCTransferSeasonalMMRRequest {
        ::std::default::Default::default()
    }

    // optional bool is_party = 1;

    pub fn is_party(&self) -> bool {
        self.is_party.unwrap_or(false)
    }

    pub fn clear_is_party(&mut self) {
        self.is_party = ::std::option::Option::None;
    }

    pub fn has_is_party(&self) -> bool {
        self.is_party.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_party(&mut self, v: bool) {
        self.is_party = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCTransferSeasonalMMRRequest {
    const NAME: &'static str = "CMsgClientToGCTransferSeasonalMMRRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.is_party = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.is_party {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.is_party {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCTransferSeasonalMMRRequest {
        CMsgClientToGCTransferSeasonalMMRRequest::new()
    }

    fn clear(&mut self) {
        self.is_party = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCTransferSeasonalMMRRequest {
        static instance: CMsgClientToGCTransferSeasonalMMRRequest = CMsgClientToGCTransferSeasonalMMRRequest {
            is_party: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCTransferSeasonalMMRResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCTransferSeasonalMMRResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCTransferSeasonalMMRResponse.success)
    pub success: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCTransferSeasonalMMRResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCTransferSeasonalMMRResponse {
    fn default() -> &'a CMsgClientToGCTransferSeasonalMMRResponse {
        <CMsgClientToGCTransferSeasonalMMRResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCTransferSeasonalMMRResponse {
    pub fn new() -> CMsgClientToGCTransferSeasonalMMRResponse {
        ::std::default::Default::default()
    }

    // optional bool success = 1;

    pub fn success(&self) -> bool {
        self.success.unwrap_or(false)
    }

    pub fn clear_success(&mut self) {
        self.success = ::std::option::Option::None;
    }

    pub fn has_success(&self) -> bool {
        self.success.is_some()
    }

    // Param is passed by value, moved
    pub fn set_success(&mut self, v: bool) {
        self.success = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCTransferSeasonalMMRResponse {
    const NAME: &'static str = "CMsgClientToGCTransferSeasonalMMRResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.success {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.success {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCTransferSeasonalMMRResponse {
        CMsgClientToGCTransferSeasonalMMRResponse::new()
    }

    fn clear(&mut self) {
        self.success = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCTransferSeasonalMMRResponse {
        static instance: CMsgClientToGCTransferSeasonalMMRResponse = CMsgClientToGCTransferSeasonalMMRResponse {
            success: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPlaytestStatus)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPlaytestStatus {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPlaytestStatus.active)
    pub active: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPlaytestStatus.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPlaytestStatus {
    fn default() -> &'a CMsgGCToClientPlaytestStatus {
        <CMsgGCToClientPlaytestStatus as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPlaytestStatus {
    pub fn new() -> CMsgGCToClientPlaytestStatus {
        ::std::default::Default::default()
    }

    // optional bool active = 1;

    pub fn active(&self) -> bool {
        self.active.unwrap_or(false)
    }

    pub fn clear_active(&mut self) {
        self.active = ::std::option::Option::None;
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: bool) {
        self.active = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPlaytestStatus {
    const NAME: &'static str = "CMsgGCToClientPlaytestStatus";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.active = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.active {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.active {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPlaytestStatus {
        CMsgGCToClientPlaytestStatus::new()
    }

    fn clear(&mut self) {
        self.active = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPlaytestStatus {
        static instance: CMsgGCToClientPlaytestStatus = CMsgGCToClientPlaytestStatus {
            active: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCJoinPlaytest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinPlaytest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCJoinPlaytest.client_version)
    pub client_version: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCJoinPlaytest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinPlaytest {
    fn default() -> &'a CMsgClientToGCJoinPlaytest {
        <CMsgClientToGCJoinPlaytest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinPlaytest {
    pub fn new() -> CMsgClientToGCJoinPlaytest {
        ::std::default::Default::default()
    }

    // optional uint32 client_version = 1;

    pub fn client_version(&self) -> u32 {
        self.client_version.unwrap_or(0)
    }

    pub fn clear_client_version(&mut self) {
        self.client_version = ::std::option::Option::None;
    }

    pub fn has_client_version(&self) -> bool {
        self.client_version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_version(&mut self, v: u32) {
        self.client_version = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCJoinPlaytest {
    const NAME: &'static str = "CMsgClientToGCJoinPlaytest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.client_version = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.client_version {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.client_version {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinPlaytest {
        CMsgClientToGCJoinPlaytest::new()
    }

    fn clear(&mut self) {
        self.client_version = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinPlaytest {
        static instance: CMsgClientToGCJoinPlaytest = CMsgClientToGCJoinPlaytest {
            client_version: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCJoinPlaytestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinPlaytestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCJoinPlaytestResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCJoinPlaytestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinPlaytestResponse {
    fn default() -> &'a CMsgClientToGCJoinPlaytestResponse {
        <CMsgClientToGCJoinPlaytestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinPlaytestResponse {
    pub fn new() -> CMsgClientToGCJoinPlaytestResponse {
        ::std::default::Default::default()
    }

    // optional string error = 1;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCJoinPlaytestResponse {
    const NAME: &'static str = "CMsgClientToGCJoinPlaytestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.error.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinPlaytestResponse {
        CMsgClientToGCJoinPlaytestResponse::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinPlaytestResponse {
        static instance: CMsgClientToGCJoinPlaytestResponse = CMsgClientToGCJoinPlaytestResponse {
            error: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASetFavoriteTeam)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASetFavoriteTeam {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASetFavoriteTeam.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASetFavoriteTeam.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASetFavoriteTeam.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASetFavoriteTeam {
    fn default() -> &'a CMsgDOTASetFavoriteTeam {
        <CMsgDOTASetFavoriteTeam as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASetFavoriteTeam {
    pub fn new() -> CMsgDOTASetFavoriteTeam {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASetFavoriteTeam {
    const NAME: &'static str = "CMsgDOTASetFavoriteTeam";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASetFavoriteTeam {
        CMsgDOTASetFavoriteTeam::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASetFavoriteTeam {
        static instance: CMsgDOTASetFavoriteTeam = CMsgDOTASetFavoriteTeam {
            team_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTATriviaCurrentQuestions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTATriviaCurrentQuestions {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTATriviaCurrentQuestions.questions)
    pub questions: ::std::vec::Vec<super::dota_gcmessages_common::CMsgDOTATriviaQuestion>,
    // @@protoc_insertion_point(field:CMsgDOTATriviaCurrentQuestions.trivia_enabled)
    pub trivia_enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTATriviaCurrentQuestions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTATriviaCurrentQuestions {
    fn default() -> &'a CMsgDOTATriviaCurrentQuestions {
        <CMsgDOTATriviaCurrentQuestions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTATriviaCurrentQuestions {
    pub fn new() -> CMsgDOTATriviaCurrentQuestions {
        ::std::default::Default::default()
    }

    // optional bool trivia_enabled = 2;

    pub fn trivia_enabled(&self) -> bool {
        self.trivia_enabled.unwrap_or(false)
    }

    pub fn clear_trivia_enabled(&mut self) {
        self.trivia_enabled = ::std::option::Option::None;
    }

    pub fn has_trivia_enabled(&self) -> bool {
        self.trivia_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trivia_enabled(&mut self, v: bool) {
        self.trivia_enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTATriviaCurrentQuestions {
    const NAME: &'static str = "CMsgDOTATriviaCurrentQuestions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.questions.push(is.read_message()?);
                },
                16 => {
                    self.trivia_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.questions {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.trivia_enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.questions {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if let Some(v) = self.trivia_enabled {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTATriviaCurrentQuestions {
        CMsgDOTATriviaCurrentQuestions::new()
    }

    fn clear(&mut self) {
        self.questions.clear();
        self.trivia_enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTATriviaCurrentQuestions {
        static instance: CMsgDOTATriviaCurrentQuestions = CMsgDOTATriviaCurrentQuestions {
            questions: ::std::vec::Vec::new(),
            trivia_enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitTriviaQuestionAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitTriviaQuestionAnswer {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitTriviaQuestionAnswer.question_id)
    pub question_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTASubmitTriviaQuestionAnswer.answer_index)
    pub answer_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitTriviaQuestionAnswer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitTriviaQuestionAnswer {
    fn default() -> &'a CMsgDOTASubmitTriviaQuestionAnswer {
        <CMsgDOTASubmitTriviaQuestionAnswer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitTriviaQuestionAnswer {
    pub fn new() -> CMsgDOTASubmitTriviaQuestionAnswer {
        ::std::default::Default::default()
    }

    // optional uint32 question_id = 1;

    pub fn question_id(&self) -> u32 {
        self.question_id.unwrap_or(0)
    }

    pub fn clear_question_id(&mut self) {
        self.question_id = ::std::option::Option::None;
    }

    pub fn has_question_id(&self) -> bool {
        self.question_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_question_id(&mut self, v: u32) {
        self.question_id = ::std::option::Option::Some(v);
    }

    // optional uint32 answer_index = 2;

    pub fn answer_index(&self) -> u32 {
        self.answer_index.unwrap_or(0)
    }

    pub fn clear_answer_index(&mut self) {
        self.answer_index = ::std::option::Option::None;
    }

    pub fn has_answer_index(&self) -> bool {
        self.answer_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_answer_index(&mut self, v: u32) {
        self.answer_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitTriviaQuestionAnswer {
    const NAME: &'static str = "CMsgDOTASubmitTriviaQuestionAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.question_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.answer_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.question_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.answer_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.question_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.answer_index {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitTriviaQuestionAnswer {
        CMsgDOTASubmitTriviaQuestionAnswer::new()
    }

    fn clear(&mut self) {
        self.question_id = ::std::option::Option::None;
        self.answer_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitTriviaQuestionAnswer {
        static instance: CMsgDOTASubmitTriviaQuestionAnswer = CMsgDOTASubmitTriviaQuestionAnswer {
            question_id: ::std::option::Option::None,
            answer_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASubmitTriviaQuestionAnswerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASubmitTriviaQuestionAnswerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASubmitTriviaQuestionAnswerResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDOTATriviaAnswerResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASubmitTriviaQuestionAnswerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn default() -> &'a CMsgDOTASubmitTriviaQuestionAnswerResponse {
        <CMsgDOTASubmitTriviaQuestionAnswerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASubmitTriviaQuestionAnswerResponse {
    pub fn new() -> CMsgDOTASubmitTriviaQuestionAnswerResponse {
        ::std::default::Default::default()
    }

    // optional .EDOTATriviaAnswerResult result = 1;

    pub fn result(&self) -> EDOTATriviaAnswerResult {
        match self.result {
            Some(e) => e.enum_value_or(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success),
            None => EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDOTATriviaAnswerResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    const NAME: &'static str = "CMsgDOTASubmitTriviaQuestionAnswerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASubmitTriviaQuestionAnswerResponse {
        CMsgDOTASubmitTriviaQuestionAnswerResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASubmitTriviaQuestionAnswerResponse {
        static instance: CMsgDOTASubmitTriviaQuestionAnswerResponse = CMsgDOTASubmitTriviaQuestionAnswerResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAStartTriviaSession)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAStartTriviaSession {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAStartTriviaSession.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAStartTriviaSession {
    fn default() -> &'a CMsgDOTAStartTriviaSession {
        <CMsgDOTAStartTriviaSession as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAStartTriviaSession {
    pub fn new() -> CMsgDOTAStartTriviaSession {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAStartTriviaSession {
    const NAME: &'static str = "CMsgDOTAStartTriviaSession";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAStartTriviaSession {
        CMsgDOTAStartTriviaSession::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAStartTriviaSession {
        static instance: CMsgDOTAStartTriviaSession = CMsgDOTAStartTriviaSession {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAStartTriviaSessionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAStartTriviaSessionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAStartTriviaSessionResponse.trivia_enabled)
    pub trivia_enabled: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgDOTAStartTriviaSessionResponse.current_timestamp)
    pub current_timestamp: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAStartTriviaSessionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAStartTriviaSessionResponse {
    fn default() -> &'a CMsgDOTAStartTriviaSessionResponse {
        <CMsgDOTAStartTriviaSessionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAStartTriviaSessionResponse {
    pub fn new() -> CMsgDOTAStartTriviaSessionResponse {
        ::std::default::Default::default()
    }

    // optional bool trivia_enabled = 1;

    pub fn trivia_enabled(&self) -> bool {
        self.trivia_enabled.unwrap_or(false)
    }

    pub fn clear_trivia_enabled(&mut self) {
        self.trivia_enabled = ::std::option::Option::None;
    }

    pub fn has_trivia_enabled(&self) -> bool {
        self.trivia_enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trivia_enabled(&mut self, v: bool) {
        self.trivia_enabled = ::std::option::Option::Some(v);
    }

    // optional uint32 current_timestamp = 2;

    pub fn current_timestamp(&self) -> u32 {
        self.current_timestamp.unwrap_or(0)
    }

    pub fn clear_current_timestamp(&mut self) {
        self.current_timestamp = ::std::option::Option::None;
    }

    pub fn has_current_timestamp(&self) -> bool {
        self.current_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_current_timestamp(&mut self, v: u32) {
        self.current_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAStartTriviaSessionResponse {
    const NAME: &'static str = "CMsgDOTAStartTriviaSessionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.trivia_enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.current_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.trivia_enabled {
            my_size += 1 + 1;
        }
        if let Some(v) = self.current_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.trivia_enabled {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.current_timestamp {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAStartTriviaSessionResponse {
        CMsgDOTAStartTriviaSessionResponse::new()
    }

    fn clear(&mut self) {
        self.trivia_enabled = ::std::option::Option::None;
        self.current_timestamp = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAStartTriviaSessionResponse {
        static instance: CMsgDOTAStartTriviaSessionResponse = CMsgDOTAStartTriviaSessionResponse {
            trivia_enabled: ::std::option::Option::None,
            current_timestamp: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAAnchorPhoneNumberRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAAnchorPhoneNumberRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAAnchorPhoneNumberRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAAnchorPhoneNumberRequest {
    fn default() -> &'a CMsgDOTAAnchorPhoneNumberRequest {
        <CMsgDOTAAnchorPhoneNumberRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAAnchorPhoneNumberRequest {
    pub fn new() -> CMsgDOTAAnchorPhoneNumberRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAAnchorPhoneNumberRequest {
    const NAME: &'static str = "CMsgDOTAAnchorPhoneNumberRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAAnchorPhoneNumberRequest {
        CMsgDOTAAnchorPhoneNumberRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAAnchorPhoneNumberRequest {
        static instance: CMsgDOTAAnchorPhoneNumberRequest = CMsgDOTAAnchorPhoneNumberRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAAnchorPhoneNumberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAAnchorPhoneNumberResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAAnchorPhoneNumberResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotaanchor_phone_number_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAAnchorPhoneNumberResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAAnchorPhoneNumberResponse {
    fn default() -> &'a CMsgDOTAAnchorPhoneNumberResponse {
        <CMsgDOTAAnchorPhoneNumberResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAAnchorPhoneNumberResponse {
    pub fn new() -> CMsgDOTAAnchorPhoneNumberResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAAnchorPhoneNumberResponse.Result result = 1;

    pub fn result(&self) -> cmsg_dotaanchor_phone_number_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotaanchor_phone_number_response::Result::SUCCESS),
            None => cmsg_dotaanchor_phone_number_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotaanchor_phone_number_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAAnchorPhoneNumberResponse {
    const NAME: &'static str = "CMsgDOTAAnchorPhoneNumberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAAnchorPhoneNumberResponse {
        CMsgDOTAAnchorPhoneNumberResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAAnchorPhoneNumberResponse {
        static instance: CMsgDOTAAnchorPhoneNumberResponse = CMsgDOTAAnchorPhoneNumberResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAAnchorPhoneNumberResponse`
pub mod cmsg_dotaanchor_phone_number_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAAnchorPhoneNumberResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.ERROR_NO_STEAM_PHONE)
        ERROR_NO_STEAM_PHONE = 2,
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.ERROR_ALREADY_IN_USE)
        ERROR_ALREADY_IN_USE = 3,
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.ERROR_COOLDOWN_ACTIVE)
        ERROR_COOLDOWN_ACTIVE = 4,
        // @@protoc_insertion_point(enum_value:CMsgDOTAAnchorPhoneNumberResponse.Result.ERROR_GAC_ISSUE)
        ERROR_GAC_ISSUE = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::ERROR_NO_STEAM_PHONE),
                3 => ::std::option::Option::Some(Result::ERROR_ALREADY_IN_USE),
                4 => ::std::option::Option::Some(Result::ERROR_COOLDOWN_ACTIVE),
                5 => ::std::option::Option::Some(Result::ERROR_GAC_ISSUE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "ERROR_NO_STEAM_PHONE" => ::std::option::Option::Some(Result::ERROR_NO_STEAM_PHONE),
                "ERROR_ALREADY_IN_USE" => ::std::option::Option::Some(Result::ERROR_ALREADY_IN_USE),
                "ERROR_COOLDOWN_ACTIVE" => ::std::option::Option::Some(Result::ERROR_COOLDOWN_ACTIVE),
                "ERROR_GAC_ISSUE" => ::std::option::Option::Some(Result::ERROR_GAC_ISSUE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::ERROR_NO_STEAM_PHONE,
            Result::ERROR_ALREADY_IN_USE,
            Result::ERROR_COOLDOWN_ACTIVE,
            Result::ERROR_GAC_ISSUE,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAUnanchorPhoneNumberRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAUnanchorPhoneNumberRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAUnanchorPhoneNumberRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAUnanchorPhoneNumberRequest {
    fn default() -> &'a CMsgDOTAUnanchorPhoneNumberRequest {
        <CMsgDOTAUnanchorPhoneNumberRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAUnanchorPhoneNumberRequest {
    pub fn new() -> CMsgDOTAUnanchorPhoneNumberRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAUnanchorPhoneNumberRequest {
    const NAME: &'static str = "CMsgDOTAUnanchorPhoneNumberRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAUnanchorPhoneNumberRequest {
        CMsgDOTAUnanchorPhoneNumberRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAUnanchorPhoneNumberRequest {
        static instance: CMsgDOTAUnanchorPhoneNumberRequest = CMsgDOTAUnanchorPhoneNumberRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAUnanchorPhoneNumberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAUnanchorPhoneNumberResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAUnanchorPhoneNumberResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotaunanchor_phone_number_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAUnanchorPhoneNumberResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAUnanchorPhoneNumberResponse {
    fn default() -> &'a CMsgDOTAUnanchorPhoneNumberResponse {
        <CMsgDOTAUnanchorPhoneNumberResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAUnanchorPhoneNumberResponse {
    pub fn new() -> CMsgDOTAUnanchorPhoneNumberResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAUnanchorPhoneNumberResponse.Result result = 1;

    pub fn result(&self) -> cmsg_dotaunanchor_phone_number_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotaunanchor_phone_number_response::Result::SUCCESS),
            None => cmsg_dotaunanchor_phone_number_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotaunanchor_phone_number_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAUnanchorPhoneNumberResponse {
    const NAME: &'static str = "CMsgDOTAUnanchorPhoneNumberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAUnanchorPhoneNumberResponse {
        CMsgDOTAUnanchorPhoneNumberResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAUnanchorPhoneNumberResponse {
        static instance: CMsgDOTAUnanchorPhoneNumberResponse = CMsgDOTAUnanchorPhoneNumberResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAUnanchorPhoneNumberResponse`
pub mod cmsg_dotaunanchor_phone_number_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAUnanchorPhoneNumberResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgDOTAUnanchorPhoneNumberResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAUnanchorPhoneNumberResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientCommendNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCommendNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCommendNotification.commender_account_id)
    pub commender_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientCommendNotification.commender_name)
    pub commender_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToClientCommendNotification.flags)
    pub flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientCommendNotification.commender_hero_id)
    pub commender_hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCommendNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCommendNotification {
    fn default() -> &'a CMsgGCToClientCommendNotification {
        <CMsgGCToClientCommendNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCommendNotification {
    pub fn new() -> CMsgGCToClientCommendNotification {
        ::std::default::Default::default()
    }

    // optional uint32 commender_account_id = 1;

    pub fn commender_account_id(&self) -> u32 {
        self.commender_account_id.unwrap_or(0)
    }

    pub fn clear_commender_account_id(&mut self) {
        self.commender_account_id = ::std::option::Option::None;
    }

    pub fn has_commender_account_id(&self) -> bool {
        self.commender_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commender_account_id(&mut self, v: u32) {
        self.commender_account_id = ::std::option::Option::Some(v);
    }

    // optional string commender_name = 2;

    pub fn commender_name(&self) -> &str {
        match self.commender_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_commender_name(&mut self) {
        self.commender_name = ::std::option::Option::None;
    }

    pub fn has_commender_name(&self) -> bool {
        self.commender_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commender_name(&mut self, v: ::std::string::String) {
        self.commender_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commender_name(&mut self) -> &mut ::std::string::String {
        if self.commender_name.is_none() {
            self.commender_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.commender_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_commender_name(&mut self) -> ::std::string::String {
        self.commender_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 flags = 3;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }

    // optional int32 commender_hero_id = 4;

    pub fn commender_hero_id(&self) -> i32 {
        self.commender_hero_id.unwrap_or(0)
    }

    pub fn clear_commender_hero_id(&mut self) {
        self.commender_hero_id = ::std::option::Option::None;
    }

    pub fn has_commender_hero_id(&self) -> bool {
        self.commender_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commender_hero_id(&mut self, v: i32) {
        self.commender_hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCommendNotification {
    const NAME: &'static str = "CMsgGCToClientCommendNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.commender_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.commender_name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.commender_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.commender_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.commender_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.commender_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.commender_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.commender_name.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.commender_hero_id {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCommendNotification {
        CMsgGCToClientCommendNotification::new()
    }

    fn clear(&mut self) {
        self.commender_account_id = ::std::option::Option::None;
        self.commender_name = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.commender_hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCommendNotification {
        static instance: CMsgGCToClientCommendNotification = CMsgGCToClientCommendNotification {
            commender_account_id: ::std::option::Option::None,
            commender_name: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            commender_hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAClientToGCQuickStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAClientToGCQuickStatsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsRequest.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsRequest.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsRequest.item_id)
    pub item_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsRequest.league_id)
    pub league_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAClientToGCQuickStatsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAClientToGCQuickStatsRequest {
    fn default() -> &'a CMsgDOTAClientToGCQuickStatsRequest {
        <CMsgDOTAClientToGCQuickStatsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAClientToGCQuickStatsRequest {
    pub fn new() -> CMsgDOTAClientToGCQuickStatsRequest {
        ::std::default::Default::default()
    }

    // optional uint32 player_account_id = 1;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional int32 item_id = 3;

    pub fn item_id(&self) -> i32 {
        self.item_id.unwrap_or(-1i32)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: i32) {
        self.item_id = ::std::option::Option::Some(v);
    }

    // optional uint32 league_id = 4;

    pub fn league_id(&self) -> u32 {
        self.league_id.unwrap_or(0)
    }

    pub fn clear_league_id(&mut self) {
        self.league_id = ::std::option::Option::None;
    }

    pub fn has_league_id(&self) -> bool {
        self.league_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_league_id(&mut self, v: u32) {
        self.league_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAClientToGCQuickStatsRequest {
    const NAME: &'static str = "CMsgDOTAClientToGCQuickStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.item_id = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.league_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.league_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.item_id {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.league_id {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAClientToGCQuickStatsRequest {
        CMsgDOTAClientToGCQuickStatsRequest::new()
    }

    fn clear(&mut self) {
        self.player_account_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.league_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAClientToGCQuickStatsRequest {
        static instance: CMsgDOTAClientToGCQuickStatsRequest = CMsgDOTAClientToGCQuickStatsRequest {
            player_account_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            league_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAClientToGCQuickStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAClientToGCQuickStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.original_request)
    pub original_request: ::steam_vent_proto_common::protobuf::MessageField<CMsgDOTAClientToGCQuickStatsRequest>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.hero_stats)
    pub hero_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.item_stats)
    pub item_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.item_hero_stats)
    pub item_hero_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.item_player_stats)
    pub item_player_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.hero_player_stats)
    pub hero_player_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.full_set_stats)
    pub full_set_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_dotaclient_to_gcquick_stats_response::SimpleStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAClientToGCQuickStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAClientToGCQuickStatsResponse {
    fn default() -> &'a CMsgDOTAClientToGCQuickStatsResponse {
        <CMsgDOTAClientToGCQuickStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAClientToGCQuickStatsResponse {
    pub fn new() -> CMsgDOTAClientToGCQuickStatsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAClientToGCQuickStatsResponse {
    const NAME: &'static str = "CMsgDOTAClientToGCQuickStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.original_request)?;
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_stats)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_stats)?;
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_hero_stats)?;
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.item_player_stats)?;
                },
                50 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_player_stats)?;
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.full_set_stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.original_request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_hero_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.item_player_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.hero_player_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.full_set_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.original_request.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.hero_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.item_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.item_hero_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.item_player_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.hero_player_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.full_set_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAClientToGCQuickStatsResponse {
        CMsgDOTAClientToGCQuickStatsResponse::new()
    }

    fn clear(&mut self) {
        self.original_request.clear();
        self.hero_stats.clear();
        self.item_stats.clear();
        self.item_hero_stats.clear();
        self.item_player_stats.clear();
        self.hero_player_stats.clear();
        self.full_set_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAClientToGCQuickStatsResponse {
        static instance: CMsgDOTAClientToGCQuickStatsResponse = CMsgDOTAClientToGCQuickStatsResponse {
            original_request: ::steam_vent_proto_common::protobuf::MessageField::none(),
            hero_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_hero_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            item_player_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            hero_player_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            full_set_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAClientToGCQuickStatsResponse`
pub mod cmsg_dotaclient_to_gcquick_stats_response {
    // @@protoc_insertion_point(message:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SimpleStats {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats.win_percent)
        pub win_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats.pick_percent)
        pub pick_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats.win_count)
        pub win_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats.pick_count)
        pub pick_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAClientToGCQuickStatsResponse.SimpleStats.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SimpleStats {
        fn default() -> &'a SimpleStats {
            <SimpleStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SimpleStats {
        pub fn new() -> SimpleStats {
            ::std::default::Default::default()
        }

        // optional float win_percent = 1;

        pub fn win_percent(&self) -> f32 {
            self.win_percent.unwrap_or(0.)
        }

        pub fn clear_win_percent(&mut self) {
            self.win_percent = ::std::option::Option::None;
        }

        pub fn has_win_percent(&self) -> bool {
            self.win_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_percent(&mut self, v: f32) {
            self.win_percent = ::std::option::Option::Some(v);
        }

        // optional float pick_percent = 2;

        pub fn pick_percent(&self) -> f32 {
            self.pick_percent.unwrap_or(0.)
        }

        pub fn clear_pick_percent(&mut self) {
            self.pick_percent = ::std::option::Option::None;
        }

        pub fn has_pick_percent(&self) -> bool {
            self.pick_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_percent(&mut self, v: f32) {
            self.pick_percent = ::std::option::Option::Some(v);
        }

        // optional uint32 win_count = 3;

        pub fn win_count(&self) -> u32 {
            self.win_count.unwrap_or(0)
        }

        pub fn clear_win_count(&mut self) {
            self.win_count = ::std::option::Option::None;
        }

        pub fn has_win_count(&self) -> bool {
            self.win_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_count(&mut self, v: u32) {
            self.win_count = ::std::option::Option::Some(v);
        }

        // optional uint32 pick_count = 4;

        pub fn pick_count(&self) -> u32 {
            self.pick_count.unwrap_or(0)
        }

        pub fn clear_pick_count(&mut self) {
            self.pick_count = ::std::option::Option::None;
        }

        pub fn has_pick_count(&self) -> bool {
            self.pick_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_count(&mut self, v: u32) {
            self.pick_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SimpleStats {
        const NAME: &'static str = "SimpleStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.win_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    21 => {
                        self.pick_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    24 => {
                        self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.pick_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.win_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.pick_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.win_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.pick_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.win_percent {
                os.write_float(1, v)?;
            }
            if let Some(v) = self.pick_percent {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.win_count {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.pick_count {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SimpleStats {
            SimpleStats::new()
        }

        fn clear(&mut self) {
            self.win_percent = ::std::option::Option::None;
            self.pick_percent = ::std::option::Option::None;
            self.win_count = ::std::option::Option::None;
            self.pick_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SimpleStats {
            static instance: SimpleStats = SimpleStats {
                win_percent: ::std::option::Option::None,
                pick_percent: ::std::option::Option::None,
                win_count: ::std::option::Option::None,
                pick_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgDOTASelectionPriorityChoiceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASelectionPriorityChoiceRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASelectionPriorityChoiceRequest.choice)
    pub choice: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::DOTASelectionPriorityChoice>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASelectionPriorityChoiceRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASelectionPriorityChoiceRequest {
    fn default() -> &'a CMsgDOTASelectionPriorityChoiceRequest {
        <CMsgDOTASelectionPriorityChoiceRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASelectionPriorityChoiceRequest {
    pub fn new() -> CMsgDOTASelectionPriorityChoiceRequest {
        ::std::default::Default::default()
    }

    // optional .DOTASelectionPriorityChoice choice = 1;

    pub fn choice(&self) -> super::dota_shared_enums::DOTASelectionPriorityChoice {
        match self.choice {
            Some(e) => e.enum_value_or(super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid),
            None => super::dota_shared_enums::DOTASelectionPriorityChoice::k_DOTASelectionPriorityChoice_Invalid,
        }
    }

    pub fn clear_choice(&mut self) {
        self.choice = ::std::option::Option::None;
    }

    pub fn has_choice(&self) -> bool {
        self.choice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_choice(&mut self, v: super::dota_shared_enums::DOTASelectionPriorityChoice) {
        self.choice = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASelectionPriorityChoiceRequest {
    const NAME: &'static str = "CMsgDOTASelectionPriorityChoiceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.choice = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.choice {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.choice {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASelectionPriorityChoiceRequest {
        CMsgDOTASelectionPriorityChoiceRequest::new()
    }

    fn clear(&mut self) {
        self.choice = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASelectionPriorityChoiceRequest {
        static instance: CMsgDOTASelectionPriorityChoiceRequest = CMsgDOTASelectionPriorityChoiceRequest {
            choice: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTASelectionPriorityChoiceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTASelectionPriorityChoiceResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTASelectionPriorityChoiceResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotaselection_priority_choice_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTASelectionPriorityChoiceResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTASelectionPriorityChoiceResponse {
    fn default() -> &'a CMsgDOTASelectionPriorityChoiceResponse {
        <CMsgDOTASelectionPriorityChoiceResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTASelectionPriorityChoiceResponse {
    pub fn new() -> CMsgDOTASelectionPriorityChoiceResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTASelectionPriorityChoiceResponse.Result result = 1;

    pub fn result(&self) -> cmsg_dotaselection_priority_choice_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotaselection_priority_choice_response::Result::SUCCESS),
            None => cmsg_dotaselection_priority_choice_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotaselection_priority_choice_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTASelectionPriorityChoiceResponse {
    const NAME: &'static str = "CMsgDOTASelectionPriorityChoiceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTASelectionPriorityChoiceResponse {
        CMsgDOTASelectionPriorityChoiceResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTASelectionPriorityChoiceResponse {
        static instance: CMsgDOTASelectionPriorityChoiceResponse = CMsgDOTASelectionPriorityChoiceResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTASelectionPriorityChoiceResponse`
pub mod cmsg_dotaselection_priority_choice_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTASelectionPriorityChoiceResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgDOTASelectionPriorityChoiceResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTASelectionPriorityChoiceResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAGameAutographReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGameAutographReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGameAutographReward.badge_id)
    pub badge_id: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGameAutographReward.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGameAutographReward {
    fn default() -> &'a CMsgDOTAGameAutographReward {
        <CMsgDOTAGameAutographReward as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGameAutographReward {
    pub fn new() -> CMsgDOTAGameAutographReward {
        ::std::default::Default::default()
    }

    // optional string badge_id = 1;

    pub fn badge_id(&self) -> &str {
        match self.badge_id.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_badge_id(&mut self) {
        self.badge_id = ::std::option::Option::None;
    }

    pub fn has_badge_id(&self) -> bool {
        self.badge_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_badge_id(&mut self, v: ::std::string::String) {
        self.badge_id = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_badge_id(&mut self) -> &mut ::std::string::String {
        if self.badge_id.is_none() {
            self.badge_id = ::std::option::Option::Some(::std::string::String::new());
        }
        self.badge_id.as_mut().unwrap()
    }

    // Take field
    pub fn take_badge_id(&mut self) -> ::std::string::String {
        self.badge_id.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGameAutographReward {
    const NAME: &'static str = "CMsgDOTAGameAutographReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.badge_id = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.badge_id.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.badge_id.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGameAutographReward {
        CMsgDOTAGameAutographReward::new()
    }

    fn clear(&mut self) {
        self.badge_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGameAutographReward {
        static instance: CMsgDOTAGameAutographReward = CMsgDOTAGameAutographReward {
            badge_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGameAutographRewardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGameAutographRewardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGameAutographRewardResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotagame_autograph_reward_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGameAutographRewardResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGameAutographRewardResponse {
    fn default() -> &'a CMsgDOTAGameAutographRewardResponse {
        <CMsgDOTAGameAutographRewardResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGameAutographRewardResponse {
    pub fn new() -> CMsgDOTAGameAutographRewardResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTAGameAutographRewardResponse.Result result = 1;

    pub fn result(&self) -> cmsg_dotagame_autograph_reward_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotagame_autograph_reward_response::Result::SUCCESS),
            None => cmsg_dotagame_autograph_reward_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotagame_autograph_reward_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGameAutographRewardResponse {
    const NAME: &'static str = "CMsgDOTAGameAutographRewardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGameAutographRewardResponse {
        CMsgDOTAGameAutographRewardResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGameAutographRewardResponse {
        static instance: CMsgDOTAGameAutographRewardResponse = CMsgDOTAGameAutographRewardResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAGameAutographRewardResponse`
pub mod cmsg_dotagame_autograph_reward_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTAGameAutographRewardResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgDOTAGameAutographRewardResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTAGameAutographRewardResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTADestroyLobbyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADestroyLobbyRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADestroyLobbyRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADestroyLobbyRequest {
    fn default() -> &'a CMsgDOTADestroyLobbyRequest {
        <CMsgDOTADestroyLobbyRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADestroyLobbyRequest {
    pub fn new() -> CMsgDOTADestroyLobbyRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADestroyLobbyRequest {
    const NAME: &'static str = "CMsgDOTADestroyLobbyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADestroyLobbyRequest {
        CMsgDOTADestroyLobbyRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADestroyLobbyRequest {
        static instance: CMsgDOTADestroyLobbyRequest = CMsgDOTADestroyLobbyRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTADestroyLobbyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTADestroyLobbyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTADestroyLobbyResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_dotadestroy_lobby_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTADestroyLobbyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTADestroyLobbyResponse {
    fn default() -> &'a CMsgDOTADestroyLobbyResponse {
        <CMsgDOTADestroyLobbyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTADestroyLobbyResponse {
    pub fn new() -> CMsgDOTADestroyLobbyResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgDOTADestroyLobbyResponse.Result result = 1;

    pub fn result(&self) -> cmsg_dotadestroy_lobby_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_dotadestroy_lobby_response::Result::SUCCESS),
            None => cmsg_dotadestroy_lobby_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_dotadestroy_lobby_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTADestroyLobbyResponse {
    const NAME: &'static str = "CMsgDOTADestroyLobbyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTADestroyLobbyResponse {
        CMsgDOTADestroyLobbyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTADestroyLobbyResponse {
        static instance: CMsgDOTADestroyLobbyResponse = CMsgDOTADestroyLobbyResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTADestroyLobbyResponse`
pub mod cmsg_dotadestroy_lobby_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgDOTADestroyLobbyResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgDOTADestroyLobbyResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgDOTADestroyLobbyResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAGetRecentPlayTimeFriendsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetRecentPlayTimeFriendsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetRecentPlayTimeFriendsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetRecentPlayTimeFriendsRequest {
    fn default() -> &'a CMsgDOTAGetRecentPlayTimeFriendsRequest {
        <CMsgDOTAGetRecentPlayTimeFriendsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetRecentPlayTimeFriendsRequest {
    pub fn new() -> CMsgDOTAGetRecentPlayTimeFriendsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetRecentPlayTimeFriendsRequest {
    const NAME: &'static str = "CMsgDOTAGetRecentPlayTimeFriendsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetRecentPlayTimeFriendsRequest {
        CMsgDOTAGetRecentPlayTimeFriendsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetRecentPlayTimeFriendsRequest {
        static instance: CMsgDOTAGetRecentPlayTimeFriendsRequest = CMsgDOTAGetRecentPlayTimeFriendsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDOTAGetRecentPlayTimeFriendsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAGetRecentPlayTimeFriendsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAGetRecentPlayTimeFriendsResponse.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAGetRecentPlayTimeFriendsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAGetRecentPlayTimeFriendsResponse {
    fn default() -> &'a CMsgDOTAGetRecentPlayTimeFriendsResponse {
        <CMsgDOTAGetRecentPlayTimeFriendsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAGetRecentPlayTimeFriendsResponse {
    pub fn new() -> CMsgDOTAGetRecentPlayTimeFriendsResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAGetRecentPlayTimeFriendsResponse {
    const NAME: &'static str = "CMsgDOTAGetRecentPlayTimeFriendsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.account_ids)?;
                },
                13 => {
                    self.account_ids.push(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.account_ids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAGetRecentPlayTimeFriendsResponse {
        CMsgDOTAGetRecentPlayTimeFriendsResponse::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAGetRecentPlayTimeFriendsResponse {
        static instance: CMsgDOTAGetRecentPlayTimeFriendsResponse = CMsgDOTAGetRecentPlayTimeFriendsResponse {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPurchaseItemWithEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPurchaseItemWithEventPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgPurchaseItemWithEventPoints.item_def)
    pub item_def: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPurchaseItemWithEventPoints.quantity)
    pub quantity: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPurchaseItemWithEventPoints.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgPurchaseItemWithEventPoints.use_premium_points)
    pub use_premium_points: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPurchaseItemWithEventPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPurchaseItemWithEventPoints {
    fn default() -> &'a CMsgPurchaseItemWithEventPoints {
        <CMsgPurchaseItemWithEventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPurchaseItemWithEventPoints {
    pub fn new() -> CMsgPurchaseItemWithEventPoints {
        ::std::default::Default::default()
    }

    // optional uint32 item_def = 1;

    pub fn item_def(&self) -> u32 {
        self.item_def.unwrap_or(0)
    }

    pub fn clear_item_def(&mut self) {
        self.item_def = ::std::option::Option::None;
    }

    pub fn has_item_def(&self) -> bool {
        self.item_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_def(&mut self, v: u32) {
        self.item_def = ::std::option::Option::Some(v);
    }

    // optional uint32 quantity = 2;

    pub fn quantity(&self) -> u32 {
        self.quantity.unwrap_or(0)
    }

    pub fn clear_quantity(&mut self) {
        self.quantity = ::std::option::Option::None;
    }

    pub fn has_quantity(&self) -> bool {
        self.quantity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: u32) {
        self.quantity = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 3;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool use_premium_points = 4;

    pub fn use_premium_points(&self) -> bool {
        self.use_premium_points.unwrap_or(false)
    }

    pub fn clear_use_premium_points(&mut self) {
        self.use_premium_points = ::std::option::Option::None;
    }

    pub fn has_use_premium_points(&self) -> bool {
        self.use_premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_use_premium_points(&mut self, v: bool) {
        self.use_premium_points = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPurchaseItemWithEventPoints {
    const NAME: &'static str = "CMsgPurchaseItemWithEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.quantity = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.use_premium_points = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_def {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quantity {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.use_premium_points {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_def {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quantity {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.use_premium_points {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPurchaseItemWithEventPoints {
        CMsgPurchaseItemWithEventPoints::new()
    }

    fn clear(&mut self) {
        self.item_def = ::std::option::Option::None;
        self.quantity = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.use_premium_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPurchaseItemWithEventPoints {
        static instance: CMsgPurchaseItemWithEventPoints = CMsgPurchaseItemWithEventPoints {
            item_def: ::std::option::Option::None,
            quantity: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            use_premium_points: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPurchaseItemWithEventPointsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPurchaseItemWithEventPointsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPurchaseItemWithEventPointsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_purchase_item_with_event_points_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPurchaseItemWithEventPointsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPurchaseItemWithEventPointsResponse {
    fn default() -> &'a CMsgPurchaseItemWithEventPointsResponse {
        <CMsgPurchaseItemWithEventPointsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPurchaseItemWithEventPointsResponse {
    pub fn new() -> CMsgPurchaseItemWithEventPointsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgPurchaseItemWithEventPointsResponse.Result result = 1;

    pub fn result(&self) -> cmsg_purchase_item_with_event_points_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_purchase_item_with_event_points_response::Result::SUCCESS),
            None => cmsg_purchase_item_with_event_points_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_purchase_item_with_event_points_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPurchaseItemWithEventPointsResponse {
    const NAME: &'static str = "CMsgPurchaseItemWithEventPointsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPurchaseItemWithEventPointsResponse {
        CMsgPurchaseItemWithEventPointsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPurchaseItemWithEventPointsResponse {
        static instance: CMsgPurchaseItemWithEventPointsResponse = CMsgPurchaseItemWithEventPointsResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgPurchaseItemWithEventPointsResponse`
pub mod cmsg_purchase_item_with_event_points_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgPurchaseItemWithEventPointsResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.UNKNOWN_EVENT)
        UNKNOWN_EVENT = 1,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.UNKNOWN_ITEM)
        UNKNOWN_ITEM = 2,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.BAD_QUANTITY)
        BAD_QUANTITY = 3,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.NOT_PURCHASEABLE)
        NOT_PURCHASEABLE = 4,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.SDO_LOAD_FAILED)
        SDO_LOAD_FAILED = 5,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.NOT_ENOUGH_POINTS)
        NOT_ENOUGH_POINTS = 6,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.SQL_ERROR)
        SQL_ERROR = 7,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.FAILED_TO_SEND)
        FAILED_TO_SEND = 8,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.SERVER_ERROR)
        SERVER_ERROR = 9,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.NOT_ALLOWED)
        NOT_ALLOWED = 10,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.CANCELLED)
        CANCELLED = 11,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.CLIENT_ERROR)
        CLIENT_ERROR = 12,
        // @@protoc_insertion_point(enum_value:CMsgPurchaseItemWithEventPointsResponse.Result.SUBSCRIPTION_REQUIRED)
        SUBSCRIPTION_REQUIRED = 13,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::UNKNOWN_EVENT),
                2 => ::std::option::Option::Some(Result::UNKNOWN_ITEM),
                3 => ::std::option::Option::Some(Result::BAD_QUANTITY),
                4 => ::std::option::Option::Some(Result::NOT_PURCHASEABLE),
                5 => ::std::option::Option::Some(Result::SDO_LOAD_FAILED),
                6 => ::std::option::Option::Some(Result::NOT_ENOUGH_POINTS),
                7 => ::std::option::Option::Some(Result::SQL_ERROR),
                8 => ::std::option::Option::Some(Result::FAILED_TO_SEND),
                9 => ::std::option::Option::Some(Result::SERVER_ERROR),
                10 => ::std::option::Option::Some(Result::NOT_ALLOWED),
                11 => ::std::option::Option::Some(Result::CANCELLED),
                12 => ::std::option::Option::Some(Result::CLIENT_ERROR),
                13 => ::std::option::Option::Some(Result::SUBSCRIPTION_REQUIRED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "UNKNOWN_EVENT" => ::std::option::Option::Some(Result::UNKNOWN_EVENT),
                "UNKNOWN_ITEM" => ::std::option::Option::Some(Result::UNKNOWN_ITEM),
                "BAD_QUANTITY" => ::std::option::Option::Some(Result::BAD_QUANTITY),
                "NOT_PURCHASEABLE" => ::std::option::Option::Some(Result::NOT_PURCHASEABLE),
                "SDO_LOAD_FAILED" => ::std::option::Option::Some(Result::SDO_LOAD_FAILED),
                "NOT_ENOUGH_POINTS" => ::std::option::Option::Some(Result::NOT_ENOUGH_POINTS),
                "SQL_ERROR" => ::std::option::Option::Some(Result::SQL_ERROR),
                "FAILED_TO_SEND" => ::std::option::Option::Some(Result::FAILED_TO_SEND),
                "SERVER_ERROR" => ::std::option::Option::Some(Result::SERVER_ERROR),
                "NOT_ALLOWED" => ::std::option::Option::Some(Result::NOT_ALLOWED),
                "CANCELLED" => ::std::option::Option::Some(Result::CANCELLED),
                "CLIENT_ERROR" => ::std::option::Option::Some(Result::CLIENT_ERROR),
                "SUBSCRIPTION_REQUIRED" => ::std::option::Option::Some(Result::SUBSCRIPTION_REQUIRED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::UNKNOWN_EVENT,
            Result::UNKNOWN_ITEM,
            Result::BAD_QUANTITY,
            Result::NOT_PURCHASEABLE,
            Result::SDO_LOAD_FAILED,
            Result::NOT_ENOUGH_POINTS,
            Result::SQL_ERROR,
            Result::FAILED_TO_SEND,
            Result::SERVER_ERROR,
            Result::NOT_ALLOWED,
            Result::CANCELLED,
            Result::CLIENT_ERROR,
            Result::SUBSCRIPTION_REQUIRED,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgPurchaseHeroRandomRelic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPurchaseHeroRandomRelic {
    // message fields
    // @@protoc_insertion_point(field:CMsgPurchaseHeroRandomRelic.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgPurchaseHeroRandomRelic.relic_rarity)
    pub relic_rarity: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::EHeroRelicRarity>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPurchaseHeroRandomRelic.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPurchaseHeroRandomRelic {
    fn default() -> &'a CMsgPurchaseHeroRandomRelic {
        <CMsgPurchaseHeroRandomRelic as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPurchaseHeroRandomRelic {
    pub fn new() -> CMsgPurchaseHeroRandomRelic {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional .EHeroRelicRarity relic_rarity = 2;

    pub fn relic_rarity(&self) -> super::dota_gcmessages_common::EHeroRelicRarity {
        match self.relic_rarity {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::EHeroRelicRarity::HERO_RELIC_RARITY_INVALID),
            None => super::dota_gcmessages_common::EHeroRelicRarity::HERO_RELIC_RARITY_INVALID,
        }
    }

    pub fn clear_relic_rarity(&mut self) {
        self.relic_rarity = ::std::option::Option::None;
    }

    pub fn has_relic_rarity(&self) -> bool {
        self.relic_rarity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_relic_rarity(&mut self, v: super::dota_gcmessages_common::EHeroRelicRarity) {
        self.relic_rarity = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPurchaseHeroRandomRelic {
    const NAME: &'static str = "CMsgPurchaseHeroRandomRelic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.relic_rarity = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.relic_rarity {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.relic_rarity {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPurchaseHeroRandomRelic {
        CMsgPurchaseHeroRandomRelic::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.relic_rarity = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPurchaseHeroRandomRelic {
        static instance: CMsgPurchaseHeroRandomRelic = CMsgPurchaseHeroRandomRelic {
            hero_id: ::std::option::Option::None,
            relic_rarity: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPurchaseHeroRandomRelicResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPurchaseHeroRandomRelicResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPurchaseHeroRandomRelicResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EPurchaseHeroRelicResult>>,
    // @@protoc_insertion_point(field:CMsgPurchaseHeroRandomRelicResponse.kill_eater_type)
    pub kill_eater_type: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPurchaseHeroRandomRelicResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPurchaseHeroRandomRelicResponse {
    fn default() -> &'a CMsgPurchaseHeroRandomRelicResponse {
        <CMsgPurchaseHeroRandomRelicResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPurchaseHeroRandomRelicResponse {
    pub fn new() -> CMsgPurchaseHeroRandomRelicResponse {
        ::std::default::Default::default()
    }

    // optional .EPurchaseHeroRelicResult result = 1;

    pub fn result(&self) -> EPurchaseHeroRelicResult {
        match self.result {
            Some(e) => e.enum_value_or(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success),
            None => EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EPurchaseHeroRelicResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 kill_eater_type = 2;

    pub fn kill_eater_type(&self) -> u32 {
        self.kill_eater_type.unwrap_or(0)
    }

    pub fn clear_kill_eater_type(&mut self) {
        self.kill_eater_type = ::std::option::Option::None;
    }

    pub fn has_kill_eater_type(&self) -> bool {
        self.kill_eater_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kill_eater_type(&mut self, v: u32) {
        self.kill_eater_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPurchaseHeroRandomRelicResponse {
    const NAME: &'static str = "CMsgPurchaseHeroRandomRelicResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.kill_eater_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.kill_eater_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.kill_eater_type {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPurchaseHeroRandomRelicResponse {
        CMsgPurchaseHeroRandomRelicResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.kill_eater_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPurchaseHeroRandomRelicResponse {
        static instance: CMsgPurchaseHeroRandomRelicResponse = CMsgPurchaseHeroRandomRelicResponse {
            result: ::std::option::Option::None,
            kill_eater_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlusWeeklyChallengeResult)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlusWeeklyChallengeResult {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlusWeeklyChallengeResult.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlusWeeklyChallengeResult.week)
    pub week: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlusWeeklyChallengeResult.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlusWeeklyChallengeResult {
    fn default() -> &'a CMsgClientToGCRequestPlusWeeklyChallengeResult {
        <CMsgClientToGCRequestPlusWeeklyChallengeResult as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlusWeeklyChallengeResult {
    pub fn new() -> CMsgClientToGCRequestPlusWeeklyChallengeResult {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 week = 2;

    pub fn week(&self) -> u32 {
        self.week.unwrap_or(0)
    }

    pub fn clear_week(&mut self) {
        self.week = ::std::option::Option::None;
    }

    pub fn has_week(&self) -> bool {
        self.week.is_some()
    }

    // Param is passed by value, moved
    pub fn set_week(&mut self, v: u32) {
        self.week = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlusWeeklyChallengeResult {
    const NAME: &'static str = "CMsgClientToGCRequestPlusWeeklyChallengeResult";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.week = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.week {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.week {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlusWeeklyChallengeResult {
        CMsgClientToGCRequestPlusWeeklyChallengeResult::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.week = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlusWeeklyChallengeResult {
        static instance: CMsgClientToGCRequestPlusWeeklyChallengeResult = CMsgClientToGCRequestPlusWeeklyChallengeResult {
            event_id: ::std::option::Option::None,
            week: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlusWeeklyChallengeResultResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlusWeeklyChallengeResultResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    fn default() -> &'a CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
        <CMsgClientToGCRequestPlusWeeklyChallengeResultResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    pub fn new() -> CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPlusWeeklyChallengeResultResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
        CMsgClientToGCRequestPlusWeeklyChallengeResultResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
        static instance: CMsgClientToGCRequestPlusWeeklyChallengeResultResponse = CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProfileRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProfileRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgProfileRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProfileRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProfileRequest {
    fn default() -> &'a CMsgProfileRequest {
        <CMsgProfileRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProfileRequest {
    pub fn new() -> CMsgProfileRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProfileRequest {
    const NAME: &'static str = "CMsgProfileRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProfileRequest {
        CMsgProfileRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProfileRequest {
        static instance: CMsgProfileRequest = CMsgProfileRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProfileResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProfileResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgProfileResponse.background_item)
    pub background_item: ::steam_vent_proto_common::protobuf::MessageField<super::base_gcmessages::CSOEconItem>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.featured_heroes)
    pub featured_heroes: ::std::vec::Vec<cmsg_profile_response::FeaturedHero>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.recent_matches)
    pub recent_matches: ::std::vec::Vec<cmsg_profile_response::MatchInfo>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.successful_heroes)
    pub successful_heroes: ::std::vec::Vec<super::dota_gcmessages_common::CMsgSuccessfulHero>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.recent_match_details)
    pub recent_match_details: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgRecentMatchInfo>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_profile_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgProfileResponse.stickerbook_page)
    pub stickerbook_page: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgStickerbookPage>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProfileResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProfileResponse {
    fn default() -> &'a CMsgProfileResponse {
        <CMsgProfileResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProfileResponse {
    pub fn new() -> CMsgProfileResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgProfileResponse.EResponse result = 6;

    pub fn result(&self) -> cmsg_profile_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_profile_response::EResponse::k_eInternalError),
            None => cmsg_profile_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_profile_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProfileResponse {
    const NAME: &'static str = "CMsgProfileResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.background_item)?;
                },
                18 => {
                    self.featured_heroes.push(is.read_message()?);
                },
                26 => {
                    self.recent_matches.push(is.read_message()?);
                },
                34 => {
                    self.successful_heroes.push(is.read_message()?);
                },
                42 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.recent_match_details)?;
                },
                48 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerbook_page)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.background_item.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.featured_heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.recent_matches {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.successful_heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.recent_match_details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.stickerbook_page.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.background_item.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.featured_heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.recent_matches {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.successful_heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.recent_match_details.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.result {
            os.write_enum(6, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.stickerbook_page.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProfileResponse {
        CMsgProfileResponse::new()
    }

    fn clear(&mut self) {
        self.background_item.clear();
        self.featured_heroes.clear();
        self.recent_matches.clear();
        self.successful_heroes.clear();
        self.recent_match_details.clear();
        self.result = ::std::option::Option::None;
        self.stickerbook_page.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProfileResponse {
        static instance: CMsgProfileResponse = CMsgProfileResponse {
            background_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
            featured_heroes: ::std::vec::Vec::new(),
            recent_matches: ::std::vec::Vec::new(),
            successful_heroes: ::std::vec::Vec::new(),
            recent_match_details: ::steam_vent_proto_common::protobuf::MessageField::none(),
            result: ::std::option::Option::None,
            stickerbook_page: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProfileResponse`
pub mod cmsg_profile_response {
    // @@protoc_insertion_point(message:CMsgProfileResponse.FeaturedHero)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FeaturedHero {
        // message fields
        // @@protoc_insertion_point(field:CMsgProfileResponse.FeaturedHero.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.FeaturedHero.equipped_econ_items)
        pub equipped_econ_items: ::std::vec::Vec<super::super::base_gcmessages::CSOEconItem>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.FeaturedHero.manually_set)
        pub manually_set: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.FeaturedHero.plus_hero_xp)
        pub plus_hero_xp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.FeaturedHero.plus_hero_relics_item)
        pub plus_hero_relics_item: ::steam_vent_proto_common::protobuf::MessageField<super::super::base_gcmessages::CSOEconItem>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgProfileResponse.FeaturedHero.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FeaturedHero {
        fn default() -> &'a FeaturedHero {
            <FeaturedHero as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FeaturedHero {
        pub fn new() -> FeaturedHero {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional bool manually_set = 3;

        pub fn manually_set(&self) -> bool {
            self.manually_set.unwrap_or(false)
        }

        pub fn clear_manually_set(&mut self) {
            self.manually_set = ::std::option::Option::None;
        }

        pub fn has_manually_set(&self) -> bool {
            self.manually_set.is_some()
        }

        // Param is passed by value, moved
        pub fn set_manually_set(&mut self, v: bool) {
            self.manually_set = ::std::option::Option::Some(v);
        }

        // optional uint32 plus_hero_xp = 4;

        pub fn plus_hero_xp(&self) -> u32 {
            self.plus_hero_xp.unwrap_or(0)
        }

        pub fn clear_plus_hero_xp(&mut self) {
            self.plus_hero_xp = ::std::option::Option::None;
        }

        pub fn has_plus_hero_xp(&self) -> bool {
            self.plus_hero_xp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_plus_hero_xp(&mut self, v: u32) {
            self.plus_hero_xp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FeaturedHero {
        const NAME: &'static str = "FeaturedHero";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    18 => {
                        self.equipped_econ_items.push(is.read_message()?);
                    },
                    24 => {
                        self.manually_set = ::std::option::Option::Some(is.read_bool()?);
                    },
                    32 => {
                        self.plus_hero_xp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    42 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.plus_hero_relics_item)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            for value in &self.equipped_econ_items {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.manually_set {
                my_size += 1 + 1;
            }
            if let Some(v) = self.plus_hero_xp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.plus_hero_relics_item.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            for v in &self.equipped_econ_items {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.manually_set {
                os.write_bool(3, v)?;
            }
            if let Some(v) = self.plus_hero_xp {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.plus_hero_relics_item.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FeaturedHero {
            FeaturedHero::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.equipped_econ_items.clear();
            self.manually_set = ::std::option::Option::None;
            self.plus_hero_xp = ::std::option::Option::None;
            self.plus_hero_relics_item.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FeaturedHero {
            static instance: FeaturedHero = FeaturedHero {
                hero_id: ::std::option::Option::None,
                equipped_econ_items: ::std::vec::Vec::new(),
                manually_set: ::std::option::Option::None,
                plus_hero_xp: ::std::option::Option::None,
                plus_hero_relics_item: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgProfileResponse.MatchInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MatchInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgProfileResponse.MatchInfo.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.MatchInfo.match_timestamp)
        pub match_timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.MatchInfo.performance_rating)
        pub performance_rating: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.MatchInfo.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgProfileResponse.MatchInfo.won_match)
        pub won_match: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgProfileResponse.MatchInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MatchInfo {
        fn default() -> &'a MatchInfo {
            <MatchInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MatchInfo {
        pub fn new() -> MatchInfo {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional uint32 match_timestamp = 2;

        pub fn match_timestamp(&self) -> u32 {
            self.match_timestamp.unwrap_or(0)
        }

        pub fn clear_match_timestamp(&mut self) {
            self.match_timestamp = ::std::option::Option::None;
        }

        pub fn has_match_timestamp(&self) -> bool {
            self.match_timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_timestamp(&mut self, v: u32) {
            self.match_timestamp = ::std::option::Option::Some(v);
        }

        // optional sint32 performance_rating = 3;

        pub fn performance_rating(&self) -> i32 {
            self.performance_rating.unwrap_or(0)
        }

        pub fn clear_performance_rating(&mut self) {
            self.performance_rating = ::std::option::Option::None;
        }

        pub fn has_performance_rating(&self) -> bool {
            self.performance_rating.is_some()
        }

        // Param is passed by value, moved
        pub fn set_performance_rating(&mut self, v: i32) {
            self.performance_rating = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 4;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional bool won_match = 5;

        pub fn won_match(&self) -> bool {
            self.won_match.unwrap_or(false)
        }

        pub fn clear_won_match(&mut self) {
            self.won_match = ::std::option::Option::None;
        }

        pub fn has_won_match(&self) -> bool {
            self.won_match.is_some()
        }

        // Param is passed by value, moved
        pub fn set_won_match(&mut self, v: bool) {
            self.won_match = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MatchInfo {
        const NAME: &'static str = "MatchInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.match_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.performance_rating = ::std::option::Option::Some(is.read_sint32()?);
                    },
                    32 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    40 => {
                        self.won_match = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.match_timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.performance_rating {
                my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
            }
            if let Some(v) = self.won_match {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.match_timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.performance_rating {
                os.write_sint32(3, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(4, v)?;
            }
            if let Some(v) = self.won_match {
                os.write_bool(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MatchInfo {
            MatchInfo::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.match_timestamp = ::std::option::Option::None;
            self.performance_rating = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.won_match = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MatchInfo {
            static instance: MatchInfo = MatchInfo {
                match_id: ::std::option::Option::None,
                match_timestamp: ::std::option::Option::None,
                performance_rating: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                won_match: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgProfileResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgProfileResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgProfileResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgProfileResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgProfileResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgProfileUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProfileUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgProfileUpdate.background_item_id)
    pub background_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgProfileUpdate.featured_hero_ids)
    pub featured_hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProfileUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProfileUpdate {
    fn default() -> &'a CMsgProfileUpdate {
        <CMsgProfileUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProfileUpdate {
    pub fn new() -> CMsgProfileUpdate {
        ::std::default::Default::default()
    }

    // optional uint64 background_item_id = 1;

    pub fn background_item_id(&self) -> u64 {
        self.background_item_id.unwrap_or(0)
    }

    pub fn clear_background_item_id(&mut self) {
        self.background_item_id = ::std::option::Option::None;
    }

    pub fn has_background_item_id(&self) -> bool {
        self.background_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_background_item_id(&mut self, v: u64) {
        self.background_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProfileUpdate {
    const NAME: &'static str = "CMsgProfileUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.background_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.featured_hero_ids)?;
                },
                16 => {
                    self.featured_hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.background_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        for value in &self.featured_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.background_item_id {
            os.write_uint64(1, v)?;
        }
        for v in &self.featured_hero_ids {
            os.write_int32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProfileUpdate {
        CMsgProfileUpdate::new()
    }

    fn clear(&mut self) {
        self.background_item_id = ::std::option::Option::None;
        self.featured_hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProfileUpdate {
        static instance: CMsgProfileUpdate = CMsgProfileUpdate {
            background_item_id: ::std::option::Option::None,
            featured_hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgProfileUpdateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgProfileUpdateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgProfileUpdateResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_profile_update_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgProfileUpdateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgProfileUpdateResponse {
    fn default() -> &'a CMsgProfileUpdateResponse {
        <CMsgProfileUpdateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgProfileUpdateResponse {
    pub fn new() -> CMsgProfileUpdateResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgProfileUpdateResponse.Result result = 1;

    pub fn result(&self) -> cmsg_profile_update_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_profile_update_response::Result::SUCCESS),
            None => cmsg_profile_update_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_profile_update_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgProfileUpdateResponse {
    const NAME: &'static str = "CMsgProfileUpdateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgProfileUpdateResponse {
        CMsgProfileUpdateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgProfileUpdateResponse {
        static instance: CMsgProfileUpdateResponse = CMsgProfileUpdateResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgProfileUpdateResponse`
pub mod cmsg_profile_update_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgProfileUpdateResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgProfileUpdateResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgProfileUpdateResponse.Result.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgProfileUpdateResponse.Result.FAILURE_BAD_HERO1)
        FAILURE_BAD_HERO1 = 2,
        // @@protoc_insertion_point(enum_value:CMsgProfileUpdateResponse.Result.FAILURE_BAD_HERO2)
        FAILURE_BAD_HERO2 = 3,
        // @@protoc_insertion_point(enum_value:CMsgProfileUpdateResponse.Result.FAILURE_BAD_HERO3)
        FAILURE_BAD_HERO3 = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILURE),
                2 => ::std::option::Option::Some(Result::FAILURE_BAD_HERO1),
                3 => ::std::option::Option::Some(Result::FAILURE_BAD_HERO2),
                4 => ::std::option::Option::Some(Result::FAILURE_BAD_HERO3),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(Result::FAILURE),
                "FAILURE_BAD_HERO1" => ::std::option::Option::Some(Result::FAILURE_BAD_HERO1),
                "FAILURE_BAD_HERO2" => ::std::option::Option::Some(Result::FAILURE_BAD_HERO2),
                "FAILURE_BAD_HERO3" => ::std::option::Option::Some(Result::FAILURE_BAD_HERO3),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILURE,
            Result::FAILURE_BAD_HERO1,
            Result::FAILURE_BAD_HERO2,
            Result::FAILURE_BAD_HERO3,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgTalentWinRates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgTalentWinRates {
    // message fields
    // @@protoc_insertion_point(field:CMsgTalentWinRates.last_run)
    pub last_run: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTalentWinRates.ability_id)
    pub ability_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgTalentWinRates.game_count)
    pub game_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgTalentWinRates.win_count)
    pub win_count: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgTalentWinRates.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgTalentWinRates {
    fn default() -> &'a CMsgTalentWinRates {
        <CMsgTalentWinRates as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgTalentWinRates {
    pub fn new() -> CMsgTalentWinRates {
        ::std::default::Default::default()
    }

    // optional uint32 last_run = 1;

    pub fn last_run(&self) -> u32 {
        self.last_run.unwrap_or(0)
    }

    pub fn clear_last_run(&mut self) {
        self.last_run = ::std::option::Option::None;
    }

    pub fn has_last_run(&self) -> bool {
        self.last_run.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_run(&mut self, v: u32) {
        self.last_run = ::std::option::Option::Some(v);
    }

    // optional int32 ability_id = 2;

    pub fn ability_id(&self) -> i32 {
        self.ability_id.unwrap_or(-1i32)
    }

    pub fn clear_ability_id(&mut self) {
        self.ability_id = ::std::option::Option::None;
    }

    pub fn has_ability_id(&self) -> bool {
        self.ability_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ability_id(&mut self, v: i32) {
        self.ability_id = ::std::option::Option::Some(v);
    }

    // optional uint32 game_count = 3;

    pub fn game_count(&self) -> u32 {
        self.game_count.unwrap_or(0)
    }

    pub fn clear_game_count(&mut self) {
        self.game_count = ::std::option::Option::None;
    }

    pub fn has_game_count(&self) -> bool {
        self.game_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_game_count(&mut self, v: u32) {
        self.game_count = ::std::option::Option::Some(v);
    }

    // optional uint32 win_count = 4;

    pub fn win_count(&self) -> u32 {
        self.win_count.unwrap_or(0)
    }

    pub fn clear_win_count(&mut self) {
        self.win_count = ::std::option::Option::None;
    }

    pub fn has_win_count(&self) -> bool {
        self.win_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_win_count(&mut self, v: u32) {
        self.win_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgTalentWinRates {
    const NAME: &'static str = "CMsgTalentWinRates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_run = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.ability_id = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.game_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.win_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_run {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.ability_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.game_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.win_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.last_run {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.ability_id {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.game_count {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.win_count {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgTalentWinRates {
        CMsgTalentWinRates::new()
    }

    fn clear(&mut self) {
        self.last_run = ::std::option::Option::None;
        self.ability_id = ::std::option::Option::None;
        self.game_count = ::std::option::Option::None;
        self.win_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgTalentWinRates {
        static instance: CMsgTalentWinRates = CMsgTalentWinRates {
            last_run: ::std::option::Option::None,
            ability_id: ::std::option::Option::None,
            game_count: ::std::option::Option::None,
            win_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGlobalHeroAverages)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGlobalHeroAverages {
    // message fields
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.last_run)
    pub last_run: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_gold_per_min)
    pub avg_gold_per_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_xp_per_min)
    pub avg_xp_per_min: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_kills)
    pub avg_kills: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_deaths)
    pub avg_deaths: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_assists)
    pub avg_assists: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_last_hits)
    pub avg_last_hits: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_denies)
    pub avg_denies: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGlobalHeroAverages.avg_net_worth)
    pub avg_net_worth: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGlobalHeroAverages.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGlobalHeroAverages {
    fn default() -> &'a CMsgGlobalHeroAverages {
        <CMsgGlobalHeroAverages as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGlobalHeroAverages {
    pub fn new() -> CMsgGlobalHeroAverages {
        ::std::default::Default::default()
    }

    // optional uint32 last_run = 1;

    pub fn last_run(&self) -> u32 {
        self.last_run.unwrap_or(0)
    }

    pub fn clear_last_run(&mut self) {
        self.last_run = ::std::option::Option::None;
    }

    pub fn has_last_run(&self) -> bool {
        self.last_run.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_run(&mut self, v: u32) {
        self.last_run = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_gold_per_min = 3;

    pub fn avg_gold_per_min(&self) -> u32 {
        self.avg_gold_per_min.unwrap_or(0)
    }

    pub fn clear_avg_gold_per_min(&mut self) {
        self.avg_gold_per_min = ::std::option::Option::None;
    }

    pub fn has_avg_gold_per_min(&self) -> bool {
        self.avg_gold_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_gold_per_min(&mut self, v: u32) {
        self.avg_gold_per_min = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_xp_per_min = 4;

    pub fn avg_xp_per_min(&self) -> u32 {
        self.avg_xp_per_min.unwrap_or(0)
    }

    pub fn clear_avg_xp_per_min(&mut self) {
        self.avg_xp_per_min = ::std::option::Option::None;
    }

    pub fn has_avg_xp_per_min(&self) -> bool {
        self.avg_xp_per_min.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_xp_per_min(&mut self, v: u32) {
        self.avg_xp_per_min = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_kills = 5;

    pub fn avg_kills(&self) -> u32 {
        self.avg_kills.unwrap_or(0)
    }

    pub fn clear_avg_kills(&mut self) {
        self.avg_kills = ::std::option::Option::None;
    }

    pub fn has_avg_kills(&self) -> bool {
        self.avg_kills.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_kills(&mut self, v: u32) {
        self.avg_kills = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_deaths = 6;

    pub fn avg_deaths(&self) -> u32 {
        self.avg_deaths.unwrap_or(0)
    }

    pub fn clear_avg_deaths(&mut self) {
        self.avg_deaths = ::std::option::Option::None;
    }

    pub fn has_avg_deaths(&self) -> bool {
        self.avg_deaths.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_deaths(&mut self, v: u32) {
        self.avg_deaths = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_assists = 7;

    pub fn avg_assists(&self) -> u32 {
        self.avg_assists.unwrap_or(0)
    }

    pub fn clear_avg_assists(&mut self) {
        self.avg_assists = ::std::option::Option::None;
    }

    pub fn has_avg_assists(&self) -> bool {
        self.avg_assists.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_assists(&mut self, v: u32) {
        self.avg_assists = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_last_hits = 8;

    pub fn avg_last_hits(&self) -> u32 {
        self.avg_last_hits.unwrap_or(0)
    }

    pub fn clear_avg_last_hits(&mut self) {
        self.avg_last_hits = ::std::option::Option::None;
    }

    pub fn has_avg_last_hits(&self) -> bool {
        self.avg_last_hits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_last_hits(&mut self, v: u32) {
        self.avg_last_hits = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_denies = 9;

    pub fn avg_denies(&self) -> u32 {
        self.avg_denies.unwrap_or(0)
    }

    pub fn clear_avg_denies(&mut self) {
        self.avg_denies = ::std::option::Option::None;
    }

    pub fn has_avg_denies(&self) -> bool {
        self.avg_denies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_denies(&mut self, v: u32) {
        self.avg_denies = ::std::option::Option::Some(v);
    }

    // optional uint32 avg_net_worth = 10;

    pub fn avg_net_worth(&self) -> u32 {
        self.avg_net_worth.unwrap_or(0)
    }

    pub fn clear_avg_net_worth(&mut self) {
        self.avg_net_worth = ::std::option::Option::None;
    }

    pub fn has_avg_net_worth(&self) -> bool {
        self.avg_net_worth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_avg_net_worth(&mut self, v: u32) {
        self.avg_net_worth = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGlobalHeroAverages {
    const NAME: &'static str = "CMsgGlobalHeroAverages";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.last_run = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.avg_gold_per_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.avg_xp_per_min = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.avg_kills = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.avg_deaths = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.avg_assists = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.avg_last_hits = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.avg_denies = ::std::option::Option::Some(is.read_uint32()?);
                },
                80 => {
                    self.avg_net_worth = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.last_run {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.avg_gold_per_min {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.avg_xp_per_min {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.avg_kills {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.avg_deaths {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.avg_assists {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.avg_last_hits {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.avg_denies {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        if let Some(v) = self.avg_net_worth {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.last_run {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.avg_gold_per_min {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.avg_xp_per_min {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.avg_kills {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.avg_deaths {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.avg_assists {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.avg_last_hits {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.avg_denies {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.avg_net_worth {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGlobalHeroAverages {
        CMsgGlobalHeroAverages::new()
    }

    fn clear(&mut self) {
        self.last_run = ::std::option::Option::None;
        self.avg_gold_per_min = ::std::option::Option::None;
        self.avg_xp_per_min = ::std::option::Option::None;
        self.avg_kills = ::std::option::Option::None;
        self.avg_deaths = ::std::option::Option::None;
        self.avg_assists = ::std::option::Option::None;
        self.avg_last_hits = ::std::option::Option::None;
        self.avg_denies = ::std::option::Option::None;
        self.avg_net_worth = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGlobalHeroAverages {
        static instance: CMsgGlobalHeroAverages = CMsgGlobalHeroAverages {
            last_run: ::std::option::Option::None,
            avg_gold_per_min: ::std::option::Option::None,
            avg_xp_per_min: ::std::option::Option::None,
            avg_kills: ::std::option::Option::None,
            avg_deaths: ::std::option::Option::None,
            avg_assists: ::std::option::Option::None,
            avg_last_hits: ::std::option::Option::None,
            avg_denies: ::std::option::Option::None,
            avg_net_worth: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroGlobalDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroGlobalDataRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroGlobalDataRequest.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroGlobalDataRequest {
    fn default() -> &'a CMsgHeroGlobalDataRequest {
        <CMsgHeroGlobalDataRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroGlobalDataRequest {
    pub fn new() -> CMsgHeroGlobalDataRequest {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroGlobalDataRequest {
    const NAME: &'static str = "CMsgHeroGlobalDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroGlobalDataRequest {
        CMsgHeroGlobalDataRequest::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroGlobalDataRequest {
        static instance: CMsgHeroGlobalDataRequest = CMsgHeroGlobalDataRequest {
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroGlobalDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroGlobalDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.hero_data_per_chunk)
    pub hero_data_per_chunk: ::std::vec::Vec<cmsg_hero_global_data_response::HeroDataPerRankChunk>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroGlobalDataResponse {
    fn default() -> &'a CMsgHeroGlobalDataResponse {
        <CMsgHeroGlobalDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroGlobalDataResponse {
    pub fn new() -> CMsgHeroGlobalDataResponse {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroGlobalDataResponse {
    const NAME: &'static str = "CMsgHeroGlobalDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                18 => {
                    self.hero_data_per_chunk.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        for value in &self.hero_data_per_chunk {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        for v in &self.hero_data_per_chunk {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroGlobalDataResponse {
        CMsgHeroGlobalDataResponse::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.hero_data_per_chunk.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroGlobalDataResponse {
        static instance: CMsgHeroGlobalDataResponse = CMsgHeroGlobalDataResponse {
            hero_id: ::std::option::Option::None,
            hero_data_per_chunk: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgHeroGlobalDataResponse`
pub mod cmsg_hero_global_data_response {
    // @@protoc_insertion_point(message:CMsgHeroGlobalDataResponse.GraphData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct GraphData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.GraphData.day)
        pub day: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.GraphData.win_percent)
        pub win_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.GraphData.pick_percent)
        pub pick_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.GraphData.ban_percent)
        pub ban_percent: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataResponse.GraphData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a GraphData {
        fn default() -> &'a GraphData {
            <GraphData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl GraphData {
        pub fn new() -> GraphData {
            ::std::default::Default::default()
        }

        // optional uint32 day = 1;

        pub fn day(&self) -> u32 {
            self.day.unwrap_or(0)
        }

        pub fn clear_day(&mut self) {
            self.day = ::std::option::Option::None;
        }

        pub fn has_day(&self) -> bool {
            self.day.is_some()
        }

        // Param is passed by value, moved
        pub fn set_day(&mut self, v: u32) {
            self.day = ::std::option::Option::Some(v);
        }

        // optional float win_percent = 2;

        pub fn win_percent(&self) -> f32 {
            self.win_percent.unwrap_or(0.)
        }

        pub fn clear_win_percent(&mut self) {
            self.win_percent = ::std::option::Option::None;
        }

        pub fn has_win_percent(&self) -> bool {
            self.win_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_percent(&mut self, v: f32) {
            self.win_percent = ::std::option::Option::Some(v);
        }

        // optional float pick_percent = 3;

        pub fn pick_percent(&self) -> f32 {
            self.pick_percent.unwrap_or(0.)
        }

        pub fn clear_pick_percent(&mut self) {
            self.pick_percent = ::std::option::Option::None;
        }

        pub fn has_pick_percent(&self) -> bool {
            self.pick_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_percent(&mut self, v: f32) {
            self.pick_percent = ::std::option::Option::Some(v);
        }

        // optional float ban_percent = 4;

        pub fn ban_percent(&self) -> f32 {
            self.ban_percent.unwrap_or(0.)
        }

        pub fn clear_ban_percent(&mut self) {
            self.ban_percent = ::std::option::Option::None;
        }

        pub fn has_ban_percent(&self) -> bool {
            self.ban_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_percent(&mut self, v: f32) {
            self.ban_percent = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for GraphData {
        const NAME: &'static str = "GraphData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.day = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.win_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    29 => {
                        self.pick_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.ban_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.day {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.win_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.pick_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ban_percent {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.day {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.win_percent {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.pick_percent {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.ban_percent {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> GraphData {
            GraphData::new()
        }

        fn clear(&mut self) {
            self.day = ::std::option::Option::None;
            self.win_percent = ::std::option::Option::None;
            self.pick_percent = ::std::option::Option::None;
            self.ban_percent = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static GraphData {
            static instance: GraphData = GraphData {
                day: ::std::option::Option::None,
                win_percent: ::std::option::Option::None,
                pick_percent: ::std::option::Option::None,
                ban_percent: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgHeroGlobalDataResponse.WeekData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct WeekData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.WeekData.week)
        pub week: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.WeekData.win_percent)
        pub win_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.WeekData.pick_percent)
        pub pick_percent: ::std::option::Option<f32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.WeekData.ban_percent)
        pub ban_percent: ::std::option::Option<f32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataResponse.WeekData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a WeekData {
        fn default() -> &'a WeekData {
            <WeekData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl WeekData {
        pub fn new() -> WeekData {
            ::std::default::Default::default()
        }

        // optional uint32 week = 1;

        pub fn week(&self) -> u32 {
            self.week.unwrap_or(0)
        }

        pub fn clear_week(&mut self) {
            self.week = ::std::option::Option::None;
        }

        pub fn has_week(&self) -> bool {
            self.week.is_some()
        }

        // Param is passed by value, moved
        pub fn set_week(&mut self, v: u32) {
            self.week = ::std::option::Option::Some(v);
        }

        // optional float win_percent = 2;

        pub fn win_percent(&self) -> f32 {
            self.win_percent.unwrap_or(0.)
        }

        pub fn clear_win_percent(&mut self) {
            self.win_percent = ::std::option::Option::None;
        }

        pub fn has_win_percent(&self) -> bool {
            self.win_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_percent(&mut self, v: f32) {
            self.win_percent = ::std::option::Option::Some(v);
        }

        // optional float pick_percent = 3;

        pub fn pick_percent(&self) -> f32 {
            self.pick_percent.unwrap_or(0.)
        }

        pub fn clear_pick_percent(&mut self) {
            self.pick_percent = ::std::option::Option::None;
        }

        pub fn has_pick_percent(&self) -> bool {
            self.pick_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_pick_percent(&mut self, v: f32) {
            self.pick_percent = ::std::option::Option::Some(v);
        }

        // optional float ban_percent = 4;

        pub fn ban_percent(&self) -> f32 {
            self.ban_percent.unwrap_or(0.)
        }

        pub fn clear_ban_percent(&mut self) {
            self.ban_percent = ::std::option::Option::None;
        }

        pub fn has_ban_percent(&self) -> bool {
            self.ban_percent.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ban_percent(&mut self, v: f32) {
            self.ban_percent = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for WeekData {
        const NAME: &'static str = "WeekData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.week = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    21 => {
                        self.win_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    29 => {
                        self.pick_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    37 => {
                        self.ban_percent = ::std::option::Option::Some(is.read_float()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.week {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.win_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.pick_percent {
                my_size += 1 + 4;
            }
            if let Some(v) = self.ban_percent {
                my_size += 1 + 4;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.week {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.win_percent {
                os.write_float(2, v)?;
            }
            if let Some(v) = self.pick_percent {
                os.write_float(3, v)?;
            }
            if let Some(v) = self.ban_percent {
                os.write_float(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> WeekData {
            WeekData::new()
        }

        fn clear(&mut self) {
            self.week = ::std::option::Option::None;
            self.win_percent = ::std::option::Option::None;
            self.pick_percent = ::std::option::Option::None;
            self.ban_percent = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static WeekData {
            static instance: WeekData = WeekData {
                week: ::std::option::Option::None,
                win_percent: ::std::option::Option::None,
                pick_percent: ::std::option::Option::None,
                ban_percent: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroDataPerRankChunk {
        // message fields
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.rank_chunk)
        pub rank_chunk: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.talent_win_rates)
        pub talent_win_rates: ::std::vec::Vec<super::CMsgTalentWinRates>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.hero_averages)
        pub hero_averages: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgGlobalHeroAverages>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.graph_data)
        pub graph_data: ::std::vec::Vec<GraphData>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.week_data)
        pub week_data: ::std::vec::Vec<WeekData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataResponse.HeroDataPerRankChunk.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroDataPerRankChunk {
        fn default() -> &'a HeroDataPerRankChunk {
            <HeroDataPerRankChunk as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroDataPerRankChunk {
        pub fn new() -> HeroDataPerRankChunk {
            ::std::default::Default::default()
        }

        // optional uint32 rank_chunk = 1;

        pub fn rank_chunk(&self) -> u32 {
            self.rank_chunk.unwrap_or(0)
        }

        pub fn clear_rank_chunk(&mut self) {
            self.rank_chunk = ::std::option::Option::None;
        }

        pub fn has_rank_chunk(&self) -> bool {
            self.rank_chunk.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank_chunk(&mut self, v: u32) {
            self.rank_chunk = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroDataPerRankChunk {
        const NAME: &'static str = "HeroDataPerRankChunk";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank_chunk = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.talent_win_rates.push(is.read_message()?);
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_averages)?;
                    },
                    34 => {
                        self.graph_data.push(is.read_message()?);
                    },
                    42 => {
                        self.week_data.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank_chunk {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.talent_win_rates {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.hero_averages.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            for value in &self.graph_data {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            for value in &self.week_data {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.rank_chunk {
                os.write_uint32(1, v)?;
            }
            for v in &self.talent_win_rates {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            if let Some(v) = self.hero_averages.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            for v in &self.graph_data {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
            };
            for v in &self.week_data {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroDataPerRankChunk {
            HeroDataPerRankChunk::new()
        }

        fn clear(&mut self) {
            self.rank_chunk = ::std::option::Option::None;
            self.talent_win_rates.clear();
            self.hero_averages.clear();
            self.graph_data.clear();
            self.week_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroDataPerRankChunk {
            static instance: HeroDataPerRankChunk = HeroDataPerRankChunk {
                rank_chunk: ::std::option::Option::None,
                talent_win_rates: ::std::vec::Vec::new(),
                hero_averages: ::steam_vent_proto_common::protobuf::MessageField::none(),
                graph_data: ::std::vec::Vec::new(),
                week_data: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgHeroGlobalDataAllHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroGlobalDataAllHeroes {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroGlobalDataAllHeroes.heroes)
    pub heroes: ::std::vec::Vec<CMsgHeroGlobalDataResponse>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataAllHeroes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroGlobalDataAllHeroes {
    fn default() -> &'a CMsgHeroGlobalDataAllHeroes {
        <CMsgHeroGlobalDataAllHeroes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroGlobalDataAllHeroes {
    pub fn new() -> CMsgHeroGlobalDataAllHeroes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroGlobalDataAllHeroes {
    const NAME: &'static str = "CMsgHeroGlobalDataAllHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.heroes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.heroes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.heroes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroGlobalDataAllHeroes {
        CMsgHeroGlobalDataAllHeroes::new()
    }

    fn clear(&mut self) {
        self.heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroGlobalDataAllHeroes {
        static instance: CMsgHeroGlobalDataAllHeroes = CMsgHeroGlobalDataAllHeroes {
            heroes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgHeroGlobalDataHeroesAlliesAndEnemies)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    // message fields
    // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.ranked_hero_data)
    pub ranked_hero_data: ::std::vec::Vec<cmsg_hero_global_data_heroes_allies_and_enemies::RankedHeroData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    fn default() -> &'a CMsgHeroGlobalDataHeroesAlliesAndEnemies {
        <CMsgHeroGlobalDataHeroesAlliesAndEnemies as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    pub fn new() -> CMsgHeroGlobalDataHeroesAlliesAndEnemies {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    const NAME: &'static str = "CMsgHeroGlobalDataHeroesAlliesAndEnemies";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.ranked_hero_data.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.ranked_hero_data {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.ranked_hero_data {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgHeroGlobalDataHeroesAlliesAndEnemies {
        CMsgHeroGlobalDataHeroesAlliesAndEnemies::new()
    }

    fn clear(&mut self) {
        self.ranked_hero_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgHeroGlobalDataHeroesAlliesAndEnemies {
        static instance: CMsgHeroGlobalDataHeroesAlliesAndEnemies = CMsgHeroGlobalDataHeroesAlliesAndEnemies {
            ranked_hero_data: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgHeroGlobalDataHeroesAlliesAndEnemies`
pub mod cmsg_hero_global_data_heroes_allies_and_enemies {
    // @@protoc_insertion_point(message:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct HeroData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.win_rate)
        pub win_rate: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.first_other_hero_id)
        pub first_other_hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.ally_win_rate)
        pub ally_win_rate: ::std::vec::Vec<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.enemy_win_rate)
        pub enemy_win_rate: ::std::vec::Vec<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.HeroData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a HeroData {
        fn default() -> &'a HeroData {
            <HeroData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl HeroData {
        pub fn new() -> HeroData {
            ::std::default::Default::default()
        }

        // optional int32 hero_id = 1;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 win_rate = 2;

        pub fn win_rate(&self) -> u32 {
            self.win_rate.unwrap_or(0)
        }

        pub fn clear_win_rate(&mut self) {
            self.win_rate = ::std::option::Option::None;
        }

        pub fn has_win_rate(&self) -> bool {
            self.win_rate.is_some()
        }

        // Param is passed by value, moved
        pub fn set_win_rate(&mut self, v: u32) {
            self.win_rate = ::std::option::Option::Some(v);
        }

        // optional int32 first_other_hero_id = 3;

        pub fn first_other_hero_id(&self) -> i32 {
            self.first_other_hero_id.unwrap_or(0)
        }

        pub fn clear_first_other_hero_id(&mut self) {
            self.first_other_hero_id = ::std::option::Option::None;
        }

        pub fn has_first_other_hero_id(&self) -> bool {
            self.first_other_hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_first_other_hero_id(&mut self, v: i32) {
            self.first_other_hero_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for HeroData {
        const NAME: &'static str = "HeroData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.win_rate = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.first_other_hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    42 => {
                        is.read_repeated_packed_uint32_into(&mut self.ally_win_rate)?;
                    },
                    40 => {
                        self.ally_win_rate.push(is.read_uint32()?);
                    },
                    50 => {
                        is.read_repeated_packed_uint32_into(&mut self.enemy_win_rate)?;
                    },
                    48 => {
                        self.enemy_win_rate.push(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
            }
            if let Some(v) = self.win_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.first_other_hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
            }
            for value in &self.ally_win_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, *value);
            };
            for value in &self.enemy_win_rate {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, *value);
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.hero_id {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.win_rate {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.first_other_hero_id {
                os.write_int32(3, v)?;
            }
            for v in &self.ally_win_rate {
                os.write_uint32(5, *v)?;
            };
            for v in &self.enemy_win_rate {
                os.write_uint32(6, *v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> HeroData {
            HeroData::new()
        }

        fn clear(&mut self) {
            self.hero_id = ::std::option::Option::None;
            self.win_rate = ::std::option::Option::None;
            self.first_other_hero_id = ::std::option::Option::None;
            self.ally_win_rate.clear();
            self.enemy_win_rate.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static HeroData {
            static instance: HeroData = HeroData {
                hero_id: ::std::option::Option::None,
                win_rate: ::std::option::Option::None,
                first_other_hero_id: ::std::option::Option::None,
                ally_win_rate: ::std::vec::Vec::new(),
                enemy_win_rate: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgHeroGlobalDataHeroesAlliesAndEnemies.RankedHeroData)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct RankedHeroData {
        // message fields
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.RankedHeroData.rank)
        pub rank: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.RankedHeroData.hero_data)
        pub hero_data: ::std::vec::Vec<HeroData>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgHeroGlobalDataHeroesAlliesAndEnemies.RankedHeroData.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a RankedHeroData {
        fn default() -> &'a RankedHeroData {
            <RankedHeroData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl RankedHeroData {
        pub fn new() -> RankedHeroData {
            ::std::default::Default::default()
        }

        // optional uint32 rank = 1;

        pub fn rank(&self) -> u32 {
            self.rank.unwrap_or(0)
        }

        pub fn clear_rank(&mut self) {
            self.rank = ::std::option::Option::None;
        }

        pub fn has_rank(&self) -> bool {
            self.rank.is_some()
        }

        // Param is passed by value, moved
        pub fn set_rank(&mut self, v: u32) {
            self.rank = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for RankedHeroData {
        const NAME: &'static str = "RankedHeroData";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.rank = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.hero_data.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.rank {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            for value in &self.hero_data {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.rank {
                os.write_uint32(1, v)?;
            }
            for v in &self.hero_data {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> RankedHeroData {
            RankedHeroData::new()
        }

        fn clear(&mut self) {
            self.rank = ::std::option::Option::None;
            self.hero_data.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static RankedHeroData {
            static instance: RankedHeroData = RankedHeroData {
                rank: ::std::option::Option::None,
                hero_data: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgPrivateMetadataKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPrivateMetadataKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgPrivateMetadataKeyRequest.match_id)
    pub match_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPrivateMetadataKeyRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPrivateMetadataKeyRequest {
    fn default() -> &'a CMsgPrivateMetadataKeyRequest {
        <CMsgPrivateMetadataKeyRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPrivateMetadataKeyRequest {
    pub fn new() -> CMsgPrivateMetadataKeyRequest {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPrivateMetadataKeyRequest {
    const NAME: &'static str = "CMsgPrivateMetadataKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPrivateMetadataKeyRequest {
        CMsgPrivateMetadataKeyRequest::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPrivateMetadataKeyRequest {
        static instance: CMsgPrivateMetadataKeyRequest = CMsgPrivateMetadataKeyRequest {
            match_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgPrivateMetadataKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPrivateMetadataKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgPrivateMetadataKeyResponse.private_key)
    pub private_key: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPrivateMetadataKeyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPrivateMetadataKeyResponse {
    fn default() -> &'a CMsgPrivateMetadataKeyResponse {
        <CMsgPrivateMetadataKeyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPrivateMetadataKeyResponse {
    pub fn new() -> CMsgPrivateMetadataKeyResponse {
        ::std::default::Default::default()
    }

    // optional uint32 private_key = 1;

    pub fn private_key(&self) -> u32 {
        self.private_key.unwrap_or(0)
    }

    pub fn clear_private_key(&mut self) {
        self.private_key = ::std::option::Option::None;
    }

    pub fn has_private_key(&self) -> bool {
        self.private_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_key(&mut self, v: u32) {
        self.private_key = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPrivateMetadataKeyResponse {
    const NAME: &'static str = "CMsgPrivateMetadataKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.private_key = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.private_key {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.private_key {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPrivateMetadataKeyResponse {
        CMsgPrivateMetadataKeyResponse::new()
    }

    fn clear(&mut self) {
        self.private_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPrivateMetadataKeyResponse {
        static instance: CMsgPrivateMetadataKeyResponse = CMsgPrivateMetadataKeyResponse {
            private_key: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgActivatePlusFreeTrialResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgActivatePlusFreeTrialResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgActivatePlusFreeTrialResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_activate_plus_free_trial_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgActivatePlusFreeTrialResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgActivatePlusFreeTrialResponse {
    fn default() -> &'a CMsgActivatePlusFreeTrialResponse {
        <CMsgActivatePlusFreeTrialResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgActivatePlusFreeTrialResponse {
    pub fn new() -> CMsgActivatePlusFreeTrialResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgActivatePlusFreeTrialResponse.Result result = 1;

    pub fn result(&self) -> cmsg_activate_plus_free_trial_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_activate_plus_free_trial_response::Result::SUCCESS),
            None => cmsg_activate_plus_free_trial_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_activate_plus_free_trial_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgActivatePlusFreeTrialResponse {
    const NAME: &'static str = "CMsgActivatePlusFreeTrialResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgActivatePlusFreeTrialResponse {
        CMsgActivatePlusFreeTrialResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgActivatePlusFreeTrialResponse {
        static instance: CMsgActivatePlusFreeTrialResponse = CMsgActivatePlusFreeTrialResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgActivatePlusFreeTrialResponse`
pub mod cmsg_activate_plus_free_trial_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgActivatePlusFreeTrialResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgActivatePlusFreeTrialResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgActivatePlusFreeTrialResponse.Result.ERROR_GENERIC)
        ERROR_GENERIC = 1,
        // @@protoc_insertion_point(enum_value:CMsgActivatePlusFreeTrialResponse.Result.ERROR_ALREADY_IN_FREE_TRIAL)
        ERROR_ALREADY_IN_FREE_TRIAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgActivatePlusFreeTrialResponse.Result.ERROR_ALREADY_USED_FREE_TRIAL)
        ERROR_ALREADY_USED_FREE_TRIAL = 3,
        // @@protoc_insertion_point(enum_value:CMsgActivatePlusFreeTrialResponse.Result.ERROR_OFFER_NOT_VALID)
        ERROR_OFFER_NOT_VALID = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_GENERIC),
                2 => ::std::option::Option::Some(Result::ERROR_ALREADY_IN_FREE_TRIAL),
                3 => ::std::option::Option::Some(Result::ERROR_ALREADY_USED_FREE_TRIAL),
                4 => ::std::option::Option::Some(Result::ERROR_OFFER_NOT_VALID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_GENERIC" => ::std::option::Option::Some(Result::ERROR_GENERIC),
                "ERROR_ALREADY_IN_FREE_TRIAL" => ::std::option::Option::Some(Result::ERROR_ALREADY_IN_FREE_TRIAL),
                "ERROR_ALREADY_USED_FREE_TRIAL" => ::std::option::Option::Some(Result::ERROR_ALREADY_USED_FREE_TRIAL),
                "ERROR_OFFER_NOT_VALID" => ::std::option::Option::Some(Result::ERROR_OFFER_NOT_VALID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_GENERIC,
            Result::ERROR_ALREADY_IN_FREE_TRIAL,
            Result::ERROR_ALREADY_USED_FREE_TRIAL,
            Result::ERROR_OFFER_NOT_VALID,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientCavernCrawlMapPathCompleted)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCavernCrawlMapPathCompleted {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.hero_id_completed)
    pub hero_id_completed: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.completed_paths)
    pub completed_paths: ::std::vec::Vec<cmsg_gcto_client_cavern_crawl_map_path_completed::CompletedPathInfo>,
    // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCavernCrawlMapPathCompleted.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCavernCrawlMapPathCompleted {
    fn default() -> &'a CMsgGCToClientCavernCrawlMapPathCompleted {
        <CMsgGCToClientCavernCrawlMapPathCompleted as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCavernCrawlMapPathCompleted {
    pub fn new() -> CMsgGCToClientCavernCrawlMapPathCompleted {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id_completed = 2;

    pub fn hero_id_completed(&self) -> i32 {
        self.hero_id_completed.unwrap_or(0)
    }

    pub fn clear_hero_id_completed(&mut self) {
        self.hero_id_completed = ::std::option::Option::None;
    }

    pub fn has_hero_id_completed(&self) -> bool {
        self.hero_id_completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id_completed(&mut self, v: i32) {
        self.hero_id_completed = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 4;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCavernCrawlMapPathCompleted {
    const NAME: &'static str = "CMsgGCToClientCavernCrawlMapPathCompleted";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id_completed = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    self.completed_paths.push(is.read_message()?);
                },
                32 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id_completed {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        for value in &self.completed_paths {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id_completed {
            os.write_int32(2, v)?;
        }
        for v in &self.completed_paths {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.map_variant {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCavernCrawlMapPathCompleted {
        CMsgGCToClientCavernCrawlMapPathCompleted::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.hero_id_completed = ::std::option::Option::None;
        self.completed_paths.clear();
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCavernCrawlMapPathCompleted {
        static instance: CMsgGCToClientCavernCrawlMapPathCompleted = CMsgGCToClientCavernCrawlMapPathCompleted {
            event_id: ::std::option::Option::None,
            hero_id_completed: ::std::option::Option::None,
            completed_paths: ::std::vec::Vec::new(),
            map_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientCavernCrawlMapPathCompleted`
pub mod cmsg_gcto_client_cavern_crawl_map_path_completed {
    // @@protoc_insertion_point(message:CMsgGCToClientCavernCrawlMapPathCompleted.CompletedPathInfo)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CompletedPathInfo {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.CompletedPathInfo.path_id_completed)
        pub path_id_completed: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.CompletedPathInfo.received_ultra_rare_reward)
        pub received_ultra_rare_reward: ::std::option::Option<bool>,
        // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapPathCompleted.CompletedPathInfo.half_completed)
        pub half_completed: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientCavernCrawlMapPathCompleted.CompletedPathInfo.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CompletedPathInfo {
        fn default() -> &'a CompletedPathInfo {
            <CompletedPathInfo as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CompletedPathInfo {
        pub fn new() -> CompletedPathInfo {
            ::std::default::Default::default()
        }

        // optional uint32 path_id_completed = 1;

        pub fn path_id_completed(&self) -> u32 {
            self.path_id_completed.unwrap_or(255u32)
        }

        pub fn clear_path_id_completed(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
        }

        pub fn has_path_id_completed(&self) -> bool {
            self.path_id_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_id_completed(&mut self, v: u32) {
            self.path_id_completed = ::std::option::Option::Some(v);
        }

        // optional bool received_ultra_rare_reward = 2;

        pub fn received_ultra_rare_reward(&self) -> bool {
            self.received_ultra_rare_reward.unwrap_or(false)
        }

        pub fn clear_received_ultra_rare_reward(&mut self) {
            self.received_ultra_rare_reward = ::std::option::Option::None;
        }

        pub fn has_received_ultra_rare_reward(&self) -> bool {
            self.received_ultra_rare_reward.is_some()
        }

        // Param is passed by value, moved
        pub fn set_received_ultra_rare_reward(&mut self, v: bool) {
            self.received_ultra_rare_reward = ::std::option::Option::Some(v);
        }

        // optional bool half_completed = 3;

        pub fn half_completed(&self) -> bool {
            self.half_completed.unwrap_or(false)
        }

        pub fn clear_half_completed(&mut self) {
            self.half_completed = ::std::option::Option::None;
        }

        pub fn has_half_completed(&self) -> bool {
            self.half_completed.is_some()
        }

        // Param is passed by value, moved
        pub fn set_half_completed(&mut self, v: bool) {
            self.half_completed = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CompletedPathInfo {
        const NAME: &'static str = "CompletedPathInfo";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.path_id_completed = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.received_ultra_rare_reward = ::std::option::Option::Some(is.read_bool()?);
                    },
                    24 => {
                        self.half_completed = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path_id_completed {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.received_ultra_rare_reward {
                my_size += 1 + 1;
            }
            if let Some(v) = self.half_completed {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.path_id_completed {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.received_ultra_rare_reward {
                os.write_bool(2, v)?;
            }
            if let Some(v) = self.half_completed {
                os.write_bool(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CompletedPathInfo {
            CompletedPathInfo::new()
        }

        fn clear(&mut self) {
            self.path_id_completed = ::std::option::Option::None;
            self.received_ultra_rare_reward = ::std::option::Option::None;
            self.half_completed = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CompletedPathInfo {
            static instance: CompletedPathInfo = CompletedPathInfo {
                path_id_completed: ::std::option::Option::None,
                received_ultra_rare_reward: ::std::option::Option::None,
                half_completed: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientCavernCrawlMapUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCavernCrawlMapUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCavernCrawlMapUpdated.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCavernCrawlMapUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCavernCrawlMapUpdated {
    fn default() -> &'a CMsgGCToClientCavernCrawlMapUpdated {
        <CMsgGCToClientCavernCrawlMapUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCavernCrawlMapUpdated {
    pub fn new() -> CMsgGCToClientCavernCrawlMapUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCavernCrawlMapUpdated {
    const NAME: &'static str = "CMsgGCToClientCavernCrawlMapUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCavernCrawlMapUpdated {
        CMsgGCToClientCavernCrawlMapUpdated::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCavernCrawlMapUpdated {
        static instance: CMsgGCToClientCavernCrawlMapUpdated = CMsgGCToClientCavernCrawlMapUpdated {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlClaimRoom)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlClaimRoom {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlClaimRoom.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlClaimRoom.room_id)
    pub room_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlClaimRoom.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlClaimRoom.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlClaimRoom {
    fn default() -> &'a CMsgClientToGCCavernCrawlClaimRoom {
        <CMsgClientToGCCavernCrawlClaimRoom as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlClaimRoom {
    pub fn new() -> CMsgClientToGCCavernCrawlClaimRoom {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 room_id = 2;

    pub fn room_id(&self) -> u32 {
        self.room_id.unwrap_or(255u32)
    }

    pub fn clear_room_id(&mut self) {
        self.room_id = ::std::option::Option::None;
    }

    pub fn has_room_id(&self) -> bool {
        self.room_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_room_id(&mut self, v: u32) {
        self.room_id = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 3;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlClaimRoom {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlClaimRoom";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.room_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.room_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.room_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.map_variant {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlClaimRoom {
        CMsgClientToGCCavernCrawlClaimRoom::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.room_id = ::std::option::Option::None;
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlClaimRoom {
        static instance: CMsgClientToGCCavernCrawlClaimRoom = CMsgClientToGCCavernCrawlClaimRoom {
            event_id: ::std::option::Option::None,
            room_id: ::std::option::Option::None,
            map_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlClaimRoomResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlClaimRoomResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlClaimRoomResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccavern_crawl_claim_room_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlClaimRoomResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlClaimRoomResponse {
    fn default() -> &'a CMsgClientToGCCavernCrawlClaimRoomResponse {
        <CMsgClientToGCCavernCrawlClaimRoomResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlClaimRoomResponse {
    pub fn new() -> CMsgClientToGCCavernCrawlClaimRoomResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCavernCrawlClaimRoomResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccavern_crawl_claim_room_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccavern_crawl_claim_room_response::Result::SUCCESS),
            None => cmsg_client_to_gccavern_crawl_claim_room_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccavern_crawl_claim_room_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlClaimRoomResponse {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlClaimRoomResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlClaimRoomResponse {
        CMsgClientToGCCavernCrawlClaimRoomResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlClaimRoomResponse {
        static instance: CMsgClientToGCCavernCrawlClaimRoomResponse = CMsgClientToGCCavernCrawlClaimRoomResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCavernCrawlClaimRoomResponse`
pub mod cmsg_client_to_gccavern_crawl_claim_room_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCavernCrawlClaimRoomResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlClaimRoomResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlClaimRoomResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlClaimRoomResponse.Result.RECEIVED_ULTRA_RARE_REWARD)
        RECEIVED_ULTRA_RARE_REWARD = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "RECEIVED_ULTRA_RARE_REWARD" => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::RECEIVED_ULTRA_RARE_REWARD,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlUseItemOnRoom)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlUseItemOnRoom {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnRoom.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnRoom.room_id)
    pub room_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnRoom.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnRoom.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlUseItemOnRoom.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlUseItemOnRoom {
    fn default() -> &'a CMsgClientToGCCavernCrawlUseItemOnRoom {
        <CMsgClientToGCCavernCrawlUseItemOnRoom as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlUseItemOnRoom {
    pub fn new() -> CMsgClientToGCCavernCrawlUseItemOnRoom {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 room_id = 2;

    pub fn room_id(&self) -> u32 {
        self.room_id.unwrap_or(255u32)
    }

    pub fn clear_room_id(&mut self) {
        self.room_id = ::std::option::Option::None;
    }

    pub fn has_room_id(&self) -> bool {
        self.room_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_room_id(&mut self, v: u32) {
        self.room_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 4;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlUseItemOnRoom {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlUseItemOnRoom";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.room_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.room_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.room_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.map_variant {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlUseItemOnRoom {
        CMsgClientToGCCavernCrawlUseItemOnRoom::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.room_id = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlUseItemOnRoom {
        static instance: CMsgClientToGCCavernCrawlUseItemOnRoom = CMsgClientToGCCavernCrawlUseItemOnRoom {
            event_id: ::std::option::Option::None,
            room_id: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            map_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlUseItemOnRoomResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccavern_crawl_use_item_on_room_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    fn default() -> &'a CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
        <CMsgClientToGCCavernCrawlUseItemOnRoomResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    pub fn new() -> CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCavernCrawlUseItemOnRoomResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccavern_crawl_use_item_on_room_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccavern_crawl_use_item_on_room_response::Result::SUCCESS),
            None => cmsg_client_to_gccavern_crawl_use_item_on_room_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccavern_crawl_use_item_on_room_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlUseItemOnRoomResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
        CMsgClientToGCCavernCrawlUseItemOnRoomResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
        static instance: CMsgClientToGCCavernCrawlUseItemOnRoomResponse = CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCavernCrawlUseItemOnRoomResponse`
pub mod cmsg_client_to_gccavern_crawl_use_item_on_room_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnRoomResponse.Result.RECEIVED_ULTRA_RARE_REWARD)
        RECEIVED_ULTRA_RARE_REWARD = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "RECEIVED_ULTRA_RARE_REWARD" => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::RECEIVED_ULTRA_RARE_REWARD,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlUseItemOnPath)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlUseItemOnPath {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnPath.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnPath.path_id)
    pub path_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnPath.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnPath.map_variant)
    pub map_variant: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlUseItemOnPath.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlUseItemOnPath {
    fn default() -> &'a CMsgClientToGCCavernCrawlUseItemOnPath {
        <CMsgClientToGCCavernCrawlUseItemOnPath as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlUseItemOnPath {
    pub fn new() -> CMsgClientToGCCavernCrawlUseItemOnPath {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 path_id = 2;

    pub fn path_id(&self) -> u32 {
        self.path_id.unwrap_or(255u32)
    }

    pub fn clear_path_id(&mut self) {
        self.path_id = ::std::option::Option::None;
    }

    pub fn has_path_id(&self) -> bool {
        self.path_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path_id(&mut self, v: u32) {
        self.path_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 3;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional uint32 map_variant = 4;

    pub fn map_variant(&self) -> u32 {
        self.map_variant.unwrap_or(255u32)
    }

    pub fn clear_map_variant(&mut self) {
        self.map_variant = ::std::option::Option::None;
    }

    pub fn has_map_variant(&self) -> bool {
        self.map_variant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_variant(&mut self, v: u32) {
        self.map_variant = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlUseItemOnPath {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlUseItemOnPath";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.path_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.path_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.map_variant {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.path_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.map_variant {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlUseItemOnPath {
        CMsgClientToGCCavernCrawlUseItemOnPath::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.path_id = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.map_variant = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlUseItemOnPath {
        static instance: CMsgClientToGCCavernCrawlUseItemOnPath = CMsgClientToGCCavernCrawlUseItemOnPath {
            event_id: ::std::option::Option::None,
            path_id: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            map_variant: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlUseItemOnPathResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlUseItemOnPathResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccavern_crawl_use_item_on_path_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlUseItemOnPathResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    fn default() -> &'a CMsgClientToGCCavernCrawlUseItemOnPathResponse {
        <CMsgClientToGCCavernCrawlUseItemOnPathResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    pub fn new() -> CMsgClientToGCCavernCrawlUseItemOnPathResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCavernCrawlUseItemOnPathResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccavern_crawl_use_item_on_path_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccavern_crawl_use_item_on_path_response::Result::SUCCESS),
            None => cmsg_client_to_gccavern_crawl_use_item_on_path_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccavern_crawl_use_item_on_path_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlUseItemOnPathResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlUseItemOnPathResponse {
        CMsgClientToGCCavernCrawlUseItemOnPathResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlUseItemOnPathResponse {
        static instance: CMsgClientToGCCavernCrawlUseItemOnPathResponse = CMsgClientToGCCavernCrawlUseItemOnPathResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCavernCrawlUseItemOnPathResponse`
pub mod cmsg_client_to_gccavern_crawl_use_item_on_path_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCavernCrawlUseItemOnPathResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnPathResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnPathResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlUseItemOnPathResponse.Result.RECEIVED_ULTRA_RARE_REWARD)
        RECEIVED_ULTRA_RARE_REWARD = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "RECEIVED_ULTRA_RARE_REWARD" => ::std::option::Option::Some(Result::RECEIVED_ULTRA_RARE_REWARD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::RECEIVED_ULTRA_RARE_REWARD,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlRequestMapState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapState.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlRequestMapState {
    fn default() -> &'a CMsgClientToGCCavernCrawlRequestMapState {
        <CMsgClientToGCCavernCrawlRequestMapState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlRequestMapState {
    pub fn new() -> CMsgClientToGCCavernCrawlRequestMapState {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlRequestMapState {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlRequestMapState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlRequestMapState {
        CMsgClientToGCCavernCrawlRequestMapState::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlRequestMapState {
        static instance: CMsgClientToGCCavernCrawlRequestMapState = CMsgClientToGCCavernCrawlRequestMapState {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlRequestMapStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccavern_crawl_request_map_state_response::Result>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.available_map_variants_mask)
    pub available_map_variants_mask: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.inventory_item)
    pub inventory_item: ::std::vec::Vec<cmsg_client_to_gccavern_crawl_request_map_state_response::InventoryItem>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.map_variants)
    pub map_variants: ::std::vec::Vec<cmsg_client_to_gccavern_crawl_request_map_state_response::MapVariant>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapStateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlRequestMapStateResponse {
    fn default() -> &'a CMsgClientToGCCavernCrawlRequestMapStateResponse {
        <CMsgClientToGCCavernCrawlRequestMapStateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlRequestMapStateResponse {
    pub fn new() -> CMsgClientToGCCavernCrawlRequestMapStateResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCavernCrawlRequestMapStateResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccavern_crawl_request_map_state_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccavern_crawl_request_map_state_response::Result::SUCCESS),
            None => cmsg_client_to_gccavern_crawl_request_map_state_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccavern_crawl_request_map_state_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 available_map_variants_mask = 2;

    pub fn available_map_variants_mask(&self) -> u32 {
        self.available_map_variants_mask.unwrap_or(0)
    }

    pub fn clear_available_map_variants_mask(&mut self) {
        self.available_map_variants_mask = ::std::option::Option::None;
    }

    pub fn has_available_map_variants_mask(&self) -> bool {
        self.available_map_variants_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_map_variants_mask(&mut self, v: u32) {
        self.available_map_variants_mask = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlRequestMapStateResponse {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlRequestMapStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.available_map_variants_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.inventory_item.push(is.read_message()?);
                },
                34 => {
                    self.map_variants.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.available_map_variants_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.inventory_item {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.map_variants {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.available_map_variants_mask {
            os.write_uint32(2, v)?;
        }
        for v in &self.inventory_item {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.map_variants {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlRequestMapStateResponse {
        CMsgClientToGCCavernCrawlRequestMapStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.available_map_variants_mask = ::std::option::Option::None;
        self.inventory_item.clear();
        self.map_variants.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlRequestMapStateResponse {
        static instance: CMsgClientToGCCavernCrawlRequestMapStateResponse = CMsgClientToGCCavernCrawlRequestMapStateResponse {
            result: ::std::option::Option::None,
            available_map_variants_mask: ::std::option::Option::None,
            inventory_item: ::std::vec::Vec::new(),
            map_variants: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCavernCrawlRequestMapStateResponse`
pub mod cmsg_client_to_gccavern_crawl_request_map_state_response {
    // @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapStateResponse.SwappedChallenge)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SwappedChallenge {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.SwappedChallenge.path_id_1)
        pub path_id_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.SwappedChallenge.path_id_2)
        pub path_id_2: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapStateResponse.SwappedChallenge.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SwappedChallenge {
        fn default() -> &'a SwappedChallenge {
            <SwappedChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SwappedChallenge {
        pub fn new() -> SwappedChallenge {
            ::std::default::Default::default()
        }

        // optional uint32 path_id_1 = 1;

        pub fn path_id_1(&self) -> u32 {
            self.path_id_1.unwrap_or(255u32)
        }

        pub fn clear_path_id_1(&mut self) {
            self.path_id_1 = ::std::option::Option::None;
        }

        pub fn has_path_id_1(&self) -> bool {
            self.path_id_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_id_1(&mut self, v: u32) {
            self.path_id_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 path_id_2 = 2;

        pub fn path_id_2(&self) -> u32 {
            self.path_id_2.unwrap_or(255u32)
        }

        pub fn clear_path_id_2(&mut self) {
            self.path_id_2 = ::std::option::Option::None;
        }

        pub fn has_path_id_2(&self) -> bool {
            self.path_id_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_path_id_2(&mut self, v: u32) {
            self.path_id_2 = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SwappedChallenge {
        const NAME: &'static str = "SwappedChallenge";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.path_id_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.path_id_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.path_id_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.path_id_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.path_id_1 {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.path_id_2 {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SwappedChallenge {
            SwappedChallenge::new()
        }

        fn clear(&mut self) {
            self.path_id_1 = ::std::option::Option::None;
            self.path_id_2 = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SwappedChallenge {
            static instance: SwappedChallenge = SwappedChallenge {
                path_id_1: ::std::option::Option::None,
                path_id_2: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapStateResponse.InventoryItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct InventoryItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.InventoryItem.item_type)
        pub item_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.InventoryItem.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapStateResponse.InventoryItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a InventoryItem {
        fn default() -> &'a InventoryItem {
            <InventoryItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl InventoryItem {
        pub fn new() -> InventoryItem {
            ::std::default::Default::default()
        }

        // optional uint32 item_type = 1;

        pub fn item_type(&self) -> u32 {
            self.item_type.unwrap_or(0)
        }

        pub fn clear_item_type(&mut self) {
            self.item_type = ::std::option::Option::None;
        }

        pub fn has_item_type(&self) -> bool {
            self.item_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_type(&mut self, v: u32) {
            self.item_type = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for InventoryItem {
        const NAME: &'static str = "InventoryItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_type {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> InventoryItem {
            InventoryItem::new()
        }

        fn clear(&mut self) {
            self.item_type = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static InventoryItem {
            static instance: InventoryItem = InventoryItem {
                item_type: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapStateResponse.TreasureMap)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct TreasureMap {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.TreasureMap.map_room_id)
        pub map_room_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.TreasureMap.revealed_room_id)
        pub revealed_room_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapStateResponse.TreasureMap.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a TreasureMap {
        fn default() -> &'a TreasureMap {
            <TreasureMap as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl TreasureMap {
        pub fn new() -> TreasureMap {
            ::std::default::Default::default()
        }

        // optional uint32 map_room_id = 1;

        pub fn map_room_id(&self) -> u32 {
            self.map_room_id.unwrap_or(255u32)
        }

        pub fn clear_map_room_id(&mut self) {
            self.map_room_id = ::std::option::Option::None;
        }

        pub fn has_map_room_id(&self) -> bool {
            self.map_room_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_room_id(&mut self, v: u32) {
            self.map_room_id = ::std::option::Option::Some(v);
        }

        // optional uint32 revealed_room_id = 2;

        pub fn revealed_room_id(&self) -> u32 {
            self.revealed_room_id.unwrap_or(255u32)
        }

        pub fn clear_revealed_room_id(&mut self) {
            self.revealed_room_id = ::std::option::Option::None;
        }

        pub fn has_revealed_room_id(&self) -> bool {
            self.revealed_room_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revealed_room_id(&mut self, v: u32) {
            self.revealed_room_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for TreasureMap {
        const NAME: &'static str = "TreasureMap";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.map_room_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.revealed_room_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.map_room_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.revealed_room_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.map_room_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.revealed_room_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> TreasureMap {
            TreasureMap::new()
        }

        fn clear(&mut self) {
            self.map_room_id = ::std::option::Option::None;
            self.revealed_room_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static TreasureMap {
            static instance: TreasureMap = TreasureMap {
                map_room_id: ::std::option::Option::None,
                revealed_room_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MapVariant {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.map_variant)
        pub map_variant: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.claimed_rooms_1)
        pub claimed_rooms_1: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.claimed_rooms_2)
        pub claimed_rooms_2: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.revealed_rooms_1)
        pub revealed_rooms_1: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.revealed_rooms_2)
        pub revealed_rooms_2: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.completed_paths_1)
        pub completed_paths_1: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.completed_paths_2)
        pub completed_paths_2: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.completed_paths_3)
        pub completed_paths_3: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.completed_paths_4)
        pub completed_paths_4: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.half_completed_paths_1)
        pub half_completed_paths_1: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.half_completed_paths_2)
        pub half_completed_paths_2: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.half_completed_paths_3)
        pub half_completed_paths_3: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.half_completed_paths_4)
        pub half_completed_paths_4: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.swapped_challenge)
        pub swapped_challenge: ::std::vec::Vec<SwappedChallenge>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.ultra_rare_reward_room_number)
        pub ultra_rare_reward_room_number: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.treasure_map)
        pub treasure_map: ::std::vec::Vec<TreasureMap>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlRequestMapStateResponse.MapVariant.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MapVariant {
        fn default() -> &'a MapVariant {
            <MapVariant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MapVariant {
        pub fn new() -> MapVariant {
            ::std::default::Default::default()
        }

        // optional uint32 map_variant = 1;

        pub fn map_variant(&self) -> u32 {
            self.map_variant.unwrap_or(255u32)
        }

        pub fn clear_map_variant(&mut self) {
            self.map_variant = ::std::option::Option::None;
        }

        pub fn has_map_variant(&self) -> bool {
            self.map_variant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_variant(&mut self, v: u32) {
            self.map_variant = ::std::option::Option::Some(v);
        }

        // optional fixed64 claimed_rooms_1 = 2;

        pub fn claimed_rooms_1(&self) -> u64 {
            self.claimed_rooms_1.unwrap_or(0)
        }

        pub fn clear_claimed_rooms_1(&mut self) {
            self.claimed_rooms_1 = ::std::option::Option::None;
        }

        pub fn has_claimed_rooms_1(&self) -> bool {
            self.claimed_rooms_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_rooms_1(&mut self, v: u64) {
            self.claimed_rooms_1 = ::std::option::Option::Some(v);
        }

        // optional fixed64 claimed_rooms_2 = 3;

        pub fn claimed_rooms_2(&self) -> u64 {
            self.claimed_rooms_2.unwrap_or(0)
        }

        pub fn clear_claimed_rooms_2(&mut self) {
            self.claimed_rooms_2 = ::std::option::Option::None;
        }

        pub fn has_claimed_rooms_2(&self) -> bool {
            self.claimed_rooms_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_claimed_rooms_2(&mut self, v: u64) {
            self.claimed_rooms_2 = ::std::option::Option::Some(v);
        }

        // optional fixed64 revealed_rooms_1 = 4;

        pub fn revealed_rooms_1(&self) -> u64 {
            self.revealed_rooms_1.unwrap_or(0)
        }

        pub fn clear_revealed_rooms_1(&mut self) {
            self.revealed_rooms_1 = ::std::option::Option::None;
        }

        pub fn has_revealed_rooms_1(&self) -> bool {
            self.revealed_rooms_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revealed_rooms_1(&mut self, v: u64) {
            self.revealed_rooms_1 = ::std::option::Option::Some(v);
        }

        // optional fixed64 revealed_rooms_2 = 5;

        pub fn revealed_rooms_2(&self) -> u64 {
            self.revealed_rooms_2.unwrap_or(0)
        }

        pub fn clear_revealed_rooms_2(&mut self) {
            self.revealed_rooms_2 = ::std::option::Option::None;
        }

        pub fn has_revealed_rooms_2(&self) -> bool {
            self.revealed_rooms_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_revealed_rooms_2(&mut self, v: u64) {
            self.revealed_rooms_2 = ::std::option::Option::Some(v);
        }

        // optional fixed64 completed_paths_1 = 6;

        pub fn completed_paths_1(&self) -> u64 {
            self.completed_paths_1.unwrap_or(0)
        }

        pub fn clear_completed_paths_1(&mut self) {
            self.completed_paths_1 = ::std::option::Option::None;
        }

        pub fn has_completed_paths_1(&self) -> bool {
            self.completed_paths_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed_paths_1(&mut self, v: u64) {
            self.completed_paths_1 = ::std::option::Option::Some(v);
        }

        // optional fixed64 completed_paths_2 = 7;

        pub fn completed_paths_2(&self) -> u64 {
            self.completed_paths_2.unwrap_or(0)
        }

        pub fn clear_completed_paths_2(&mut self) {
            self.completed_paths_2 = ::std::option::Option::None;
        }

        pub fn has_completed_paths_2(&self) -> bool {
            self.completed_paths_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed_paths_2(&mut self, v: u64) {
            self.completed_paths_2 = ::std::option::Option::Some(v);
        }

        // optional fixed64 completed_paths_3 = 8;

        pub fn completed_paths_3(&self) -> u64 {
            self.completed_paths_3.unwrap_or(0)
        }

        pub fn clear_completed_paths_3(&mut self) {
            self.completed_paths_3 = ::std::option::Option::None;
        }

        pub fn has_completed_paths_3(&self) -> bool {
            self.completed_paths_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed_paths_3(&mut self, v: u64) {
            self.completed_paths_3 = ::std::option::Option::Some(v);
        }

        // optional fixed64 completed_paths_4 = 9;

        pub fn completed_paths_4(&self) -> u64 {
            self.completed_paths_4.unwrap_or(0)
        }

        pub fn clear_completed_paths_4(&mut self) {
            self.completed_paths_4 = ::std::option::Option::None;
        }

        pub fn has_completed_paths_4(&self) -> bool {
            self.completed_paths_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_completed_paths_4(&mut self, v: u64) {
            self.completed_paths_4 = ::std::option::Option::Some(v);
        }

        // optional fixed64 half_completed_paths_1 = 10;

        pub fn half_completed_paths_1(&self) -> u64 {
            self.half_completed_paths_1.unwrap_or(0)
        }

        pub fn clear_half_completed_paths_1(&mut self) {
            self.half_completed_paths_1 = ::std::option::Option::None;
        }

        pub fn has_half_completed_paths_1(&self) -> bool {
            self.half_completed_paths_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_half_completed_paths_1(&mut self, v: u64) {
            self.half_completed_paths_1 = ::std::option::Option::Some(v);
        }

        // optional fixed64 half_completed_paths_2 = 11;

        pub fn half_completed_paths_2(&self) -> u64 {
            self.half_completed_paths_2.unwrap_or(0)
        }

        pub fn clear_half_completed_paths_2(&mut self) {
            self.half_completed_paths_2 = ::std::option::Option::None;
        }

        pub fn has_half_completed_paths_2(&self) -> bool {
            self.half_completed_paths_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_half_completed_paths_2(&mut self, v: u64) {
            self.half_completed_paths_2 = ::std::option::Option::Some(v);
        }

        // optional fixed64 half_completed_paths_3 = 12;

        pub fn half_completed_paths_3(&self) -> u64 {
            self.half_completed_paths_3.unwrap_or(0)
        }

        pub fn clear_half_completed_paths_3(&mut self) {
            self.half_completed_paths_3 = ::std::option::Option::None;
        }

        pub fn has_half_completed_paths_3(&self) -> bool {
            self.half_completed_paths_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_half_completed_paths_3(&mut self, v: u64) {
            self.half_completed_paths_3 = ::std::option::Option::Some(v);
        }

        // optional fixed64 half_completed_paths_4 = 13;

        pub fn half_completed_paths_4(&self) -> u64 {
            self.half_completed_paths_4.unwrap_or(0)
        }

        pub fn clear_half_completed_paths_4(&mut self) {
            self.half_completed_paths_4 = ::std::option::Option::None;
        }

        pub fn has_half_completed_paths_4(&self) -> bool {
            self.half_completed_paths_4.is_some()
        }

        // Param is passed by value, moved
        pub fn set_half_completed_paths_4(&mut self, v: u64) {
            self.half_completed_paths_4 = ::std::option::Option::Some(v);
        }

        // optional uint32 ultra_rare_reward_room_number = 15;

        pub fn ultra_rare_reward_room_number(&self) -> u32 {
            self.ultra_rare_reward_room_number.unwrap_or(255u32)
        }

        pub fn clear_ultra_rare_reward_room_number(&mut self) {
            self.ultra_rare_reward_room_number = ::std::option::Option::None;
        }

        pub fn has_ultra_rare_reward_room_number(&self) -> bool {
            self.ultra_rare_reward_room_number.is_some()
        }

        // Param is passed by value, moved
        pub fn set_ultra_rare_reward_room_number(&mut self, v: u32) {
            self.ultra_rare_reward_room_number = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MapVariant {
        const NAME: &'static str = "MapVariant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    17 => {
                        self.claimed_rooms_1 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    25 => {
                        self.claimed_rooms_2 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    33 => {
                        self.revealed_rooms_1 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    41 => {
                        self.revealed_rooms_2 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    49 => {
                        self.completed_paths_1 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    57 => {
                        self.completed_paths_2 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    65 => {
                        self.completed_paths_3 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    73 => {
                        self.completed_paths_4 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    81 => {
                        self.half_completed_paths_1 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    89 => {
                        self.half_completed_paths_2 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    97 => {
                        self.half_completed_paths_3 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    105 => {
                        self.half_completed_paths_4 = ::std::option::Option::Some(is.read_fixed64()?);
                    },
                    114 => {
                        self.swapped_challenge.push(is.read_message()?);
                    },
                    120 => {
                        self.ultra_rare_reward_room_number = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    130 => {
                        self.treasure_map.push(is.read_message()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.map_variant {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.claimed_rooms_1 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.claimed_rooms_2 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.revealed_rooms_1 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.revealed_rooms_2 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.completed_paths_1 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.completed_paths_2 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.completed_paths_3 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.completed_paths_4 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.half_completed_paths_1 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.half_completed_paths_2 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.half_completed_paths_3 {
                my_size += 1 + 8;
            }
            if let Some(v) = self.half_completed_paths_4 {
                my_size += 1 + 8;
            }
            for value in &self.swapped_challenge {
                let len = value.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            if let Some(v) = self.ultra_rare_reward_room_number {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(15, v);
            }
            for value in &self.treasure_map {
                let len = value.compute_size();
                my_size += 2 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            };
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.map_variant {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.claimed_rooms_1 {
                os.write_fixed64(2, v)?;
            }
            if let Some(v) = self.claimed_rooms_2 {
                os.write_fixed64(3, v)?;
            }
            if let Some(v) = self.revealed_rooms_1 {
                os.write_fixed64(4, v)?;
            }
            if let Some(v) = self.revealed_rooms_2 {
                os.write_fixed64(5, v)?;
            }
            if let Some(v) = self.completed_paths_1 {
                os.write_fixed64(6, v)?;
            }
            if let Some(v) = self.completed_paths_2 {
                os.write_fixed64(7, v)?;
            }
            if let Some(v) = self.completed_paths_3 {
                os.write_fixed64(8, v)?;
            }
            if let Some(v) = self.completed_paths_4 {
                os.write_fixed64(9, v)?;
            }
            if let Some(v) = self.half_completed_paths_1 {
                os.write_fixed64(10, v)?;
            }
            if let Some(v) = self.half_completed_paths_2 {
                os.write_fixed64(11, v)?;
            }
            if let Some(v) = self.half_completed_paths_3 {
                os.write_fixed64(12, v)?;
            }
            if let Some(v) = self.half_completed_paths_4 {
                os.write_fixed64(13, v)?;
            }
            for v in &self.swapped_challenge {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
            };
            if let Some(v) = self.ultra_rare_reward_room_number {
                os.write_uint32(15, v)?;
            }
            for v in &self.treasure_map {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MapVariant {
            MapVariant::new()
        }

        fn clear(&mut self) {
            self.map_variant = ::std::option::Option::None;
            self.claimed_rooms_1 = ::std::option::Option::None;
            self.claimed_rooms_2 = ::std::option::Option::None;
            self.revealed_rooms_1 = ::std::option::Option::None;
            self.revealed_rooms_2 = ::std::option::Option::None;
            self.completed_paths_1 = ::std::option::Option::None;
            self.completed_paths_2 = ::std::option::Option::None;
            self.completed_paths_3 = ::std::option::Option::None;
            self.completed_paths_4 = ::std::option::Option::None;
            self.half_completed_paths_1 = ::std::option::Option::None;
            self.half_completed_paths_2 = ::std::option::Option::None;
            self.half_completed_paths_3 = ::std::option::Option::None;
            self.half_completed_paths_4 = ::std::option::Option::None;
            self.swapped_challenge.clear();
            self.ultra_rare_reward_room_number = ::std::option::Option::None;
            self.treasure_map.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MapVariant {
            static instance: MapVariant = MapVariant {
                map_variant: ::std::option::Option::None,
                claimed_rooms_1: ::std::option::Option::None,
                claimed_rooms_2: ::std::option::Option::None,
                revealed_rooms_1: ::std::option::Option::None,
                revealed_rooms_2: ::std::option::Option::None,
                completed_paths_1: ::std::option::Option::None,
                completed_paths_2: ::std::option::Option::None,
                completed_paths_3: ::std::option::Option::None,
                completed_paths_4: ::std::option::Option::None,
                half_completed_paths_1: ::std::option::Option::None,
                half_completed_paths_2: ::std::option::Option::None,
                half_completed_paths_3: ::std::option::Option::None,
                half_completed_paths_4: ::std::option::Option::None,
                swapped_challenge: ::std::vec::Vec::new(),
                ultra_rare_reward_room_number: ::std::option::Option::None,
                treasure_map: ::std::vec::Vec::new(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCavernCrawlRequestMapStateResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlRequestMapStateResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlRequestMapStateResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlRequestMapStateResponse.Result.EVENT_NOT_OWNED)
        EVENT_NOT_OWNED = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::EVENT_NOT_OWNED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "EVENT_NOT_OWNED" => ::std::option::Option::Some(Result::EVENT_NOT_OWNED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::EVENT_NOT_OWNED,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlGetClaimedRoomCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCount.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlGetClaimedRoomCount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    fn default() -> &'a CMsgClientToGCCavernCrawlGetClaimedRoomCount {
        <CMsgClientToGCCavernCrawlGetClaimedRoomCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    pub fn new() -> CMsgClientToGCCavernCrawlGetClaimedRoomCount {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlGetClaimedRoomCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlGetClaimedRoomCount {
        CMsgClientToGCCavernCrawlGetClaimedRoomCount::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlGetClaimedRoomCount {
        static instance: CMsgClientToGCCavernCrawlGetClaimedRoomCount = CMsgClientToGCCavernCrawlGetClaimedRoomCount {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::Result>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.map_variants)
    pub map_variants: ::std::vec::Vec<cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::MapVariant>,
    // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.available_map_variants_mask)
    pub available_map_variants_mask: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    fn default() -> &'a CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
        <CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    pub fn new() -> CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::Result::SUCCESS),
            None => cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gccavern_crawl_get_claimed_room_count_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 available_map_variants_mask = 3;

    pub fn available_map_variants_mask(&self) -> u32 {
        self.available_map_variants_mask.unwrap_or(0)
    }

    pub fn clear_available_map_variants_mask(&mut self) {
        self.available_map_variants_mask = ::std::option::Option::None;
    }

    pub fn has_available_map_variants_mask(&self) -> bool {
        self.available_map_variants_mask.is_some()
    }

    // Param is passed by value, moved
    pub fn set_available_map_variants_mask(&mut self, v: u32) {
        self.available_map_variants_mask = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    const NAME: &'static str = "CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.map_variants.push(is.read_message()?);
                },
                24 => {
                    self.available_map_variants_mask = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.map_variants {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.available_map_variants_mask {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.map_variants {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.available_map_variants_mask {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
        CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.map_variants.clear();
        self.available_map_variants_mask = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
        static instance: CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse = CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
            result: ::std::option::Option::None,
            map_variants: ::std::vec::Vec::new(),
            available_map_variants_mask: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse`
pub mod cmsg_client_to_gccavern_crawl_get_claimed_room_count_response {
    // @@protoc_insertion_point(message:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.MapVariant)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct MapVariant {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.MapVariant.map_variant)
        pub map_variant: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.MapVariant.count)
        pub count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.MapVariant.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a MapVariant {
        fn default() -> &'a MapVariant {
            <MapVariant as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl MapVariant {
        pub fn new() -> MapVariant {
            ::std::default::Default::default()
        }

        // optional uint32 map_variant = 1;

        pub fn map_variant(&self) -> u32 {
            self.map_variant.unwrap_or(255u32)
        }

        pub fn clear_map_variant(&mut self) {
            self.map_variant = ::std::option::Option::None;
        }

        pub fn has_map_variant(&self) -> bool {
            self.map_variant.is_some()
        }

        // Param is passed by value, moved
        pub fn set_map_variant(&mut self, v: u32) {
            self.map_variant = ::std::option::Option::Some(v);
        }

        // optional uint32 count = 2;

        pub fn count(&self) -> u32 {
            self.count.unwrap_or(0)
        }

        pub fn clear_count(&mut self) {
            self.count = ::std::option::Option::None;
        }

        pub fn has_count(&self) -> bool {
            self.count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_count(&mut self, v: u32) {
            self.count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for MapVariant {
        const NAME: &'static str = "MapVariant";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.map_variant = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.map_variant {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.map_variant {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> MapVariant {
            MapVariant::new()
        }

        fn clear(&mut self) {
            self.map_variant = ::std::option::Option::None;
            self.count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static MapVariant {
            static instance: MapVariant = MapVariant {
                map_variant: ::std::option::Option::None,
                count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.Result.ERROR_UNKNOWN)
        ERROR_UNKNOWN = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse.Result.EVENT_NOT_OWNED)
        EVENT_NOT_OWNED = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                2 => ::std::option::Option::Some(Result::EVENT_NOT_OWNED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_UNKNOWN" => ::std::option::Option::Some(Result::ERROR_UNKNOWN),
                "EVENT_NOT_OWNED" => ::std::option::Option::Some(Result::EVENT_NOT_OWNED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_UNKNOWN,
            Result::EVENT_NOT_OWNED,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAMutationList)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAMutationList {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAMutationList.mutations)
    pub mutations: ::std::vec::Vec<cmsg_dotamutation_list::Mutation>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAMutationList.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAMutationList {
    fn default() -> &'a CMsgDOTAMutationList {
        <CMsgDOTAMutationList as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAMutationList {
    pub fn new() -> CMsgDOTAMutationList {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAMutationList {
    const NAME: &'static str = "CMsgDOTAMutationList";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.mutations.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.mutations {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.mutations {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAMutationList {
        CMsgDOTAMutationList::new()
    }

    fn clear(&mut self) {
        self.mutations.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAMutationList {
        static instance: CMsgDOTAMutationList = CMsgDOTAMutationList {
            mutations: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgDOTAMutationList`
pub mod cmsg_dotamutation_list {
    // @@protoc_insertion_point(message:CMsgDOTAMutationList.Mutation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Mutation {
        // message fields
        // @@protoc_insertion_point(field:CMsgDOTAMutationList.Mutation.id)
        pub id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgDOTAMutationList.Mutation.name)
        pub name: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:CMsgDOTAMutationList.Mutation.description)
        pub description: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgDOTAMutationList.Mutation.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Mutation {
        fn default() -> &'a Mutation {
            <Mutation as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Mutation {
        pub fn new() -> Mutation {
            ::std::default::Default::default()
        }

        // optional uint32 id = 1;

        pub fn id(&self) -> u32 {
            self.id.unwrap_or(0)
        }

        pub fn clear_id(&mut self) {
            self.id = ::std::option::Option::None;
        }

        pub fn has_id(&self) -> bool {
            self.id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_id(&mut self, v: u32) {
            self.id = ::std::option::Option::Some(v);
        }

        // optional string name = 2;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string description = 3;

        pub fn description(&self) -> &str {
            match self.description.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_description(&mut self) {
            self.description = ::std::option::Option::None;
        }

        pub fn has_description(&self) -> bool {
            self.description.is_some()
        }

        // Param is passed by value, moved
        pub fn set_description(&mut self, v: ::std::string::String) {
            self.description = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_description(&mut self) -> &mut ::std::string::String {
            if self.description.is_none() {
                self.description = ::std::option::Option::Some(::std::string::String::new());
            }
            self.description.as_mut().unwrap()
        }

        // Take field
        pub fn take_description(&mut self) -> ::std::string::String {
            self.description.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Mutation {
        const NAME: &'static str = "Mutation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    18 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    26 => {
                        self.description = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.name.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
            }
            if let Some(v) = self.description.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.name.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.description.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Mutation {
            Mutation::new()
        }

        fn clear(&mut self) {
            self.id = ::std::option::Option::None;
            self.name = ::std::option::Option::None;
            self.description = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Mutation {
            static instance: Mutation = Mutation {
                id: ::std::option::Option::None,
                name: ::std::option::Option::None,
                description: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgEventTipsSummaryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEventTipsSummaryRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgEventTipsSummaryRequest.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgEventTipsSummaryRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEventTipsSummaryRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEventTipsSummaryRequest {
    fn default() -> &'a CMsgEventTipsSummaryRequest {
        <CMsgEventTipsSummaryRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEventTipsSummaryRequest {
    pub fn new() -> CMsgEventTipsSummaryRequest {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEventTipsSummaryRequest {
    const NAME: &'static str = "CMsgEventTipsSummaryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEventTipsSummaryRequest {
        CMsgEventTipsSummaryRequest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEventTipsSummaryRequest {
        static instance: CMsgEventTipsSummaryRequest = CMsgEventTipsSummaryRequest {
            event_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgEventTipsSummaryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgEventTipsSummaryResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgEventTipsSummaryResponse.result)
    pub result: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgEventTipsSummaryResponse.tips_received)
    pub tips_received: ::std::vec::Vec<cmsg_event_tips_summary_response::Tipper>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgEventTipsSummaryResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgEventTipsSummaryResponse {
    fn default() -> &'a CMsgEventTipsSummaryResponse {
        <CMsgEventTipsSummaryResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgEventTipsSummaryResponse {
    pub fn new() -> CMsgEventTipsSummaryResponse {
        ::std::default::Default::default()
    }

    // optional bool result = 1;

    pub fn result(&self) -> bool {
        self.result.unwrap_or(false)
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: bool) {
        self.result = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgEventTipsSummaryResponse {
    const NAME: &'static str = "CMsgEventTipsSummaryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_bool()?);
                },
                18 => {
                    self.tips_received.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += 1 + 1;
        }
        for value in &self.tips_received {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_bool(1, v)?;
        }
        for v in &self.tips_received {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgEventTipsSummaryResponse {
        CMsgEventTipsSummaryResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.tips_received.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgEventTipsSummaryResponse {
        static instance: CMsgEventTipsSummaryResponse = CMsgEventTipsSummaryResponse {
            result: ::std::option::Option::None,
            tips_received: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgEventTipsSummaryResponse`
pub mod cmsg_event_tips_summary_response {
    // @@protoc_insertion_point(message:CMsgEventTipsSummaryResponse.Tipper)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Tipper {
        // message fields
        // @@protoc_insertion_point(field:CMsgEventTipsSummaryResponse.Tipper.tipper_account_id)
        pub tipper_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgEventTipsSummaryResponse.Tipper.tip_count)
        pub tip_count: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgEventTipsSummaryResponse.Tipper.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Tipper {
        fn default() -> &'a Tipper {
            <Tipper as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Tipper {
        pub fn new() -> Tipper {
            ::std::default::Default::default()
        }

        // optional uint32 tipper_account_id = 1;

        pub fn tipper_account_id(&self) -> u32 {
            self.tipper_account_id.unwrap_or(0)
        }

        pub fn clear_tipper_account_id(&mut self) {
            self.tipper_account_id = ::std::option::Option::None;
        }

        pub fn has_tipper_account_id(&self) -> bool {
            self.tipper_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tipper_account_id(&mut self, v: u32) {
            self.tipper_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 tip_count = 2;

        pub fn tip_count(&self) -> u32 {
            self.tip_count.unwrap_or(1u32)
        }

        pub fn clear_tip_count(&mut self) {
            self.tip_count = ::std::option::Option::None;
        }

        pub fn has_tip_count(&self) -> bool {
            self.tip_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_tip_count(&mut self, v: u32) {
            self.tip_count = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Tipper {
        const NAME: &'static str = "Tipper";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.tipper_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.tip_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.tipper_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.tip_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.tipper_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.tip_count {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Tipper {
            Tipper::new()
        }

        fn clear(&mut self) {
            self.tipper_account_id = ::std::option::Option::None;
            self.tip_count = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Tipper {
            static instance: Tipper = Tipper {
                tipper_account_id: ::std::option::Option::None,
                tip_count: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgSocialFeedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSocialFeedRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSocialFeedRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgSocialFeedRequest.self_only)
    pub self_only: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSocialFeedRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSocialFeedRequest {
    fn default() -> &'a CMsgSocialFeedRequest {
        <CMsgSocialFeedRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSocialFeedRequest {
    pub fn new() -> CMsgSocialFeedRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional bool self_only = 2;

    pub fn self_only(&self) -> bool {
        self.self_only.unwrap_or(false)
    }

    pub fn clear_self_only(&mut self) {
        self.self_only = ::std::option::Option::None;
    }

    pub fn has_self_only(&self) -> bool {
        self.self_only.is_some()
    }

    // Param is passed by value, moved
    pub fn set_self_only(&mut self, v: bool) {
        self.self_only = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSocialFeedRequest {
    const NAME: &'static str = "CMsgSocialFeedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.self_only = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.self_only {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.self_only {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSocialFeedRequest {
        CMsgSocialFeedRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.self_only = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSocialFeedRequest {
        static instance: CMsgSocialFeedRequest = CMsgSocialFeedRequest {
            account_id: ::std::option::Option::None,
            self_only: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSocialFeedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSocialFeedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSocialFeedResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_social_feed_response::Result>>,
    // @@protoc_insertion_point(field:CMsgSocialFeedResponse.feed_events)
    pub feed_events: ::std::vec::Vec<cmsg_social_feed_response::FeedEvent>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSocialFeedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSocialFeedResponse {
    fn default() -> &'a CMsgSocialFeedResponse {
        <CMsgSocialFeedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSocialFeedResponse {
    pub fn new() -> CMsgSocialFeedResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgSocialFeedResponse.Result result = 1;

    pub fn result(&self) -> cmsg_social_feed_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_social_feed_response::Result::SUCCESS),
            None => cmsg_social_feed_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_social_feed_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSocialFeedResponse {
    const NAME: &'static str = "CMsgSocialFeedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.feed_events.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.feed_events {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.feed_events {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSocialFeedResponse {
        CMsgSocialFeedResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.feed_events.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSocialFeedResponse {
        static instance: CMsgSocialFeedResponse = CMsgSocialFeedResponse {
            result: ::std::option::Option::None,
            feed_events: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSocialFeedResponse`
pub mod cmsg_social_feed_response {
    // @@protoc_insertion_point(message:CMsgSocialFeedResponse.FeedEvent)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FeedEvent {
        // message fields
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.feed_event_id)
        pub feed_event_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.comment_count)
        pub comment_count: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.event_type)
        pub event_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.event_sub_type)
        pub event_sub_type: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.param_big_int_1)
        pub param_big_int_1: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.param_int_1)
        pub param_int_1: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.param_int_2)
        pub param_int_2: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.param_int_3)
        pub param_int_3: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedResponse.FeedEvent.param_string)
        pub param_string: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSocialFeedResponse.FeedEvent.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FeedEvent {
        fn default() -> &'a FeedEvent {
            <FeedEvent as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FeedEvent {
        pub fn new() -> FeedEvent {
            ::std::default::Default::default()
        }

        // optional uint64 feed_event_id = 1;

        pub fn feed_event_id(&self) -> u64 {
            self.feed_event_id.unwrap_or(0)
        }

        pub fn clear_feed_event_id(&mut self) {
            self.feed_event_id = ::std::option::Option::None;
        }

        pub fn has_feed_event_id(&self) -> bool {
            self.feed_event_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_feed_event_id(&mut self, v: u64) {
            self.feed_event_id = ::std::option::Option::Some(v);
        }

        // optional uint32 account_id = 2;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 3;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional uint32 comment_count = 4;

        pub fn comment_count(&self) -> u32 {
            self.comment_count.unwrap_or(0)
        }

        pub fn clear_comment_count(&mut self) {
            self.comment_count = ::std::option::Option::None;
        }

        pub fn has_comment_count(&self) -> bool {
            self.comment_count.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment_count(&mut self, v: u32) {
            self.comment_count = ::std::option::Option::Some(v);
        }

        // optional uint32 event_type = 5;

        pub fn event_type(&self) -> u32 {
            self.event_type.unwrap_or(0)
        }

        pub fn clear_event_type(&mut self) {
            self.event_type = ::std::option::Option::None;
        }

        pub fn has_event_type(&self) -> bool {
            self.event_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_type(&mut self, v: u32) {
            self.event_type = ::std::option::Option::Some(v);
        }

        // optional uint32 event_sub_type = 6;

        pub fn event_sub_type(&self) -> u32 {
            self.event_sub_type.unwrap_or(0)
        }

        pub fn clear_event_sub_type(&mut self) {
            self.event_sub_type = ::std::option::Option::None;
        }

        pub fn has_event_sub_type(&self) -> bool {
            self.event_sub_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_event_sub_type(&mut self, v: u32) {
            self.event_sub_type = ::std::option::Option::Some(v);
        }

        // optional uint64 param_big_int_1 = 7;

        pub fn param_big_int_1(&self) -> u64 {
            self.param_big_int_1.unwrap_or(0)
        }

        pub fn clear_param_big_int_1(&mut self) {
            self.param_big_int_1 = ::std::option::Option::None;
        }

        pub fn has_param_big_int_1(&self) -> bool {
            self.param_big_int_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_big_int_1(&mut self, v: u64) {
            self.param_big_int_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 param_int_1 = 8;

        pub fn param_int_1(&self) -> u32 {
            self.param_int_1.unwrap_or(0)
        }

        pub fn clear_param_int_1(&mut self) {
            self.param_int_1 = ::std::option::Option::None;
        }

        pub fn has_param_int_1(&self) -> bool {
            self.param_int_1.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_int_1(&mut self, v: u32) {
            self.param_int_1 = ::std::option::Option::Some(v);
        }

        // optional uint32 param_int_2 = 9;

        pub fn param_int_2(&self) -> u32 {
            self.param_int_2.unwrap_or(0)
        }

        pub fn clear_param_int_2(&mut self) {
            self.param_int_2 = ::std::option::Option::None;
        }

        pub fn has_param_int_2(&self) -> bool {
            self.param_int_2.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_int_2(&mut self, v: u32) {
            self.param_int_2 = ::std::option::Option::Some(v);
        }

        // optional uint32 param_int_3 = 10;

        pub fn param_int_3(&self) -> u32 {
            self.param_int_3.unwrap_or(0)
        }

        pub fn clear_param_int_3(&mut self) {
            self.param_int_3 = ::std::option::Option::None;
        }

        pub fn has_param_int_3(&self) -> bool {
            self.param_int_3.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_int_3(&mut self, v: u32) {
            self.param_int_3 = ::std::option::Option::Some(v);
        }

        // optional string param_string = 11;

        pub fn param_string(&self) -> &str {
            match self.param_string.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_param_string(&mut self) {
            self.param_string = ::std::option::Option::None;
        }

        pub fn has_param_string(&self) -> bool {
            self.param_string.is_some()
        }

        // Param is passed by value, moved
        pub fn set_param_string(&mut self, v: ::std::string::String) {
            self.param_string = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_param_string(&mut self) -> &mut ::std::string::String {
            if self.param_string.is_none() {
                self.param_string = ::std::option::Option::Some(::std::string::String::new());
            }
            self.param_string.as_mut().unwrap()
        }

        // Take field
        pub fn take_param_string(&mut self) -> ::std::string::String {
            self.param_string.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FeedEvent {
        const NAME: &'static str = "FeedEvent";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.feed_event_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.comment_count = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.event_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    48 => {
                        self.event_sub_type = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    56 => {
                        self.param_big_int_1 = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    64 => {
                        self.param_int_1 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    72 => {
                        self.param_int_2 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    80 => {
                        self.param_int_3 = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    90 => {
                        self.param_string = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.feed_event_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.comment_count {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.event_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            if let Some(v) = self.event_sub_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
            }
            if let Some(v) = self.param_big_int_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(7, v);
            }
            if let Some(v) = self.param_int_1 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
            }
            if let Some(v) = self.param_int_2 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
            }
            if let Some(v) = self.param_int_3 {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
            }
            if let Some(v) = self.param_string.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(11, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.feed_event_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.account_id {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.comment_count {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.event_type {
                os.write_uint32(5, v)?;
            }
            if let Some(v) = self.event_sub_type {
                os.write_uint32(6, v)?;
            }
            if let Some(v) = self.param_big_int_1 {
                os.write_uint64(7, v)?;
            }
            if let Some(v) = self.param_int_1 {
                os.write_uint32(8, v)?;
            }
            if let Some(v) = self.param_int_2 {
                os.write_uint32(9, v)?;
            }
            if let Some(v) = self.param_int_3 {
                os.write_uint32(10, v)?;
            }
            if let Some(v) = self.param_string.as_ref() {
                os.write_string(11, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FeedEvent {
            FeedEvent::new()
        }

        fn clear(&mut self) {
            self.feed_event_id = ::std::option::Option::None;
            self.account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.comment_count = ::std::option::Option::None;
            self.event_type = ::std::option::Option::None;
            self.event_sub_type = ::std::option::Option::None;
            self.param_big_int_1 = ::std::option::Option::None;
            self.param_int_1 = ::std::option::Option::None;
            self.param_int_2 = ::std::option::Option::None;
            self.param_int_3 = ::std::option::Option::None;
            self.param_string = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FeedEvent {
            static instance: FeedEvent = FeedEvent {
                feed_event_id: ::std::option::Option::None,
                account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                comment_count: ::std::option::Option::None,
                event_type: ::std::option::Option::None,
                event_sub_type: ::std::option::Option::None,
                param_big_int_1: ::std::option::Option::None,
                param_int_1: ::std::option::Option::None,
                param_int_2: ::std::option::Option::None,
                param_int_3: ::std::option::Option::None,
                param_string: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSocialFeedResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.FAILED_TO_LOAD_FRIENDS)
        FAILED_TO_LOAD_FRIENDS = 1,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.FAILED_TO_LOAD_FEED_DATA)
        FAILED_TO_LOAD_FEED_DATA = 2,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.FAILED_TO_LOAD_FEED_ENTRY)
        FAILED_TO_LOAD_FEED_ENTRY = 3,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.FAILED_TO_LOAD_COMMENTS)
        FAILED_TO_LOAD_COMMENTS = 4,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedResponse.Result.FAILED_TOO_MANY_REQUESTS)
        FAILED_TOO_MANY_REQUESTS = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FRIENDS),
                2 => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FEED_DATA),
                3 => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FEED_ENTRY),
                4 => ::std::option::Option::Some(Result::FAILED_TO_LOAD_COMMENTS),
                5 => ::std::option::Option::Some(Result::FAILED_TOO_MANY_REQUESTS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILED_TO_LOAD_FRIENDS" => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FRIENDS),
                "FAILED_TO_LOAD_FEED_DATA" => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FEED_DATA),
                "FAILED_TO_LOAD_FEED_ENTRY" => ::std::option::Option::Some(Result::FAILED_TO_LOAD_FEED_ENTRY),
                "FAILED_TO_LOAD_COMMENTS" => ::std::option::Option::Some(Result::FAILED_TO_LOAD_COMMENTS),
                "FAILED_TOO_MANY_REQUESTS" => ::std::option::Option::Some(Result::FAILED_TOO_MANY_REQUESTS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILED_TO_LOAD_FRIENDS,
            Result::FAILED_TO_LOAD_FEED_DATA,
            Result::FAILED_TO_LOAD_FEED_ENTRY,
            Result::FAILED_TO_LOAD_COMMENTS,
            Result::FAILED_TOO_MANY_REQUESTS,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgSocialFeedCommentsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSocialFeedCommentsRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgSocialFeedCommentsRequest.feed_event_id)
    pub feed_event_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSocialFeedCommentsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSocialFeedCommentsRequest {
    fn default() -> &'a CMsgSocialFeedCommentsRequest {
        <CMsgSocialFeedCommentsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSocialFeedCommentsRequest {
    pub fn new() -> CMsgSocialFeedCommentsRequest {
        ::std::default::Default::default()
    }

    // optional uint64 feed_event_id = 1;

    pub fn feed_event_id(&self) -> u64 {
        self.feed_event_id.unwrap_or(0)
    }

    pub fn clear_feed_event_id(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
    }

    pub fn has_feed_event_id(&self) -> bool {
        self.feed_event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_feed_event_id(&mut self, v: u64) {
        self.feed_event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSocialFeedCommentsRequest {
    const NAME: &'static str = "CMsgSocialFeedCommentsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.feed_event_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed_event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.feed_event_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSocialFeedCommentsRequest {
        CMsgSocialFeedCommentsRequest::new()
    }

    fn clear(&mut self) {
        self.feed_event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSocialFeedCommentsRequest {
        static instance: CMsgSocialFeedCommentsRequest = CMsgSocialFeedCommentsRequest {
            feed_event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgSocialFeedCommentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgSocialFeedCommentsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgSocialFeedCommentsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_social_feed_comments_response::Result>>,
    // @@protoc_insertion_point(field:CMsgSocialFeedCommentsResponse.feed_comments)
    pub feed_comments: ::std::vec::Vec<cmsg_social_feed_comments_response::FeedComment>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgSocialFeedCommentsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgSocialFeedCommentsResponse {
    fn default() -> &'a CMsgSocialFeedCommentsResponse {
        <CMsgSocialFeedCommentsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgSocialFeedCommentsResponse {
    pub fn new() -> CMsgSocialFeedCommentsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgSocialFeedCommentsResponse.Result result = 1;

    pub fn result(&self) -> cmsg_social_feed_comments_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_social_feed_comments_response::Result::SUCCESS),
            None => cmsg_social_feed_comments_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_social_feed_comments_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgSocialFeedCommentsResponse {
    const NAME: &'static str = "CMsgSocialFeedCommentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    self.feed_comments.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.feed_comments {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.feed_comments {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgSocialFeedCommentsResponse {
        CMsgSocialFeedCommentsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.feed_comments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgSocialFeedCommentsResponse {
        static instance: CMsgSocialFeedCommentsResponse = CMsgSocialFeedCommentsResponse {
            result: ::std::option::Option::None,
            feed_comments: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgSocialFeedCommentsResponse`
pub mod cmsg_social_feed_comments_response {
    // @@protoc_insertion_point(message:CMsgSocialFeedCommentsResponse.FeedComment)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct FeedComment {
        // message fields
        // @@protoc_insertion_point(field:CMsgSocialFeedCommentsResponse.FeedComment.commenter_account_id)
        pub commenter_account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedCommentsResponse.FeedComment.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgSocialFeedCommentsResponse.FeedComment.comment_text)
        pub comment_text: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgSocialFeedCommentsResponse.FeedComment.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a FeedComment {
        fn default() -> &'a FeedComment {
            <FeedComment as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl FeedComment {
        pub fn new() -> FeedComment {
            ::std::default::Default::default()
        }

        // optional uint32 commenter_account_id = 1;

        pub fn commenter_account_id(&self) -> u32 {
            self.commenter_account_id.unwrap_or(0)
        }

        pub fn clear_commenter_account_id(&mut self) {
            self.commenter_account_id = ::std::option::Option::None;
        }

        pub fn has_commenter_account_id(&self) -> bool {
            self.commenter_account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_commenter_account_id(&mut self, v: u32) {
            self.commenter_account_id = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 2;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }

        // optional string comment_text = 3;

        pub fn comment_text(&self) -> &str {
            match self.comment_text.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_comment_text(&mut self) {
            self.comment_text = ::std::option::Option::None;
        }

        pub fn has_comment_text(&self) -> bool {
            self.comment_text.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comment_text(&mut self, v: ::std::string::String) {
            self.comment_text = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_comment_text(&mut self) -> &mut ::std::string::String {
            if self.comment_text.is_none() {
                self.comment_text = ::std::option::Option::Some(::std::string::String::new());
            }
            self.comment_text.as_mut().unwrap()
        }

        // Take field
        pub fn take_comment_text(&mut self) -> ::std::string::String {
            self.comment_text.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for FeedComment {
        const NAME: &'static str = "FeedComment";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.commenter_account_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        self.comment_text = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.commenter_account_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.comment_text.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.commenter_account_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.comment_text.as_ref() {
                os.write_string(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> FeedComment {
            FeedComment::new()
        }

        fn clear(&mut self) {
            self.commenter_account_id = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.comment_text = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static FeedComment {
            static instance: FeedComment = FeedComment {
                commenter_account_id: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                comment_text: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgSocialFeedCommentsResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedCommentsResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedCommentsResponse.Result.FAILED_TOO_MANY_REQUESTS)
        FAILED_TOO_MANY_REQUESTS = 1,
        // @@protoc_insertion_point(enum_value:CMsgSocialFeedCommentsResponse.Result.FAILED_TO_LOAD_COMMENTS)
        FAILED_TO_LOAD_COMMENTS = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILED_TOO_MANY_REQUESTS),
                2 => ::std::option::Option::Some(Result::FAILED_TO_LOAD_COMMENTS),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILED_TOO_MANY_REQUESTS" => ::std::option::Option::Some(Result::FAILED_TOO_MANY_REQUESTS),
                "FAILED_TO_LOAD_COMMENTS" => ::std::option::Option::Some(Result::FAILED_TO_LOAD_COMMENTS),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILED_TOO_MANY_REQUESTS,
            Result::FAILED_TO_LOAD_COMMENTS,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPlayerCardSpecificPurchaseRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerCardSpecificPurchaseRequest.player_account_id)
    pub player_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerCardSpecificPurchaseRequest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerCardSpecificPurchaseRequest.card_dust_item_id)
    pub card_dust_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlayerCardSpecificPurchaseRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    fn default() -> &'a CMsgClientToGCPlayerCardSpecificPurchaseRequest {
        <CMsgClientToGCPlayerCardSpecificPurchaseRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    pub fn new() -> CMsgClientToGCPlayerCardSpecificPurchaseRequest {
        ::std::default::Default::default()
    }

    // optional uint32 player_account_id = 1;

    pub fn player_account_id(&self) -> u32 {
        self.player_account_id.unwrap_or(0)
    }

    pub fn clear_player_account_id(&mut self) {
        self.player_account_id = ::std::option::Option::None;
    }

    pub fn has_player_account_id(&self) -> bool {
        self.player_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_player_account_id(&mut self, v: u32) {
        self.player_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint64 card_dust_item_id = 3;

    pub fn card_dust_item_id(&self) -> u64 {
        self.card_dust_item_id.unwrap_or(0)
    }

    pub fn clear_card_dust_item_id(&mut self) {
        self.card_dust_item_id = ::std::option::Option::None;
    }

    pub fn has_card_dust_item_id(&self) -> bool {
        self.card_dust_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_card_dust_item_id(&mut self, v: u64) {
        self.card_dust_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    const NAME: &'static str = "CMsgClientToGCPlayerCardSpecificPurchaseRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.player_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.card_dust_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.player_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.card_dust_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.player_account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.card_dust_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlayerCardSpecificPurchaseRequest {
        CMsgClientToGCPlayerCardSpecificPurchaseRequest::new()
    }

    fn clear(&mut self) {
        self.player_account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.card_dust_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlayerCardSpecificPurchaseRequest {
        static instance: CMsgClientToGCPlayerCardSpecificPurchaseRequest = CMsgClientToGCPlayerCardSpecificPurchaseRequest {
            player_account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            card_dust_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPlayerCardSpecificPurchaseResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerCardSpecificPurchaseResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcplayer_card_specific_purchase_response::Result>>,
    // @@protoc_insertion_point(field:CMsgClientToGCPlayerCardSpecificPurchaseResponse.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlayerCardSpecificPurchaseResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    fn default() -> &'a CMsgClientToGCPlayerCardSpecificPurchaseResponse {
        <CMsgClientToGCPlayerCardSpecificPurchaseResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    pub fn new() -> CMsgClientToGCPlayerCardSpecificPurchaseResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result result = 1;

    pub fn result(&self) -> cmsg_client_to_gcplayer_card_specific_purchase_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcplayer_card_specific_purchase_response::Result::SUCCESS),
            None => cmsg_client_to_gcplayer_card_specific_purchase_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcplayer_card_specific_purchase_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 item_id = 2;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    const NAME: &'static str = "CMsgClientToGCPlayerCardSpecificPurchaseResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.item_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlayerCardSpecificPurchaseResponse {
        CMsgClientToGCPlayerCardSpecificPurchaseResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlayerCardSpecificPurchaseResponse {
        static instance: CMsgClientToGCPlayerCardSpecificPurchaseResponse = CMsgClientToGCPlayerCardSpecificPurchaseResponse {
            result: ::std::option::Option::None,
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPlayerCardSpecificPurchaseResponse`
pub mod cmsg_client_to_gcplayer_card_specific_purchase_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.SUCCESS)
        SUCCESS = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.ERROR_INTERNAL)
        ERROR_INTERNAL = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.ERROR_INSUFFICIENT_DUST)
        ERROR_INSUFFICIENT_DUST = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.ERROR_ITEM_NOT_DUST_ITEM)
        ERROR_ITEM_NOT_DUST_ITEM = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.ERROR_FAILED_CARD_PACK_CREATE)
        ERROR_FAILED_CARD_PACK_CREATE = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlayerCardSpecificPurchaseResponse.Result.ERROR_NOT_AVAILABLE)
        ERROR_NOT_AVAILABLE = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                1 => ::std::option::Option::Some(Result::SUCCESS),
                2 => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                3 => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                4 => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                5 => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                6 => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "ERROR_INTERNAL" => ::std::option::Option::Some(Result::ERROR_INTERNAL),
                "ERROR_INSUFFICIENT_DUST" => ::std::option::Option::Some(Result::ERROR_INSUFFICIENT_DUST),
                "ERROR_ITEM_NOT_DUST_ITEM" => ::std::option::Option::Some(Result::ERROR_ITEM_NOT_DUST_ITEM),
                "ERROR_FAILED_CARD_PACK_CREATE" => ::std::option::Option::Some(Result::ERROR_FAILED_CARD_PACK_CREATE),
                "ERROR_NOT_AVAILABLE" => ::std::option::Option::Some(Result::ERROR_NOT_AVAILABLE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::ERROR_INTERNAL,
            Result::ERROR_INSUFFICIENT_DUST,
            Result::ERROR_ITEM_NOT_DUST_ITEM,
            Result::ERROR_FAILED_CARD_PACK_CREATE,
            Result::ERROR_NOT_AVAILABLE,
        ];
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestContestVotes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestContestVotes {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestContestVotes.contest_id)
    pub contest_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestContestVotes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestContestVotes {
    fn default() -> &'a CMsgClientToGCRequestContestVotes {
        <CMsgClientToGCRequestContestVotes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestContestVotes {
    pub fn new() -> CMsgClientToGCRequestContestVotes {
        ::std::default::Default::default()
    }

    // optional uint32 contest_id = 1;

    pub fn contest_id(&self) -> u32 {
        self.contest_id.unwrap_or(0)
    }

    pub fn clear_contest_id(&mut self) {
        self.contest_id = ::std::option::Option::None;
    }

    pub fn has_contest_id(&self) -> bool {
        self.contest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contest_id(&mut self, v: u32) {
        self.contest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestContestVotes {
    const NAME: &'static str = "CMsgClientToGCRequestContestVotes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contest_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestContestVotes {
        CMsgClientToGCRequestContestVotes::new()
    }

    fn clear(&mut self) {
        self.contest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestContestVotes {
        static instance: CMsgClientToGCRequestContestVotes = CMsgClientToGCRequestContestVotes {
            contest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestContestVotesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestContestVotesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestContestVotesResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_contest_votes_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestContestVotesResponse.votes)
    pub votes: ::std::vec::Vec<cmsg_client_to_gcrequest_contest_votes_response::ItemVote>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestContestVotesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestContestVotesResponse {
    fn default() -> &'a CMsgClientToGCRequestContestVotesResponse {
        <CMsgClientToGCRequestContestVotesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestContestVotesResponse {
    pub fn new() -> CMsgClientToGCRequestContestVotesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestContestVotesResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_contest_votes_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_contest_votes_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_contest_votes_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_contest_votes_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestContestVotesResponse {
    const NAME: &'static str = "CMsgClientToGCRequestContestVotesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.votes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.votes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestContestVotesResponse {
        CMsgClientToGCRequestContestVotesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestContestVotesResponse {
        static instance: CMsgClientToGCRequestContestVotesResponse = CMsgClientToGCRequestContestVotesResponse {
            result: ::std::option::Option::None,
            votes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestContestVotesResponse`
pub mod cmsg_client_to_gcrequest_contest_votes_response {
    // @@protoc_insertion_point(message:CMsgClientToGCRequestContestVotesResponse.ItemVote)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ItemVote {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCRequestContestVotesResponse.ItemVote.contest_item_id)
        pub contest_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestContestVotesResponse.ItemVote.vote)
        pub vote: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCRequestContestVotesResponse.ItemVote.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ItemVote {
        fn default() -> &'a ItemVote {
            <ItemVote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ItemVote {
        pub fn new() -> ItemVote {
            ::std::default::Default::default()
        }

        // optional uint64 contest_item_id = 1;

        pub fn contest_item_id(&self) -> u64 {
            self.contest_item_id.unwrap_or(0)
        }

        pub fn clear_contest_item_id(&mut self) {
            self.contest_item_id = ::std::option::Option::None;
        }

        pub fn has_contest_item_id(&self) -> bool {
            self.contest_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_contest_item_id(&mut self, v: u64) {
            self.contest_item_id = ::std::option::Option::Some(v);
        }

        // optional int32 vote = 2;

        pub fn vote(&self) -> i32 {
            self.vote.unwrap_or(0)
        }

        pub fn clear_vote(&mut self) {
            self.vote = ::std::option::Option::None;
        }

        pub fn has_vote(&self) -> bool {
            self.vote.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote(&mut self, v: i32) {
            self.vote = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ItemVote {
        const NAME: &'static str = "ItemVote";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.contest_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.vote = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.contest_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.vote {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.contest_item_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.vote {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ItemVote {
            ItemVote::new()
        }

        fn clear(&mut self) {
            self.contest_item_id = ::std::option::Option::None;
            self.vote = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ItemVote {
            static instance: ItemVote = ItemVote {
                contest_item_id: ::std::option::Option::None,
                vote: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestContestVotesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestContestVotesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestContestVotesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestContestVotesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestContestVotesResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRecordContestVote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRecordContestVote {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRecordContestVote.contest_id)
    pub contest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRecordContestVote.contest_item_id)
    pub contest_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCRecordContestVote.vote)
    pub vote: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRecordContestVote.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRecordContestVote {
    fn default() -> &'a CMsgClientToGCRecordContestVote {
        <CMsgClientToGCRecordContestVote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRecordContestVote {
    pub fn new() -> CMsgClientToGCRecordContestVote {
        ::std::default::Default::default()
    }

    // optional uint32 contest_id = 1;

    pub fn contest_id(&self) -> u32 {
        self.contest_id.unwrap_or(0)
    }

    pub fn clear_contest_id(&mut self) {
        self.contest_id = ::std::option::Option::None;
    }

    pub fn has_contest_id(&self) -> bool {
        self.contest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contest_id(&mut self, v: u32) {
        self.contest_id = ::std::option::Option::Some(v);
    }

    // optional uint64 contest_item_id = 2;

    pub fn contest_item_id(&self) -> u64 {
        self.contest_item_id.unwrap_or(0)
    }

    pub fn clear_contest_item_id(&mut self) {
        self.contest_item_id = ::std::option::Option::None;
    }

    pub fn has_contest_item_id(&self) -> bool {
        self.contest_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contest_item_id(&mut self, v: u64) {
        self.contest_item_id = ::std::option::Option::Some(v);
    }

    // optional int32 vote = 3;

    pub fn vote(&self) -> i32 {
        self.vote.unwrap_or(0)
    }

    pub fn clear_vote(&mut self) {
        self.vote = ::std::option::Option::None;
    }

    pub fn has_vote(&self) -> bool {
        self.vote.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vote(&mut self, v: i32) {
        self.vote = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRecordContestVote {
    const NAME: &'static str = "CMsgClientToGCRecordContestVote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.contest_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.vote = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.contest_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.vote {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.contest_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.vote {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRecordContestVote {
        CMsgClientToGCRecordContestVote::new()
    }

    fn clear(&mut self) {
        self.contest_id = ::std::option::Option::None;
        self.contest_item_id = ::std::option::Option::None;
        self.vote = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRecordContestVote {
        static instance: CMsgClientToGCRecordContestVote = CMsgClientToGCRecordContestVote {
            contest_id: ::std::option::Option::None,
            contest_item_id: ::std::option::Option::None,
            vote: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRecordContestVoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRecordContestVoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRecordContestVoteResponse.eresult)
    pub eresult: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_record_contest_vote_response::EResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRecordContestVoteResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRecordContestVoteResponse {
    fn default() -> &'a CMsgGCToClientRecordContestVoteResponse {
        <CMsgGCToClientRecordContestVoteResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRecordContestVoteResponse {
    pub fn new() -> CMsgGCToClientRecordContestVoteResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientRecordContestVoteResponse.EResult eresult = 1;

    pub fn eresult(&self) -> cmsg_gcto_client_record_contest_vote_response::EResult {
        match self.eresult {
            Some(e) => e.enum_value_or(cmsg_gcto_client_record_contest_vote_response::EResult::SUCCESS),
            None => cmsg_gcto_client_record_contest_vote_response::EResult::SUCCESS,
        }
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: cmsg_gcto_client_record_contest_vote_response::EResult) {
        self.eresult = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRecordContestVoteResponse {
    const NAME: &'static str = "CMsgGCToClientRecordContestVoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRecordContestVoteResponse {
        CMsgGCToClientRecordContestVoteResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRecordContestVoteResponse {
        static instance: CMsgGCToClientRecordContestVoteResponse = CMsgGCToClientRecordContestVoteResponse {
            eresult: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientRecordContestVoteResponse`
pub mod cmsg_gcto_client_record_contest_vote_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientRecordContestVoteResponse.EResult)
    pub enum EResult {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.FAILED_EVENT_NOT_OWNED)
        FAILED_EVENT_NOT_OWNED = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.FAILED_SQL_INSERT_FAILED)
        FAILED_SQL_INSERT_FAILED = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.FAILED_INVALID_CONTEST)
        FAILED_INVALID_CONTEST = 3,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.FAILED_CONTEST_NOT_ACTIVE)
        FAILED_CONTEST_NOT_ACTIVE = 4,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRecordContestVoteResponse.EResult.FAILED_TIMEOUT)
        FAILED_TIMEOUT = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResult {
        const NAME: &'static str = "EResult";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResult> {
            match value {
                0 => ::std::option::Option::Some(EResult::SUCCESS),
                1 => ::std::option::Option::Some(EResult::FAILED_EVENT_NOT_OWNED),
                2 => ::std::option::Option::Some(EResult::FAILED_SQL_INSERT_FAILED),
                3 => ::std::option::Option::Some(EResult::FAILED_INVALID_CONTEST),
                4 => ::std::option::Option::Some(EResult::FAILED_CONTEST_NOT_ACTIVE),
                5 => ::std::option::Option::Some(EResult::FAILED_TIMEOUT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResult> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResult::SUCCESS),
                "FAILED_EVENT_NOT_OWNED" => ::std::option::Option::Some(EResult::FAILED_EVENT_NOT_OWNED),
                "FAILED_SQL_INSERT_FAILED" => ::std::option::Option::Some(EResult::FAILED_SQL_INSERT_FAILED),
                "FAILED_INVALID_CONTEST" => ::std::option::Option::Some(EResult::FAILED_INVALID_CONTEST),
                "FAILED_CONTEST_NOT_ACTIVE" => ::std::option::Option::Some(EResult::FAILED_CONTEST_NOT_ACTIVE),
                "FAILED_TIMEOUT" => ::std::option::Option::Some(EResult::FAILED_TIMEOUT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResult] = &[
            EResult::SUCCESS,
            EResult::FAILED_EVENT_NOT_OWNED,
            EResult::FAILED_SQL_INSERT_FAILED,
            EResult::FAILED_INVALID_CONTEST,
            EResult::FAILED_CONTEST_NOT_ACTIVE,
            EResult::FAILED_TIMEOUT,
        ];
    }

    impl ::std::default::Default for EResult {
        fn default() -> Self {
            EResult::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgDevGrantEventPoints)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevGrantEventPoints {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevGrantEventPoints.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDevGrantEventPoints.event_points)
    pub event_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDevGrantEventPoints.premium_points)
    pub premium_points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevGrantEventPoints.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevGrantEventPoints {
    fn default() -> &'a CMsgDevGrantEventPoints {
        <CMsgDevGrantEventPoints as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevGrantEventPoints {
    pub fn new() -> CMsgDevGrantEventPoints {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_points = 2;

    pub fn event_points(&self) -> u32 {
        self.event_points.unwrap_or(0)
    }

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: u32) {
        self.event_points = ::std::option::Option::Some(v);
    }

    // optional uint32 premium_points = 3;

    pub fn premium_points(&self) -> u32 {
        self.premium_points.unwrap_or(0)
    }

    pub fn clear_premium_points(&mut self) {
        self.premium_points = ::std::option::Option::None;
    }

    pub fn has_premium_points(&self) -> bool {
        self.premium_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_premium_points(&mut self, v: u32) {
        self.premium_points = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevGrantEventPoints {
    const NAME: &'static str = "CMsgDevGrantEventPoints";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.premium_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.premium_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_points {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.premium_points {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevGrantEventPoints {
        CMsgDevGrantEventPoints::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.event_points = ::std::option::Option::None;
        self.premium_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevGrantEventPoints {
        static instance: CMsgDevGrantEventPoints = CMsgDevGrantEventPoints {
            event_id: ::std::option::Option::None,
            event_points: ::std::option::Option::None,
            premium_points: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevGrantEventPointsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevGrantEventPointsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevGrantEventPointsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDevEventRequestResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevGrantEventPointsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevGrantEventPointsResponse {
    fn default() -> &'a CMsgDevGrantEventPointsResponse {
        <CMsgDevGrantEventPointsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevGrantEventPointsResponse {
    pub fn new() -> CMsgDevGrantEventPointsResponse {
        ::std::default::Default::default()
    }

    // optional .EDevEventRequestResult result = 1;

    pub fn result(&self) -> EDevEventRequestResult {
        match self.result {
            Some(e) => e.enum_value_or(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            None => EDevEventRequestResult::k_EDevEventRequestResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDevEventRequestResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevGrantEventPointsResponse {
    const NAME: &'static str = "CMsgDevGrantEventPointsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevGrantEventPointsResponse {
        CMsgDevGrantEventPointsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevGrantEventPointsResponse {
        static instance: CMsgDevGrantEventPointsResponse = CMsgDevGrantEventPointsResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevGrantEventAction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevGrantEventAction {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevGrantEventAction.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDevGrantEventAction.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDevGrantEventAction.action_score)
    pub action_score: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevGrantEventAction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevGrantEventAction {
    fn default() -> &'a CMsgDevGrantEventAction {
        <CMsgDevGrantEventAction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevGrantEventAction {
    pub fn new() -> CMsgDevGrantEventAction {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_score = 3;

    pub fn action_score(&self) -> u32 {
        self.action_score.unwrap_or(0)
    }

    pub fn clear_action_score(&mut self) {
        self.action_score = ::std::option::Option::None;
    }

    pub fn has_action_score(&self) -> bool {
        self.action_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_score(&mut self, v: u32) {
        self.action_score = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevGrantEventAction {
    const NAME: &'static str = "CMsgDevGrantEventAction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.action_score = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.action_score {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.action_score {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevGrantEventAction {
        CMsgDevGrantEventAction::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.action_score = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevGrantEventAction {
        static instance: CMsgDevGrantEventAction = CMsgDevGrantEventAction {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            action_score: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevGrantEventActionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevGrantEventActionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevGrantEventActionResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDevEventRequestResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevGrantEventActionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevGrantEventActionResponse {
    fn default() -> &'a CMsgDevGrantEventActionResponse {
        <CMsgDevGrantEventActionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevGrantEventActionResponse {
    pub fn new() -> CMsgDevGrantEventActionResponse {
        ::std::default::Default::default()
    }

    // optional .EDevEventRequestResult result = 1;

    pub fn result(&self) -> EDevEventRequestResult {
        match self.result {
            Some(e) => e.enum_value_or(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            None => EDevEventRequestResult::k_EDevEventRequestResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDevEventRequestResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevGrantEventActionResponse {
    const NAME: &'static str = "CMsgDevGrantEventActionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevGrantEventActionResponse {
        CMsgDevGrantEventActionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevGrantEventActionResponse {
        static instance: CMsgDevGrantEventActionResponse = CMsgDevGrantEventActionResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevDeleteEventActions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevDeleteEventActions {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevDeleteEventActions.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDevDeleteEventActions.start_action_id)
    pub start_action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDevDeleteEventActions.end_action_id)
    pub end_action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDevDeleteEventActions.remove_audit)
    pub remove_audit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevDeleteEventActions.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevDeleteEventActions {
    fn default() -> &'a CMsgDevDeleteEventActions {
        <CMsgDevDeleteEventActions as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevDeleteEventActions {
    pub fn new() -> CMsgDevDeleteEventActions {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 start_action_id = 2;

    pub fn start_action_id(&self) -> u32 {
        self.start_action_id.unwrap_or(0)
    }

    pub fn clear_start_action_id(&mut self) {
        self.start_action_id = ::std::option::Option::None;
    }

    pub fn has_start_action_id(&self) -> bool {
        self.start_action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_action_id(&mut self, v: u32) {
        self.start_action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 end_action_id = 3;

    pub fn end_action_id(&self) -> u32 {
        self.end_action_id.unwrap_or(0)
    }

    pub fn clear_end_action_id(&mut self) {
        self.end_action_id = ::std::option::Option::None;
    }

    pub fn has_end_action_id(&self) -> bool {
        self.end_action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_action_id(&mut self, v: u32) {
        self.end_action_id = ::std::option::Option::Some(v);
    }

    // optional bool remove_audit = 4;

    pub fn remove_audit(&self) -> bool {
        self.remove_audit.unwrap_or(false)
    }

    pub fn clear_remove_audit(&mut self) {
        self.remove_audit = ::std::option::Option::None;
    }

    pub fn has_remove_audit(&self) -> bool {
        self.remove_audit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_audit(&mut self, v: bool) {
        self.remove_audit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevDeleteEventActions {
    const NAME: &'static str = "CMsgDevDeleteEventActions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.start_action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.end_action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.remove_audit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.start_action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.end_action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.remove_audit {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.start_action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_action_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.remove_audit {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevDeleteEventActions {
        CMsgDevDeleteEventActions::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.start_action_id = ::std::option::Option::None;
        self.end_action_id = ::std::option::Option::None;
        self.remove_audit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevDeleteEventActions {
        static instance: CMsgDevDeleteEventActions = CMsgDevDeleteEventActions {
            event_id: ::std::option::Option::None,
            start_action_id: ::std::option::Option::None,
            end_action_id: ::std::option::Option::None,
            remove_audit: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevDeleteEventActionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevDeleteEventActionsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevDeleteEventActionsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDevEventRequestResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevDeleteEventActionsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevDeleteEventActionsResponse {
    fn default() -> &'a CMsgDevDeleteEventActionsResponse {
        <CMsgDevDeleteEventActionsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevDeleteEventActionsResponse {
    pub fn new() -> CMsgDevDeleteEventActionsResponse {
        ::std::default::Default::default()
    }

    // optional .EDevEventRequestResult result = 1;

    pub fn result(&self) -> EDevEventRequestResult {
        match self.result {
            Some(e) => e.enum_value_or(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            None => EDevEventRequestResult::k_EDevEventRequestResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDevEventRequestResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevDeleteEventActionsResponse {
    const NAME: &'static str = "CMsgDevDeleteEventActionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevDeleteEventActionsResponse {
        CMsgDevDeleteEventActionsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevDeleteEventActionsResponse {
        static instance: CMsgDevDeleteEventActionsResponse = CMsgDevDeleteEventActionsResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevResetEventState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevResetEventState {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevResetEventState.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgDevResetEventState.remove_audit)
    pub remove_audit: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevResetEventState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevResetEventState {
    fn default() -> &'a CMsgDevResetEventState {
        <CMsgDevResetEventState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevResetEventState {
    pub fn new() -> CMsgDevResetEventState {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool remove_audit = 2;

    pub fn remove_audit(&self) -> bool {
        self.remove_audit.unwrap_or(false)
    }

    pub fn clear_remove_audit(&mut self) {
        self.remove_audit = ::std::option::Option::None;
    }

    pub fn has_remove_audit(&self) -> bool {
        self.remove_audit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remove_audit(&mut self, v: bool) {
        self.remove_audit = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevResetEventState {
    const NAME: &'static str = "CMsgDevResetEventState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.remove_audit = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.remove_audit {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.remove_audit {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevResetEventState {
        CMsgDevResetEventState::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.remove_audit = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevResetEventState {
        static instance: CMsgDevResetEventState = CMsgDevResetEventState {
            event_id: ::std::option::Option::None,
            remove_audit: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDevResetEventStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDevResetEventStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgDevResetEventStateResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDevEventRequestResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDevResetEventStateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDevResetEventStateResponse {
    fn default() -> &'a CMsgDevResetEventStateResponse {
        <CMsgDevResetEventStateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDevResetEventStateResponse {
    pub fn new() -> CMsgDevResetEventStateResponse {
        ::std::default::Default::default()
    }

    // optional .EDevEventRequestResult result = 1;

    pub fn result(&self) -> EDevEventRequestResult {
        match self.result {
            Some(e) => e.enum_value_or(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            None => EDevEventRequestResult::k_EDevEventRequestResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDevEventRequestResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDevResetEventStateResponse {
    const NAME: &'static str = "CMsgDevResetEventStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDevResetEventStateResponse {
        CMsgDevResetEventStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDevResetEventStateResponse {
        static instance: CMsgDevResetEventStateResponse = CMsgDevResetEventStateResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConsumeEventSupportGrantItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumeEventSupportGrantItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumeEventSupportGrantItem.item_id)
    pub item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumeEventSupportGrantItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumeEventSupportGrantItem {
    fn default() -> &'a CMsgConsumeEventSupportGrantItem {
        <CMsgConsumeEventSupportGrantItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumeEventSupportGrantItem {
    pub fn new() -> CMsgConsumeEventSupportGrantItem {
        ::std::default::Default::default()
    }

    // optional uint64 item_id = 1;

    pub fn item_id(&self) -> u64 {
        self.item_id.unwrap_or(0)
    }

    pub fn clear_item_id(&mut self) {
        self.item_id = ::std::option::Option::None;
    }

    pub fn has_item_id(&self) -> bool {
        self.item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_id(&mut self, v: u64) {
        self.item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConsumeEventSupportGrantItem {
    const NAME: &'static str = "CMsgConsumeEventSupportGrantItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.item_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumeEventSupportGrantItem {
        CMsgConsumeEventSupportGrantItem::new()
    }

    fn clear(&mut self) {
        self.item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumeEventSupportGrantItem {
        static instance: CMsgConsumeEventSupportGrantItem = CMsgConsumeEventSupportGrantItem {
            item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgConsumeEventSupportGrantItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgConsumeEventSupportGrantItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgConsumeEventSupportGrantItemResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<ESupportEventRequestResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgConsumeEventSupportGrantItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgConsumeEventSupportGrantItemResponse {
    fn default() -> &'a CMsgConsumeEventSupportGrantItemResponse {
        <CMsgConsumeEventSupportGrantItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgConsumeEventSupportGrantItemResponse {
    pub fn new() -> CMsgConsumeEventSupportGrantItemResponse {
        ::std::default::Default::default()
    }

    // optional .ESupportEventRequestResult result = 1;

    pub fn result(&self) -> ESupportEventRequestResult {
        match self.result {
            Some(e) => e.enum_value_or(ESupportEventRequestResult::k_ESupportEventRequestResult_Success),
            None => ESupportEventRequestResult::k_ESupportEventRequestResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ESupportEventRequestResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgConsumeEventSupportGrantItemResponse {
    const NAME: &'static str = "CMsgConsumeEventSupportGrantItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgConsumeEventSupportGrantItemResponse {
        CMsgConsumeEventSupportGrantItemResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgConsumeEventSupportGrantItemResponse {
        static instance: CMsgConsumeEventSupportGrantItemResponse = CMsgConsumeEventSupportGrantItemResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetFilteredPlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetFilteredPlayers {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetFilteredPlayers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetFilteredPlayers {
    fn default() -> &'a CMsgClientToGCGetFilteredPlayers {
        <CMsgClientToGCGetFilteredPlayers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetFilteredPlayers {
    pub fn new() -> CMsgClientToGCGetFilteredPlayers {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetFilteredPlayers {
    const NAME: &'static str = "CMsgClientToGCGetFilteredPlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetFilteredPlayers {
        CMsgClientToGCGetFilteredPlayers::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetFilteredPlayers {
        static instance: CMsgClientToGCGetFilteredPlayers = CMsgClientToGCGetFilteredPlayers {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientGetFilteredPlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGetFilteredPlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_get_filtered_players_response::Result>>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.filtered_players)
    pub filtered_players: ::std::vec::Vec<cmsg_gcto_client_get_filtered_players_response::CFilterEntry>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.base_slots)
    pub base_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.additional_slots)
    pub additional_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.next_slot_cost)
    pub next_slot_cost: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGetFilteredPlayersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGetFilteredPlayersResponse {
    fn default() -> &'a CMsgGCToClientGetFilteredPlayersResponse {
        <CMsgGCToClientGetFilteredPlayersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGetFilteredPlayersResponse {
    pub fn new() -> CMsgGCToClientGetFilteredPlayersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientGetFilteredPlayersResponse.Result result = 1;

    pub fn result(&self) -> cmsg_gcto_client_get_filtered_players_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcto_client_get_filtered_players_response::Result::SUCCESS),
            None => cmsg_gcto_client_get_filtered_players_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcto_client_get_filtered_players_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 base_slots = 3;

    pub fn base_slots(&self) -> i32 {
        self.base_slots.unwrap_or(0)
    }

    pub fn clear_base_slots(&mut self) {
        self.base_slots = ::std::option::Option::None;
    }

    pub fn has_base_slots(&self) -> bool {
        self.base_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_base_slots(&mut self, v: i32) {
        self.base_slots = ::std::option::Option::Some(v);
    }

    // optional int32 additional_slots = 4;

    pub fn additional_slots(&self) -> i32 {
        self.additional_slots.unwrap_or(0)
    }

    pub fn clear_additional_slots(&mut self) {
        self.additional_slots = ::std::option::Option::None;
    }

    pub fn has_additional_slots(&self) -> bool {
        self.additional_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_slots(&mut self, v: i32) {
        self.additional_slots = ::std::option::Option::Some(v);
    }

    // optional int32 next_slot_cost = 5;

    pub fn next_slot_cost(&self) -> i32 {
        self.next_slot_cost.unwrap_or(0)
    }

    pub fn clear_next_slot_cost(&mut self) {
        self.next_slot_cost = ::std::option::Option::None;
    }

    pub fn has_next_slot_cost(&self) -> bool {
        self.next_slot_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_slot_cost(&mut self, v: i32) {
        self.next_slot_cost = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGetFilteredPlayersResponse {
    const NAME: &'static str = "CMsgGCToClientGetFilteredPlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.filtered_players.push(is.read_message()?);
                },
                24 => {
                    self.base_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.additional_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                40 => {
                    self.next_slot_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.filtered_players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.base_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.additional_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        if let Some(v) = self.next_slot_cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.filtered_players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.base_slots {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.additional_slots {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.next_slot_cost {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGetFilteredPlayersResponse {
        CMsgGCToClientGetFilteredPlayersResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.filtered_players.clear();
        self.base_slots = ::std::option::Option::None;
        self.additional_slots = ::std::option::Option::None;
        self.next_slot_cost = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGetFilteredPlayersResponse {
        static instance: CMsgGCToClientGetFilteredPlayersResponse = CMsgGCToClientGetFilteredPlayersResponse {
            result: ::std::option::Option::None,
            filtered_players: ::std::vec::Vec::new(),
            base_slots: ::std::option::Option::None,
            additional_slots: ::std::option::Option::None,
            next_slot_cost: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientGetFilteredPlayersResponse`
pub mod cmsg_gcto_client_get_filtered_players_response {
    // @@protoc_insertion_point(message:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct CFilterEntry {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry.account_id)
        pub account_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry.time_added)
        pub time_added: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry.time_expires)
        pub time_expires: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry.note)
        pub note: ::std::option::Option<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientGetFilteredPlayersResponse.CFilterEntry.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a CFilterEntry {
        fn default() -> &'a CFilterEntry {
            <CFilterEntry as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl CFilterEntry {
        pub fn new() -> CFilterEntry {
            ::std::default::Default::default()
        }

        // optional fixed32 account_id = 1;

        pub fn account_id(&self) -> u32 {
            self.account_id.unwrap_or(0)
        }

        pub fn clear_account_id(&mut self) {
            self.account_id = ::std::option::Option::None;
        }

        pub fn has_account_id(&self) -> bool {
            self.account_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_account_id(&mut self, v: u32) {
            self.account_id = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_added = 2;

        pub fn time_added(&self) -> u32 {
            self.time_added.unwrap_or(0)
        }

        pub fn clear_time_added(&mut self) {
            self.time_added = ::std::option::Option::None;
        }

        pub fn has_time_added(&self) -> bool {
            self.time_added.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_added(&mut self, v: u32) {
            self.time_added = ::std::option::Option::Some(v);
        }

        // optional fixed32 time_expires = 3;

        pub fn time_expires(&self) -> u32 {
            self.time_expires.unwrap_or(0)
        }

        pub fn clear_time_expires(&mut self) {
            self.time_expires = ::std::option::Option::None;
        }

        pub fn has_time_expires(&self) -> bool {
            self.time_expires.is_some()
        }

        // Param is passed by value, moved
        pub fn set_time_expires(&mut self, v: u32) {
            self.time_expires = ::std::option::Option::Some(v);
        }

        // optional string note = 4;

        pub fn note(&self) -> &str {
            match self.note.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_note(&mut self) {
            self.note = ::std::option::Option::None;
        }

        pub fn has_note(&self) -> bool {
            self.note.is_some()
        }

        // Param is passed by value, moved
        pub fn set_note(&mut self, v: ::std::string::String) {
            self.note = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_note(&mut self) -> &mut ::std::string::String {
            if self.note.is_none() {
                self.note = ::std::option::Option::Some(::std::string::String::new());
            }
            self.note.as_mut().unwrap()
        }

        // Take field
        pub fn take_note(&mut self) -> ::std::string::String {
            self.note.take().unwrap_or_else(|| ::std::string::String::new())
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for CFilterEntry {
        const NAME: &'static str = "CFilterEntry";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    13 => {
                        self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    21 => {
                        self.time_added = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    29 => {
                        self.time_expires = ::std::option::Option::Some(is.read_fixed32()?);
                    },
                    34 => {
                        self.note = ::std::option::Option::Some(is.read_string()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.account_id {
                my_size += 1 + 4;
            }
            if let Some(v) = self.time_added {
                my_size += 1 + 4;
            }
            if let Some(v) = self.time_expires {
                my_size += 1 + 4;
            }
            if let Some(v) = self.note.as_ref() {
                my_size += ::steam_vent_proto_common::protobuf::rt::string_size(4, &v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.account_id {
                os.write_fixed32(1, v)?;
            }
            if let Some(v) = self.time_added {
                os.write_fixed32(2, v)?;
            }
            if let Some(v) = self.time_expires {
                os.write_fixed32(3, v)?;
            }
            if let Some(v) = self.note.as_ref() {
                os.write_string(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> CFilterEntry {
            CFilterEntry::new()
        }

        fn clear(&mut self) {
            self.account_id = ::std::option::Option::None;
            self.time_added = ::std::option::Option::None;
            self.time_expires = ::std::option::Option::None;
            self.note = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static CFilterEntry {
            static instance: CFilterEntry = CFilterEntry {
                account_id: ::std::option::Option::None,
                time_added: ::std::option::Option::None,
                time_expires: ::std::option::Option::None,
                note: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientGetFilteredPlayersResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientGetFilteredPlayersResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientGetFilteredPlayersResponse.Result.FAILURE)
        FAILURE = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(Result::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILURE,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRemoveFilteredPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRemoveFilteredPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRemoveFilteredPlayer.account_id_to_remove)
    pub account_id_to_remove: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRemoveFilteredPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRemoveFilteredPlayer {
    fn default() -> &'a CMsgClientToGCRemoveFilteredPlayer {
        <CMsgClientToGCRemoveFilteredPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRemoveFilteredPlayer {
    pub fn new() -> CMsgClientToGCRemoveFilteredPlayer {
        ::std::default::Default::default()
    }

    // optional fixed32 account_id_to_remove = 1;

    pub fn account_id_to_remove(&self) -> u32 {
        self.account_id_to_remove.unwrap_or(0)
    }

    pub fn clear_account_id_to_remove(&mut self) {
        self.account_id_to_remove = ::std::option::Option::None;
    }

    pub fn has_account_id_to_remove(&self) -> bool {
        self.account_id_to_remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id_to_remove(&mut self, v: u32) {
        self.account_id_to_remove = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRemoveFilteredPlayer {
    const NAME: &'static str = "CMsgClientToGCRemoveFilteredPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.account_id_to_remove = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id_to_remove {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id_to_remove {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRemoveFilteredPlayer {
        CMsgClientToGCRemoveFilteredPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id_to_remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRemoveFilteredPlayer {
        static instance: CMsgClientToGCRemoveFilteredPlayer = CMsgClientToGCRemoveFilteredPlayer {
            account_id_to_remove: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRemoveFilteredPlayerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRemoveFilteredPlayerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRemoveFilteredPlayerResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_remove_filtered_player_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRemoveFilteredPlayerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRemoveFilteredPlayerResponse {
    fn default() -> &'a CMsgGCToClientRemoveFilteredPlayerResponse {
        <CMsgGCToClientRemoveFilteredPlayerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRemoveFilteredPlayerResponse {
    pub fn new() -> CMsgGCToClientRemoveFilteredPlayerResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientRemoveFilteredPlayerResponse.Result result = 1;

    pub fn result(&self) -> cmsg_gcto_client_remove_filtered_player_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcto_client_remove_filtered_player_response::Result::SUCCESS),
            None => cmsg_gcto_client_remove_filtered_player_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcto_client_remove_filtered_player_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRemoveFilteredPlayerResponse {
    const NAME: &'static str = "CMsgGCToClientRemoveFilteredPlayerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRemoveFilteredPlayerResponse {
        CMsgGCToClientRemoveFilteredPlayerResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRemoveFilteredPlayerResponse {
        static instance: CMsgGCToClientRemoveFilteredPlayerResponse = CMsgGCToClientRemoveFilteredPlayerResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientRemoveFilteredPlayerResponse`
pub mod cmsg_gcto_client_remove_filtered_player_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientRemoveFilteredPlayerResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRemoveFilteredPlayerResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRemoveFilteredPlayerResponse.Result.FAILURE)
        FAILURE = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(Result::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILURE,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPurchaseFilteredPlayerSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPurchaseFilteredPlayerSlot {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseFilteredPlayerSlot.additional_slots_current)
    pub additional_slots_current: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseFilteredPlayerSlot.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPurchaseFilteredPlayerSlot {
    fn default() -> &'a CMsgClientToGCPurchaseFilteredPlayerSlot {
        <CMsgClientToGCPurchaseFilteredPlayerSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPurchaseFilteredPlayerSlot {
    pub fn new() -> CMsgClientToGCPurchaseFilteredPlayerSlot {
        ::std::default::Default::default()
    }

    // optional int32 additional_slots_current = 1;

    pub fn additional_slots_current(&self) -> i32 {
        self.additional_slots_current.unwrap_or(0)
    }

    pub fn clear_additional_slots_current(&mut self) {
        self.additional_slots_current = ::std::option::Option::None;
    }

    pub fn has_additional_slots_current(&self) -> bool {
        self.additional_slots_current.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_slots_current(&mut self, v: i32) {
        self.additional_slots_current = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPurchaseFilteredPlayerSlot {
    const NAME: &'static str = "CMsgClientToGCPurchaseFilteredPlayerSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.additional_slots_current = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.additional_slots_current {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.additional_slots_current {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPurchaseFilteredPlayerSlot {
        CMsgClientToGCPurchaseFilteredPlayerSlot::new()
    }

    fn clear(&mut self) {
        self.additional_slots_current = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPurchaseFilteredPlayerSlot {
        static instance: CMsgClientToGCPurchaseFilteredPlayerSlot = CMsgClientToGCPurchaseFilteredPlayerSlot {
            additional_slots_current: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPurchaseFilteredPlayerSlotResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_purchase_filtered_player_slot_response::Result>>,
    // @@protoc_insertion_point(field:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.additional_slots)
    pub additional_slots: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.next_slot_cost)
    pub next_slot_cost: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    fn default() -> &'a CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
        <CMsgGCToClientPurchaseFilteredPlayerSlotResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    pub fn new() -> CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result result = 1;

    pub fn result(&self) -> cmsg_gcto_client_purchase_filtered_player_slot_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcto_client_purchase_filtered_player_slot_response::Result::SUCCESS),
            None => cmsg_gcto_client_purchase_filtered_player_slot_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcto_client_purchase_filtered_player_slot_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 additional_slots = 2;

    pub fn additional_slots(&self) -> i32 {
        self.additional_slots.unwrap_or(0)
    }

    pub fn clear_additional_slots(&mut self) {
        self.additional_slots = ::std::option::Option::None;
    }

    pub fn has_additional_slots(&self) -> bool {
        self.additional_slots.is_some()
    }

    // Param is passed by value, moved
    pub fn set_additional_slots(&mut self, v: i32) {
        self.additional_slots = ::std::option::Option::Some(v);
    }

    // optional int32 next_slot_cost = 3;

    pub fn next_slot_cost(&self) -> i32 {
        self.next_slot_cost.unwrap_or(0)
    }

    pub fn clear_next_slot_cost(&mut self) {
        self.next_slot_cost = ::std::option::Option::None;
    }

    pub fn has_next_slot_cost(&self) -> bool {
        self.next_slot_cost.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_slot_cost(&mut self, v: i32) {
        self.next_slot_cost = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    const NAME: &'static str = "CMsgGCToClientPurchaseFilteredPlayerSlotResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.additional_slots = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.next_slot_cost = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.additional_slots {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.next_slot_cost {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.additional_slots {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.next_slot_cost {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
        CMsgGCToClientPurchaseFilteredPlayerSlotResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.additional_slots = ::std::option::Option::None;
        self.next_slot_cost = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
        static instance: CMsgGCToClientPurchaseFilteredPlayerSlotResponse = CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
            result: ::std::option::Option::None,
            additional_slots: ::std::option::Option::None,
            next_slot_cost: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientPurchaseFilteredPlayerSlotResponse`
pub mod cmsg_gcto_client_purchase_filtered_player_slot_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result.CURRENT_SLOTCOUNT_DOESNT_MATCH)
        CURRENT_SLOTCOUNT_DOESNT_MATCH = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientPurchaseFilteredPlayerSlotResponse.Result.CANT_AFFORD)
        CANT_AFFORD = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILURE),
                2 => ::std::option::Option::Some(Result::CURRENT_SLOTCOUNT_DOESNT_MATCH),
                3 => ::std::option::Option::Some(Result::CANT_AFFORD),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(Result::FAILURE),
                "CURRENT_SLOTCOUNT_DOESNT_MATCH" => ::std::option::Option::Some(Result::CURRENT_SLOTCOUNT_DOESNT_MATCH),
                "CANT_AFFORD" => ::std::option::Option::Some(Result::CANT_AFFORD),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILURE,
            Result::CURRENT_SLOTCOUNT_DOESNT_MATCH,
            Result::CANT_AFFORD,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCUpdateFilteredPlayerNote)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUpdateFilteredPlayerNote {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUpdateFilteredPlayerNote.target_account_id)
    pub target_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUpdateFilteredPlayerNote.new_note)
    pub new_note: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUpdateFilteredPlayerNote.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUpdateFilteredPlayerNote {
    fn default() -> &'a CMsgClientToGCUpdateFilteredPlayerNote {
        <CMsgClientToGCUpdateFilteredPlayerNote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUpdateFilteredPlayerNote {
    pub fn new() -> CMsgClientToGCUpdateFilteredPlayerNote {
        ::std::default::Default::default()
    }

    // optional fixed32 target_account_id = 1;

    pub fn target_account_id(&self) -> u32 {
        self.target_account_id.unwrap_or(0)
    }

    pub fn clear_target_account_id(&mut self) {
        self.target_account_id = ::std::option::Option::None;
    }

    pub fn has_target_account_id(&self) -> bool {
        self.target_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_account_id(&mut self, v: u32) {
        self.target_account_id = ::std::option::Option::Some(v);
    }

    // optional string new_note = 2;

    pub fn new_note(&self) -> &str {
        match self.new_note.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_new_note(&mut self) {
        self.new_note = ::std::option::Option::None;
    }

    pub fn has_new_note(&self) -> bool {
        self.new_note.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_note(&mut self, v: ::std::string::String) {
        self.new_note = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_new_note(&mut self) -> &mut ::std::string::String {
        if self.new_note.is_none() {
            self.new_note = ::std::option::Option::Some(::std::string::String::new());
        }
        self.new_note.as_mut().unwrap()
    }

    // Take field
    pub fn take_new_note(&mut self) -> ::std::string::String {
        self.new_note.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUpdateFilteredPlayerNote {
    const NAME: &'static str = "CMsgClientToGCUpdateFilteredPlayerNote";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.target_account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                18 => {
                    self.new_note = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.target_account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.new_note.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.target_account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.new_note.as_ref() {
            os.write_string(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUpdateFilteredPlayerNote {
        CMsgClientToGCUpdateFilteredPlayerNote::new()
    }

    fn clear(&mut self) {
        self.target_account_id = ::std::option::Option::None;
        self.new_note = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUpdateFilteredPlayerNote {
        static instance: CMsgClientToGCUpdateFilteredPlayerNote = CMsgClientToGCUpdateFilteredPlayerNote {
            target_account_id: ::std::option::Option::None,
            new_note: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientUpdateFilteredPlayerNoteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientUpdateFilteredPlayerNoteResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_update_filtered_player_note_response::Result>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientUpdateFilteredPlayerNoteResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    fn default() -> &'a CMsgGCToClientUpdateFilteredPlayerNoteResponse {
        <CMsgGCToClientUpdateFilteredPlayerNoteResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    pub fn new() -> CMsgGCToClientUpdateFilteredPlayerNoteResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientUpdateFilteredPlayerNoteResponse.Result result = 1;

    pub fn result(&self) -> cmsg_gcto_client_update_filtered_player_note_response::Result {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_gcto_client_update_filtered_player_note_response::Result::SUCCESS),
            None => cmsg_gcto_client_update_filtered_player_note_response::Result::SUCCESS,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_gcto_client_update_filtered_player_note_response::Result) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    const NAME: &'static str = "CMsgGCToClientUpdateFilteredPlayerNoteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientUpdateFilteredPlayerNoteResponse {
        CMsgGCToClientUpdateFilteredPlayerNoteResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientUpdateFilteredPlayerNoteResponse {
        static instance: CMsgGCToClientUpdateFilteredPlayerNoteResponse = CMsgGCToClientUpdateFilteredPlayerNoteResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientUpdateFilteredPlayerNoteResponse`
pub mod cmsg_gcto_client_update_filtered_player_note_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientUpdateFilteredPlayerNoteResponse.Result)
    pub enum Result {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUpdateFilteredPlayerNoteResponse.Result.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUpdateFilteredPlayerNoteResponse.Result.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUpdateFilteredPlayerNoteResponse.Result.NOT_FOUND)
        NOT_FOUND = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Result {
        const NAME: &'static str = "Result";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Result> {
            match value {
                0 => ::std::option::Option::Some(Result::SUCCESS),
                1 => ::std::option::Option::Some(Result::FAILURE),
                2 => ::std::option::Option::Some(Result::NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Result> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(Result::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(Result::FAILURE),
                "NOT_FOUND" => ::std::option::Option::Some(Result::NOT_FOUND),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Result] = &[
            Result::SUCCESS,
            Result::FAILURE,
            Result::NOT_FOUND,
        ];
    }

    impl ::std::default::Default for Result {
        fn default() -> Self {
            Result::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgPartySearchPlayer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgPartySearchPlayer {
    // message fields
    // @@protoc_insertion_point(field:CMsgPartySearchPlayer.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgPartySearchPlayer.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgPartySearchPlayer.creation_time)
    pub creation_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgPartySearchPlayer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgPartySearchPlayer {
    fn default() -> &'a CMsgPartySearchPlayer {
        <CMsgPartySearchPlayer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgPartySearchPlayer {
    pub fn new() -> CMsgPartySearchPlayer {
        ::std::default::Default::default()
    }

    // optional fixed32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 match_id = 2;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 creation_time = 3;

    pub fn creation_time(&self) -> u32 {
        self.creation_time.unwrap_or(0)
    }

    pub fn clear_creation_time(&mut self) {
        self.creation_time = ::std::option::Option::None;
    }

    pub fn has_creation_time(&self) -> bool {
        self.creation_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creation_time(&mut self, v: u32) {
        self.creation_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgPartySearchPlayer {
    const NAME: &'static str = "CMsgPartySearchPlayer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                17 => {
                    self.match_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                29 => {
                    self.creation_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.match_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.creation_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_fixed32(1, v)?;
        }
        if let Some(v) = self.match_id {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.creation_time {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgPartySearchPlayer {
        CMsgPartySearchPlayer::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.match_id = ::std::option::Option::None;
        self.creation_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgPartySearchPlayer {
        static instance: CMsgPartySearchPlayer = CMsgPartySearchPlayer {
            account_id: ::std::option::Option::None,
            match_id: ::std::option::Option::None,
            creation_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPlayerBeaconState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPlayerBeaconState {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPlayerBeaconState.num_active_beacons)
    pub num_active_beacons: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPlayerBeaconState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPlayerBeaconState {
    fn default() -> &'a CMsgGCToClientPlayerBeaconState {
        <CMsgGCToClientPlayerBeaconState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPlayerBeaconState {
    pub fn new() -> CMsgGCToClientPlayerBeaconState {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPlayerBeaconState {
    const NAME: &'static str = "CMsgGCToClientPlayerBeaconState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.num_active_beacons)?;
                },
                8 => {
                    self.num_active_beacons.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.num_active_beacons {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.num_active_beacons {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPlayerBeaconState {
        CMsgGCToClientPlayerBeaconState::new()
    }

    fn clear(&mut self) {
        self.num_active_beacons.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPlayerBeaconState {
        static instance: CMsgGCToClientPlayerBeaconState = CMsgGCToClientPlayerBeaconState {
            num_active_beacons: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientPartyBeaconUpdate)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPartyBeaconUpdate {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPartyBeaconUpdate.beacon_added)
    pub beacon_added: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgGCToClientPartyBeaconUpdate.beacon_type)
    pub beacon_type: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgGCToClientPartyBeaconUpdate.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPartyBeaconUpdate.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPartyBeaconUpdate {
    fn default() -> &'a CMsgGCToClientPartyBeaconUpdate {
        <CMsgGCToClientPartyBeaconUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPartyBeaconUpdate {
    pub fn new() -> CMsgGCToClientPartyBeaconUpdate {
        ::std::default::Default::default()
    }

    // optional bool beacon_added = 1;

    pub fn beacon_added(&self) -> bool {
        self.beacon_added.unwrap_or(false)
    }

    pub fn clear_beacon_added(&mut self) {
        self.beacon_added = ::std::option::Option::None;
    }

    pub fn has_beacon_added(&self) -> bool {
        self.beacon_added.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_added(&mut self, v: bool) {
        self.beacon_added = ::std::option::Option::Some(v);
    }

    // optional int32 beacon_type = 2;

    pub fn beacon_type(&self) -> i32 {
        self.beacon_type.unwrap_or(0)
    }

    pub fn clear_beacon_type(&mut self) {
        self.beacon_type = ::std::option::Option::None;
    }

    pub fn has_beacon_type(&self) -> bool {
        self.beacon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_type(&mut self, v: i32) {
        self.beacon_type = ::std::option::Option::Some(v);
    }

    // optional fixed32 account_id = 3;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPartyBeaconUpdate {
    const NAME: &'static str = "CMsgGCToClientPartyBeaconUpdate";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.beacon_added = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.beacon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                29 => {
                    self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.beacon_added {
            my_size += 1 + 1;
        }
        if let Some(v) = self.beacon_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        if let Some(v) = self.account_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.beacon_added {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.beacon_type {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_fixed32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPartyBeaconUpdate {
        CMsgGCToClientPartyBeaconUpdate::new()
    }

    fn clear(&mut self) {
        self.beacon_added = ::std::option::Option::None;
        self.beacon_type = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPartyBeaconUpdate {
        static instance: CMsgGCToClientPartyBeaconUpdate = CMsgGCToClientPartyBeaconUpdate {
            beacon_added: ::std::option::Option::None,
            beacon_type: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUpdatePartyBeacon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUpdatePartyBeacon {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUpdatePartyBeacon.action)
    pub action: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcupdate_party_beacon::Action>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUpdatePartyBeacon.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUpdatePartyBeacon {
    fn default() -> &'a CMsgClientToGCUpdatePartyBeacon {
        <CMsgClientToGCUpdatePartyBeacon as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUpdatePartyBeacon {
    pub fn new() -> CMsgClientToGCUpdatePartyBeacon {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCUpdatePartyBeacon.Action action = 1;

    pub fn action(&self) -> cmsg_client_to_gcupdate_party_beacon::Action {
        match self.action {
            Some(e) => e.enum_value_or(cmsg_client_to_gcupdate_party_beacon::Action::ON),
            None => cmsg_client_to_gcupdate_party_beacon::Action::ON,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: cmsg_client_to_gcupdate_party_beacon::Action) {
        self.action = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUpdatePartyBeacon {
    const NAME: &'static str = "CMsgClientToGCUpdatePartyBeacon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUpdatePartyBeacon {
        CMsgClientToGCUpdatePartyBeacon::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUpdatePartyBeacon {
        static instance: CMsgClientToGCUpdatePartyBeacon = CMsgClientToGCUpdatePartyBeacon {
            action: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCUpdatePartyBeacon`
pub mod cmsg_client_to_gcupdate_party_beacon {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCUpdatePartyBeacon.Action)
    pub enum Action {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUpdatePartyBeacon.Action.ON)
        ON = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCUpdatePartyBeacon.Action.OFF)
        OFF = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Action {
        const NAME: &'static str = "Action";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Action> {
            match value {
                0 => ::std::option::Option::Some(Action::ON),
                1 => ::std::option::Option::Some(Action::OFF),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Action> {
            match str {
                "ON" => ::std::option::Option::Some(Action::ON),
                "OFF" => ::std::option::Option::Some(Action::OFF),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Action] = &[
            Action::ON,
            Action::OFF,
        ];
    }

    impl ::std::default::Default for Action {
        fn default() -> Self {
            Action::ON
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestActiveBeaconParties)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveBeaconParties {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestActiveBeaconParties.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveBeaconParties {
    fn default() -> &'a CMsgClientToGCRequestActiveBeaconParties {
        <CMsgClientToGCRequestActiveBeaconParties as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveBeaconParties {
    pub fn new() -> CMsgClientToGCRequestActiveBeaconParties {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestActiveBeaconParties {
    const NAME: &'static str = "CMsgClientToGCRequestActiveBeaconParties";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveBeaconParties {
        CMsgClientToGCRequestActiveBeaconParties::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveBeaconParties {
        static instance: CMsgClientToGCRequestActiveBeaconParties = CMsgClientToGCRequestActiveBeaconParties {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientRequestActiveBeaconPartiesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRequestActiveBeaconPartiesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRequestActiveBeaconPartiesResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_request_active_beacon_parties_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgGCToClientRequestActiveBeaconPartiesResponse.active_parties)
    pub active_parties: ::std::vec::Vec<super::dota_gcmessages_common::CPartySearchClientParty>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRequestActiveBeaconPartiesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRequestActiveBeaconPartiesResponse {
    fn default() -> &'a CMsgGCToClientRequestActiveBeaconPartiesResponse {
        <CMsgGCToClientRequestActiveBeaconPartiesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRequestActiveBeaconPartiesResponse {
    pub fn new() -> CMsgGCToClientRequestActiveBeaconPartiesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientRequestActiveBeaconPartiesResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_request_active_beacon_parties_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_request_active_beacon_parties_response::EResponse::SUCCESS),
            None => cmsg_gcto_client_request_active_beacon_parties_response::EResponse::SUCCESS,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_request_active_beacon_parties_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRequestActiveBeaconPartiesResponse {
    const NAME: &'static str = "CMsgGCToClientRequestActiveBeaconPartiesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.active_parties.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.active_parties {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.active_parties {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRequestActiveBeaconPartiesResponse {
        CMsgGCToClientRequestActiveBeaconPartiesResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.active_parties.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRequestActiveBeaconPartiesResponse {
        static instance: CMsgGCToClientRequestActiveBeaconPartiesResponse = CMsgGCToClientRequestActiveBeaconPartiesResponse {
            response: ::std::option::Option::None,
            active_parties: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientRequestActiveBeaconPartiesResponse`
pub mod cmsg_gcto_client_request_active_beacon_parties_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientRequestActiveBeaconPartiesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRequestActiveBeaconPartiesResponse.EResponse.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRequestActiveBeaconPartiesResponse.EResponse.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientRequestActiveBeaconPartiesResponse.EResponse.BUSY)
        BUSY = 2,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::SUCCESS),
                1 => ::std::option::Option::Some(EResponse::FAILURE),
                2 => ::std::option::Option::Some(EResponse::BUSY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResponse::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(EResponse::FAILURE),
                "BUSY" => ::std::option::Option::Some(EResponse::BUSY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::SUCCESS,
            EResponse::FAILURE,
            EResponse::BUSY,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCJoinPartyFromBeacon)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCJoinPartyFromBeacon {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCJoinPartyFromBeacon.party_id)
    pub party_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCJoinPartyFromBeacon.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCJoinPartyFromBeacon.beacon_type)
    pub beacon_type: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCJoinPartyFromBeacon.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCJoinPartyFromBeacon {
    fn default() -> &'a CMsgClientToGCJoinPartyFromBeacon {
        <CMsgClientToGCJoinPartyFromBeacon as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCJoinPartyFromBeacon {
    pub fn new() -> CMsgClientToGCJoinPartyFromBeacon {
        ::std::default::Default::default()
    }

    // optional fixed64 party_id = 1;

    pub fn party_id(&self) -> u64 {
        self.party_id.unwrap_or(0)
    }

    pub fn clear_party_id(&mut self) {
        self.party_id = ::std::option::Option::None;
    }

    pub fn has_party_id(&self) -> bool {
        self.party_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_party_id(&mut self, v: u64) {
        self.party_id = ::std::option::Option::Some(v);
    }

    // optional fixed32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 beacon_type = 3;

    pub fn beacon_type(&self) -> i32 {
        self.beacon_type.unwrap_or(0)
    }

    pub fn clear_beacon_type(&mut self) {
        self.beacon_type = ::std::option::Option::None;
    }

    pub fn has_beacon_type(&self) -> bool {
        self.beacon_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_beacon_type(&mut self, v: i32) {
        self.beacon_type = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCJoinPartyFromBeacon {
    const NAME: &'static str = "CMsgClientToGCJoinPartyFromBeacon";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.party_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                21 => {
                    self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                24 => {
                    self.beacon_type = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.party_id {
            my_size += 1 + 8;
        }
        if let Some(v) = self.account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.beacon_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.party_id {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.beacon_type {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCJoinPartyFromBeacon {
        CMsgClientToGCJoinPartyFromBeacon::new()
    }

    fn clear(&mut self) {
        self.party_id = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.beacon_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCJoinPartyFromBeacon {
        static instance: CMsgClientToGCJoinPartyFromBeacon = CMsgClientToGCJoinPartyFromBeacon {
            party_id: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            beacon_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientJoinPartyFromBeaconResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientJoinPartyFromBeaconResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientJoinPartyFromBeaconResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_join_party_from_beacon_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientJoinPartyFromBeaconResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientJoinPartyFromBeaconResponse {
    fn default() -> &'a CMsgGCToClientJoinPartyFromBeaconResponse {
        <CMsgGCToClientJoinPartyFromBeaconResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientJoinPartyFromBeaconResponse {
    pub fn new() -> CMsgGCToClientJoinPartyFromBeaconResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientJoinPartyFromBeaconResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_join_party_from_beacon_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_join_party_from_beacon_response::EResponse::SUCCESS),
            None => cmsg_gcto_client_join_party_from_beacon_response::EResponse::SUCCESS,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_join_party_from_beacon_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientJoinPartyFromBeaconResponse {
    const NAME: &'static str = "CMsgGCToClientJoinPartyFromBeaconResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientJoinPartyFromBeaconResponse {
        CMsgGCToClientJoinPartyFromBeaconResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientJoinPartyFromBeaconResponse {
        static instance: CMsgGCToClientJoinPartyFromBeaconResponse = CMsgGCToClientJoinPartyFromBeaconResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientJoinPartyFromBeaconResponse`
pub mod cmsg_gcto_client_join_party_from_beacon_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientJoinPartyFromBeaconResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientJoinPartyFromBeaconResponse.EResponse.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientJoinPartyFromBeaconResponse.EResponse.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientJoinPartyFromBeaconResponse.EResponse.BUSY)
        BUSY = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientJoinPartyFromBeaconResponse.EResponse.NOT_LEADER)
        NOT_LEADER = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::SUCCESS),
                1 => ::std::option::Option::Some(EResponse::FAILURE),
                2 => ::std::option::Option::Some(EResponse::BUSY),
                3 => ::std::option::Option::Some(EResponse::NOT_LEADER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResponse::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(EResponse::FAILURE),
                "BUSY" => ::std::option::Option::Some(EResponse::BUSY),
                "NOT_LEADER" => ::std::option::Option::Some(EResponse::NOT_LEADER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::SUCCESS,
            EResponse::FAILURE,
            EResponse::BUSY,
            EResponse::NOT_LEADER,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCManageFavorites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCManageFavorites {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.action)
    pub action: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcmanage_favorites::Action>>,
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.favorite_name)
    pub favorite_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.invite_response)
    pub invite_response: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.from_friendlist)
    pub from_friendlist: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCManageFavorites.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCManageFavorites.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCManageFavorites {
    fn default() -> &'a CMsgClientToGCManageFavorites {
        <CMsgClientToGCManageFavorites as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCManageFavorites {
    pub fn new() -> CMsgClientToGCManageFavorites {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCManageFavorites.Action action = 1;

    pub fn action(&self) -> cmsg_client_to_gcmanage_favorites::Action {
        match self.action {
            Some(e) => e.enum_value_or(cmsg_client_to_gcmanage_favorites::Action::ADD),
            None => cmsg_client_to_gcmanage_favorites::Action::ADD,
        }
    }

    pub fn clear_action(&mut self) {
        self.action = ::std::option::Option::None;
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: cmsg_client_to_gcmanage_favorites::Action) {
        self.action = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional fixed32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional string favorite_name = 3;

    pub fn favorite_name(&self) -> &str {
        match self.favorite_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_favorite_name(&mut self) {
        self.favorite_name = ::std::option::Option::None;
    }

    pub fn has_favorite_name(&self) -> bool {
        self.favorite_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_name(&mut self, v: ::std::string::String) {
        self.favorite_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_favorite_name(&mut self) -> &mut ::std::string::String {
        if self.favorite_name.is_none() {
            self.favorite_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.favorite_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_favorite_name(&mut self) -> ::std::string::String {
        self.favorite_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool invite_response = 4;

    pub fn invite_response(&self) -> bool {
        self.invite_response.unwrap_or(false)
    }

    pub fn clear_invite_response(&mut self) {
        self.invite_response = ::std::option::Option::None;
    }

    pub fn has_invite_response(&self) -> bool {
        self.invite_response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_invite_response(&mut self, v: bool) {
        self.invite_response = ::std::option::Option::Some(v);
    }

    // optional bool from_friendlist = 5;

    pub fn from_friendlist(&self) -> bool {
        self.from_friendlist.unwrap_or(false)
    }

    pub fn clear_from_friendlist(&mut self) {
        self.from_friendlist = ::std::option::Option::None;
    }

    pub fn has_from_friendlist(&self) -> bool {
        self.from_friendlist.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from_friendlist(&mut self, v: bool) {
        self.from_friendlist = ::std::option::Option::Some(v);
    }

    // optional fixed64 lobby_id = 6;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCManageFavorites {
    const NAME: &'static str = "CMsgClientToGCManageFavorites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.action = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                21 => {
                    self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                26 => {
                    self.favorite_name = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.invite_response = ::std::option::Option::Some(is.read_bool()?);
                },
                40 => {
                    self.from_friendlist = ::std::option::Option::Some(is.read_bool()?);
                },
                49 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_fixed64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.action {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.account_id {
            my_size += 1 + 4;
        }
        if let Some(v) = self.favorite_name.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.invite_response {
            my_size += 1 + 1;
        }
        if let Some(v) = self.from_friendlist {
            my_size += 1 + 1;
        }
        if let Some(v) = self.lobby_id {
            my_size += 1 + 8;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.action {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account_id {
            os.write_fixed32(2, v)?;
        }
        if let Some(v) = self.favorite_name.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.invite_response {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.from_friendlist {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_fixed64(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCManageFavorites {
        CMsgClientToGCManageFavorites::new()
    }

    fn clear(&mut self) {
        self.action = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.favorite_name = ::std::option::Option::None;
        self.invite_response = ::std::option::Option::None;
        self.from_friendlist = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCManageFavorites {
        static instance: CMsgClientToGCManageFavorites = CMsgClientToGCManageFavorites {
            action: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            favorite_name: ::std::option::Option::None,
            invite_response: ::std::option::Option::None,
            from_friendlist: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCManageFavorites`
pub mod cmsg_client_to_gcmanage_favorites {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCManageFavorites.Action)
    pub enum Action {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCManageFavorites.Action.ADD)
        ADD = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCManageFavorites.Action.REMOVE)
        REMOVE = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for Action {
        const NAME: &'static str = "Action";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Action> {
            match value {
                0 => ::std::option::Option::Some(Action::ADD),
                1 => ::std::option::Option::Some(Action::REMOVE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Action> {
            match str {
                "ADD" => ::std::option::Option::Some(Action::ADD),
                "REMOVE" => ::std::option::Option::Some(Action::REMOVE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Action] = &[
            Action::ADD,
            Action::REMOVE,
        ];
    }

    impl ::std::default::Default for Action {
        fn default() -> Self {
            Action::ADD
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientManageFavoritesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientManageFavoritesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientManageFavoritesResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_manage_favorites_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgGCToClientManageFavoritesResponse.debug_message)
    pub debug_message: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:CMsgGCToClientManageFavoritesResponse.player)
    pub player: ::steam_vent_proto_common::protobuf::MessageField<CMsgPartySearchPlayer>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientManageFavoritesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientManageFavoritesResponse {
    fn default() -> &'a CMsgGCToClientManageFavoritesResponse {
        <CMsgGCToClientManageFavoritesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientManageFavoritesResponse {
    pub fn new() -> CMsgGCToClientManageFavoritesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientManageFavoritesResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_manage_favorites_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_manage_favorites_response::EResponse::SUCCESS),
            None => cmsg_gcto_client_manage_favorites_response::EResponse::SUCCESS,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_manage_favorites_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional string debug_message = 2;

    pub fn debug_message(&self) -> &str {
        match self.debug_message.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_debug_message(&mut self) {
        self.debug_message = ::std::option::Option::None;
    }

    pub fn has_debug_message(&self) -> bool {
        self.debug_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_message(&mut self, v: ::std::string::String) {
        self.debug_message = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_message(&mut self) -> &mut ::std::string::String {
        if self.debug_message.is_none() {
            self.debug_message = ::std::option::Option::Some(::std::string::String::new());
        }
        self.debug_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_message(&mut self) -> ::std::string::String {
        self.debug_message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientManageFavoritesResponse {
    const NAME: &'static str = "CMsgGCToClientManageFavoritesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.debug_message = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.debug_message.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.player.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.debug_message.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.player.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientManageFavoritesResponse {
        CMsgGCToClientManageFavoritesResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.debug_message = ::std::option::Option::None;
        self.player.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientManageFavoritesResponse {
        static instance: CMsgGCToClientManageFavoritesResponse = CMsgGCToClientManageFavoritesResponse {
            response: ::std::option::Option::None,
            debug_message: ::std::option::Option::None,
            player: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientManageFavoritesResponse`
pub mod cmsg_gcto_client_manage_favorites_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientManageFavoritesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.FAILURE)
        FAILURE = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.NO_INVITE_PRESENT)
        NO_INVITE_PRESENT = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.INVITE_SENT)
        INVITE_SENT = 3,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.EXPIRED)
        EXPIRED = 4,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientManageFavoritesResponse.EResponse.BUSY)
        BUSY = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::SUCCESS),
                1 => ::std::option::Option::Some(EResponse::FAILURE),
                2 => ::std::option::Option::Some(EResponse::NO_INVITE_PRESENT),
                3 => ::std::option::Option::Some(EResponse::INVITE_SENT),
                4 => ::std::option::Option::Some(EResponse::EXPIRED),
                5 => ::std::option::Option::Some(EResponse::BUSY),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResponse::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(EResponse::FAILURE),
                "NO_INVITE_PRESENT" => ::std::option::Option::Some(EResponse::NO_INVITE_PRESENT),
                "INVITE_SENT" => ::std::option::Option::Some(EResponse::INVITE_SENT),
                "EXPIRED" => ::std::option::Option::Some(EResponse::EXPIRED),
                "BUSY" => ::std::option::Option::Some(EResponse::BUSY),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::SUCCESS,
            EResponse::FAILURE,
            EResponse::NO_INVITE_PRESENT,
            EResponse::INVITE_SENT,
            EResponse::EXPIRED,
            EResponse::BUSY,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetFavoritePlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetFavoritePlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetFavoritePlayers.pagination_key)
    pub pagination_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetFavoritePlayers.pagination_count)
    pub pagination_count: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetFavoritePlayers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetFavoritePlayers {
    fn default() -> &'a CMsgClientToGCGetFavoritePlayers {
        <CMsgClientToGCGetFavoritePlayers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetFavoritePlayers {
    pub fn new() -> CMsgClientToGCGetFavoritePlayers {
        ::std::default::Default::default()
    }

    // optional uint64 pagination_key = 1;

    pub fn pagination_key(&self) -> u64 {
        self.pagination_key.unwrap_or(0)
    }

    pub fn clear_pagination_key(&mut self) {
        self.pagination_key = ::std::option::Option::None;
    }

    pub fn has_pagination_key(&self) -> bool {
        self.pagination_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination_key(&mut self, v: u64) {
        self.pagination_key = ::std::option::Option::Some(v);
    }

    // optional int32 pagination_count = 2;

    pub fn pagination_count(&self) -> i32 {
        self.pagination_count.unwrap_or(0)
    }

    pub fn clear_pagination_count(&mut self) {
        self.pagination_count = ::std::option::Option::None;
    }

    pub fn has_pagination_count(&self) -> bool {
        self.pagination_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pagination_count(&mut self, v: i32) {
        self.pagination_count = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetFavoritePlayers {
    const NAME: &'static str = "CMsgClientToGCGetFavoritePlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.pagination_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.pagination_count = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pagination_key {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.pagination_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.pagination_key {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.pagination_count {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetFavoritePlayers {
        CMsgClientToGCGetFavoritePlayers::new()
    }

    fn clear(&mut self) {
        self.pagination_key = ::std::option::Option::None;
        self.pagination_count = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetFavoritePlayers {
        static instance: CMsgClientToGCGetFavoritePlayers = CMsgClientToGCGetFavoritePlayers {
            pagination_key: ::std::option::Option::None,
            pagination_count: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientGetFavoritePlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGetFavoritePlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGetFavoritePlayersResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_get_favorite_players_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFavoritePlayersResponse.players)
    pub players: ::std::vec::Vec<CMsgPartySearchPlayer>,
    // @@protoc_insertion_point(field:CMsgGCToClientGetFavoritePlayersResponse.next_pagination_key)
    pub next_pagination_key: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGetFavoritePlayersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGetFavoritePlayersResponse {
    fn default() -> &'a CMsgGCToClientGetFavoritePlayersResponse {
        <CMsgGCToClientGetFavoritePlayersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGetFavoritePlayersResponse {
    pub fn new() -> CMsgGCToClientGetFavoritePlayersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientGetFavoritePlayersResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_get_favorite_players_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_get_favorite_players_response::EResponse::SUCCESS),
            None => cmsg_gcto_client_get_favorite_players_response::EResponse::SUCCESS,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_get_favorite_players_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 next_pagination_key = 3;

    pub fn next_pagination_key(&self) -> u64 {
        self.next_pagination_key.unwrap_or(0)
    }

    pub fn clear_next_pagination_key(&mut self) {
        self.next_pagination_key = ::std::option::Option::None;
    }

    pub fn has_next_pagination_key(&self) -> bool {
        self.next_pagination_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_next_pagination_key(&mut self, v: u64) {
        self.next_pagination_key = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGetFavoritePlayersResponse {
    const NAME: &'static str = "CMsgGCToClientGetFavoritePlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.players.push(is.read_message()?);
                },
                24 => {
                    self.next_pagination_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.players {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.next_pagination_key {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.players {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.next_pagination_key {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGetFavoritePlayersResponse {
        CMsgGCToClientGetFavoritePlayersResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.players.clear();
        self.next_pagination_key = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGetFavoritePlayersResponse {
        static instance: CMsgGCToClientGetFavoritePlayersResponse = CMsgGCToClientGetFavoritePlayersResponse {
            response: ::std::option::Option::None,
            players: ::std::vec::Vec::new(),
            next_pagination_key: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientGetFavoritePlayersResponse`
pub mod cmsg_gcto_client_get_favorite_players_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientGetFavoritePlayersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientGetFavoritePlayersResponse.EResponse.SUCCESS)
        SUCCESS = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientGetFavoritePlayersResponse.EResponse.FAILURE)
        FAILURE = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::SUCCESS),
                1 => ::std::option::Option::Some(EResponse::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "SUCCESS" => ::std::option::Option::Some(EResponse::SUCCESS),
                "FAILURE" => ::std::option::Option::Some(EResponse::FAILURE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::SUCCESS,
            EResponse::FAILURE,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::SUCCESS
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientPartySearchInvite)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientPartySearchInvite {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientPartySearchInvite.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientPartySearchInvite.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientPartySearchInvite {
    fn default() -> &'a CMsgGCToClientPartySearchInvite {
        <CMsgGCToClientPartySearchInvite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientPartySearchInvite {
    pub fn new() -> CMsgGCToClientPartySearchInvite {
        ::std::default::Default::default()
    }

    // optional fixed32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientPartySearchInvite {
    const NAME: &'static str = "CMsgGCToClientPartySearchInvite";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.account_id = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientPartySearchInvite {
        CMsgGCToClientPartySearchInvite::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientPartySearchInvite {
        static instance: CMsgGCToClientPartySearchInvite = CMsgGCToClientPartySearchInvite {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCVerifyFavoritePlayers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCVerifyFavoritePlayers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCVerifyFavoritePlayers.account_ids)
    pub account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCVerifyFavoritePlayers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCVerifyFavoritePlayers {
    fn default() -> &'a CMsgClientToGCVerifyFavoritePlayers {
        <CMsgClientToGCVerifyFavoritePlayers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCVerifyFavoritePlayers {
    pub fn new() -> CMsgClientToGCVerifyFavoritePlayers {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCVerifyFavoritePlayers {
    const NAME: &'static str = "CMsgClientToGCVerifyFavoritePlayers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_fixed32_into(&mut self.account_ids)?;
                },
                13 => {
                    self.account_ids.push(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += 5 * self.account_ids.len() as u64;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.account_ids {
            os.write_fixed32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCVerifyFavoritePlayers {
        CMsgClientToGCVerifyFavoritePlayers::new()
    }

    fn clear(&mut self) {
        self.account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCVerifyFavoritePlayers {
        static instance: CMsgClientToGCVerifyFavoritePlayers = CMsgClientToGCVerifyFavoritePlayers {
            account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientVerifyFavoritePlayersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientVerifyFavoritePlayersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientVerifyFavoritePlayersResponse.results)
    pub results: ::std::vec::Vec<cmsg_gcto_client_verify_favorite_players_response::Result>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientVerifyFavoritePlayersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientVerifyFavoritePlayersResponse {
    fn default() -> &'a CMsgGCToClientVerifyFavoritePlayersResponse {
        <CMsgGCToClientVerifyFavoritePlayersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientVerifyFavoritePlayersResponse {
    pub fn new() -> CMsgGCToClientVerifyFavoritePlayersResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientVerifyFavoritePlayersResponse {
    const NAME: &'static str = "CMsgGCToClientVerifyFavoritePlayersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.results.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.results {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.results {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientVerifyFavoritePlayersResponse {
        CMsgGCToClientVerifyFavoritePlayersResponse::new()
    }

    fn clear(&mut self) {
        self.results.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientVerifyFavoritePlayersResponse {
        static instance: CMsgGCToClientVerifyFavoritePlayersResponse = CMsgGCToClientVerifyFavoritePlayersResponse {
            results: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientVerifyFavoritePlayersResponse`
pub mod cmsg_gcto_client_verify_favorite_players_response {
    // @@protoc_insertion_point(message:CMsgGCToClientVerifyFavoritePlayersResponse.Result)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Result {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientVerifyFavoritePlayersResponse.Result.player)
        pub player: ::steam_vent_proto_common::protobuf::MessageField<super::CMsgPartySearchPlayer>,
        // @@protoc_insertion_point(field:CMsgGCToClientVerifyFavoritePlayersResponse.Result.is_favorite)
        pub is_favorite: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientVerifyFavoritePlayersResponse.Result.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Result {
        fn default() -> &'a Result {
            <Result as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Result {
        pub fn new() -> Result {
            ::std::default::Default::default()
        }

        // optional bool is_favorite = 2;

        pub fn is_favorite(&self) -> bool {
            self.is_favorite.unwrap_or(false)
        }

        pub fn clear_is_favorite(&mut self) {
            self.is_favorite = ::std::option::Option::None;
        }

        pub fn has_is_favorite(&self) -> bool {
            self.is_favorite.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_favorite(&mut self, v: bool) {
            self.is_favorite = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Result {
        const NAME: &'static str = "Result";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player)?;
                    },
                    16 => {
                        self.is_favorite = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.player.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            if let Some(v) = self.is_favorite {
                my_size += 1 + 1;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.player.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
            }
            if let Some(v) = self.is_favorite {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Result {
            Result::new()
        }

        fn clear(&mut self) {
            self.player.clear();
            self.is_favorite = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Result {
            static instance: Result = Result {
                player: ::steam_vent_proto_common::protobuf::MessageField::none(),
                is_favorite: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlayerRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerRecentAccomplishments.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlayerRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerRecentAccomplishments {
    fn default() -> &'a CMsgClientToGCRequestPlayerRecentAccomplishments {
        <CMsgClientToGCRequestPlayerRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerRecentAccomplishments {
    pub fn new() -> CMsgClientToGCRequestPlayerRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlayerRecentAccomplishments {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerRecentAccomplishments {
        CMsgClientToGCRequestPlayerRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerRecentAccomplishments {
        static instance: CMsgClientToGCRequestPlayerRecentAccomplishments = CMsgClientToGCRequestPlayerRecentAccomplishments {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_player_recent_accomplishments_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.player_accomplishments)
    pub player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgPlayerRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    fn default() -> &'a CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
        <CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    pub fn new() -> CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_player_recent_accomplishments_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_player_recent_accomplishments_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_player_recent_accomplishments_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.player_accomplishments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.player_accomplishments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
        CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.player_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
        static instance: CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse = CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
            result: ::std::option::Option::None,
            player_accomplishments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse`
pub mod cmsg_client_to_gcrequest_player_recent_accomplishments_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlayerHeroRecentAccomplishments)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerHeroRecentAccomplishments.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerHeroRecentAccomplishments.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlayerHeroRecentAccomplishments.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    fn default() -> &'a CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
        <CMsgClientToGCRequestPlayerHeroRecentAccomplishments as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    pub fn new() -> CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional int32 hero_id = 2;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerHeroRecentAccomplishments";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.hero_id {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
        CMsgClientToGCRequestPlayerHeroRecentAccomplishments::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.hero_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
        static instance: CMsgClientToGCRequestPlayerHeroRecentAccomplishments = CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
            account_id: ::std::option::Option::None,
            hero_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.hero_accomplishments)
    pub hero_accomplishments: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgPlayerHeroRecentAccomplishments>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    fn default() -> &'a CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
        <CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    pub fn new() -> CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    const NAME: &'static str = "CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.hero_accomplishments)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.hero_accomplishments.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
        CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.hero_accomplishments.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
        static instance: CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse = CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
            result: ::std::option::Option::None,
            hero_accomplishments: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse`
pub mod cmsg_client_to_gcrequest_player_hero_recent_accomplishments_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitPlayerMatchSurvey)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitPlayerMatchSurvey {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitPlayerMatchSurvey.match_id)
    pub match_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitPlayerMatchSurvey.rating)
    pub rating: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitPlayerMatchSurvey.flags)
    pub flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitPlayerMatchSurvey.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitPlayerMatchSurvey {
    fn default() -> &'a CMsgClientToGCSubmitPlayerMatchSurvey {
        <CMsgClientToGCSubmitPlayerMatchSurvey as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitPlayerMatchSurvey {
    pub fn new() -> CMsgClientToGCSubmitPlayerMatchSurvey {
        ::std::default::Default::default()
    }

    // optional uint64 match_id = 1;

    pub fn match_id(&self) -> u64 {
        self.match_id.unwrap_or(0)
    }

    pub fn clear_match_id(&mut self) {
        self.match_id = ::std::option::Option::None;
    }

    pub fn has_match_id(&self) -> bool {
        self.match_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_match_id(&mut self, v: u64) {
        self.match_id = ::std::option::Option::Some(v);
    }

    // optional sint32 rating = 3;

    pub fn rating(&self) -> i32 {
        self.rating.unwrap_or(0)
    }

    pub fn clear_rating(&mut self) {
        self.rating = ::std::option::Option::None;
    }

    pub fn has_rating(&self) -> bool {
        self.rating.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: i32) {
        self.rating = ::std::option::Option::Some(v);
    }

    // optional uint32 flags = 4;

    pub fn flags(&self) -> u32 {
        self.flags.unwrap_or(0)
    }

    pub fn clear_flags(&mut self) {
        self.flags = ::std::option::Option::None;
    }

    pub fn has_flags(&self) -> bool {
        self.flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flags(&mut self, v: u32) {
        self.flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitPlayerMatchSurvey {
    const NAME: &'static str = "CMsgClientToGCSubmitPlayerMatchSurvey";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.rating = ::std::option::Option::Some(is.read_sint32()?);
                },
                32 => {
                    self.flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.rating {
            my_size += ::steam_vent_proto_common::protobuf::rt::sint32_size(3, v);
        }
        if let Some(v) = self.flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.rating {
            os.write_sint32(3, v)?;
        }
        if let Some(v) = self.flags {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitPlayerMatchSurvey {
        CMsgClientToGCSubmitPlayerMatchSurvey::new()
    }

    fn clear(&mut self) {
        self.match_id = ::std::option::Option::None;
        self.rating = ::std::option::Option::None;
        self.flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitPlayerMatchSurvey {
        static instance: CMsgClientToGCSubmitPlayerMatchSurvey = CMsgClientToGCSubmitPlayerMatchSurvey {
            match_id: ::std::option::Option::None,
            rating: ::std::option::Option::None,
            flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitPlayerMatchSurveyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitPlayerMatchSurveyResponse.eresult)
    pub eresult: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcsubmit_player_match_survey_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitPlayerMatchSurveyResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitPlayerMatchSurveyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    fn default() -> &'a CMsgClientToGCSubmitPlayerMatchSurveyResponse {
        <CMsgClientToGCSubmitPlayerMatchSurveyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    pub fn new() -> CMsgClientToGCSubmitPlayerMatchSurveyResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse eresult = 1;

    pub fn eresult(&self) -> cmsg_client_to_gcsubmit_player_match_survey_response::EResponse {
        match self.eresult {
            Some(e) => e.enum_value_or(cmsg_client_to_gcsubmit_player_match_survey_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcsubmit_player_match_survey_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: cmsg_client_to_gcsubmit_player_match_survey_response::EResponse) {
        self.eresult = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    const NAME: &'static str = "CMsgClientToGCSubmitPlayerMatchSurveyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.eresult = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.eresult {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.eresult {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitPlayerMatchSurveyResponse {
        CMsgClientToGCSubmitPlayerMatchSurveyResponse::new()
    }

    fn clear(&mut self) {
        self.eresult = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitPlayerMatchSurveyResponse {
        static instance: CMsgClientToGCSubmitPlayerMatchSurveyResponse = CMsgClientToGCSubmitPlayerMatchSurveyResponse {
            eresult: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSubmitPlayerMatchSurveyResponse`
pub mod cmsg_client_to_gcsubmit_player_match_survey_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_eAlreadySubmitted)
        k_eAlreadySubmitted = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitPlayerMatchSurveyResponse.EResponse.k_ePlayerNotValid)
        k_ePlayerNotValid = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                5 => ::std::option::Option::Some(EResponse::k_ePlayerNotValid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eAlreadySubmitted" => ::std::option::Option::Some(EResponse::k_eAlreadySubmitted),
                "k_ePlayerNotValid" => ::std::option::Option::Some(EResponse::k_ePlayerNotValid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eAlreadySubmitted,
            EResponse::k_ePlayerNotValid,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientVACReminder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientVACReminder {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientVACReminder.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientVACReminder {
    fn default() -> &'a CMsgGCToClientVACReminder {
        <CMsgGCToClientVACReminder as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientVACReminder {
    pub fn new() -> CMsgGCToClientVACReminder {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientVACReminder {
    const NAME: &'static str = "CMsgGCToClientVACReminder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientVACReminder {
        CMsgGCToClientVACReminder::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientVACReminder {
        static instance: CMsgGCToClientVACReminder = CMsgGCToClientVACReminder {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRequest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRequest {
    fn default() -> &'a CMsgClientToGCUnderDraftRequest {
        <CMsgClientToGCUnderDraftRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRequest {
    pub fn new() -> CMsgClientToGCUnderDraftRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRequest {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRequest {
        CMsgClientToGCUnderDraftRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRequest {
        static instance: CMsgClientToGCUnderDraftRequest = CMsgClientToGCUnderDraftRequest {
            account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftResponse.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftResponse.draft_data)
    pub draft_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgUnderDraftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftResponse {
        <CMsgClientToGCUnderDraftResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftResponse {
    pub fn new() -> CMsgClientToGCUnderDraftResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 account_id = 2;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 3;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.draft_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.draft_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.account_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.draft_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftResponse {
        CMsgClientToGCUnderDraftResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.account_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.draft_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftResponse {
        static instance: CMsgClientToGCUnderDraftResponse = CMsgClientToGCUnderDraftResponse {
            result: ::std::option::Option::None,
            account_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            draft_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftReroll)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftReroll {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftReroll.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftReroll.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftReroll {
    fn default() -> &'a CMsgClientToGCUnderDraftReroll {
        <CMsgClientToGCUnderDraftReroll as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftReroll {
    pub fn new() -> CMsgClientToGCUnderDraftReroll {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftReroll {
    const NAME: &'static str = "CMsgClientToGCUnderDraftReroll";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftReroll {
        CMsgClientToGCUnderDraftReroll::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftReroll {
        static instance: CMsgClientToGCUnderDraftReroll = CMsgClientToGCUnderDraftReroll {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRerollResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRerollResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRerollResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRerollResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRerollResponse.draft_data)
    pub draft_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgUnderDraftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRerollResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRerollResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftRerollResponse {
        <CMsgClientToGCUnderDraftRerollResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRerollResponse {
    pub fn new() -> CMsgClientToGCUnderDraftRerollResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRerollResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRerollResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.draft_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.draft_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.draft_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRerollResponse {
        CMsgClientToGCUnderDraftRerollResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.draft_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRerollResponse {
        static instance: CMsgClientToGCUnderDraftRerollResponse = CMsgClientToGCUnderDraftRerollResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            draft_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftBuy)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftBuy {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuy.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuy.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftBuy.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftBuy {
    fn default() -> &'a CMsgClientToGCUnderDraftBuy {
        <CMsgClientToGCUnderDraftBuy as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftBuy {
    pub fn new() -> CMsgClientToGCUnderDraftBuy {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftBuy {
    const NAME: &'static str = "CMsgClientToGCUnderDraftBuy";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftBuy {
        CMsgClientToGCUnderDraftBuy::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftBuy {
        static instance: CMsgClientToGCUnderDraftBuy = CMsgClientToGCUnderDraftBuy {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientGuildUnderDraftGoldUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientGuildUnderDraftGoldUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientGuildUnderDraftGoldUpdated.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientGuildUnderDraftGoldUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientGuildUnderDraftGoldUpdated {
    fn default() -> &'a CMsgGCToClientGuildUnderDraftGoldUpdated {
        <CMsgGCToClientGuildUnderDraftGoldUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientGuildUnderDraftGoldUpdated {
    pub fn new() -> CMsgGCToClientGuildUnderDraftGoldUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientGuildUnderDraftGoldUpdated {
    const NAME: &'static str = "CMsgGCToClientGuildUnderDraftGoldUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientGuildUnderDraftGoldUpdated {
        CMsgGCToClientGuildUnderDraftGoldUpdated::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientGuildUnderDraftGoldUpdated {
        static instance: CMsgGCToClientGuildUnderDraftGoldUpdated = CMsgGCToClientGuildUnderDraftGoldUpdated {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftBuyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftBuyResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuyResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuyResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuyResponse.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftBuyResponse.draft_data)
    pub draft_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgUnderDraftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftBuyResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftBuyResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftBuyResponse {
        <CMsgClientToGCUnderDraftBuyResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftBuyResponse {
    pub fn new() -> CMsgClientToGCUnderDraftBuyResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftBuyResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftBuyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.draft_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.draft_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.draft_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftBuyResponse {
        CMsgClientToGCUnderDraftBuyResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.draft_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftBuyResponse {
        static instance: CMsgClientToGCUnderDraftBuyResponse = CMsgClientToGCUnderDraftBuyResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            draft_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRollBackBench)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRollBackBench {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRollBackBench.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRollBackBench.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRollBackBench {
    fn default() -> &'a CMsgClientToGCUnderDraftRollBackBench {
        <CMsgClientToGCUnderDraftRollBackBench as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRollBackBench {
    pub fn new() -> CMsgClientToGCUnderDraftRollBackBench {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRollBackBench {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRollBackBench";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRollBackBench {
        CMsgClientToGCUnderDraftRollBackBench::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRollBackBench {
        static instance: CMsgClientToGCUnderDraftRollBackBench = CMsgClientToGCUnderDraftRollBackBench {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRollBackBenchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRollBackBenchResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRollBackBenchResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRollBackBenchResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRollBackBenchResponse.draft_data)
    pub draft_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgUnderDraftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRollBackBenchResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRollBackBenchResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftRollBackBenchResponse {
        <CMsgClientToGCUnderDraftRollBackBenchResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRollBackBenchResponse {
    pub fn new() -> CMsgClientToGCUnderDraftRollBackBenchResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRollBackBenchResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRollBackBenchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.draft_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.draft_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.draft_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRollBackBenchResponse {
        CMsgClientToGCUnderDraftRollBackBenchResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.draft_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRollBackBenchResponse {
        static instance: CMsgClientToGCUnderDraftRollBackBenchResponse = CMsgClientToGCUnderDraftRollBackBenchResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            draft_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftSell)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftSell {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSell.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSell.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftSell.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftSell {
    fn default() -> &'a CMsgClientToGCUnderDraftSell {
        <CMsgClientToGCUnderDraftSell as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftSell {
    pub fn new() -> CMsgClientToGCUnderDraftSell {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 2;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftSell {
    const NAME: &'static str = "CMsgClientToGCUnderDraftSell";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftSell {
        CMsgClientToGCUnderDraftSell::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftSell {
        static instance: CMsgClientToGCUnderDraftSell = CMsgClientToGCUnderDraftSell {
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftSellResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftSellResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSellResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSellResponse.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSellResponse.slot_id)
    pub slot_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftSellResponse.draft_data)
    pub draft_data: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgUnderDraftData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftSellResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftSellResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftSellResponse {
        <CMsgClientToGCUnderDraftSellResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftSellResponse {
    pub fn new() -> CMsgClientToGCUnderDraftSellResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 slot_id = 3;

    pub fn slot_id(&self) -> u32 {
        self.slot_id.unwrap_or(0)
    }

    pub fn clear_slot_id(&mut self) {
        self.slot_id = ::std::option::Option::None;
    }

    pub fn has_slot_id(&self) -> bool {
        self.slot_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_slot_id(&mut self, v: u32) {
        self.slot_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftSellResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftSellResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.slot_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.draft_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.slot_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.draft_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.slot_id {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.draft_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftSellResponse {
        CMsgClientToGCUnderDraftSellResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.slot_id = ::std::option::Option::None;
        self.draft_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftSellResponse {
        static instance: CMsgClientToGCUnderDraftSellResponse = CMsgClientToGCUnderDraftSellResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            slot_id: ::std::option::Option::None,
            draft_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRedeemReward)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRedeemReward {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRedeemReward.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRedeemReward.action_id)
    pub action_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRedeemReward.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRedeemReward {
    fn default() -> &'a CMsgClientToGCUnderDraftRedeemReward {
        <CMsgClientToGCUnderDraftRedeemReward as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRedeemReward {
    pub fn new() -> CMsgClientToGCUnderDraftRedeemReward {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRedeemReward {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRedeemReward";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRedeemReward {
        CMsgClientToGCUnderDraftRedeemReward::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRedeemReward {
        static instance: CMsgClientToGCUnderDraftRedeemReward = CMsgClientToGCUnderDraftRedeemReward {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUnderDraftRedeemRewardResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUnderDraftRedeemRewardResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUnderDraftRedeemRewardResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EUnderDraftResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUnderDraftRedeemRewardResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUnderDraftRedeemRewardResponse {
    fn default() -> &'a CMsgClientToGCUnderDraftRedeemRewardResponse {
        <CMsgClientToGCUnderDraftRedeemRewardResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUnderDraftRedeemRewardResponse {
    pub fn new() -> CMsgClientToGCUnderDraftRedeemRewardResponse {
        ::std::default::Default::default()
    }

    // optional .EUnderDraftResponse result = 1;

    pub fn result(&self) -> EUnderDraftResponse {
        match self.result {
            Some(e) => e.enum_value_or(EUnderDraftResponse::k_eInternalError),
            None => EUnderDraftResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EUnderDraftResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUnderDraftRedeemRewardResponse {
    const NAME: &'static str = "CMsgClientToGCUnderDraftRedeemRewardResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUnderDraftRedeemRewardResponse {
        CMsgClientToGCUnderDraftRedeemRewardResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUnderDraftRedeemRewardResponse {
        static instance: CMsgClientToGCUnderDraftRedeemRewardResponse = CMsgClientToGCUnderDraftRedeemRewardResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitDraftTriviaMatchAnswer)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitDraftTriviaMatchAnswer.chose_radiant_as_winner)
    pub chose_radiant_as_winner: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitDraftTriviaMatchAnswer.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitDraftTriviaMatchAnswer.end_time)
    pub end_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitDraftTriviaMatchAnswer.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    fn default() -> &'a CMsgClientToGCSubmitDraftTriviaMatchAnswer {
        <CMsgClientToGCSubmitDraftTriviaMatchAnswer as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    pub fn new() -> CMsgClientToGCSubmitDraftTriviaMatchAnswer {
        ::std::default::Default::default()
    }

    // optional bool chose_radiant_as_winner = 1;

    pub fn chose_radiant_as_winner(&self) -> bool {
        self.chose_radiant_as_winner.unwrap_or(false)
    }

    pub fn clear_chose_radiant_as_winner(&mut self) {
        self.chose_radiant_as_winner = ::std::option::Option::None;
    }

    pub fn has_chose_radiant_as_winner(&self) -> bool {
        self.chose_radiant_as_winner.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chose_radiant_as_winner(&mut self, v: bool) {
        self.chose_radiant_as_winner = ::std::option::Option::Some(v);
    }

    // optional uint32 event_id = 2;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 end_time = 3;

    pub fn end_time(&self) -> u32 {
        self.end_time.unwrap_or(0)
    }

    pub fn clear_end_time(&mut self) {
        self.end_time = ::std::option::Option::None;
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: u32) {
        self.end_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    const NAME: &'static str = "CMsgClientToGCSubmitDraftTriviaMatchAnswer";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.chose_radiant_as_winner = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.end_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.chose_radiant_as_winner {
            my_size += 1 + 1;
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.end_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.chose_radiant_as_winner {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.end_time {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitDraftTriviaMatchAnswer {
        CMsgClientToGCSubmitDraftTriviaMatchAnswer::new()
    }

    fn clear(&mut self) {
        self.chose_radiant_as_winner = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.end_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitDraftTriviaMatchAnswer {
        static instance: CMsgClientToGCSubmitDraftTriviaMatchAnswer = CMsgClientToGCSubmitDraftTriviaMatchAnswer {
            chose_radiant_as_winner: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            end_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<EDOTADraftTriviaAnswerResult>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    fn default() -> &'a CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
        <CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    pub fn new() -> CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
        ::std::default::Default::default()
    }

    // optional .EDOTADraftTriviaAnswerResult result = 1;

    pub fn result(&self) -> EDOTADraftTriviaAnswerResult {
        match self.result {
            Some(e) => e.enum_value_or(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success),
            None => EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: EDOTADraftTriviaAnswerResult) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    const NAME: &'static str = "CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
        CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
        static instance: CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse = CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgDraftTriviaVoteCount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDraftTriviaVoteCount {
    // message fields
    // @@protoc_insertion_point(field:CMsgDraftTriviaVoteCount.total_votes)
    pub total_votes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraftTriviaVoteCount.radiant_votes)
    pub radiant_votes: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDraftTriviaVoteCount.dire_votes)
    pub dire_votes: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDraftTriviaVoteCount.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDraftTriviaVoteCount {
    fn default() -> &'a CMsgDraftTriviaVoteCount {
        <CMsgDraftTriviaVoteCount as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDraftTriviaVoteCount {
    pub fn new() -> CMsgDraftTriviaVoteCount {
        ::std::default::Default::default()
    }

    // optional uint32 total_votes = 1;

    pub fn total_votes(&self) -> u32 {
        self.total_votes.unwrap_or(0)
    }

    pub fn clear_total_votes(&mut self) {
        self.total_votes = ::std::option::Option::None;
    }

    pub fn has_total_votes(&self) -> bool {
        self.total_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_votes(&mut self, v: u32) {
        self.total_votes = ::std::option::Option::Some(v);
    }

    // optional uint32 radiant_votes = 2;

    pub fn radiant_votes(&self) -> u32 {
        self.radiant_votes.unwrap_or(0)
    }

    pub fn clear_radiant_votes(&mut self) {
        self.radiant_votes = ::std::option::Option::None;
    }

    pub fn has_radiant_votes(&self) -> bool {
        self.radiant_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_radiant_votes(&mut self, v: u32) {
        self.radiant_votes = ::std::option::Option::Some(v);
    }

    // optional uint32 dire_votes = 3;

    pub fn dire_votes(&self) -> u32 {
        self.dire_votes.unwrap_or(0)
    }

    pub fn clear_dire_votes(&mut self) {
        self.dire_votes = ::std::option::Option::None;
    }

    pub fn has_dire_votes(&self) -> bool {
        self.dire_votes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dire_votes(&mut self, v: u32) {
        self.dire_votes = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDraftTriviaVoteCount {
    const NAME: &'static str = "CMsgDraftTriviaVoteCount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.total_votes = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.radiant_votes = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.dire_votes = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.total_votes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.radiant_votes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.dire_votes {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.total_votes {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.radiant_votes {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.dire_votes {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDraftTriviaVoteCount {
        CMsgDraftTriviaVoteCount::new()
    }

    fn clear(&mut self) {
        self.total_votes = ::std::option::Option::None;
        self.radiant_votes = ::std::option::Option::None;
        self.dire_votes = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDraftTriviaVoteCount {
        static instance: CMsgDraftTriviaVoteCount = CMsgDraftTriviaVoteCount {
            total_votes: ::std::option::Option::None,
            radiant_votes: ::std::option::Option::None,
            dire_votes: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestReporterUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestReporterUpdates {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestReporterUpdates.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestReporterUpdates {
    fn default() -> &'a CMsgClientToGCRequestReporterUpdates {
        <CMsgClientToGCRequestReporterUpdates as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestReporterUpdates {
    pub fn new() -> CMsgClientToGCRequestReporterUpdates {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestReporterUpdates {
    const NAME: &'static str = "CMsgClientToGCRequestReporterUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestReporterUpdates {
        CMsgClientToGCRequestReporterUpdates::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestReporterUpdates {
        static instance: CMsgClientToGCRequestReporterUpdates = CMsgClientToGCRequestReporterUpdates {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestReporterUpdatesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestReporterUpdatesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.enum_result)
    pub enum_result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_reporter_updates_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.updates)
    pub updates: ::std::vec::Vec<cmsg_client_to_gcrequest_reporter_updates_response::ReporterUpdate>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.num_reported)
    pub num_reported: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.num_no_action_taken)
    pub num_no_action_taken: ::std::option::Option<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestReporterUpdatesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestReporterUpdatesResponse {
    fn default() -> &'a CMsgClientToGCRequestReporterUpdatesResponse {
        <CMsgClientToGCRequestReporterUpdatesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestReporterUpdatesResponse {
    pub fn new() -> CMsgClientToGCRequestReporterUpdatesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestReporterUpdatesResponse.EResponse enum_result = 1;

    pub fn enum_result(&self) -> cmsg_client_to_gcrequest_reporter_updates_response::EResponse {
        match self.enum_result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_reporter_updates_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_reporter_updates_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_enum_result(&mut self) {
        self.enum_result = ::std::option::Option::None;
    }

    pub fn has_enum_result(&self) -> bool {
        self.enum_result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enum_result(&mut self, v: cmsg_client_to_gcrequest_reporter_updates_response::EResponse) {
        self.enum_result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 num_reported = 3;

    pub fn num_reported(&self) -> i32 {
        self.num_reported.unwrap_or(0)
    }

    pub fn clear_num_reported(&mut self) {
        self.num_reported = ::std::option::Option::None;
    }

    pub fn has_num_reported(&self) -> bool {
        self.num_reported.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_reported(&mut self, v: i32) {
        self.num_reported = ::std::option::Option::Some(v);
    }

    // optional int32 num_no_action_taken = 4;

    pub fn num_no_action_taken(&self) -> i32 {
        self.num_no_action_taken.unwrap_or(0)
    }

    pub fn clear_num_no_action_taken(&mut self) {
        self.num_no_action_taken = ::std::option::Option::None;
    }

    pub fn has_num_no_action_taken(&self) -> bool {
        self.num_no_action_taken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_num_no_action_taken(&mut self, v: i32) {
        self.num_no_action_taken = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestReporterUpdatesResponse {
    const NAME: &'static str = "CMsgClientToGCRequestReporterUpdatesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.enum_result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.updates.push(is.read_message()?);
                },
                24 => {
                    self.num_reported = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.num_no_action_taken = ::std::option::Option::Some(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.enum_result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.updates {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.num_reported {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v);
        }
        if let Some(v) = self.num_no_action_taken {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.enum_result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.updates {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.num_reported {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.num_no_action_taken {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestReporterUpdatesResponse {
        CMsgClientToGCRequestReporterUpdatesResponse::new()
    }

    fn clear(&mut self) {
        self.enum_result = ::std::option::Option::None;
        self.updates.clear();
        self.num_reported = ::std::option::Option::None;
        self.num_no_action_taken = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestReporterUpdatesResponse {
        static instance: CMsgClientToGCRequestReporterUpdatesResponse = CMsgClientToGCRequestReporterUpdatesResponse {
            enum_result: ::std::option::Option::None,
            updates: ::std::vec::Vec::new(),
            num_reported: ::std::option::Option::None,
            num_no_action_taken: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestReporterUpdatesResponse`
pub mod cmsg_client_to_gcrequest_reporter_updates_response {
    // @@protoc_insertion_point(message:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReporterUpdate {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate.match_id)
        pub match_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate.hero_id)
        pub hero_id: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate.report_reason)
        pub report_reason: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate.timestamp)
        pub timestamp: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCRequestReporterUpdatesResponse.ReporterUpdate.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReporterUpdate {
        fn default() -> &'a ReporterUpdate {
            <ReporterUpdate as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl ReporterUpdate {
        pub fn new() -> ReporterUpdate {
            ::std::default::Default::default()
        }

        // optional uint64 match_id = 1;

        pub fn match_id(&self) -> u64 {
            self.match_id.unwrap_or(0)
        }

        pub fn clear_match_id(&mut self) {
            self.match_id = ::std::option::Option::None;
        }

        pub fn has_match_id(&self) -> bool {
            self.match_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_match_id(&mut self, v: u64) {
            self.match_id = ::std::option::Option::Some(v);
        }

        // optional int32 hero_id = 2;

        pub fn hero_id(&self) -> i32 {
            self.hero_id.unwrap_or(0)
        }

        pub fn clear_hero_id(&mut self) {
            self.hero_id = ::std::option::Option::None;
        }

        pub fn has_hero_id(&self) -> bool {
            self.hero_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_hero_id(&mut self, v: i32) {
            self.hero_id = ::std::option::Option::Some(v);
        }

        // optional uint32 report_reason = 3;

        pub fn report_reason(&self) -> u32 {
            self.report_reason.unwrap_or(0)
        }

        pub fn clear_report_reason(&mut self) {
            self.report_reason = ::std::option::Option::None;
        }

        pub fn has_report_reason(&self) -> bool {
            self.report_reason.is_some()
        }

        // Param is passed by value, moved
        pub fn set_report_reason(&mut self, v: u32) {
            self.report_reason = ::std::option::Option::Some(v);
        }

        // optional uint32 timestamp = 4;

        pub fn timestamp(&self) -> u32 {
            self.timestamp.unwrap_or(0)
        }

        pub fn clear_timestamp(&mut self) {
            self.timestamp = ::std::option::Option::None;
        }

        pub fn has_timestamp(&self) -> bool {
            self.timestamp.is_some()
        }

        // Param is passed by value, moved
        pub fn set_timestamp(&mut self, v: u32) {
            self.timestamp = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for ReporterUpdate {
        const NAME: &'static str = "ReporterUpdate";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.match_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    16 => {
                        self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                    },
                    24 => {
                        self.report_reason = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    32 => {
                        self.timestamp = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.match_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
            }
            if let Some(v) = self.hero_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v);
            }
            if let Some(v) = self.report_reason {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            if let Some(v) = self.timestamp {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.match_id {
                os.write_uint64(1, v)?;
            }
            if let Some(v) = self.hero_id {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.report_reason {
                os.write_uint32(3, v)?;
            }
            if let Some(v) = self.timestamp {
                os.write_uint32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReporterUpdate {
            ReporterUpdate::new()
        }

        fn clear(&mut self) {
            self.match_id = ::std::option::Option::None;
            self.hero_id = ::std::option::Option::None;
            self.report_reason = ::std::option::Option::None;
            self.timestamp = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReporterUpdate {
            static instance: ReporterUpdate = ReporterUpdate {
                match_id: ::std::option::Option::None,
                hero_id: ::std::option::Option::None,
                report_reason: ::std::option::Option::None,
                timestamp: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestReporterUpdatesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eNotPermitted)
        k_eNotPermitted = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eNotToSoon)
        k_eNotToSoon = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestReporterUpdatesResponse.EResponse.k_eNotValid)
        k_eNotValid = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                5 => ::std::option::Option::Some(EResponse::k_eNotToSoon),
                6 => ::std::option::Option::Some(EResponse::k_eNotValid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eNotPermitted" => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                "k_eNotToSoon" => ::std::option::Option::Some(EResponse::k_eNotToSoon),
                "k_eNotValid" => ::std::option::Option::Some(EResponse::k_eNotValid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eNotPermitted,
            EResponse::k_eNotToSoon,
            EResponse::k_eNotValid,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCAcknowledgeReporterUpdates)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCAcknowledgeReporterUpdates {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCAcknowledgeReporterUpdates.match_ids)
    pub match_ids: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCAcknowledgeReporterUpdates.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCAcknowledgeReporterUpdates {
    fn default() -> &'a CMsgClientToGCAcknowledgeReporterUpdates {
        <CMsgClientToGCAcknowledgeReporterUpdates as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCAcknowledgeReporterUpdates {
    pub fn new() -> CMsgClientToGCAcknowledgeReporterUpdates {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCAcknowledgeReporterUpdates {
    const NAME: &'static str = "CMsgClientToGCAcknowledgeReporterUpdates";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.match_ids)?;
                },
                8 => {
                    self.match_ids.push(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.match_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.match_ids {
            os.write_uint64(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCAcknowledgeReporterUpdates {
        CMsgClientToGCAcknowledgeReporterUpdates::new()
    }

    fn clear(&mut self) {
        self.match_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCAcknowledgeReporterUpdates {
        static instance: CMsgClientToGCAcknowledgeReporterUpdates = CMsgClientToGCAcknowledgeReporterUpdates {
            match_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRecalibrateMMR)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRecalibrateMMR {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRecalibrateMMR.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRecalibrateMMR {
    fn default() -> &'a CMsgClientToGCRecalibrateMMR {
        <CMsgClientToGCRecalibrateMMR as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRecalibrateMMR {
    pub fn new() -> CMsgClientToGCRecalibrateMMR {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRecalibrateMMR {
    const NAME: &'static str = "CMsgClientToGCRecalibrateMMR";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRecalibrateMMR {
        CMsgClientToGCRecalibrateMMR::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRecalibrateMMR {
        static instance: CMsgClientToGCRecalibrateMMR = CMsgClientToGCRecalibrateMMR {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRecalibrateMMRResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRecalibrateMMRResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRecalibrateMMRResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrecalibrate_mmrresponse::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRecalibrateMMRResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRecalibrateMMRResponse {
    fn default() -> &'a CMsgClientToGCRecalibrateMMRResponse {
        <CMsgClientToGCRecalibrateMMRResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRecalibrateMMRResponse {
    pub fn new() -> CMsgClientToGCRecalibrateMMRResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRecalibrateMMRResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrecalibrate_mmrresponse::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrecalibrate_mmrresponse::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrecalibrate_mmrresponse::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrecalibrate_mmrresponse::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRecalibrateMMRResponse {
    const NAME: &'static str = "CMsgClientToGCRecalibrateMMRResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRecalibrateMMRResponse {
        CMsgClientToGCRecalibrateMMRResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRecalibrateMMRResponse {
        static instance: CMsgClientToGCRecalibrateMMRResponse = CMsgClientToGCRecalibrateMMRResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRecalibrateMMRResponse`
pub mod cmsg_client_to_gcrecalibrate_mmrresponse {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRecalibrateMMRResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eNotPermitted)
        k_eNotPermitted = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eNotToSoon)
        k_eNotToSoon = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRecalibrateMMRResponse.EResponse.k_eNotValid)
        k_eNotValid = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                5 => ::std::option::Option::Some(EResponse::k_eNotToSoon),
                6 => ::std::option::Option::Some(EResponse::k_eNotValid),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eNotPermitted" => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                "k_eNotToSoon" => ::std::option::Option::Some(EResponse::k_eNotToSoon),
                "k_eNotValid" => ::std::option::Option::Some(EResponse::k_eNotValid),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eNotPermitted,
            EResponse::k_eNotToSoon,
            EResponse::k_eNotValid,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgDOTAPostGameItemAwardNotification)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgDOTAPostGameItemAwardNotification {
    // message fields
    // @@protoc_insertion_point(field:CMsgDOTAPostGameItemAwardNotification.receiver_account_id)
    pub receiver_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAPostGameItemAwardNotification.item_def_index)
    pub item_def_index: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgDOTAPostGameItemAwardNotification.action_id)
    pub action_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgDOTAPostGameItemAwardNotification.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgDOTAPostGameItemAwardNotification {
    fn default() -> &'a CMsgDOTAPostGameItemAwardNotification {
        <CMsgDOTAPostGameItemAwardNotification as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgDOTAPostGameItemAwardNotification {
    pub fn new() -> CMsgDOTAPostGameItemAwardNotification {
        ::std::default::Default::default()
    }

    // optional uint32 receiver_account_id = 1;

    pub fn receiver_account_id(&self) -> u32 {
        self.receiver_account_id.unwrap_or(0)
    }

    pub fn clear_receiver_account_id(&mut self) {
        self.receiver_account_id = ::std::option::Option::None;
    }

    pub fn has_receiver_account_id(&self) -> bool {
        self.receiver_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_receiver_account_id(&mut self, v: u32) {
        self.receiver_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 action_id = 3;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgDOTAPostGameItemAwardNotification {
    const NAME: &'static str = "CMsgDOTAPostGameItemAwardNotification";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.receiver_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.item_def_index)?;
                },
                16 => {
                    self.item_def_index.push(is.read_uint32()?);
                },
                24 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.receiver_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.item_def_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.receiver_account_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.item_def_index {
            os.write_uint32(2, *v)?;
        };
        if let Some(v) = self.action_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgDOTAPostGameItemAwardNotification {
        CMsgDOTAPostGameItemAwardNotification::new()
    }

    fn clear(&mut self) {
        self.receiver_account_id = ::std::option::Option::None;
        self.item_def_index.clear();
        self.action_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgDOTAPostGameItemAwardNotification {
        static instance: CMsgDOTAPostGameItemAwardNotification = CMsgDOTAPostGameItemAwardNotification {
            receiver_account_id: ::std::option::Option::None,
            item_def_index: ::std::vec::Vec::new(),
            action_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetOWMatchDetails)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetOWMatchDetails {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetOWMatchDetails.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetOWMatchDetails {
    fn default() -> &'a CMsgClientToGCGetOWMatchDetails {
        <CMsgClientToGCGetOWMatchDetails as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetOWMatchDetails {
    pub fn new() -> CMsgClientToGCGetOWMatchDetails {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetOWMatchDetails {
    const NAME: &'static str = "CMsgClientToGCGetOWMatchDetails";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetOWMatchDetails {
        CMsgClientToGCGetOWMatchDetails::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetOWMatchDetails {
        static instance: CMsgClientToGCGetOWMatchDetails = CMsgClientToGCGetOWMatchDetails {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetOWMatchDetailsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetOWMatchDetailsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_owmatch_details_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.decryption_key)
    pub decryption_key: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.cluster)
    pub cluster: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.overwatch_salt)
    pub overwatch_salt: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.target_player_slot)
    pub target_player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.markers)
    pub markers: ::std::vec::Vec<cmsg_client_to_gcget_owmatch_details_response::Marker>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.report_reason)
    pub report_reason: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EOverwatchReportReason>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.target_hero_id)
    pub target_hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.rank_tier)
    pub rank_tier: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.lane_selection_flags)
    pub lane_selection_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetOWMatchDetailsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetOWMatchDetailsResponse {
    fn default() -> &'a CMsgClientToGCGetOWMatchDetailsResponse {
        <CMsgClientToGCGetOWMatchDetailsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetOWMatchDetailsResponse {
    pub fn new() -> CMsgClientToGCGetOWMatchDetailsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetOWMatchDetailsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_owmatch_details_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_owmatch_details_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_owmatch_details_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_owmatch_details_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 overwatch_replay_id = 2;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }

    // optional uint64 decryption_key = 3;

    pub fn decryption_key(&self) -> u64 {
        self.decryption_key.unwrap_or(0)
    }

    pub fn clear_decryption_key(&mut self) {
        self.decryption_key = ::std::option::Option::None;
    }

    pub fn has_decryption_key(&self) -> bool {
        self.decryption_key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_decryption_key(&mut self, v: u64) {
        self.decryption_key = ::std::option::Option::Some(v);
    }

    // optional uint32 cluster = 4;

    pub fn cluster(&self) -> u32 {
        self.cluster.unwrap_or(0)
    }

    pub fn clear_cluster(&mut self) {
        self.cluster = ::std::option::Option::None;
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: u32) {
        self.cluster = ::std::option::Option::Some(v);
    }

    // optional uint32 overwatch_salt = 5;

    pub fn overwatch_salt(&self) -> u32 {
        self.overwatch_salt.unwrap_or(0)
    }

    pub fn clear_overwatch_salt(&mut self) {
        self.overwatch_salt = ::std::option::Option::None;
    }

    pub fn has_overwatch_salt(&self) -> bool {
        self.overwatch_salt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_salt(&mut self, v: u32) {
        self.overwatch_salt = ::std::option::Option::Some(v);
    }

    // optional uint32 target_player_slot = 6;

    pub fn target_player_slot(&self) -> u32 {
        self.target_player_slot.unwrap_or(0)
    }

    pub fn clear_target_player_slot(&mut self) {
        self.target_player_slot = ::std::option::Option::None;
    }

    pub fn has_target_player_slot(&self) -> bool {
        self.target_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_slot(&mut self, v: u32) {
        self.target_player_slot = ::std::option::Option::Some(v);
    }

    // optional .EOverwatchReportReason report_reason = 8;

    pub fn report_reason(&self) -> super::dota_shared_enums::EOverwatchReportReason {
        match self.report_reason {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown),
            None => super::dota_shared_enums::EOverwatchReportReason::k_EOverwatchReportReason_Unknown,
        }
    }

    pub fn clear_report_reason(&mut self) {
        self.report_reason = ::std::option::Option::None;
    }

    pub fn has_report_reason(&self) -> bool {
        self.report_reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_report_reason(&mut self, v: super::dota_shared_enums::EOverwatchReportReason) {
        self.report_reason = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional int32 target_hero_id = 9;

    pub fn target_hero_id(&self) -> i32 {
        self.target_hero_id.unwrap_or(0)
    }

    pub fn clear_target_hero_id(&mut self) {
        self.target_hero_id = ::std::option::Option::None;
    }

    pub fn has_target_hero_id(&self) -> bool {
        self.target_hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_hero_id(&mut self, v: i32) {
        self.target_hero_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rank_tier = 10;

    pub fn rank_tier(&self) -> u32 {
        self.rank_tier.unwrap_or(0)
    }

    pub fn clear_rank_tier(&mut self) {
        self.rank_tier = ::std::option::Option::None;
    }

    pub fn has_rank_tier(&self) -> bool {
        self.rank_tier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rank_tier(&mut self, v: u32) {
        self.rank_tier = ::std::option::Option::Some(v);
    }

    // optional uint32 lane_selection_flags = 11;

    pub fn lane_selection_flags(&self) -> u32 {
        self.lane_selection_flags.unwrap_or(0)
    }

    pub fn clear_lane_selection_flags(&mut self) {
        self.lane_selection_flags = ::std::option::Option::None;
    }

    pub fn has_lane_selection_flags(&self) -> bool {
        self.lane_selection_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lane_selection_flags(&mut self, v: u32) {
        self.lane_selection_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetOWMatchDetailsResponse {
    const NAME: &'static str = "CMsgClientToGCGetOWMatchDetailsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.decryption_key = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.cluster = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.overwatch_salt = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                58 => {
                    self.markers.push(is.read_message()?);
                },
                64 => {
                    self.report_reason = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                72 => {
                    self.target_hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                80 => {
                    self.rank_tier = ::std::option::Option::Some(is.read_uint32()?);
                },
                88 => {
                    self.lane_selection_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.decryption_key {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.cluster {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.overwatch_salt {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.target_player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        for value in &self.markers {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.report_reason {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(8, v.value());
        }
        if let Some(v) = self.target_hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(9, v);
        }
        if let Some(v) = self.rank_tier {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(10, v);
        }
        if let Some(v) = self.lane_selection_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(11, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.decryption_key {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.cluster {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.overwatch_salt {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.target_player_slot {
            os.write_uint32(6, v)?;
        }
        for v in &self.markers {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.report_reason {
            os.write_enum(8, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.target_hero_id {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.rank_tier {
            os.write_uint32(10, v)?;
        }
        if let Some(v) = self.lane_selection_flags {
            os.write_uint32(11, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetOWMatchDetailsResponse {
        CMsgClientToGCGetOWMatchDetailsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.overwatch_replay_id = ::std::option::Option::None;
        self.decryption_key = ::std::option::Option::None;
        self.cluster = ::std::option::Option::None;
        self.overwatch_salt = ::std::option::Option::None;
        self.target_player_slot = ::std::option::Option::None;
        self.markers.clear();
        self.report_reason = ::std::option::Option::None;
        self.target_hero_id = ::std::option::Option::None;
        self.rank_tier = ::std::option::Option::None;
        self.lane_selection_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetOWMatchDetailsResponse {
        static instance: CMsgClientToGCGetOWMatchDetailsResponse = CMsgClientToGCGetOWMatchDetailsResponse {
            result: ::std::option::Option::None,
            overwatch_replay_id: ::std::option::Option::None,
            decryption_key: ::std::option::Option::None,
            cluster: ::std::option::Option::None,
            overwatch_salt: ::std::option::Option::None,
            target_player_slot: ::std::option::Option::None,
            markers: ::std::vec::Vec::new(),
            report_reason: ::std::option::Option::None,
            target_hero_id: ::std::option::Option::None,
            rank_tier: ::std::option::Option::None,
            lane_selection_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetOWMatchDetailsResponse`
pub mod cmsg_client_to_gcget_owmatch_details_response {
    // @@protoc_insertion_point(message:CMsgClientToGCGetOWMatchDetailsResponse.Marker)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Marker {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.Marker.start_game_time_s)
        pub start_game_time_s: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetOWMatchDetailsResponse.Marker.end_game_time_s)
        pub end_game_time_s: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetOWMatchDetailsResponse.Marker.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Marker {
        fn default() -> &'a Marker {
            <Marker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Marker {
        pub fn new() -> Marker {
            ::std::default::Default::default()
        }

        // optional uint32 start_game_time_s = 1;

        pub fn start_game_time_s(&self) -> u32 {
            self.start_game_time_s.unwrap_or(0)
        }

        pub fn clear_start_game_time_s(&mut self) {
            self.start_game_time_s = ::std::option::Option::None;
        }

        pub fn has_start_game_time_s(&self) -> bool {
            self.start_game_time_s.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start_game_time_s(&mut self, v: u32) {
            self.start_game_time_s = ::std::option::Option::Some(v);
        }

        // optional uint32 end_game_time_s = 2;

        pub fn end_game_time_s(&self) -> u32 {
            self.end_game_time_s.unwrap_or(0)
        }

        pub fn clear_end_game_time_s(&mut self) {
            self.end_game_time_s = ::std::option::Option::None;
        }

        pub fn has_end_game_time_s(&self) -> bool {
            self.end_game_time_s.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end_game_time_s(&mut self, v: u32) {
            self.end_game_time_s = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Marker {
        const NAME: &'static str = "Marker";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start_game_time_s = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.end_game_time_s = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start_game_time_s {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.end_game_time_s {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.start_game_time_s {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.end_game_time_s {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Marker {
            Marker::new()
        }

        fn clear(&mut self) {
            self.start_game_time_s = ::std::option::Option::None;
            self.end_game_time_s = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Marker {
            static instance: Marker = Marker {
                start_game_time_s: ::std::option::Option::None,
                end_game_time_s: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetOWMatchDetailsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eNotPermitted)
        k_eNotPermitted = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetOWMatchDetailsResponse.EResponse.k_eNoCaseAvailable)
        k_eNoCaseAvailable = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                5 => ::std::option::Option::Some(EResponse::k_eNoCaseAvailable),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eNotPermitted" => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                "k_eNoCaseAvailable" => ::std::option::Option::Some(EResponse::k_eNoCaseAvailable),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eNotPermitted,
            EResponse::k_eNoCaseAvailable,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitOWConviction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitOWConviction {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConviction.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConviction.target_player_slot)
    pub target_player_slot: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConviction.cheating_conviction)
    pub cheating_conviction: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::EOverwatchConviction>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConviction.griefing_conviction)
    pub griefing_conviction: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::EOverwatchConviction>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitOWConviction.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitOWConviction {
    fn default() -> &'a CMsgClientToGCSubmitOWConviction {
        <CMsgClientToGCSubmitOWConviction as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitOWConviction {
    pub fn new() -> CMsgClientToGCSubmitOWConviction {
        ::std::default::Default::default()
    }

    // optional uint64 overwatch_replay_id = 1;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_player_slot = 2;

    pub fn target_player_slot(&self) -> u32 {
        self.target_player_slot.unwrap_or(0)
    }

    pub fn clear_target_player_slot(&mut self) {
        self.target_player_slot = ::std::option::Option::None;
    }

    pub fn has_target_player_slot(&self) -> bool {
        self.target_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_slot(&mut self, v: u32) {
        self.target_player_slot = ::std::option::Option::Some(v);
    }

    // optional .EOverwatchConviction cheating_conviction = 3;

    pub fn cheating_conviction(&self) -> super::dota_gcmessages_common::EOverwatchConviction {
        match self.cheating_conviction {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::EOverwatchConviction::k_EOverwatchConviction_None),
            None => super::dota_gcmessages_common::EOverwatchConviction::k_EOverwatchConviction_None,
        }
    }

    pub fn clear_cheating_conviction(&mut self) {
        self.cheating_conviction = ::std::option::Option::None;
    }

    pub fn has_cheating_conviction(&self) -> bool {
        self.cheating_conviction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cheating_conviction(&mut self, v: super::dota_gcmessages_common::EOverwatchConviction) {
        self.cheating_conviction = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EOverwatchConviction griefing_conviction = 4;

    pub fn griefing_conviction(&self) -> super::dota_gcmessages_common::EOverwatchConviction {
        match self.griefing_conviction {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::EOverwatchConviction::k_EOverwatchConviction_None),
            None => super::dota_gcmessages_common::EOverwatchConviction::k_EOverwatchConviction_None,
        }
    }

    pub fn clear_griefing_conviction(&mut self) {
        self.griefing_conviction = ::std::option::Option::None;
    }

    pub fn has_griefing_conviction(&self) -> bool {
        self.griefing_conviction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_griefing_conviction(&mut self, v: super::dota_gcmessages_common::EOverwatchConviction) {
        self.griefing_conviction = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitOWConviction {
    const NAME: &'static str = "CMsgClientToGCSubmitOWConviction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.cheating_conviction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                32 => {
                    self.griefing_conviction = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.cheating_conviction {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        if let Some(v) = self.griefing_conviction {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(4, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_player_slot {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.cheating_conviction {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.griefing_conviction {
            os.write_enum(4, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitOWConviction {
        CMsgClientToGCSubmitOWConviction::new()
    }

    fn clear(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
        self.target_player_slot = ::std::option::Option::None;
        self.cheating_conviction = ::std::option::Option::None;
        self.griefing_conviction = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitOWConviction {
        static instance: CMsgClientToGCSubmitOWConviction = CMsgClientToGCSubmitOWConviction {
            overwatch_replay_id: ::std::option::Option::None,
            target_player_slot: ::std::option::Option::None,
            cheating_conviction: ::std::option::Option::None,
            griefing_conviction: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSubmitOWConvictionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSubmitOWConvictionResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConvictionResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcsubmit_owconviction_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSubmitOWConvictionResponse.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSubmitOWConvictionResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSubmitOWConvictionResponse {
    fn default() -> &'a CMsgClientToGCSubmitOWConvictionResponse {
        <CMsgClientToGCSubmitOWConvictionResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSubmitOWConvictionResponse {
    pub fn new() -> CMsgClientToGCSubmitOWConvictionResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSubmitOWConvictionResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcsubmit_owconviction_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcsubmit_owconviction_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcsubmit_owconviction_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcsubmit_owconviction_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 overwatch_replay_id = 2;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSubmitOWConvictionResponse {
    const NAME: &'static str = "CMsgClientToGCSubmitOWConvictionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSubmitOWConvictionResponse {
        CMsgClientToGCSubmitOWConvictionResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.overwatch_replay_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSubmitOWConvictionResponse {
        static instance: CMsgClientToGCSubmitOWConvictionResponse = CMsgClientToGCSubmitOWConvictionResponse {
            result: ::std::option::Option::None,
            overwatch_replay_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSubmitOWConvictionResponse`
pub mod cmsg_client_to_gcsubmit_owconviction_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSubmitOWConvictionResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eNotPermitted)
        k_eNotPermitted = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eInvalidReplayID)
        k_eInvalidReplayID = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eInvalidConviction)
        k_eInvalidConviction = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSubmitOWConvictionResponse.EResponse.k_eInvalidPlayerSlot)
        k_eInvalidPlayerSlot = 7,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidReplayID),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidConviction),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidPlayerSlot),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eNotPermitted" => ::std::option::Option::Some(EResponse::k_eNotPermitted),
                "k_eInvalidReplayID" => ::std::option::Option::Some(EResponse::k_eInvalidReplayID),
                "k_eInvalidConviction" => ::std::option::Option::Some(EResponse::k_eInvalidConviction),
                "k_eInvalidPlayerSlot" => ::std::option::Option::Some(EResponse::k_eInvalidPlayerSlot),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eNotPermitted,
            EResponse::k_eInvalidReplayID,
            EResponse::k_eInvalidConviction,
            EResponse::k_eInvalidPlayerSlot,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCChinaSSAURLRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCChinaSSAURLRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCChinaSSAURLRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCChinaSSAURLRequest {
    fn default() -> &'a CMsgClientToGCChinaSSAURLRequest {
        <CMsgClientToGCChinaSSAURLRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCChinaSSAURLRequest {
    pub fn new() -> CMsgClientToGCChinaSSAURLRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCChinaSSAURLRequest {
    const NAME: &'static str = "CMsgClientToGCChinaSSAURLRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCChinaSSAURLRequest {
        CMsgClientToGCChinaSSAURLRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCChinaSSAURLRequest {
        static instance: CMsgClientToGCChinaSSAURLRequest = CMsgClientToGCChinaSSAURLRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCChinaSSAURLResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCChinaSSAURLResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCChinaSSAURLResponse.agreement_url)
    pub agreement_url: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCChinaSSAURLResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCChinaSSAURLResponse {
    fn default() -> &'a CMsgClientToGCChinaSSAURLResponse {
        <CMsgClientToGCChinaSSAURLResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCChinaSSAURLResponse {
    pub fn new() -> CMsgClientToGCChinaSSAURLResponse {
        ::std::default::Default::default()
    }

    // optional string agreement_url = 1;

    pub fn agreement_url(&self) -> &str {
        match self.agreement_url.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_agreement_url(&mut self) {
        self.agreement_url = ::std::option::Option::None;
    }

    pub fn has_agreement_url(&self) -> bool {
        self.agreement_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agreement_url(&mut self, v: ::std::string::String) {
        self.agreement_url = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_agreement_url(&mut self) -> &mut ::std::string::String {
        if self.agreement_url.is_none() {
            self.agreement_url = ::std::option::Option::Some(::std::string::String::new());
        }
        self.agreement_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_agreement_url(&mut self) -> ::std::string::String {
        self.agreement_url.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCChinaSSAURLResponse {
    const NAME: &'static str = "CMsgClientToGCChinaSSAURLResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.agreement_url = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.agreement_url.as_ref() {
            my_size += ::steam_vent_proto_common::protobuf::rt::string_size(1, &v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.agreement_url.as_ref() {
            os.write_string(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCChinaSSAURLResponse {
        CMsgClientToGCChinaSSAURLResponse::new()
    }

    fn clear(&mut self) {
        self.agreement_url = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCChinaSSAURLResponse {
        static instance: CMsgClientToGCChinaSSAURLResponse = CMsgClientToGCChinaSSAURLResponse {
            agreement_url: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCChinaSSAAcceptedRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCChinaSSAAcceptedRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCChinaSSAAcceptedRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCChinaSSAAcceptedRequest {
    fn default() -> &'a CMsgClientToGCChinaSSAAcceptedRequest {
        <CMsgClientToGCChinaSSAAcceptedRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCChinaSSAAcceptedRequest {
    pub fn new() -> CMsgClientToGCChinaSSAAcceptedRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCChinaSSAAcceptedRequest {
    const NAME: &'static str = "CMsgClientToGCChinaSSAAcceptedRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCChinaSSAAcceptedRequest {
        CMsgClientToGCChinaSSAAcceptedRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCChinaSSAAcceptedRequest {
        static instance: CMsgClientToGCChinaSSAAcceptedRequest = CMsgClientToGCChinaSSAAcceptedRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCChinaSSAAcceptedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCChinaSSAAcceptedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCChinaSSAAcceptedResponse.agreement_accepted)
    pub agreement_accepted: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCChinaSSAAcceptedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCChinaSSAAcceptedResponse {
    fn default() -> &'a CMsgClientToGCChinaSSAAcceptedResponse {
        <CMsgClientToGCChinaSSAAcceptedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCChinaSSAAcceptedResponse {
    pub fn new() -> CMsgClientToGCChinaSSAAcceptedResponse {
        ::std::default::Default::default()
    }

    // optional bool agreement_accepted = 1;

    pub fn agreement_accepted(&self) -> bool {
        self.agreement_accepted.unwrap_or(false)
    }

    pub fn clear_agreement_accepted(&mut self) {
        self.agreement_accepted = ::std::option::Option::None;
    }

    pub fn has_agreement_accepted(&self) -> bool {
        self.agreement_accepted.is_some()
    }

    // Param is passed by value, moved
    pub fn set_agreement_accepted(&mut self, v: bool) {
        self.agreement_accepted = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCChinaSSAAcceptedResponse {
    const NAME: &'static str = "CMsgClientToGCChinaSSAAcceptedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.agreement_accepted = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.agreement_accepted {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.agreement_accepted {
            os.write_bool(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCChinaSSAAcceptedResponse {
        CMsgClientToGCChinaSSAAcceptedResponse::new()
    }

    fn clear(&mut self) {
        self.agreement_accepted = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCChinaSSAAcceptedResponse {
        static instance: CMsgClientToGCChinaSSAAcceptedResponse = CMsgClientToGCChinaSSAAcceptedResponse {
            agreement_accepted: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientOverwatchCasesAvailable)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientOverwatchCasesAvailable {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientOverwatchCasesAvailable.expire_time)
    pub expire_time: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientOverwatchCasesAvailable.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientOverwatchCasesAvailable {
    fn default() -> &'a CMsgGCToClientOverwatchCasesAvailable {
        <CMsgGCToClientOverwatchCasesAvailable as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientOverwatchCasesAvailable {
    pub fn new() -> CMsgGCToClientOverwatchCasesAvailable {
        ::std::default::Default::default()
    }

    // optional fixed32 expire_time = 1;

    pub fn expire_time(&self) -> u32 {
        self.expire_time.unwrap_or(0)
    }

    pub fn clear_expire_time(&mut self) {
        self.expire_time = ::std::option::Option::None;
    }

    pub fn has_expire_time(&self) -> bool {
        self.expire_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: u32) {
        self.expire_time = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientOverwatchCasesAvailable {
    const NAME: &'static str = "CMsgGCToClientOverwatchCasesAvailable";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.expire_time = ::std::option::Option::Some(is.read_fixed32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.expire_time {
            my_size += 1 + 4;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.expire_time {
            os.write_fixed32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientOverwatchCasesAvailable {
        CMsgGCToClientOverwatchCasesAvailable::new()
    }

    fn clear(&mut self) {
        self.expire_time = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientOverwatchCasesAvailable {
        static instance: CMsgGCToClientOverwatchCasesAvailable = CMsgGCToClientOverwatchCasesAvailable {
            expire_time: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCStartWatchingOverwatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCStartWatchingOverwatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCStartWatchingOverwatch.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCStartWatchingOverwatch.target_player_slot)
    pub target_player_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCStartWatchingOverwatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCStartWatchingOverwatch {
    fn default() -> &'a CMsgClientToGCStartWatchingOverwatch {
        <CMsgClientToGCStartWatchingOverwatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCStartWatchingOverwatch {
    pub fn new() -> CMsgClientToGCStartWatchingOverwatch {
        ::std::default::Default::default()
    }

    // optional uint64 overwatch_replay_id = 1;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_player_slot = 2;

    pub fn target_player_slot(&self) -> u32 {
        self.target_player_slot.unwrap_or(0)
    }

    pub fn clear_target_player_slot(&mut self) {
        self.target_player_slot = ::std::option::Option::None;
    }

    pub fn has_target_player_slot(&self) -> bool {
        self.target_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_slot(&mut self, v: u32) {
        self.target_player_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCStartWatchingOverwatch {
    const NAME: &'static str = "CMsgClientToGCStartWatchingOverwatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_player_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCStartWatchingOverwatch {
        CMsgClientToGCStartWatchingOverwatch::new()
    }

    fn clear(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
        self.target_player_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCStartWatchingOverwatch {
        static instance: CMsgClientToGCStartWatchingOverwatch = CMsgClientToGCStartWatchingOverwatch {
            overwatch_replay_id: ::std::option::Option::None,
            target_player_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCStopWatchingOverwatch)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCStopWatchingOverwatch {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCStopWatchingOverwatch.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCStopWatchingOverwatch.target_player_slot)
    pub target_player_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCStopWatchingOverwatch.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCStopWatchingOverwatch {
    fn default() -> &'a CMsgClientToGCStopWatchingOverwatch {
        <CMsgClientToGCStopWatchingOverwatch as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCStopWatchingOverwatch {
    pub fn new() -> CMsgClientToGCStopWatchingOverwatch {
        ::std::default::Default::default()
    }

    // optional uint64 overwatch_replay_id = 1;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }

    // optional uint32 target_player_slot = 2;

    pub fn target_player_slot(&self) -> u32 {
        self.target_player_slot.unwrap_or(0)
    }

    pub fn clear_target_player_slot(&mut self) {
        self.target_player_slot = ::std::option::Option::None;
    }

    pub fn has_target_player_slot(&self) -> bool {
        self.target_player_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_player_slot(&mut self, v: u32) {
        self.target_player_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCStopWatchingOverwatch {
    const NAME: &'static str = "CMsgClientToGCStopWatchingOverwatch";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.target_player_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.target_player_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.target_player_slot {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCStopWatchingOverwatch {
        CMsgClientToGCStopWatchingOverwatch::new()
    }

    fn clear(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
        self.target_player_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCStopWatchingOverwatch {
        static instance: CMsgClientToGCStopWatchingOverwatch = CMsgClientToGCStopWatchingOverwatch {
            overwatch_replay_id: ::std::option::Option::None,
            target_player_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOverwatchReplayError)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOverwatchReplayError {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOverwatchReplayError.overwatch_replay_id)
    pub overwatch_replay_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOverwatchReplayError.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOverwatchReplayError {
    fn default() -> &'a CMsgClientToGCOverwatchReplayError {
        <CMsgClientToGCOverwatchReplayError as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOverwatchReplayError {
    pub fn new() -> CMsgClientToGCOverwatchReplayError {
        ::std::default::Default::default()
    }

    // optional uint64 overwatch_replay_id = 1;

    pub fn overwatch_replay_id(&self) -> u64 {
        self.overwatch_replay_id.unwrap_or(0)
    }

    pub fn clear_overwatch_replay_id(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
    }

    pub fn has_overwatch_replay_id(&self) -> bool {
        self.overwatch_replay_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_overwatch_replay_id(&mut self, v: u64) {
        self.overwatch_replay_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOverwatchReplayError {
    const NAME: &'static str = "CMsgClientToGCOverwatchReplayError";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.overwatch_replay_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.overwatch_replay_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.overwatch_replay_id {
            os.write_uint64(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOverwatchReplayError {
        CMsgClientToGCOverwatchReplayError::new()
    }

    fn clear(&mut self) {
        self.overwatch_replay_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOverwatchReplayError {
        static instance: CMsgClientToGCOverwatchReplayError = CMsgClientToGCOverwatchReplayError {
            overwatch_replay_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetDPCFavorites)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetDPCFavorites {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetDPCFavorites.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetDPCFavorites {
    fn default() -> &'a CMsgClientToGCGetDPCFavorites {
        <CMsgClientToGCGetDPCFavorites as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetDPCFavorites {
    pub fn new() -> CMsgClientToGCGetDPCFavorites {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetDPCFavorites {
    const NAME: &'static str = "CMsgClientToGCGetDPCFavorites";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetDPCFavorites {
        CMsgClientToGCGetDPCFavorites::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetDPCFavorites {
        static instance: CMsgClientToGCGetDPCFavorites = CMsgClientToGCGetDPCFavorites {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetDPCFavoritesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetDPCFavoritesResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetDPCFavoritesResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_dpcfavorites_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetDPCFavoritesResponse.favorites)
    pub favorites: ::std::vec::Vec<cmsg_client_to_gcget_dpcfavorites_response::Favorite>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetDPCFavoritesResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetDPCFavoritesResponse {
    fn default() -> &'a CMsgClientToGCGetDPCFavoritesResponse {
        <CMsgClientToGCGetDPCFavoritesResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetDPCFavoritesResponse {
    pub fn new() -> CMsgClientToGCGetDPCFavoritesResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetDPCFavoritesResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcget_dpcfavorites_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_dpcfavorites_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_dpcfavorites_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcget_dpcfavorites_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetDPCFavoritesResponse {
    const NAME: &'static str = "CMsgClientToGCGetDPCFavoritesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.favorites.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.favorites {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.favorites {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetDPCFavoritesResponse {
        CMsgClientToGCGetDPCFavoritesResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.favorites.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetDPCFavoritesResponse {
        static instance: CMsgClientToGCGetDPCFavoritesResponse = CMsgClientToGCGetDPCFavoritesResponse {
            result: ::std::option::Option::None,
            favorites: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetDPCFavoritesResponse`
pub mod cmsg_client_to_gcget_dpcfavorites_response {
    // @@protoc_insertion_point(message:CMsgClientToGCGetDPCFavoritesResponse.Favorite)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Favorite {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCGetDPCFavoritesResponse.Favorite.favorite_type)
        pub favorite_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::super::dota_shared_enums::EDPCFavoriteType>>,
        // @@protoc_insertion_point(field:CMsgClientToGCGetDPCFavoritesResponse.Favorite.favorite_id)
        pub favorite_id: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCGetDPCFavoritesResponse.Favorite.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Favorite {
        fn default() -> &'a Favorite {
            <Favorite as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Favorite {
        pub fn new() -> Favorite {
            ::std::default::Default::default()
        }

        // optional .EDPCFavoriteType favorite_type = 1;

        pub fn favorite_type(&self) -> super::super::dota_shared_enums::EDPCFavoriteType {
            match self.favorite_type {
                Some(e) => e.enum_value_or(super::super::dota_shared_enums::EDPCFavoriteType::FAVORITE_TYPE_ALL),
                None => super::super::dota_shared_enums::EDPCFavoriteType::FAVORITE_TYPE_ALL,
            }
        }

        pub fn clear_favorite_type(&mut self) {
            self.favorite_type = ::std::option::Option::None;
        }

        pub fn has_favorite_type(&self) -> bool {
            self.favorite_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite_type(&mut self, v: super::super::dota_shared_enums::EDPCFavoriteType) {
            self.favorite_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 favorite_id = 2;

        pub fn favorite_id(&self) -> u32 {
            self.favorite_id.unwrap_or(0)
        }

        pub fn clear_favorite_id(&mut self) {
            self.favorite_id = ::std::option::Option::None;
        }

        pub fn has_favorite_id(&self) -> bool {
            self.favorite_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_favorite_id(&mut self, v: u32) {
            self.favorite_id = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Favorite {
        const NAME: &'static str = "Favorite";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.favorite_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.favorite_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.favorite_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.favorite_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.favorite_type {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.favorite_id {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Favorite {
            Favorite::new()
        }

        fn clear(&mut self) {
            self.favorite_type = ::std::option::Option::None;
            self.favorite_id = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Favorite {
            static instance: Favorite = Favorite {
                favorite_type: ::std::option::Option::None,
                favorite_id: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetDPCFavoritesResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetDPCFavoritesResponse.EResponse.k_eInvalidRequest)
        k_eInvalidRequest = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidRequest" => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidRequest,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetDPCFavoriteState)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetDPCFavoriteState {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetDPCFavoriteState.favorite_type)
    pub favorite_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EDPCFavoriteType>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetDPCFavoriteState.favorite_id)
    pub favorite_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetDPCFavoriteState.enabled)
    pub enabled: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetDPCFavoriteState.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetDPCFavoriteState {
    fn default() -> &'a CMsgClientToGCSetDPCFavoriteState {
        <CMsgClientToGCSetDPCFavoriteState as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetDPCFavoriteState {
    pub fn new() -> CMsgClientToGCSetDPCFavoriteState {
        ::std::default::Default::default()
    }

    // optional .EDPCFavoriteType favorite_type = 1;

    pub fn favorite_type(&self) -> super::dota_shared_enums::EDPCFavoriteType {
        match self.favorite_type {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EDPCFavoriteType::FAVORITE_TYPE_ALL),
            None => super::dota_shared_enums::EDPCFavoriteType::FAVORITE_TYPE_ALL,
        }
    }

    pub fn clear_favorite_type(&mut self) {
        self.favorite_type = ::std::option::Option::None;
    }

    pub fn has_favorite_type(&self) -> bool {
        self.favorite_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_type(&mut self, v: super::dota_shared_enums::EDPCFavoriteType) {
        self.favorite_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 favorite_id = 2;

    pub fn favorite_id(&self) -> u32 {
        self.favorite_id.unwrap_or(0)
    }

    pub fn clear_favorite_id(&mut self) {
        self.favorite_id = ::std::option::Option::None;
    }

    pub fn has_favorite_id(&self) -> bool {
        self.favorite_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_favorite_id(&mut self, v: u32) {
        self.favorite_id = ::std::option::Option::Some(v);
    }

    // optional bool enabled = 3;

    pub fn enabled(&self) -> bool {
        self.enabled.unwrap_or(false)
    }

    pub fn clear_enabled(&mut self) {
        self.enabled = ::std::option::Option::None;
    }

    pub fn has_enabled(&self) -> bool {
        self.enabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetDPCFavoriteState {
    const NAME: &'static str = "CMsgClientToGCSetDPCFavoriteState";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.favorite_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.favorite_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.enabled = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.favorite_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.favorite_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.enabled {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.favorite_type {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.favorite_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.enabled {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetDPCFavoriteState {
        CMsgClientToGCSetDPCFavoriteState::new()
    }

    fn clear(&mut self) {
        self.favorite_type = ::std::option::Option::None;
        self.favorite_id = ::std::option::Option::None;
        self.enabled = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetDPCFavoriteState {
        static instance: CMsgClientToGCSetDPCFavoriteState = CMsgClientToGCSetDPCFavoriteState {
            favorite_type: ::std::option::Option::None,
            favorite_id: ::std::option::Option::None,
            enabled: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetDPCFavoriteStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetDPCFavoriteStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetDPCFavoriteStateResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_dpcfavorite_state_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetDPCFavoriteStateResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetDPCFavoriteStateResponse {
    fn default() -> &'a CMsgClientToGCSetDPCFavoriteStateResponse {
        <CMsgClientToGCSetDPCFavoriteStateResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetDPCFavoriteStateResponse {
    pub fn new() -> CMsgClientToGCSetDPCFavoriteStateResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetDPCFavoriteStateResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_dpcfavorite_state_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_dpcfavorite_state_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_dpcfavorite_state_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_dpcfavorite_state_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetDPCFavoriteStateResponse {
    const NAME: &'static str = "CMsgClientToGCSetDPCFavoriteStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetDPCFavoriteStateResponse {
        CMsgClientToGCSetDPCFavoriteStateResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetDPCFavoriteStateResponse {
        static instance: CMsgClientToGCSetDPCFavoriteStateResponse = CMsgClientToGCSetDPCFavoriteStateResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetDPCFavoriteStateResponse`
pub mod cmsg_client_to_gcset_dpcfavorite_state_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eFavoriteTypeOutOfRange)
        k_eFavoriteTypeOutOfRange = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eLockFailed)
        k_eLockFailed = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eAlreadyFavorited)
        k_eAlreadyFavorited = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eAlreadyUnfavorited)
        k_eAlreadyUnfavorited = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eInsertRecordFailed)
        k_eInsertRecordFailed = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eRemoveRecordFailed)
        k_eRemoveRecordFailed = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetDPCFavoriteStateResponse.EResponse.k_eTimeout)
        k_eTimeout = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eFavoriteTypeOutOfRange),
                3 => ::std::option::Option::Some(EResponse::k_eLockFailed),
                4 => ::std::option::Option::Some(EResponse::k_eAlreadyFavorited),
                5 => ::std::option::Option::Some(EResponse::k_eAlreadyUnfavorited),
                6 => ::std::option::Option::Some(EResponse::k_eInsertRecordFailed),
                7 => ::std::option::Option::Some(EResponse::k_eRemoveRecordFailed),
                8 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eFavoriteTypeOutOfRange" => ::std::option::Option::Some(EResponse::k_eFavoriteTypeOutOfRange),
                "k_eLockFailed" => ::std::option::Option::Some(EResponse::k_eLockFailed),
                "k_eAlreadyFavorited" => ::std::option::Option::Some(EResponse::k_eAlreadyFavorited),
                "k_eAlreadyUnfavorited" => ::std::option::Option::Some(EResponse::k_eAlreadyUnfavorited),
                "k_eInsertRecordFailed" => ::std::option::Option::Some(EResponse::k_eInsertRecordFailed),
                "k_eRemoveRecordFailed" => ::std::option::Option::Some(EResponse::k_eRemoveRecordFailed),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eFavoriteTypeOutOfRange,
            EResponse::k_eLockFailed,
            EResponse::k_eAlreadyFavorited,
            EResponse::k_eAlreadyUnfavorited,
            EResponse::k_eInsertRecordFailed,
            EResponse::k_eRemoveRecordFailed,
            EResponse::k_eTimeout,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetEventActiveSeasonID)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetEventActiveSeasonID {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetEventActiveSeasonID.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetEventActiveSeasonID.active_season_id)
    pub active_season_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetEventActiveSeasonID.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetEventActiveSeasonID {
    fn default() -> &'a CMsgClientToGCSetEventActiveSeasonID {
        <CMsgClientToGCSetEventActiveSeasonID as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetEventActiveSeasonID {
    pub fn new() -> CMsgClientToGCSetEventActiveSeasonID {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 active_season_id = 2;

    pub fn active_season_id(&self) -> u32 {
        self.active_season_id.unwrap_or(0)
    }

    pub fn clear_active_season_id(&mut self) {
        self.active_season_id = ::std::option::Option::None;
    }

    pub fn has_active_season_id(&self) -> bool {
        self.active_season_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active_season_id(&mut self, v: u32) {
        self.active_season_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetEventActiveSeasonID {
    const NAME: &'static str = "CMsgClientToGCSetEventActiveSeasonID";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.active_season_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.active_season_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.active_season_id {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetEventActiveSeasonID {
        CMsgClientToGCSetEventActiveSeasonID::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.active_season_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetEventActiveSeasonID {
        static instance: CMsgClientToGCSetEventActiveSeasonID = CMsgClientToGCSetEventActiveSeasonID {
            event_id: ::std::option::Option::None,
            active_season_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetEventActiveSeasonIDResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetEventActiveSeasonIDResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetEventActiveSeasonIDResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_event_active_season_idresponse::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetEventActiveSeasonIDResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetEventActiveSeasonIDResponse {
    fn default() -> &'a CMsgClientToGCSetEventActiveSeasonIDResponse {
        <CMsgClientToGCSetEventActiveSeasonIDResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetEventActiveSeasonIDResponse {
    pub fn new() -> CMsgClientToGCSetEventActiveSeasonIDResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcset_event_active_season_idresponse::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_event_active_season_idresponse::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_event_active_season_idresponse::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcset_event_active_season_idresponse::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetEventActiveSeasonIDResponse {
    const NAME: &'static str = "CMsgClientToGCSetEventActiveSeasonIDResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetEventActiveSeasonIDResponse {
        CMsgClientToGCSetEventActiveSeasonIDResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetEventActiveSeasonIDResponse {
        static instance: CMsgClientToGCSetEventActiveSeasonIDResponse = CMsgClientToGCSetEventActiveSeasonIDResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetEventActiveSeasonIDResponse`
pub mod cmsg_client_to_gcset_event_active_season_idresponse {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eDisabled)
        k_eDisabled = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eTimeout)
        k_eTimeout = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetEventActiveSeasonIDResponse.EResponse.k_eInternalSuccessNoChange)
        k_eInternalSuccessNoChange = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eDisabled),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                5 => ::std::option::Option::Some(EResponse::k_eTimeout),
                6 => ::std::option::Option::Some(EResponse::k_eInternalSuccessNoChange),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInternalSuccessNoChange" => ::std::option::Option::Some(EResponse::k_eInternalSuccessNoChange),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eDisabled,
            EResponse::k_eTooBusy,
            EResponse::k_eNotAllowed,
            EResponse::k_eTimeout,
            EResponse::k_eInternalSuccessNoChange,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPurchaseLabyrinthBlessings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPurchaseLabyrinthBlessings {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseLabyrinthBlessings.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseLabyrinthBlessings.blessing_ids)
    pub blessing_ids: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseLabyrinthBlessings.debug)
    pub debug: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseLabyrinthBlessings.debug_remove)
    pub debug_remove: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseLabyrinthBlessings.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPurchaseLabyrinthBlessings {
    fn default() -> &'a CMsgClientToGCPurchaseLabyrinthBlessings {
        <CMsgClientToGCPurchaseLabyrinthBlessings as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPurchaseLabyrinthBlessings {
    pub fn new() -> CMsgClientToGCPurchaseLabyrinthBlessings {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional bool debug = 3;

    pub fn debug(&self) -> bool {
        self.debug.unwrap_or(false)
    }

    pub fn clear_debug(&mut self) {
        self.debug = ::std::option::Option::None;
    }

    pub fn has_debug(&self) -> bool {
        self.debug.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug(&mut self, v: bool) {
        self.debug = ::std::option::Option::Some(v);
    }

    // optional bool debug_remove = 4;

    pub fn debug_remove(&self) -> bool {
        self.debug_remove.unwrap_or(false)
    }

    pub fn clear_debug_remove(&mut self) {
        self.debug_remove = ::std::option::Option::None;
    }

    pub fn has_debug_remove(&self) -> bool {
        self.debug_remove.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_remove(&mut self, v: bool) {
        self.debug_remove = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPurchaseLabyrinthBlessings {
    const NAME: &'static str = "CMsgClientToGCPurchaseLabyrinthBlessings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_int32_into(&mut self.blessing_ids)?;
                },
                16 => {
                    self.blessing_ids.push(is.read_int32()?);
                },
                24 => {
                    self.debug = ::std::option::Option::Some(is.read_bool()?);
                },
                32 => {
                    self.debug_remove = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.blessing_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, *value);
        };
        if let Some(v) = self.debug {
            my_size += 1 + 1;
        }
        if let Some(v) = self.debug_remove {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.blessing_ids {
            os.write_int32(2, *v)?;
        };
        if let Some(v) = self.debug {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.debug_remove {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPurchaseLabyrinthBlessings {
        CMsgClientToGCPurchaseLabyrinthBlessings::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.blessing_ids.clear();
        self.debug = ::std::option::Option::None;
        self.debug_remove = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPurchaseLabyrinthBlessings {
        static instance: CMsgClientToGCPurchaseLabyrinthBlessings = CMsgClientToGCPurchaseLabyrinthBlessings {
            event_id: ::std::option::Option::None,
            blessing_ids: ::std::vec::Vec::new(),
            debug: ::std::option::Option::None,
            debug_remove: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPurchaseLabyrinthBlessingsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcpurchase_labyrinth_blessings_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    fn default() -> &'a CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
        <CMsgClientToGCPurchaseLabyrinthBlessingsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    pub fn new() -> CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcpurchase_labyrinth_blessings_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcpurchase_labyrinth_blessings_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcpurchase_labyrinth_blessings_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcpurchase_labyrinth_blessings_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    const NAME: &'static str = "CMsgClientToGCPurchaseLabyrinthBlessingsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
        CMsgClientToGCPurchaseLabyrinthBlessingsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
        static instance: CMsgClientToGCPurchaseLabyrinthBlessingsResponse = CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPurchaseLabyrinthBlessingsResponse`
pub mod cmsg_client_to_gcpurchase_labyrinth_blessings_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eNoSuchBlessing)
        k_eNoSuchBlessing = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eNotEnoughShards)
        k_eNotEnoughShards = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eNoPath)
        k_eNoPath = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPurchaseLabyrinthBlessingsResponse.EResponse.k_eTimeout)
        k_eTimeout = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eNoSuchBlessing),
                3 => ::std::option::Option::Some(EResponse::k_eNotEnoughShards),
                4 => ::std::option::Option::Some(EResponse::k_eNoPath),
                5 => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eNoSuchBlessing" => ::std::option::Option::Some(EResponse::k_eNoSuchBlessing),
                "k_eNotEnoughShards" => ::std::option::Option::Some(EResponse::k_eNotEnoughShards),
                "k_eNoPath" => ::std::option::Option::Some(EResponse::k_eNoPath),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eNoSuchBlessing,
            EResponse::k_eNotEnoughShards,
            EResponse::k_eNoPath,
            EResponse::k_eTimeout,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetStickerbookRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetStickerbookRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetStickerbookRequest.account_id)
    pub account_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetStickerbookRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetStickerbookRequest {
    fn default() -> &'a CMsgClientToGCGetStickerbookRequest {
        <CMsgClientToGCGetStickerbookRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetStickerbookRequest {
    pub fn new() -> CMsgClientToGCGetStickerbookRequest {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetStickerbookRequest {
    const NAME: &'static str = "CMsgClientToGCGetStickerbookRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetStickerbookRequest {
        CMsgClientToGCGetStickerbookRequest::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetStickerbookRequest {
        static instance: CMsgClientToGCGetStickerbookRequest = CMsgClientToGCGetStickerbookRequest {
            account_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetStickerbookResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetStickerbookResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetStickerbookResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_stickerbook_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetStickerbookResponse.stickerbook)
    pub stickerbook: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgStickerbook>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetStickerbookResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetStickerbookResponse {
    fn default() -> &'a CMsgClientToGCGetStickerbookResponse {
        <CMsgClientToGCGetStickerbookResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetStickerbookResponse {
    pub fn new() -> CMsgClientToGCGetStickerbookResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetStickerbookResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcget_stickerbook_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_stickerbook_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_stickerbook_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_stickerbook_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetStickerbookResponse {
    const NAME: &'static str = "CMsgClientToGCGetStickerbookResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.stickerbook)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.stickerbook.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.stickerbook.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetStickerbookResponse {
        CMsgClientToGCGetStickerbookResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.stickerbook.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetStickerbookResponse {
        static instance: CMsgClientToGCGetStickerbookResponse = CMsgClientToGCGetStickerbookResponse {
            response: ::std::option::Option::None,
            stickerbook: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetStickerbookResponse`
pub mod cmsg_client_to_gcget_stickerbook_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetStickerbookResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetStickerbookResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetStickerbookResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetStickerbookResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetStickerbookResponse.EResponse.k_eNotAllowed)
        k_eNotAllowed = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetStickerbookResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eNotAllowed" => ::std::option::Option::Some(EResponse::k_eNotAllowed),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eNotAllowed,
            EResponse::k_eTooBusy,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCreateStickerbookPageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStickerbookPageRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStickerbookPageRequest.team_id)
    pub team_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStickerbookPageRequest.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStickerbookPageRequest.page_type)
    pub page_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::EStickerbookPageType>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStickerbookPageRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStickerbookPageRequest {
    fn default() -> &'a CMsgClientToGCCreateStickerbookPageRequest {
        <CMsgClientToGCCreateStickerbookPageRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStickerbookPageRequest {
    pub fn new() -> CMsgClientToGCCreateStickerbookPageRequest {
        ::std::default::Default::default()
    }

    // optional uint32 team_id = 1;

    pub fn team_id(&self) -> u32 {
        self.team_id.unwrap_or(0)
    }

    pub fn clear_team_id(&mut self) {
        self.team_id = ::std::option::Option::None;
    }

    pub fn has_team_id(&self) -> bool {
        self.team_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_team_id(&mut self, v: u32) {
        self.team_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EStickerbookPageType page_type = 3;

    pub fn page_type(&self) -> super::dota_gcmessages_common::EStickerbookPageType {
        match self.page_type {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::EStickerbookPageType::STICKER_PAGE_GENERIC),
            None => super::dota_gcmessages_common::EStickerbookPageType::STICKER_PAGE_GENERIC,
        }
    }

    pub fn clear_page_type(&mut self) {
        self.page_type = ::std::option::Option::None;
    }

    pub fn has_page_type(&self) -> bool {
        self.page_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_type(&mut self, v: super::dota_gcmessages_common::EStickerbookPageType) {
        self.page_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateStickerbookPageRequest {
    const NAME: &'static str = "CMsgClientToGCCreateStickerbookPageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.team_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.page_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.team_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.page_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(3, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.team_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.page_type {
            os.write_enum(3, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStickerbookPageRequest {
        CMsgClientToGCCreateStickerbookPageRequest::new()
    }

    fn clear(&mut self) {
        self.team_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.page_type = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStickerbookPageRequest {
        static instance: CMsgClientToGCCreateStickerbookPageRequest = CMsgClientToGCCreateStickerbookPageRequest {
            team_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            page_type: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCCreateStickerbookPageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCreateStickerbookPageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStickerbookPageResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gccreate_stickerbook_page_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCCreateStickerbookPageResponse.page_number)
    pub page_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCreateStickerbookPageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCreateStickerbookPageResponse {
    fn default() -> &'a CMsgClientToGCCreateStickerbookPageResponse {
        <CMsgClientToGCCreateStickerbookPageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCreateStickerbookPageResponse {
    pub fn new() -> CMsgClientToGCCreateStickerbookPageResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCCreateStickerbookPageResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gccreate_stickerbook_page_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gccreate_stickerbook_page_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gccreate_stickerbook_page_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gccreate_stickerbook_page_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 page_number = 2;

    pub fn page_number(&self) -> u32 {
        self.page_number.unwrap_or(0)
    }

    pub fn clear_page_number(&mut self) {
        self.page_number = ::std::option::Option::None;
    }

    pub fn has_page_number(&self) -> bool {
        self.page_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_number(&mut self, v: u32) {
        self.page_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCreateStickerbookPageResponse {
    const NAME: &'static str = "CMsgClientToGCCreateStickerbookPageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.page_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.page_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.page_number {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCreateStickerbookPageResponse {
        CMsgClientToGCCreateStickerbookPageResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.page_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCreateStickerbookPageResponse {
        static instance: CMsgClientToGCCreateStickerbookPageResponse = CMsgClientToGCCreateStickerbookPageResponse {
            response: ::std::option::Option::None,
            page_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCCreateStickerbookPageResponse`
pub mod cmsg_client_to_gccreate_stickerbook_page_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCCreateStickerbookPageResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStickerbookPageResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStickerbookPageResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStickerbookPageResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStickerbookPageResponse.EResponse.k_eTooManyPages)
        k_eTooManyPages = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCCreateStickerbookPageResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooManyPages),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooManyPages" => ::std::option::Option::Some(EResponse::k_eTooManyPages),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooManyPages,
            EResponse::k_eTooBusy,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCDeleteStickerbookPageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeleteStickerbookPageRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDeleteStickerbookPageRequest.page_num)
    pub page_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCDeleteStickerbookPageRequest.sticker_count)
    pub sticker_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCDeleteStickerbookPageRequest.sticker_max)
    pub sticker_max: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDeleteStickerbookPageRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeleteStickerbookPageRequest {
    fn default() -> &'a CMsgClientToGCDeleteStickerbookPageRequest {
        <CMsgClientToGCDeleteStickerbookPageRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeleteStickerbookPageRequest {
    pub fn new() -> CMsgClientToGCDeleteStickerbookPageRequest {
        ::std::default::Default::default()
    }

    // optional uint32 page_num = 1;

    pub fn page_num(&self) -> u32 {
        self.page_num.unwrap_or(0)
    }

    pub fn clear_page_num(&mut self) {
        self.page_num = ::std::option::Option::None;
    }

    pub fn has_page_num(&self) -> bool {
        self.page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_num(&mut self, v: u32) {
        self.page_num = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_count = 2;

    pub fn sticker_count(&self) -> u32 {
        self.sticker_count.unwrap_or(0)
    }

    pub fn clear_sticker_count(&mut self) {
        self.sticker_count = ::std::option::Option::None;
    }

    pub fn has_sticker_count(&self) -> bool {
        self.sticker_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_count(&mut self, v: u32) {
        self.sticker_count = ::std::option::Option::Some(v);
    }

    // optional uint32 sticker_max = 3;

    pub fn sticker_max(&self) -> u32 {
        self.sticker_max.unwrap_or(0)
    }

    pub fn clear_sticker_max(&mut self) {
        self.sticker_max = ::std::option::Option::None;
    }

    pub fn has_sticker_max(&self) -> bool {
        self.sticker_max.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sticker_max(&mut self, v: u32) {
        self.sticker_max = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDeleteStickerbookPageRequest {
    const NAME: &'static str = "CMsgClientToGCDeleteStickerbookPageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.sticker_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.sticker_max = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.sticker_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.sticker_max {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.page_num {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.sticker_count {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.sticker_max {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeleteStickerbookPageRequest {
        CMsgClientToGCDeleteStickerbookPageRequest::new()
    }

    fn clear(&mut self) {
        self.page_num = ::std::option::Option::None;
        self.sticker_count = ::std::option::Option::None;
        self.sticker_max = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeleteStickerbookPageRequest {
        static instance: CMsgClientToGCDeleteStickerbookPageRequest = CMsgClientToGCDeleteStickerbookPageRequest {
            page_num: ::std::option::Option::None,
            sticker_count: ::std::option::Option::None,
            sticker_max: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCDeleteStickerbookPageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCDeleteStickerbookPageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCDeleteStickerbookPageResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcdelete_stickerbook_page_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCDeleteStickerbookPageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCDeleteStickerbookPageResponse {
    fn default() -> &'a CMsgClientToGCDeleteStickerbookPageResponse {
        <CMsgClientToGCDeleteStickerbookPageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCDeleteStickerbookPageResponse {
    pub fn new() -> CMsgClientToGCDeleteStickerbookPageResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCDeleteStickerbookPageResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcdelete_stickerbook_page_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcdelete_stickerbook_page_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcdelete_stickerbook_page_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcdelete_stickerbook_page_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCDeleteStickerbookPageResponse {
    const NAME: &'static str = "CMsgClientToGCDeleteStickerbookPageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCDeleteStickerbookPageResponse {
        CMsgClientToGCDeleteStickerbookPageResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCDeleteStickerbookPageResponse {
        static instance: CMsgClientToGCDeleteStickerbookPageResponse = CMsgClientToGCDeleteStickerbookPageResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCDeleteStickerbookPageResponse`
pub mod cmsg_client_to_gcdelete_stickerbook_page_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCDeleteStickerbookPageResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eInvalidStickerCount)
        k_eInvalidStickerCount = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eInvalidStickerMax)
        k_eInvalidStickerMax = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCDeleteStickerbookPageResponse.EResponse.k_eInvalidPage)
        k_eInvalidPage = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eInvalidStickerCount),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidStickerMax),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidStickerCount" => ::std::option::Option::Some(EResponse::k_eInvalidStickerCount),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eInvalidStickerMax" => ::std::option::Option::Some(EResponse::k_eInvalidStickerMax),
                "k_eInvalidPage" => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidStickerCount,
            EResponse::k_eTooBusy,
            EResponse::k_eInvalidStickerMax,
            EResponse::k_eInvalidPage,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPlaceStickersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlaceStickersRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlaceStickersRequest.sticker_items)
    pub sticker_items: ::std::vec::Vec<cmsg_client_to_gcplace_stickers_request::StickerItem>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceStickersRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlaceStickersRequest {
    fn default() -> &'a CMsgClientToGCPlaceStickersRequest {
        <CMsgClientToGCPlaceStickersRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlaceStickersRequest {
    pub fn new() -> CMsgClientToGCPlaceStickersRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlaceStickersRequest {
    const NAME: &'static str = "CMsgClientToGCPlaceStickersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.sticker_items.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.sticker_items {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.sticker_items {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlaceStickersRequest {
        CMsgClientToGCPlaceStickersRequest::new()
    }

    fn clear(&mut self) {
        self.sticker_items.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlaceStickersRequest {
        static instance: CMsgClientToGCPlaceStickersRequest = CMsgClientToGCPlaceStickersRequest {
            sticker_items: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPlaceStickersRequest`
pub mod cmsg_client_to_gcplace_stickers_request {
    // @@protoc_insertion_point(message:CMsgClientToGCPlaceStickersRequest.StickerItem)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct StickerItem {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceStickersRequest.StickerItem.page_num)
        pub page_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceStickersRequest.StickerItem.sticker)
        pub sticker: ::steam_vent_proto_common::protobuf::MessageField<super::super::dota_gcmessages_common::CMsgStickerbookSticker>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceStickersRequest.StickerItem.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a StickerItem {
        fn default() -> &'a StickerItem {
            <StickerItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl StickerItem {
        pub fn new() -> StickerItem {
            ::std::default::Default::default()
        }

        // optional uint32 page_num = 2;

        pub fn page_num(&self) -> u32 {
            self.page_num.unwrap_or(0)
        }

        pub fn clear_page_num(&mut self) {
            self.page_num = ::std::option::Option::None;
        }

        pub fn has_page_num(&self) -> bool {
            self.page_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_page_num(&mut self, v: u32) {
            self.page_num = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for StickerItem {
        const NAME: &'static str = "StickerItem";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    16 => {
                        self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    26 => {
                        ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.sticker)?;
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.page_num {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.sticker.as_ref() {
                let len = v.compute_size();
                my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.page_num {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.sticker.as_ref() {
                ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> StickerItem {
            StickerItem::new()
        }

        fn clear(&mut self) {
            self.page_num = ::std::option::Option::None;
            self.sticker.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static StickerItem {
            static instance: StickerItem = StickerItem {
                page_num: ::std::option::Option::None,
                sticker: ::steam_vent_proto_common::protobuf::MessageField::none(),
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPlaceStickersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlaceStickersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlaceStickersResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcplace_stickers_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceStickersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlaceStickersResponse {
    fn default() -> &'a CMsgClientToGCPlaceStickersResponse {
        <CMsgClientToGCPlaceStickersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlaceStickersResponse {
    pub fn new() -> CMsgClientToGCPlaceStickersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCPlaceStickersResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcplace_stickers_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcplace_stickers_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcplace_stickers_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcplace_stickers_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlaceStickersResponse {
    const NAME: &'static str = "CMsgClientToGCPlaceStickersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlaceStickersResponse {
        CMsgClientToGCPlaceStickersResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlaceStickersResponse {
        static instance: CMsgClientToGCPlaceStickersResponse = CMsgClientToGCPlaceStickersResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPlaceStickersResponse`
pub mod cmsg_client_to_gcplace_stickers_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPlaceStickersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eMissingItem)
        k_eMissingItem = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eDuplicateItem)
        k_eDuplicateItem = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eInvalidPage)
        k_eInvalidPage = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_ePageTypeMismatch)
        k_ePageTypeMismatch = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceStickersResponse.EResponse.k_eTooManyStickers)
        k_eTooManyStickers = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eMissingItem),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eDuplicateItem),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                7 => ::std::option::Option::Some(EResponse::k_ePageTypeMismatch),
                8 => ::std::option::Option::Some(EResponse::k_eTooManyStickers),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eMissingItem" => ::std::option::Option::Some(EResponse::k_eMissingItem),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDuplicateItem" => ::std::option::Option::Some(EResponse::k_eDuplicateItem),
                "k_eInvalidPage" => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                "k_ePageTypeMismatch" => ::std::option::Option::Some(EResponse::k_ePageTypeMismatch),
                "k_eTooManyStickers" => ::std::option::Option::Some(EResponse::k_eTooManyStickers),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eMissingItem,
            EResponse::k_eTooBusy,
            EResponse::k_eDuplicateItem,
            EResponse::k_eInvalidPage,
            EResponse::k_ePageTypeMismatch,
            EResponse::k_eTooManyStickers,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCPlaceCollectionStickersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlaceCollectionStickersRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.slots)
    pub slots: ::std::vec::Vec<cmsg_client_to_gcplace_collection_stickers_request::Slot>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceCollectionStickersRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlaceCollectionStickersRequest {
    fn default() -> &'a CMsgClientToGCPlaceCollectionStickersRequest {
        <CMsgClientToGCPlaceCollectionStickersRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlaceCollectionStickersRequest {
    pub fn new() -> CMsgClientToGCPlaceCollectionStickersRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlaceCollectionStickersRequest {
    const NAME: &'static str = "CMsgClientToGCPlaceCollectionStickersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.slots.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlaceCollectionStickersRequest {
        CMsgClientToGCPlaceCollectionStickersRequest::new()
    }

    fn clear(&mut self) {
        self.slots.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlaceCollectionStickersRequest {
        static instance: CMsgClientToGCPlaceCollectionStickersRequest = CMsgClientToGCPlaceCollectionStickersRequest {
            slots: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPlaceCollectionStickersRequest`
pub mod cmsg_client_to_gcplace_collection_stickers_request {
    // @@protoc_insertion_point(message:CMsgClientToGCPlaceCollectionStickersRequest.Slot)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Slot {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.page_num)
        pub page_num: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.slot)
        pub slot: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.new_item_id)
        pub new_item_id: ::std::option::Option<u64>,
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.old_item_def_id)
        pub old_item_def_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.old_quality)
        pub old_quality: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceCollectionStickersRequest.Slot.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Slot {
        fn default() -> &'a Slot {
            <Slot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Slot {
        pub fn new() -> Slot {
            ::std::default::Default::default()
        }

        // optional uint32 page_num = 1;

        pub fn page_num(&self) -> u32 {
            self.page_num.unwrap_or(0)
        }

        pub fn clear_page_num(&mut self) {
            self.page_num = ::std::option::Option::None;
        }

        pub fn has_page_num(&self) -> bool {
            self.page_num.is_some()
        }

        // Param is passed by value, moved
        pub fn set_page_num(&mut self, v: u32) {
            self.page_num = ::std::option::Option::Some(v);
        }

        // optional uint32 slot = 2;

        pub fn slot(&self) -> u32 {
            self.slot.unwrap_or(0)
        }

        pub fn clear_slot(&mut self) {
            self.slot = ::std::option::Option::None;
        }

        pub fn has_slot(&self) -> bool {
            self.slot.is_some()
        }

        // Param is passed by value, moved
        pub fn set_slot(&mut self, v: u32) {
            self.slot = ::std::option::Option::Some(v);
        }

        // optional uint64 new_item_id = 3;

        pub fn new_item_id(&self) -> u64 {
            self.new_item_id.unwrap_or(0)
        }

        pub fn clear_new_item_id(&mut self) {
            self.new_item_id = ::std::option::Option::None;
        }

        pub fn has_new_item_id(&self) -> bool {
            self.new_item_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_new_item_id(&mut self, v: u64) {
            self.new_item_id = ::std::option::Option::Some(v);
        }

        // optional uint32 old_item_def_id = 4;

        pub fn old_item_def_id(&self) -> u32 {
            self.old_item_def_id.unwrap_or(0)
        }

        pub fn clear_old_item_def_id(&mut self) {
            self.old_item_def_id = ::std::option::Option::None;
        }

        pub fn has_old_item_def_id(&self) -> bool {
            self.old_item_def_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_old_item_def_id(&mut self, v: u32) {
            self.old_item_def_id = ::std::option::Option::Some(v);
        }

        // optional uint32 old_quality = 5;

        pub fn old_quality(&self) -> u32 {
            self.old_quality.unwrap_or(0)
        }

        pub fn clear_old_quality(&mut self) {
            self.old_quality = ::std::option::Option::None;
        }

        pub fn has_old_quality(&self) -> bool {
            self.old_quality.is_some()
        }

        // Param is passed by value, moved
        pub fn set_old_quality(&mut self, v: u32) {
            self.old_quality = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Slot {
        const NAME: &'static str = "Slot";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.slot = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.new_item_id = ::std::option::Option::Some(is.read_uint64()?);
                    },
                    32 => {
                        self.old_item_def_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    40 => {
                        self.old_quality = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.page_num {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.slot {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.new_item_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
            }
            if let Some(v) = self.old_item_def_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
            }
            if let Some(v) = self.old_quality {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.page_num {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.slot {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.new_item_id {
                os.write_uint64(3, v)?;
            }
            if let Some(v) = self.old_item_def_id {
                os.write_uint32(4, v)?;
            }
            if let Some(v) = self.old_quality {
                os.write_uint32(5, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Slot {
            Slot::new()
        }

        fn clear(&mut self) {
            self.page_num = ::std::option::Option::None;
            self.slot = ::std::option::Option::None;
            self.new_item_id = ::std::option::Option::None;
            self.old_item_def_id = ::std::option::Option::None;
            self.old_quality = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Slot {
            static instance: Slot = Slot {
                page_num: ::std::option::Option::None,
                slot: ::std::option::Option::None,
                new_item_id: ::std::option::Option::None,
                old_item_def_id: ::std::option::Option::None,
                old_quality: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCPlaceCollectionStickersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCPlaceCollectionStickersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCPlaceCollectionStickersResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcplace_collection_stickers_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCPlaceCollectionStickersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCPlaceCollectionStickersResponse {
    fn default() -> &'a CMsgClientToGCPlaceCollectionStickersResponse {
        <CMsgClientToGCPlaceCollectionStickersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCPlaceCollectionStickersResponse {
    pub fn new() -> CMsgClientToGCPlaceCollectionStickersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCPlaceCollectionStickersResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcplace_collection_stickers_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcplace_collection_stickers_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcplace_collection_stickers_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcplace_collection_stickers_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCPlaceCollectionStickersResponse {
    const NAME: &'static str = "CMsgClientToGCPlaceCollectionStickersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCPlaceCollectionStickersResponse {
        CMsgClientToGCPlaceCollectionStickersResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCPlaceCollectionStickersResponse {
        static instance: CMsgClientToGCPlaceCollectionStickersResponse = CMsgClientToGCPlaceCollectionStickersResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCPlaceCollectionStickersResponse`
pub mod cmsg_client_to_gcplace_collection_stickers_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCPlaceCollectionStickersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eMissingItem)
        k_eMissingItem = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eDuplicateItem)
        k_eDuplicateItem = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eInvalidPage)
        k_eInvalidPage = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_ePageTypeMismatch)
        k_ePageTypeMismatch = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eOldItemMismatch)
        k_eOldItemMismatch = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eInvalidSlot)
        k_eInvalidSlot = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCPlaceCollectionStickersResponse.EResponse.k_eSlotTypeMismatch)
        k_eSlotTypeMismatch = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eMissingItem),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eDuplicateItem),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                7 => ::std::option::Option::Some(EResponse::k_ePageTypeMismatch),
                8 => ::std::option::Option::Some(EResponse::k_eOldItemMismatch),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidSlot),
                10 => ::std::option::Option::Some(EResponse::k_eSlotTypeMismatch),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eMissingItem" => ::std::option::Option::Some(EResponse::k_eMissingItem),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDuplicateItem" => ::std::option::Option::Some(EResponse::k_eDuplicateItem),
                "k_eInvalidPage" => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                "k_ePageTypeMismatch" => ::std::option::Option::Some(EResponse::k_ePageTypeMismatch),
                "k_eOldItemMismatch" => ::std::option::Option::Some(EResponse::k_eOldItemMismatch),
                "k_eInvalidSlot" => ::std::option::Option::Some(EResponse::k_eInvalidSlot),
                "k_eSlotTypeMismatch" => ::std::option::Option::Some(EResponse::k_eSlotTypeMismatch),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eMissingItem,
            EResponse::k_eTooBusy,
            EResponse::k_eDuplicateItem,
            EResponse::k_eInvalidPage,
            EResponse::k_ePageTypeMismatch,
            EResponse::k_eOldItemMismatch,
            EResponse::k_eInvalidSlot,
            EResponse::k_eSlotTypeMismatch,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCOrderStickerbookTeamPageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOrderStickerbookTeamPageRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOrderStickerbookTeamPageRequest.page_order_sequence)
    pub page_order_sequence: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgStickerbookTeamPageOrderSequence>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOrderStickerbookTeamPageRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOrderStickerbookTeamPageRequest {
    fn default() -> &'a CMsgClientToGCOrderStickerbookTeamPageRequest {
        <CMsgClientToGCOrderStickerbookTeamPageRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOrderStickerbookTeamPageRequest {
    pub fn new() -> CMsgClientToGCOrderStickerbookTeamPageRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOrderStickerbookTeamPageRequest {
    const NAME: &'static str = "CMsgClientToGCOrderStickerbookTeamPageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.page_order_sequence)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_order_sequence.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.page_order_sequence.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOrderStickerbookTeamPageRequest {
        CMsgClientToGCOrderStickerbookTeamPageRequest::new()
    }

    fn clear(&mut self) {
        self.page_order_sequence.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOrderStickerbookTeamPageRequest {
        static instance: CMsgClientToGCOrderStickerbookTeamPageRequest = CMsgClientToGCOrderStickerbookTeamPageRequest {
            page_order_sequence: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCOrderStickerbookTeamPageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCOrderStickerbookTeamPageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCOrderStickerbookTeamPageResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcorder_stickerbook_team_page_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCOrderStickerbookTeamPageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCOrderStickerbookTeamPageResponse {
    fn default() -> &'a CMsgClientToGCOrderStickerbookTeamPageResponse {
        <CMsgClientToGCOrderStickerbookTeamPageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCOrderStickerbookTeamPageResponse {
    pub fn new() -> CMsgClientToGCOrderStickerbookTeamPageResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcorder_stickerbook_team_page_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcorder_stickerbook_team_page_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcorder_stickerbook_team_page_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcorder_stickerbook_team_page_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCOrderStickerbookTeamPageResponse {
    const NAME: &'static str = "CMsgClientToGCOrderStickerbookTeamPageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCOrderStickerbookTeamPageResponse {
        CMsgClientToGCOrderStickerbookTeamPageResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCOrderStickerbookTeamPageResponse {
        static instance: CMsgClientToGCOrderStickerbookTeamPageResponse = CMsgClientToGCOrderStickerbookTeamPageResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCOrderStickerbookTeamPageResponse`
pub mod cmsg_client_to_gcorder_stickerbook_team_page_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eTooManyPages)
        k_eTooManyPages = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCOrderStickerbookTeamPageResponse.EResponse.k_eInvalidPage)
        k_eInvalidPage = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eTooManyPages),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooManyPages" => ::std::option::Option::Some(EResponse::k_eTooManyPages),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eInvalidPage" => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooManyPages,
            EResponse::k_eTooBusy,
            EResponse::k_eInvalidPage,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetHeroSticker)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetHeroSticker {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetHeroSticker.hero_id)
    pub hero_id: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetHeroSticker.new_item_id)
    pub new_item_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetHeroSticker.old_item_id)
    pub old_item_id: ::std::option::Option<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetHeroSticker.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetHeroSticker {
    fn default() -> &'a CMsgClientToGCSetHeroSticker {
        <CMsgClientToGCSetHeroSticker as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetHeroSticker {
    pub fn new() -> CMsgClientToGCSetHeroSticker {
        ::std::default::Default::default()
    }

    // optional int32 hero_id = 1;

    pub fn hero_id(&self) -> i32 {
        self.hero_id.unwrap_or(0)
    }

    pub fn clear_hero_id(&mut self) {
        self.hero_id = ::std::option::Option::None;
    }

    pub fn has_hero_id(&self) -> bool {
        self.hero_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_id(&mut self, v: i32) {
        self.hero_id = ::std::option::Option::Some(v);
    }

    // optional uint64 new_item_id = 2;

    pub fn new_item_id(&self) -> u64 {
        self.new_item_id.unwrap_or(0)
    }

    pub fn clear_new_item_id(&mut self) {
        self.new_item_id = ::std::option::Option::None;
    }

    pub fn has_new_item_id(&self) -> bool {
        self.new_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_new_item_id(&mut self, v: u64) {
        self.new_item_id = ::std::option::Option::Some(v);
    }

    // optional uint64 old_item_id = 3;

    pub fn old_item_id(&self) -> u64 {
        self.old_item_id.unwrap_or(0)
    }

    pub fn clear_old_item_id(&mut self) {
        self.old_item_id = ::std::option::Option::None;
    }

    pub fn has_old_item_id(&self) -> bool {
        self.old_item_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_old_item_id(&mut self, v: u64) {
        self.old_item_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetHeroSticker {
    const NAME: &'static str = "CMsgClientToGCSetHeroSticker";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.hero_id = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.new_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                24 => {
                    self.old_item_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.hero_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v);
        }
        if let Some(v) = self.new_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        if let Some(v) = self.old_item_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.hero_id {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.new_item_id {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.old_item_id {
            os.write_uint64(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetHeroSticker {
        CMsgClientToGCSetHeroSticker::new()
    }

    fn clear(&mut self) {
        self.hero_id = ::std::option::Option::None;
        self.new_item_id = ::std::option::Option::None;
        self.old_item_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetHeroSticker {
        static instance: CMsgClientToGCSetHeroSticker = CMsgClientToGCSetHeroSticker {
            hero_id: ::std::option::Option::None,
            new_item_id: ::std::option::Option::None,
            old_item_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetHeroStickerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetHeroStickerResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetHeroStickerResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_hero_sticker_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetHeroStickerResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetHeroStickerResponse {
    fn default() -> &'a CMsgClientToGCSetHeroStickerResponse {
        <CMsgClientToGCSetHeroStickerResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetHeroStickerResponse {
    pub fn new() -> CMsgClientToGCSetHeroStickerResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetHeroStickerResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcset_hero_sticker_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_hero_sticker_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_hero_sticker_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcset_hero_sticker_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetHeroStickerResponse {
    const NAME: &'static str = "CMsgClientToGCSetHeroStickerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetHeroStickerResponse {
        CMsgClientToGCSetHeroStickerResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetHeroStickerResponse {
        static instance: CMsgClientToGCSetHeroStickerResponse = CMsgClientToGCSetHeroStickerResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetHeroStickerResponse`
pub mod cmsg_client_to_gcset_hero_sticker_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetHeroStickerResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eMissingItem)
        k_eMissingItem = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eOldItemMismatch)
        k_eOldItemMismatch = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetHeroStickerResponse.EResponse.k_eInvalidHero)
        k_eInvalidHero = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                3 => ::std::option::Option::Some(EResponse::k_eMissingItem),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eOldItemMismatch),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidHero),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eMissingItem" => ::std::option::Option::Some(EResponse::k_eMissingItem),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eOldItemMismatch" => ::std::option::Option::Some(EResponse::k_eOldItemMismatch),
                "k_eInvalidHero" => ::std::option::Option::Some(EResponse::k_eInvalidHero),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eMissingItem,
            EResponse::k_eTooBusy,
            EResponse::k_eOldItemMismatch,
            EResponse::k_eInvalidHero,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCGetHeroStickers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetHeroStickers {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetHeroStickers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetHeroStickers {
    fn default() -> &'a CMsgClientToGCGetHeroStickers {
        <CMsgClientToGCGetHeroStickers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetHeroStickers {
    pub fn new() -> CMsgClientToGCGetHeroStickers {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetHeroStickers {
    const NAME: &'static str = "CMsgClientToGCGetHeroStickers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetHeroStickers {
        CMsgClientToGCGetHeroStickers::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetHeroStickers {
        static instance: CMsgClientToGCGetHeroStickers = CMsgClientToGCGetHeroStickers {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCGetHeroStickersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCGetHeroStickersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCGetHeroStickersResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcget_hero_stickers_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCGetHeroStickersResponse.sticker_heroes)
    pub sticker_heroes: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgStickerHeroes>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCGetHeroStickersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCGetHeroStickersResponse {
    fn default() -> &'a CMsgClientToGCGetHeroStickersResponse {
        <CMsgClientToGCGetHeroStickersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCGetHeroStickersResponse {
    pub fn new() -> CMsgClientToGCGetHeroStickersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCGetHeroStickersResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcget_hero_stickers_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcget_hero_stickers_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcget_hero_stickers_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcget_hero_stickers_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCGetHeroStickersResponse {
    const NAME: &'static str = "CMsgClientToGCGetHeroStickersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.sticker_heroes)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.sticker_heroes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.sticker_heroes.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCGetHeroStickersResponse {
        CMsgClientToGCGetHeroStickersResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.sticker_heroes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCGetHeroStickersResponse {
        static instance: CMsgClientToGCGetHeroStickersResponse = CMsgClientToGCGetHeroStickersResponse {
            response: ::std::option::Option::None,
            sticker_heroes: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCGetHeroStickersResponse`
pub mod cmsg_client_to_gcget_hero_stickers_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCGetHeroStickersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetHeroStickersResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetHeroStickersResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetHeroStickersResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCGetHeroStickersResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCSetFavoritePage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetFavoritePage {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetFavoritePage.page_num)
    pub page_num: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSetFavoritePage.clear)
    pub clear: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetFavoritePage.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetFavoritePage {
    fn default() -> &'a CMsgClientToGCSetFavoritePage {
        <CMsgClientToGCSetFavoritePage as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetFavoritePage {
    pub fn new() -> CMsgClientToGCSetFavoritePage {
        ::std::default::Default::default()
    }

    // optional uint32 page_num = 1;

    pub fn page_num(&self) -> u32 {
        self.page_num.unwrap_or(0)
    }

    pub fn clear_page_num(&mut self) {
        self.page_num = ::std::option::Option::None;
    }

    pub fn has_page_num(&self) -> bool {
        self.page_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_page_num(&mut self, v: u32) {
        self.page_num = ::std::option::Option::Some(v);
    }

    // optional bool clear = 2;

    pub fn clear(&self) -> bool {
        self.clear.unwrap_or(false)
    }

    pub fn clear_clear(&mut self) {
        self.clear = ::std::option::Option::None;
    }

    pub fn has_clear(&self) -> bool {
        self.clear.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clear(&mut self, v: bool) {
        self.clear = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetFavoritePage {
    const NAME: &'static str = "CMsgClientToGCSetFavoritePage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.page_num = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.clear = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.page_num {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.clear {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.page_num {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.clear {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetFavoritePage {
        CMsgClientToGCSetFavoritePage::new()
    }

    fn clear(&mut self) {
        self.page_num = ::std::option::Option::None;
        self.clear = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetFavoritePage {
        static instance: CMsgClientToGCSetFavoritePage = CMsgClientToGCSetFavoritePage {
            page_num: ::std::option::Option::None,
            clear: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetFavoritePageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetFavoritePageResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetFavoritePageResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcset_favorite_page_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetFavoritePageResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetFavoritePageResponse {
    fn default() -> &'a CMsgClientToGCSetFavoritePageResponse {
        <CMsgClientToGCSetFavoritePageResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetFavoritePageResponse {
    pub fn new() -> CMsgClientToGCSetFavoritePageResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSetFavoritePageResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcset_favorite_page_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcset_favorite_page_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcset_favorite_page_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcset_favorite_page_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetFavoritePageResponse {
    const NAME: &'static str = "CMsgClientToGCSetFavoritePageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetFavoritePageResponse {
        CMsgClientToGCSetFavoritePageResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetFavoritePageResponse {
        static instance: CMsgClientToGCSetFavoritePageResponse = CMsgClientToGCSetFavoritePageResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSetFavoritePageResponse`
pub mod cmsg_client_to_gcset_favorite_page_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSetFavoritePageResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetFavoritePageResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetFavoritePageResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetFavoritePageResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetFavoritePageResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSetFavoritePageResponse.EResponse.k_eInvalidPage)
        k_eInvalidPage = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eInvalidPage" => ::std::option::Option::Some(EResponse::k_eInvalidPage),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eInvalidPage,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCClaimSwag)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimSwag {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimSwag.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimSwag.action_id)
    pub action_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimSwag.data)
    pub data: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimSwag.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimSwag {
    fn default() -> &'a CMsgClientToGCClaimSwag {
        <CMsgClientToGCClaimSwag as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimSwag {
    pub fn new() -> CMsgClientToGCClaimSwag {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 action_id = 2;

    pub fn action_id(&self) -> u32 {
        self.action_id.unwrap_or(0)
    }

    pub fn clear_action_id(&mut self) {
        self.action_id = ::std::option::Option::None;
    }

    pub fn has_action_id(&self) -> bool {
        self.action_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action_id(&mut self, v: u32) {
        self.action_id = ::std::option::Option::Some(v);
    }

    // optional uint32 data = 3;

    pub fn data(&self) -> u32 {
        self.data.unwrap_or(0)
    }

    pub fn clear_data(&mut self) {
        self.data = ::std::option::Option::None;
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: u32) {
        self.data = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimSwag {
    const NAME: &'static str = "CMsgClientToGCClaimSwag";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.action_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.data = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.action_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.data {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.action_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.data {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimSwag {
        CMsgClientToGCClaimSwag::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.action_id = ::std::option::Option::None;
        self.data = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimSwag {
        static instance: CMsgClientToGCClaimSwag = CMsgClientToGCClaimSwag {
            event_id: ::std::option::Option::None,
            action_id: ::std::option::Option::None,
            data: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCClaimSwagResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimSwagResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimSwagResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcclaim_swag_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimSwagResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimSwagResponse {
    fn default() -> &'a CMsgClientToGCClaimSwagResponse {
        <CMsgClientToGCClaimSwagResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimSwagResponse {
    pub fn new() -> CMsgClientToGCClaimSwagResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCClaimSwagResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcclaim_swag_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcclaim_swag_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcclaim_swag_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcclaim_swag_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimSwagResponse {
    const NAME: &'static str = "CMsgClientToGCClaimSwagResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimSwagResponse {
        CMsgClientToGCClaimSwagResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimSwagResponse {
        static instance: CMsgClientToGCClaimSwagResponse = CMsgClientToGCClaimSwagResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCClaimSwagResponse`
pub mod cmsg_client_to_gcclaim_swag_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCClaimSwagResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eAlreadyClaimed)
        k_eAlreadyClaimed = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eDisabled)
        k_eDisabled = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eInvalidRequest)
        k_eInvalidRequest = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eUserNotEligible)
        k_eUserNotEligible = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eStorageError)
        k_eStorageError = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimSwagResponse.EResponse.k_eRewardDisabled)
        k_eRewardDisabled = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                5 => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                6 => ::std::option::Option::Some(EResponse::k_eDisabled),
                7 => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                8 => ::std::option::Option::Some(EResponse::k_eUserNotEligible),
                9 => ::std::option::Option::Some(EResponse::k_eStorageError),
                10 => ::std::option::Option::Some(EResponse::k_eRewardDisabled),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eAlreadyClaimed" => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eInvalidRequest" => ::std::option::Option::Some(EResponse::k_eInvalidRequest),
                "k_eUserNotEligible" => ::std::option::Option::Some(EResponse::k_eUserNotEligible),
                "k_eStorageError" => ::std::option::Option::Some(EResponse::k_eStorageError),
                "k_eRewardDisabled" => ::std::option::Option::Some(EResponse::k_eRewardDisabled),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
            EResponse::k_eAlreadyClaimed,
            EResponse::k_eDisabled,
            EResponse::k_eInvalidRequest,
            EResponse::k_eUserNotEligible,
            EResponse::k_eStorageError,
            EResponse::k_eRewardDisabled,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCCollectorsCacheAvailableDataRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCCollectorsCacheAvailableDataRequest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCCollectorsCacheAvailableDataRequest.contest_id)
    pub contest_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCCollectorsCacheAvailableDataRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCCollectorsCacheAvailableDataRequest {
    fn default() -> &'a CMsgClientToGCCollectorsCacheAvailableDataRequest {
        <CMsgClientToGCCollectorsCacheAvailableDataRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCCollectorsCacheAvailableDataRequest {
    pub fn new() -> CMsgClientToGCCollectorsCacheAvailableDataRequest {
        ::std::default::Default::default()
    }

    // optional uint32 contest_id = 1;

    pub fn contest_id(&self) -> u32 {
        self.contest_id.unwrap_or(0)
    }

    pub fn clear_contest_id(&mut self) {
        self.contest_id = ::std::option::Option::None;
    }

    pub fn has_contest_id(&self) -> bool {
        self.contest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contest_id(&mut self, v: u32) {
        self.contest_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCCollectorsCacheAvailableDataRequest {
    const NAME: &'static str = "CMsgClientToGCCollectorsCacheAvailableDataRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contest_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCCollectorsCacheAvailableDataRequest {
        CMsgClientToGCCollectorsCacheAvailableDataRequest::new()
    }

    fn clear(&mut self) {
        self.contest_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCCollectorsCacheAvailableDataRequest {
        static instance: CMsgClientToGCCollectorsCacheAvailableDataRequest = CMsgClientToGCCollectorsCacheAvailableDataRequest {
            contest_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientCollectorsCacheAvailableDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientCollectorsCacheAvailableDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientCollectorsCacheAvailableDataResponse.votes)
    pub votes: ::std::vec::Vec<cmsg_gcto_client_collectors_cache_available_data_response::Vote>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientCollectorsCacheAvailableDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientCollectorsCacheAvailableDataResponse {
    fn default() -> &'a CMsgGCToClientCollectorsCacheAvailableDataResponse {
        <CMsgGCToClientCollectorsCacheAvailableDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientCollectorsCacheAvailableDataResponse {
    pub fn new() -> CMsgGCToClientCollectorsCacheAvailableDataResponse {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientCollectorsCacheAvailableDataResponse {
    const NAME: &'static str = "CMsgGCToClientCollectorsCacheAvailableDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.votes.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.votes {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.votes {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientCollectorsCacheAvailableDataResponse {
        CMsgGCToClientCollectorsCacheAvailableDataResponse::new()
    }

    fn clear(&mut self) {
        self.votes.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientCollectorsCacheAvailableDataResponse {
        static instance: CMsgGCToClientCollectorsCacheAvailableDataResponse = CMsgGCToClientCollectorsCacheAvailableDataResponse {
            votes: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientCollectorsCacheAvailableDataResponse`
pub mod cmsg_gcto_client_collectors_cache_available_data_response {
    // @@protoc_insertion_point(message:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Vote {
        // message fields
        // @@protoc_insertion_point(field:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.item_def)
        pub item_def: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.vote_type)
        pub vote_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<vote::EVoteType>>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Vote {
        fn default() -> &'a Vote {
            <Vote as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl Vote {
        pub fn new() -> Vote {
            ::std::default::Default::default()
        }

        // optional uint32 item_def = 1;

        pub fn item_def(&self) -> u32 {
            self.item_def.unwrap_or(0)
        }

        pub fn clear_item_def(&mut self) {
            self.item_def = ::std::option::Option::None;
        }

        pub fn has_item_def(&self) -> bool {
            self.item_def.is_some()
        }

        // Param is passed by value, moved
        pub fn set_item_def(&mut self, v: u32) {
            self.item_def = ::std::option::Option::Some(v);
        }

        // optional .CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.EVoteType vote_type = 2;

        pub fn vote_type(&self) -> vote::EVoteType {
            match self.vote_type {
                Some(e) => e.enum_value_or(vote::EVoteType::k_eUp),
                None => vote::EVoteType::k_eUp,
            }
        }

        pub fn clear_vote_type(&mut self) {
            self.vote_type = ::std::option::Option::None;
        }

        pub fn has_vote_type(&self) -> bool {
            self.vote_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_vote_type(&mut self, v: vote::EVoteType) {
            self.vote_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for Vote {
        const NAME: &'static str = "Vote";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.item_def = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.vote_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.item_def {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.vote_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.item_def {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.vote_type {
                os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Vote {
            Vote::new()
        }

        fn clear(&mut self) {
            self.item_def = ::std::option::Option::None;
            self.vote_type = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Vote {
            static instance: Vote = Vote {
                item_def: ::std::option::Option::None,
                vote_type: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    /// Nested message and enums of message `Vote`
    pub mod vote {
        #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
        // @@protoc_insertion_point(enum:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.EVoteType)
        pub enum EVoteType {
            // @@protoc_insertion_point(enum_value:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.EVoteType.k_eUp)
            k_eUp = 0,
            // @@protoc_insertion_point(enum_value:CMsgGCToClientCollectorsCacheAvailableDataResponse.Vote.EVoteType.k_eDown)
            k_eDown = 1,
        }

        impl ::steam_vent_proto_common::protobuf::Enum for EVoteType {
            const NAME: &'static str = "EVoteType";

            fn value(&self) -> i32 {
                *self as i32
            }

            fn from_i32(value: i32) -> ::std::option::Option<EVoteType> {
                match value {
                    0 => ::std::option::Option::Some(EVoteType::k_eUp),
                    1 => ::std::option::Option::Some(EVoteType::k_eDown),
                    _ => ::std::option::Option::None
                }
            }

            fn from_str(str: &str) -> ::std::option::Option<EVoteType> {
                match str {
                    "k_eUp" => ::std::option::Option::Some(EVoteType::k_eUp),
                    "k_eDown" => ::std::option::Option::Some(EVoteType::k_eDown),
                    _ => ::std::option::Option::None
                }
            }

            const VALUES: &'static [EVoteType] = &[
                EVoteType::k_eUp,
                EVoteType::k_eDown,
            ];
        }

        impl ::std::default::Default for EVoteType {
            fn default() -> Self {
                EVoteType::k_eUp
            }
        }

    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUploadMatchClip)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUploadMatchClip {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUploadMatchClip.match_clip)
    pub match_clip: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMatchClip>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUploadMatchClip.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUploadMatchClip {
    fn default() -> &'a CMsgClientToGCUploadMatchClip {
        <CMsgClientToGCUploadMatchClip as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUploadMatchClip {
    pub fn new() -> CMsgClientToGCUploadMatchClip {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUploadMatchClip {
    const NAME: &'static str = "CMsgClientToGCUploadMatchClip";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.match_clip)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.match_clip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.match_clip.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUploadMatchClip {
        CMsgClientToGCUploadMatchClip::new()
    }

    fn clear(&mut self) {
        self.match_clip.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUploadMatchClip {
        static instance: CMsgClientToGCUploadMatchClip = CMsgClientToGCUploadMatchClip {
            match_clip: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientUploadMatchClipResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientUploadMatchClipResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientUploadMatchClipResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_upload_match_clip_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientUploadMatchClipResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientUploadMatchClipResponse {
    fn default() -> &'a CMsgGCToClientUploadMatchClipResponse {
        <CMsgGCToClientUploadMatchClipResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientUploadMatchClipResponse {
    pub fn new() -> CMsgGCToClientUploadMatchClipResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientUploadMatchClipResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_upload_match_clip_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_upload_match_clip_response::EResponse::k_eInternalError),
            None => cmsg_gcto_client_upload_match_clip_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_upload_match_clip_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientUploadMatchClipResponse {
    const NAME: &'static str = "CMsgGCToClientUploadMatchClipResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientUploadMatchClipResponse {
        CMsgGCToClientUploadMatchClipResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientUploadMatchClipResponse {
        static instance: CMsgGCToClientUploadMatchClipResponse = CMsgGCToClientUploadMatchClipResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientUploadMatchClipResponse`
pub mod cmsg_gcto_client_upload_match_clip_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientUploadMatchClipResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUploadMatchClipResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUploadMatchClipResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUploadMatchClipResponse.EResponse.k_eTimeout)
        k_eTimeout = 2,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientUploadMatchClipResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 4,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTimeout),
                4 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTimeout,
            EResponse::k_eTooBusy,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCMapStatsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCMapStatsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCMapStatsRequest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCMapStatsRequest {
    fn default() -> &'a CMsgClientToGCMapStatsRequest {
        <CMsgClientToGCMapStatsRequest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCMapStatsRequest {
    pub fn new() -> CMsgClientToGCMapStatsRequest {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCMapStatsRequest {
    const NAME: &'static str = "CMsgClientToGCMapStatsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCMapStatsRequest {
        CMsgClientToGCMapStatsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCMapStatsRequest {
        static instance: CMsgClientToGCMapStatsRequest = CMsgClientToGCMapStatsRequest {
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGCToClientMapStatsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientMapStatsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientMapStatsResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_gcto_client_map_stats_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgGCToClientMapStatsResponse.personal_stats)
    pub personal_stats: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgMapStatsSnapshot>,
    // @@protoc_insertion_point(field:CMsgGCToClientMapStatsResponse.global_stats)
    pub global_stats: ::steam_vent_proto_common::protobuf::MessageField<super::dota_gcmessages_common::CMsgGlobalMapStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientMapStatsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientMapStatsResponse {
    fn default() -> &'a CMsgGCToClientMapStatsResponse {
        <CMsgGCToClientMapStatsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientMapStatsResponse {
    pub fn new() -> CMsgGCToClientMapStatsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgGCToClientMapStatsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_gcto_client_map_stats_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_gcto_client_map_stats_response::EResponse::k_eInternalError),
            None => cmsg_gcto_client_map_stats_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_gcto_client_map_stats_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientMapStatsResponse {
    const NAME: &'static str = "CMsgGCToClientMapStatsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.personal_stats)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.global_stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.personal_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.global_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.personal_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.global_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientMapStatsResponse {
        CMsgGCToClientMapStatsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.personal_stats.clear();
        self.global_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientMapStatsResponse {
        static instance: CMsgGCToClientMapStatsResponse = CMsgGCToClientMapStatsResponse {
            response: ::std::option::Option::None,
            personal_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            global_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgGCToClientMapStatsResponse`
pub mod cmsg_gcto_client_map_stats_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgGCToClientMapStatsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgGCToClientMapStatsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgGCToClientMapStatsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgRoadToTIAssignedQuest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRoadToTIAssignedQuest {
    // message fields
    // @@protoc_insertion_point(field:CMsgRoadToTIAssignedQuest.quest_id)
    pub quest_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRoadToTIAssignedQuest.difficulty)
    pub difficulty: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRoadToTIAssignedQuest.progress_flags)
    pub progress_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRoadToTIAssignedQuest.half_credit_flags)
    pub half_credit_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgRoadToTIAssignedQuest.completed)
    pub completed: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRoadToTIAssignedQuest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRoadToTIAssignedQuest {
    fn default() -> &'a CMsgRoadToTIAssignedQuest {
        <CMsgRoadToTIAssignedQuest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRoadToTIAssignedQuest {
    pub fn new() -> CMsgRoadToTIAssignedQuest {
        ::std::default::Default::default()
    }

    // optional uint32 quest_id = 1;

    pub fn quest_id(&self) -> u32 {
        self.quest_id.unwrap_or(0)
    }

    pub fn clear_quest_id(&mut self) {
        self.quest_id = ::std::option::Option::None;
    }

    pub fn has_quest_id(&self) -> bool {
        self.quest_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_id(&mut self, v: u32) {
        self.quest_id = ::std::option::Option::Some(v);
    }

    // optional uint32 difficulty = 2;

    pub fn difficulty(&self) -> u32 {
        self.difficulty.unwrap_or(0)
    }

    pub fn clear_difficulty(&mut self) {
        self.difficulty = ::std::option::Option::None;
    }

    pub fn has_difficulty(&self) -> bool {
        self.difficulty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_difficulty(&mut self, v: u32) {
        self.difficulty = ::std::option::Option::Some(v);
    }

    // optional uint32 progress_flags = 3;

    pub fn progress_flags(&self) -> u32 {
        self.progress_flags.unwrap_or(0)
    }

    pub fn clear_progress_flags(&mut self) {
        self.progress_flags = ::std::option::Option::None;
    }

    pub fn has_progress_flags(&self) -> bool {
        self.progress_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_progress_flags(&mut self, v: u32) {
        self.progress_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 half_credit_flags = 4;

    pub fn half_credit_flags(&self) -> u32 {
        self.half_credit_flags.unwrap_or(0)
    }

    pub fn clear_half_credit_flags(&mut self) {
        self.half_credit_flags = ::std::option::Option::None;
    }

    pub fn has_half_credit_flags(&self) -> bool {
        self.half_credit_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_half_credit_flags(&mut self, v: u32) {
        self.half_credit_flags = ::std::option::Option::Some(v);
    }

    // optional bool completed = 5;

    pub fn completed(&self) -> bool {
        self.completed.unwrap_or(false)
    }

    pub fn clear_completed(&mut self) {
        self.completed = ::std::option::Option::None;
    }

    pub fn has_completed(&self) -> bool {
        self.completed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed(&mut self, v: bool) {
        self.completed = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRoadToTIAssignedQuest {
    const NAME: &'static str = "CMsgRoadToTIAssignedQuest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.quest_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.difficulty = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.progress_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.half_credit_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.completed = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.difficulty {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.progress_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.half_credit_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.completed {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.difficulty {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.progress_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.half_credit_flags {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.completed {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRoadToTIAssignedQuest {
        CMsgRoadToTIAssignedQuest::new()
    }

    fn clear(&mut self) {
        self.quest_id = ::std::option::Option::None;
        self.difficulty = ::std::option::Option::None;
        self.progress_flags = ::std::option::Option::None;
        self.half_credit_flags = ::std::option::Option::None;
        self.completed = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRoadToTIAssignedQuest {
        static instance: CMsgRoadToTIAssignedQuest = CMsgRoadToTIAssignedQuest {
            quest_id: ::std::option::Option::None,
            difficulty: ::std::option::Option::None,
            progress_flags: ::std::option::Option::None,
            half_credit_flags: ::std::option::Option::None,
            completed: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgRoadToTIUserData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgRoadToTIUserData {
    // message fields
    // @@protoc_insertion_point(field:CMsgRoadToTIUserData.quests)
    pub quests: ::std::vec::Vec<CMsgRoadToTIAssignedQuest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgRoadToTIUserData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgRoadToTIUserData {
    fn default() -> &'a CMsgRoadToTIUserData {
        <CMsgRoadToTIUserData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgRoadToTIUserData {
    pub fn new() -> CMsgRoadToTIUserData {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgRoadToTIUserData {
    const NAME: &'static str = "CMsgRoadToTIUserData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.quests.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.quests {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.quests {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgRoadToTIUserData {
        CMsgRoadToTIUserData::new()
    }

    fn clear(&mut self) {
        self.quests.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgRoadToTIUserData {
        static instance: CMsgRoadToTIUserData = CMsgRoadToTIUserData {
            quests: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIGetQuests)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIGetQuests {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetQuests.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIGetQuests.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIGetQuests {
    fn default() -> &'a CMsgClientToGCRoadToTIGetQuests {
        <CMsgClientToGCRoadToTIGetQuests as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIGetQuests {
    pub fn new() -> CMsgClientToGCRoadToTIGetQuests {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIGetQuests {
    const NAME: &'static str = "CMsgClientToGCRoadToTIGetQuests";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIGetQuests {
        CMsgClientToGCRoadToTIGetQuests::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIGetQuests {
        static instance: CMsgClientToGCRoadToTIGetQuests = CMsgClientToGCRoadToTIGetQuests {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIGetQuestsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIGetQuestsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetQuestsResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcroad_to_tiget_quests_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetQuestsResponse.quest_data)
    pub quest_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgRoadToTIUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIGetQuestsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIGetQuestsResponse {
    fn default() -> &'a CMsgClientToGCRoadToTIGetQuestsResponse {
        <CMsgClientToGCRoadToTIGetQuestsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIGetQuestsResponse {
    pub fn new() -> CMsgClientToGCRoadToTIGetQuestsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRoadToTIGetQuestsResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcroad_to_tiget_quests_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcroad_to_tiget_quests_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcroad_to_tiget_quests_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcroad_to_tiget_quests_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIGetQuestsResponse {
    const NAME: &'static str = "CMsgClientToGCRoadToTIGetQuestsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.quest_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quest_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIGetQuestsResponse {
        CMsgClientToGCRoadToTIGetQuestsResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.quest_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIGetQuestsResponse {
        static instance: CMsgClientToGCRoadToTIGetQuestsResponse = CMsgClientToGCRoadToTIGetQuestsResponse {
            response: ::std::option::Option::None,
            quest_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRoadToTIGetQuestsResponse`
pub mod cmsg_client_to_gcroad_to_tiget_quests_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetQuestsResponse.EResponse.k_eInvalidID)
        k_eInvalidID = 5,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidID" => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidID,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIGetActiveQuest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIGetActiveQuest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetActiveQuest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIGetActiveQuest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIGetActiveQuest {
    fn default() -> &'a CMsgClientToGCRoadToTIGetActiveQuest {
        <CMsgClientToGCRoadToTIGetActiveQuest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIGetActiveQuest {
    pub fn new() -> CMsgClientToGCRoadToTIGetActiveQuest {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIGetActiveQuest {
    const NAME: &'static str = "CMsgClientToGCRoadToTIGetActiveQuest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIGetActiveQuest {
        CMsgClientToGCRoadToTIGetActiveQuest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIGetActiveQuest {
        static instance: CMsgClientToGCRoadToTIGetActiveQuest = CMsgClientToGCRoadToTIGetActiveQuest {
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIGetActiveQuestResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIGetActiveQuestResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetActiveQuestResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcroad_to_tiget_active_quest_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIGetActiveQuestResponse.quest_data)
    pub quest_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgRoadToTIAssignedQuest>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIGetActiveQuestResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIGetActiveQuestResponse {
    fn default() -> &'a CMsgClientToGCRoadToTIGetActiveQuestResponse {
        <CMsgClientToGCRoadToTIGetActiveQuestResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIGetActiveQuestResponse {
    pub fn new() -> CMsgClientToGCRoadToTIGetActiveQuestResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcroad_to_tiget_active_quest_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcroad_to_tiget_active_quest_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcroad_to_tiget_active_quest_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcroad_to_tiget_active_quest_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIGetActiveQuestResponse {
    const NAME: &'static str = "CMsgClientToGCRoadToTIGetActiveQuestResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.quest_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.quest_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIGetActiveQuestResponse {
        CMsgClientToGCRoadToTIGetActiveQuestResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.quest_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIGetActiveQuestResponse {
        static instance: CMsgClientToGCRoadToTIGetActiveQuestResponse = CMsgClientToGCRoadToTIGetActiveQuestResponse {
            response: ::std::option::Option::None,
            quest_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRoadToTIGetActiveQuestResponse`
pub mod cmsg_client_to_gcroad_to_tiget_active_quest_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eNone)
        k_eNone = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eDisabled)
        k_eDisabled = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eTimeout)
        k_eTimeout = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIGetActiveQuestResponse.EResponse.k_eInvalidID)
        k_eInvalidID = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eNone),
                3 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                4 => ::std::option::Option::Some(EResponse::k_eDisabled),
                5 => ::std::option::Option::Some(EResponse::k_eTimeout),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eNone" => ::std::option::Option::Some(EResponse::k_eNone),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidID" => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eNone,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidID,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientRoadToTIQuestDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientRoadToTIQuestDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientRoadToTIQuestDataUpdated.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientRoadToTIQuestDataUpdated.quest_data)
    pub quest_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgRoadToTIUserData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientRoadToTIQuestDataUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientRoadToTIQuestDataUpdated {
    fn default() -> &'a CMsgGCToClientRoadToTIQuestDataUpdated {
        <CMsgGCToClientRoadToTIQuestDataUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientRoadToTIQuestDataUpdated {
    pub fn new() -> CMsgGCToClientRoadToTIQuestDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientRoadToTIQuestDataUpdated {
    const NAME: &'static str = "CMsgGCToClientRoadToTIQuestDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.quest_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.quest_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientRoadToTIQuestDataUpdated {
        CMsgGCToClientRoadToTIQuestDataUpdated::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.quest_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientRoadToTIQuestDataUpdated {
        static instance: CMsgGCToClientRoadToTIQuestDataUpdated = CMsgGCToClientRoadToTIQuestDataUpdated {
            event_id: ::std::option::Option::None,
            quest_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIUseItem)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIUseItem {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIUseItem.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIUseItem.item_type)
    pub item_type: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIUseItem.hero_index)
    pub hero_index: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIUseItem.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIUseItem {
    fn default() -> &'a CMsgClientToGCRoadToTIUseItem {
        <CMsgClientToGCRoadToTIUseItem as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIUseItem {
    pub fn new() -> CMsgClientToGCRoadToTIUseItem {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional uint32 item_type = 2;

    pub fn item_type(&self) -> u32 {
        self.item_type.unwrap_or(0)
    }

    pub fn clear_item_type(&mut self) {
        self.item_type = ::std::option::Option::None;
    }

    pub fn has_item_type(&self) -> bool {
        self.item_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_item_type(&mut self, v: u32) {
        self.item_type = ::std::option::Option::Some(v);
    }

    // optional uint32 hero_index = 3;

    pub fn hero_index(&self) -> u32 {
        self.hero_index.unwrap_or(0)
    }

    pub fn clear_hero_index(&mut self) {
        self.hero_index = ::std::option::Option::None;
    }

    pub fn has_hero_index(&self) -> bool {
        self.hero_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hero_index(&mut self, v: u32) {
        self.hero_index = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIUseItem {
    const NAME: &'static str = "CMsgClientToGCRoadToTIUseItem";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.item_type = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.hero_index = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.item_type {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.hero_index {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.item_type {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.hero_index {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIUseItem {
        CMsgClientToGCRoadToTIUseItem::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.item_type = ::std::option::Option::None;
        self.hero_index = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIUseItem {
        static instance: CMsgClientToGCRoadToTIUseItem = CMsgClientToGCRoadToTIUseItem {
            event_id: ::std::option::Option::None,
            item_type: ::std::option::Option::None,
            hero_index: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIUseItemResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIUseItemResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIUseItemResponse.response)
    pub response: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcroad_to_tiuse_item_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIUseItemResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIUseItemResponse {
    fn default() -> &'a CMsgClientToGCRoadToTIUseItemResponse {
        <CMsgClientToGCRoadToTIUseItemResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIUseItemResponse {
    pub fn new() -> CMsgClientToGCRoadToTIUseItemResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRoadToTIUseItemResponse.EResponse response = 1;

    pub fn response(&self) -> cmsg_client_to_gcroad_to_tiuse_item_response::EResponse {
        match self.response {
            Some(e) => e.enum_value_or(cmsg_client_to_gcroad_to_tiuse_item_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcroad_to_tiuse_item_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_response(&mut self) {
        self.response = ::std::option::Option::None;
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: cmsg_client_to_gcroad_to_tiuse_item_response::EResponse) {
        self.response = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIUseItemResponse {
    const NAME: &'static str = "CMsgClientToGCRoadToTIUseItemResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.response = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.response {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.response {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIUseItemResponse {
        CMsgClientToGCRoadToTIUseItemResponse::new()
    }

    fn clear(&mut self) {
        self.response = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIUseItemResponse {
        static instance: CMsgClientToGCRoadToTIUseItemResponse = CMsgClientToGCRoadToTIUseItemResponse {
            response: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRoadToTIUseItemResponse`
pub mod cmsg_client_to_gcroad_to_tiuse_item_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRoadToTIUseItemResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eBadInput)
        k_eBadInput = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eNoItem)
        k_eNoItem = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eDisabled)
        k_eDisabled = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eTimeout)
        k_eTimeout = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRoadToTIUseItemResponse.EResponse.k_eInvalidID)
        k_eInvalidID = 6,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eBadInput),
                3 => ::std::option::Option::Some(EResponse::k_eNoItem),
                4 => ::std::option::Option::Some(EResponse::k_eDisabled),
                5 => ::std::option::Option::Some(EResponse::k_eTimeout),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eBadInput" => ::std::option::Option::Some(EResponse::k_eBadInput),
                "k_eNoItem" => ::std::option::Option::Some(EResponse::k_eNoItem),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidID" => ::std::option::Option::Some(EResponse::k_eInvalidID),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eBadInput,
            EResponse::k_eNoItem,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidID,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRoadToTIDevForceQuest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRoadToTIDevForceQuest {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIDevForceQuest.event_id)
    pub event_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIDevForceQuest.force_match_type)
    pub force_match_type: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:CMsgClientToGCRoadToTIDevForceQuest.force_id)
    pub force_id: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRoadToTIDevForceQuest.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRoadToTIDevForceQuest {
    fn default() -> &'a CMsgClientToGCRoadToTIDevForceQuest {
        <CMsgClientToGCRoadToTIDevForceQuest as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRoadToTIDevForceQuest {
    pub fn new() -> CMsgClientToGCRoadToTIDevForceQuest {
        ::std::default::Default::default()
    }

    // optional uint32 event_id = 1;

    pub fn event_id(&self) -> u32 {
        self.event_id.unwrap_or(0)
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: u32) {
        self.event_id = ::std::option::Option::Some(v);
    }

    // optional bool force_match_type = 2;

    pub fn force_match_type(&self) -> bool {
        self.force_match_type.unwrap_or(false)
    }

    pub fn clear_force_match_type(&mut self) {
        self.force_match_type = ::std::option::Option::None;
    }

    pub fn has_force_match_type(&self) -> bool {
        self.force_match_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_match_type(&mut self, v: bool) {
        self.force_match_type = ::std::option::Option::Some(v);
    }

    // optional uint32 force_id = 3;

    pub fn force_id(&self) -> u32 {
        self.force_id.unwrap_or(0)
    }

    pub fn clear_force_id(&mut self) {
        self.force_id = ::std::option::Option::None;
    }

    pub fn has_force_id(&self) -> bool {
        self.force_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force_id(&mut self, v: u32) {
        self.force_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRoadToTIDevForceQuest {
    const NAME: &'static str = "CMsgClientToGCRoadToTIDevForceQuest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.force_match_type = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.force_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.force_match_type {
            my_size += 1 + 1;
        }
        if let Some(v) = self.force_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.force_match_type {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.force_id {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRoadToTIDevForceQuest {
        CMsgClientToGCRoadToTIDevForceQuest::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.force_match_type = ::std::option::Option::None;
        self.force_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRoadToTIDevForceQuest {
        static instance: CMsgClientToGCRoadToTIDevForceQuest = CMsgClientToGCRoadToTIDevForceQuest {
            event_id: ::std::option::Option::None,
            force_match_type: ::std::option::Option::None,
            force_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgLobbyRoadToTIMatchQuestData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgLobbyRoadToTIMatchQuestData {
    // message fields
    // @@protoc_insertion_point(field:CMsgLobbyRoadToTIMatchQuestData.quest_data)
    pub quest_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgRoadToTIAssignedQuest>,
    // @@protoc_insertion_point(field:CMsgLobbyRoadToTIMatchQuestData.quest_period)
    pub quest_period: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgLobbyRoadToTIMatchQuestData.quest_number)
    pub quest_number: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgLobbyRoadToTIMatchQuestData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgLobbyRoadToTIMatchQuestData {
    fn default() -> &'a CMsgLobbyRoadToTIMatchQuestData {
        <CMsgLobbyRoadToTIMatchQuestData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgLobbyRoadToTIMatchQuestData {
    pub fn new() -> CMsgLobbyRoadToTIMatchQuestData {
        ::std::default::Default::default()
    }

    // optional uint32 quest_period = 2;

    pub fn quest_period(&self) -> u32 {
        self.quest_period.unwrap_or(0)
    }

    pub fn clear_quest_period(&mut self) {
        self.quest_period = ::std::option::Option::None;
    }

    pub fn has_quest_period(&self) -> bool {
        self.quest_period.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_period(&mut self, v: u32) {
        self.quest_period = ::std::option::Option::Some(v);
    }

    // optional uint32 quest_number = 3;

    pub fn quest_number(&self) -> u32 {
        self.quest_number.unwrap_or(0)
    }

    pub fn clear_quest_number(&mut self) {
        self.quest_number = ::std::option::Option::None;
    }

    pub fn has_quest_number(&self) -> bool {
        self.quest_number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quest_number(&mut self, v: u32) {
        self.quest_number = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgLobbyRoadToTIMatchQuestData {
    const NAME: &'static str = "CMsgLobbyRoadToTIMatchQuestData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.quest_data)?;
                },
                16 => {
                    self.quest_period = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.quest_number = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.quest_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.quest_period {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.quest_number {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.quest_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.quest_period {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.quest_number {
            os.write_uint32(3, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgLobbyRoadToTIMatchQuestData {
        CMsgLobbyRoadToTIMatchQuestData::new()
    }

    fn clear(&mut self) {
        self.quest_data.clear();
        self.quest_period = ::std::option::Option::None;
        self.quest_number = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgLobbyRoadToTIMatchQuestData {
        static instance: CMsgLobbyRoadToTIMatchQuestData = CMsgLobbyRoadToTIMatchQuestData {
            quest_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            quest_period: ::std::option::Option::None,
            quest_number: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCNewBloomGift)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNewBloomGift {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCNewBloomGift.defindex)
    pub defindex: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCNewBloomGift.lobby_id)
    pub lobby_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCNewBloomGift.target_account_ids)
    pub target_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCNewBloomGift.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNewBloomGift {
    fn default() -> &'a CMsgClientToGCNewBloomGift {
        <CMsgClientToGCNewBloomGift as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNewBloomGift {
    pub fn new() -> CMsgClientToGCNewBloomGift {
        ::std::default::Default::default()
    }

    // optional uint32 defindex = 1;

    pub fn defindex(&self) -> u32 {
        self.defindex.unwrap_or(0)
    }

    pub fn clear_defindex(&mut self) {
        self.defindex = ::std::option::Option::None;
    }

    pub fn has_defindex(&self) -> bool {
        self.defindex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defindex(&mut self, v: u32) {
        self.defindex = ::std::option::Option::Some(v);
    }

    // optional uint64 lobby_id = 2;

    pub fn lobby_id(&self) -> u64 {
        self.lobby_id.unwrap_or(0)
    }

    pub fn clear_lobby_id(&mut self) {
        self.lobby_id = ::std::option::Option::None;
    }

    pub fn has_lobby_id(&self) -> bool {
        self.lobby_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lobby_id(&mut self, v: u64) {
        self.lobby_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCNewBloomGift {
    const NAME: &'static str = "CMsgClientToGCNewBloomGift";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.defindex = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.lobby_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                26 => {
                    is.read_repeated_packed_uint32_into(&mut self.target_account_ids)?;
                },
                24 => {
                    self.target_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.defindex {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.lobby_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(2, v);
        }
        for value in &self.target_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.defindex {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.lobby_id {
            os.write_uint64(2, v)?;
        }
        for v in &self.target_account_ids {
            os.write_uint32(3, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNewBloomGift {
        CMsgClientToGCNewBloomGift::new()
    }

    fn clear(&mut self) {
        self.defindex = ::std::option::Option::None;
        self.lobby_id = ::std::option::Option::None;
        self.target_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNewBloomGift {
        static instance: CMsgClientToGCNewBloomGift = CMsgClientToGCNewBloomGift {
            defindex: ::std::option::Option::None,
            lobby_id: ::std::option::Option::None,
            target_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCNewBloomGiftResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCNewBloomGiftResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCNewBloomGiftResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_gcmessages_common::ENewBloomGiftingResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCNewBloomGiftResponse.received_account_ids)
    pub received_account_ids: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCNewBloomGiftResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCNewBloomGiftResponse {
    fn default() -> &'a CMsgClientToGCNewBloomGiftResponse {
        <CMsgClientToGCNewBloomGiftResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCNewBloomGiftResponse {
    pub fn new() -> CMsgClientToGCNewBloomGiftResponse {
        ::std::default::Default::default()
    }

    // optional .ENewBloomGiftingResponse result = 1;

    pub fn result(&self) -> super::dota_gcmessages_common::ENewBloomGiftingResponse {
        match self.result {
            Some(e) => e.enum_value_or(super::dota_gcmessages_common::ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure),
            None => super::dota_gcmessages_common::ENewBloomGiftingResponse::kENewBloomGifting_UnknownFailure,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::dota_gcmessages_common::ENewBloomGiftingResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCNewBloomGiftResponse {
    const NAME: &'static str = "CMsgClientToGCNewBloomGiftResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.received_account_ids)?;
                },
                16 => {
                    self.received_account_ids.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.received_account_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.received_account_ids {
            os.write_uint32(2, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCNewBloomGiftResponse {
        CMsgClientToGCNewBloomGiftResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.received_account_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCNewBloomGiftResponse {
        static instance: CMsgClientToGCNewBloomGiftResponse = CMsgClientToGCNewBloomGiftResponse {
            result: ::std::option::Option::None,
            received_account_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSetBannedHeroes)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSetBannedHeroes {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSetBannedHeroes.banned_hero_ids)
    pub banned_hero_ids: ::std::vec::Vec<i32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSetBannedHeroes.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSetBannedHeroes {
    fn default() -> &'a CMsgClientToGCSetBannedHeroes {
        <CMsgClientToGCSetBannedHeroes as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSetBannedHeroes {
    pub fn new() -> CMsgClientToGCSetBannedHeroes {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSetBannedHeroes {
    const NAME: &'static str = "CMsgClientToGCSetBannedHeroes";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_int32_into(&mut self.banned_hero_ids)?;
                },
                8 => {
                    self.banned_hero_ids.push(is.read_int32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.banned_hero_ids {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, *value);
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        for v in &self.banned_hero_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSetBannedHeroes {
        CMsgClientToGCSetBannedHeroes::new()
    }

    fn clear(&mut self) {
        self.banned_hero_ids.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSetBannedHeroes {
        static instance: CMsgClientToGCSetBannedHeroes = CMsgClientToGCSetBannedHeroes {
            banned_hero_ids: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCUpdateComicBookStats)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCUpdateComicBookStats {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.comic_id)
    pub comic_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.stats)
    pub stats: ::std::vec::Vec<cmsg_client_to_gcupdate_comic_book_stats::SingleStat>,
    // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.language_stats)
    pub language_stats: ::steam_vent_proto_common::protobuf::MessageField<cmsg_client_to_gcupdate_comic_book_stats::LanguageStats>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCUpdateComicBookStats.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCUpdateComicBookStats {
    fn default() -> &'a CMsgClientToGCUpdateComicBookStats {
        <CMsgClientToGCUpdateComicBookStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCUpdateComicBookStats {
    pub fn new() -> CMsgClientToGCUpdateComicBookStats {
        ::std::default::Default::default()
    }

    // optional uint32 comic_id = 1;

    pub fn comic_id(&self) -> u32 {
        self.comic_id.unwrap_or(0)
    }

    pub fn clear_comic_id(&mut self) {
        self.comic_id = ::std::option::Option::None;
    }

    pub fn has_comic_id(&self) -> bool {
        self.comic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comic_id(&mut self, v: u32) {
        self.comic_id = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCUpdateComicBookStats {
    const NAME: &'static str = "CMsgClientToGCUpdateComicBookStats";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.comic_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.stats.push(is.read_message()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.language_stats)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.comic_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.stats {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.language_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.comic_id {
            os.write_uint32(1, v)?;
        }
        for v in &self.stats {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.language_stats.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCUpdateComicBookStats {
        CMsgClientToGCUpdateComicBookStats::new()
    }

    fn clear(&mut self) {
        self.comic_id = ::std::option::Option::None;
        self.stats.clear();
        self.language_stats.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCUpdateComicBookStats {
        static instance: CMsgClientToGCUpdateComicBookStats = CMsgClientToGCUpdateComicBookStats {
            comic_id: ::std::option::Option::None,
            stats: ::std::vec::Vec::new(),
            language_stats: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCUpdateComicBookStats`
pub mod cmsg_client_to_gcupdate_comic_book_stats {
    // @@protoc_insertion_point(message:CMsgClientToGCUpdateComicBookStats.SingleStat)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct SingleStat {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.SingleStat.stat_type)
        pub stat_type: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::CMsgClientToGCUpdateComicBookStat_Type>>,
        // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.SingleStat.stat_value)
        pub stat_value: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCUpdateComicBookStats.SingleStat.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a SingleStat {
        fn default() -> &'a SingleStat {
            <SingleStat as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl SingleStat {
        pub fn new() -> SingleStat {
            ::std::default::Default::default()
        }

        // optional .CMsgClientToGCUpdateComicBookStat_Type stat_type = 1;

        pub fn stat_type(&self) -> super::CMsgClientToGCUpdateComicBookStat_Type {
            match self.stat_type {
                Some(e) => e.enum_value_or(super::CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead),
                None => super::CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead,
            }
        }

        pub fn clear_stat_type(&mut self) {
            self.stat_type = ::std::option::Option::None;
        }

        pub fn has_stat_type(&self) -> bool {
            self.stat_type.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_type(&mut self, v: super::CMsgClientToGCUpdateComicBookStat_Type) {
            self.stat_type = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
        }

        // optional uint32 stat_value = 2;

        pub fn stat_value(&self) -> u32 {
            self.stat_value.unwrap_or(0)
        }

        pub fn clear_stat_value(&mut self) {
            self.stat_value = ::std::option::Option::None;
        }

        pub fn has_stat_value(&self) -> bool {
            self.stat_value.is_some()
        }

        // Param is passed by value, moved
        pub fn set_stat_value(&mut self, v: u32) {
            self.stat_value = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for SingleStat {
        const NAME: &'static str = "SingleStat";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.stat_type = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                    },
                    16 => {
                        self.stat_value = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.stat_type {
                my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
            }
            if let Some(v) = self.stat_value {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.stat_type {
                os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
            }
            if let Some(v) = self.stat_value {
                os.write_uint32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> SingleStat {
            SingleStat::new()
        }

        fn clear(&mut self) {
            self.stat_type = ::std::option::Option::None;
            self.stat_value = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static SingleStat {
            static instance: SingleStat = SingleStat {
                stat_type: ::std::option::Option::None,
                stat_value: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }

    // @@protoc_insertion_point(message:CMsgClientToGCUpdateComicBookStats.LanguageStats)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct LanguageStats {
        // message fields
        // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.LanguageStats.comic_id)
        pub comic_id: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.LanguageStats.client_language)
        pub client_language: ::std::option::Option<u32>,
        // @@protoc_insertion_point(field:CMsgClientToGCUpdateComicBookStats.LanguageStats.client_comic_language)
        pub client_comic_language: ::std::option::Option<u32>,
        // special fields
        // @@protoc_insertion_point(special_field:CMsgClientToGCUpdateComicBookStats.LanguageStats.special_fields)
        pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a LanguageStats {
        fn default() -> &'a LanguageStats {
            <LanguageStats as ::steam_vent_proto_common::protobuf::Message>::default_instance()
        }
    }

    impl LanguageStats {
        pub fn new() -> LanguageStats {
            ::std::default::Default::default()
        }

        // optional uint32 comic_id = 1;

        pub fn comic_id(&self) -> u32 {
            self.comic_id.unwrap_or(0)
        }

        pub fn clear_comic_id(&mut self) {
            self.comic_id = ::std::option::Option::None;
        }

        pub fn has_comic_id(&self) -> bool {
            self.comic_id.is_some()
        }

        // Param is passed by value, moved
        pub fn set_comic_id(&mut self, v: u32) {
            self.comic_id = ::std::option::Option::Some(v);
        }

        // optional uint32 client_language = 2;

        pub fn client_language(&self) -> u32 {
            self.client_language.unwrap_or(0)
        }

        pub fn clear_client_language(&mut self) {
            self.client_language = ::std::option::Option::None;
        }

        pub fn has_client_language(&self) -> bool {
            self.client_language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_language(&mut self, v: u32) {
            self.client_language = ::std::option::Option::Some(v);
        }

        // optional uint32 client_comic_language = 3;

        pub fn client_comic_language(&self) -> u32 {
            self.client_comic_language.unwrap_or(0)
        }

        pub fn clear_client_comic_language(&mut self) {
            self.client_comic_language = ::std::option::Option::None;
        }

        pub fn has_client_comic_language(&self) -> bool {
            self.client_comic_language.is_some()
        }

        // Param is passed by value, moved
        pub fn set_client_comic_language(&mut self, v: u32) {
            self.client_comic_language = ::std::option::Option::Some(v);
        }
    }

    impl ::steam_vent_proto_common::protobuf::Message for LanguageStats {
        const NAME: &'static str = "LanguageStats";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.comic_id = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    16 => {
                        self.client_language = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    24 => {
                        self.client_comic_language = ::std::option::Option::Some(is.read_uint32()?);
                    },
                    tag => {
                        ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.comic_id {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
            }
            if let Some(v) = self.client_language {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
            }
            if let Some(v) = self.client_comic_language {
                my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
            }
            my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
            if let Some(v) = self.comic_id {
                os.write_uint32(1, v)?;
            }
            if let Some(v) = self.client_language {
                os.write_uint32(2, v)?;
            }
            if let Some(v) = self.client_comic_language {
                os.write_uint32(3, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> LanguageStats {
            LanguageStats::new()
        }

        fn clear(&mut self) {
            self.comic_id = ::std::option::Option::None;
            self.client_language = ::std::option::Option::None;
            self.client_comic_language = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static LanguageStats {
            static instance: LanguageStats = LanguageStats {
                comic_id: ::std::option::Option::None,
                client_language: ::std::option::Option::None,
                client_comic_language: ::std::option::Option::None,
                special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
            };
            &instance
        }
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgDOTARequestMatches_SkillLevel)
pub enum CMsgDOTARequestMatches_SkillLevel {
    // @@protoc_insertion_point(enum_value:CMsgDOTARequestMatches_SkillLevel.CMsgDOTARequestMatches_SkillLevel_Any)
    CMsgDOTARequestMatches_SkillLevel_Any = 0,
    // @@protoc_insertion_point(enum_value:CMsgDOTARequestMatches_SkillLevel.CMsgDOTARequestMatches_SkillLevel_Normal)
    CMsgDOTARequestMatches_SkillLevel_Normal = 1,
    // @@protoc_insertion_point(enum_value:CMsgDOTARequestMatches_SkillLevel.CMsgDOTARequestMatches_SkillLevel_High)
    CMsgDOTARequestMatches_SkillLevel_High = 2,
    // @@protoc_insertion_point(enum_value:CMsgDOTARequestMatches_SkillLevel.CMsgDOTARequestMatches_SkillLevel_VeryHigh)
    CMsgDOTARequestMatches_SkillLevel_VeryHigh = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgDOTARequestMatches_SkillLevel {
    const NAME: &'static str = "CMsgDOTARequestMatches_SkillLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgDOTARequestMatches_SkillLevel> {
        match value {
            0 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Any),
            1 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Normal),
            2 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_High),
            3 => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_VeryHigh),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgDOTARequestMatches_SkillLevel> {
        match str {
            "CMsgDOTARequestMatches_SkillLevel_Any" => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Any),
            "CMsgDOTARequestMatches_SkillLevel_Normal" => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Normal),
            "CMsgDOTARequestMatches_SkillLevel_High" => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_High),
            "CMsgDOTARequestMatches_SkillLevel_VeryHigh" => ::std::option::Option::Some(CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_VeryHigh),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgDOTARequestMatches_SkillLevel] = &[
        CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Any,
        CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Normal,
        CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_High,
        CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_VeryHigh,
    ];
}

impl ::std::default::Default for CMsgDOTARequestMatches_SkillLevel {
    fn default() -> Self {
        CMsgDOTARequestMatches_SkillLevel::CMsgDOTARequestMatches_SkillLevel_Any
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:DOTA_WatchReplayType)
pub enum DOTA_WatchReplayType {
    // @@protoc_insertion_point(enum_value:DOTA_WatchReplayType.DOTA_WATCH_REPLAY_NORMAL)
    DOTA_WATCH_REPLAY_NORMAL = 0,
    // @@protoc_insertion_point(enum_value:DOTA_WatchReplayType.DOTA_WATCH_REPLAY_HIGHLIGHTS)
    DOTA_WATCH_REPLAY_HIGHLIGHTS = 1,
}

impl ::steam_vent_proto_common::protobuf::Enum for DOTA_WatchReplayType {
    const NAME: &'static str = "DOTA_WatchReplayType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DOTA_WatchReplayType> {
        match value {
            0 => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL),
            1 => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_HIGHLIGHTS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<DOTA_WatchReplayType> {
        match str {
            "DOTA_WATCH_REPLAY_NORMAL" => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL),
            "DOTA_WATCH_REPLAY_HIGHLIGHTS" => ::std::option::Option::Some(DOTA_WatchReplayType::DOTA_WATCH_REPLAY_HIGHLIGHTS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [DOTA_WatchReplayType] = &[
        DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL,
        DOTA_WatchReplayType::DOTA_WATCH_REPLAY_HIGHLIGHTS,
    ];
}

impl ::std::default::Default for DOTA_WatchReplayType {
    fn default() -> Self {
        DOTA_WatchReplayType::DOTA_WATCH_REPLAY_NORMAL
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EItemEditorReservationResult)
pub enum EItemEditorReservationResult {
    // @@protoc_insertion_point(enum_value:EItemEditorReservationResult.k_EItemEditorReservationResult_OK)
    k_EItemEditorReservationResult_OK = 1,
    // @@protoc_insertion_point(enum_value:EItemEditorReservationResult.k_EItemEditorReservationResult_AlreadyExists)
    k_EItemEditorReservationResult_AlreadyExists = 2,
    // @@protoc_insertion_point(enum_value:EItemEditorReservationResult.k_EItemEditorReservationResult_Reserved)
    k_EItemEditorReservationResult_Reserved = 3,
    // @@protoc_insertion_point(enum_value:EItemEditorReservationResult.k_EItemEditorReservationResult_TimedOut)
    k_EItemEditorReservationResult_TimedOut = 4,
}

impl ::steam_vent_proto_common::protobuf::Enum for EItemEditorReservationResult {
    const NAME: &'static str = "EItemEditorReservationResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EItemEditorReservationResult> {
        match value {
            1 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_OK),
            2 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_AlreadyExists),
            3 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_Reserved),
            4 => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_TimedOut),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EItemEditorReservationResult> {
        match str {
            "k_EItemEditorReservationResult_OK" => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_OK),
            "k_EItemEditorReservationResult_AlreadyExists" => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_AlreadyExists),
            "k_EItemEditorReservationResult_Reserved" => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_Reserved),
            "k_EItemEditorReservationResult_TimedOut" => ::std::option::Option::Some(EItemEditorReservationResult::k_EItemEditorReservationResult_TimedOut),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EItemEditorReservationResult] = &[
        EItemEditorReservationResult::k_EItemEditorReservationResult_OK,
        EItemEditorReservationResult::k_EItemEditorReservationResult_AlreadyExists,
        EItemEditorReservationResult::k_EItemEditorReservationResult_Reserved,
        EItemEditorReservationResult::k_EItemEditorReservationResult_TimedOut,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EItemEditorReservationResult {
    fn default() -> Self {
        EItemEditorReservationResult::k_EItemEditorReservationResult_OK
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EWeekendTourneyRichPresenceEvent)
pub enum EWeekendTourneyRichPresenceEvent {
    // @@protoc_insertion_point(enum_value:EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_None)
    k_EWeekendTourneyRichPresenceEvent_None = 0,
    // @@protoc_insertion_point(enum_value:EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_StartedMatch)
    k_EWeekendTourneyRichPresenceEvent_StartedMatch = 1,
    // @@protoc_insertion_point(enum_value:EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_WonMatch)
    k_EWeekendTourneyRichPresenceEvent_WonMatch = 2,
    // @@protoc_insertion_point(enum_value:EWeekendTourneyRichPresenceEvent.k_EWeekendTourneyRichPresenceEvent_Eliminated)
    k_EWeekendTourneyRichPresenceEvent_Eliminated = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for EWeekendTourneyRichPresenceEvent {
    const NAME: &'static str = "EWeekendTourneyRichPresenceEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EWeekendTourneyRichPresenceEvent> {
        match value {
            0 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None),
            1 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_StartedMatch),
            2 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_WonMatch),
            3 => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_Eliminated),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EWeekendTourneyRichPresenceEvent> {
        match str {
            "k_EWeekendTourneyRichPresenceEvent_None" => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None),
            "k_EWeekendTourneyRichPresenceEvent_StartedMatch" => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_StartedMatch),
            "k_EWeekendTourneyRichPresenceEvent_WonMatch" => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_WonMatch),
            "k_EWeekendTourneyRichPresenceEvent_Eliminated" => ::std::option::Option::Some(EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_Eliminated),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EWeekendTourneyRichPresenceEvent] = &[
        EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None,
        EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_StartedMatch,
        EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_WonMatch,
        EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_Eliminated,
    ];
}

impl ::std::default::Default for EWeekendTourneyRichPresenceEvent {
    fn default() -> Self {
        EWeekendTourneyRichPresenceEvent::k_EWeekendTourneyRichPresenceEvent_None
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTATriviaAnswerResult)
pub enum EDOTATriviaAnswerResult {
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_Success)
    k_EDOTATriviaAnswerResult_Success = 0,
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidQuestion)
    k_EDOTATriviaAnswerResult_InvalidQuestion = 1,
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_InvalidAnswer)
    k_EDOTATriviaAnswerResult_InvalidAnswer = 2,
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_QuestionLocked)
    k_EDOTATriviaAnswerResult_QuestionLocked = 3,
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_AlreadyAnswered)
    k_EDOTATriviaAnswerResult_AlreadyAnswered = 4,
    // @@protoc_insertion_point(enum_value:EDOTATriviaAnswerResult.k_EDOTATriviaAnswerResult_TriviaDisabled)
    k_EDOTATriviaAnswerResult_TriviaDisabled = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTATriviaAnswerResult {
    const NAME: &'static str = "EDOTATriviaAnswerResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTATriviaAnswerResult> {
        match value {
            0 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success),
            1 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidQuestion),
            2 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidAnswer),
            3 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_QuestionLocked),
            4 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_AlreadyAnswered),
            5 => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_TriviaDisabled),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTATriviaAnswerResult> {
        match str {
            "k_EDOTATriviaAnswerResult_Success" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success),
            "k_EDOTATriviaAnswerResult_InvalidQuestion" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidQuestion),
            "k_EDOTATriviaAnswerResult_InvalidAnswer" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidAnswer),
            "k_EDOTATriviaAnswerResult_QuestionLocked" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_QuestionLocked),
            "k_EDOTATriviaAnswerResult_AlreadyAnswered" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_AlreadyAnswered),
            "k_EDOTATriviaAnswerResult_TriviaDisabled" => ::std::option::Option::Some(EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_TriviaDisabled),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTATriviaAnswerResult] = &[
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success,
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidQuestion,
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_InvalidAnswer,
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_QuestionLocked,
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_AlreadyAnswered,
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_TriviaDisabled,
    ];
}

impl ::std::default::Default for EDOTATriviaAnswerResult {
    fn default() -> Self {
        EDOTATriviaAnswerResult::k_EDOTATriviaAnswerResult_Success
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EPurchaseHeroRelicResult)
pub enum EPurchaseHeroRelicResult {
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_Success)
    k_EPurchaseHeroRelicResult_Success = 0,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_FailedToSend)
    k_EPurchaseHeroRelicResult_FailedToSend = 1,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_NotEnoughPoints)
    k_EPurchaseHeroRelicResult_NotEnoughPoints = 2,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InternalServerError)
    k_EPurchaseHeroRelicResult_InternalServerError = 3,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_PurchaseNotAllowed)
    k_EPurchaseHeroRelicResult_PurchaseNotAllowed = 4,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRelic)
    k_EPurchaseHeroRelicResult_InvalidRelic = 5,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_AlreadyOwned)
    k_EPurchaseHeroRelicResult_AlreadyOwned = 6,
    // @@protoc_insertion_point(enum_value:EPurchaseHeroRelicResult.k_EPurchaseHeroRelicResult_InvalidRarity)
    k_EPurchaseHeroRelicResult_InvalidRarity = 7,
}

impl ::steam_vent_proto_common::protobuf::Enum for EPurchaseHeroRelicResult {
    const NAME: &'static str = "EPurchaseHeroRelicResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EPurchaseHeroRelicResult> {
        match value {
            0 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success),
            1 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_FailedToSend),
            2 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_NotEnoughPoints),
            3 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InternalServerError),
            4 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_PurchaseNotAllowed),
            5 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRelic),
            6 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_AlreadyOwned),
            7 => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRarity),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EPurchaseHeroRelicResult> {
        match str {
            "k_EPurchaseHeroRelicResult_Success" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success),
            "k_EPurchaseHeroRelicResult_FailedToSend" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_FailedToSend),
            "k_EPurchaseHeroRelicResult_NotEnoughPoints" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_NotEnoughPoints),
            "k_EPurchaseHeroRelicResult_InternalServerError" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InternalServerError),
            "k_EPurchaseHeroRelicResult_PurchaseNotAllowed" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_PurchaseNotAllowed),
            "k_EPurchaseHeroRelicResult_InvalidRelic" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRelic),
            "k_EPurchaseHeroRelicResult_AlreadyOwned" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_AlreadyOwned),
            "k_EPurchaseHeroRelicResult_InvalidRarity" => ::std::option::Option::Some(EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRarity),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EPurchaseHeroRelicResult] = &[
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_FailedToSend,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_NotEnoughPoints,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InternalServerError,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_PurchaseNotAllowed,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRelic,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_AlreadyOwned,
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_InvalidRarity,
    ];
}

impl ::std::default::Default for EPurchaseHeroRelicResult {
    fn default() -> Self {
        EPurchaseHeroRelicResult::k_EPurchaseHeroRelicResult_Success
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDevEventRequestResult)
pub enum EDevEventRequestResult {
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_Success)
    k_EDevEventRequestResult_Success = 0,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_NotAllowed)
    k_EDevEventRequestResult_NotAllowed = 1,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_InvalidEvent)
    k_EDevEventRequestResult_InvalidEvent = 2,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_SqlFailure)
    k_EDevEventRequestResult_SqlFailure = 3,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_Timeout)
    k_EDevEventRequestResult_Timeout = 4,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_LockFailure)
    k_EDevEventRequestResult_LockFailure = 5,
    // @@protoc_insertion_point(enum_value:EDevEventRequestResult.k_EDevEventRequestResult_SDOLoadFailure)
    k_EDevEventRequestResult_SDOLoadFailure = 6,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDevEventRequestResult {
    const NAME: &'static str = "EDevEventRequestResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDevEventRequestResult> {
        match value {
            0 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            1 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_NotAllowed),
            2 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_InvalidEvent),
            3 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_SqlFailure),
            4 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_Timeout),
            5 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_LockFailure),
            6 => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_SDOLoadFailure),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDevEventRequestResult> {
        match str {
            "k_EDevEventRequestResult_Success" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_Success),
            "k_EDevEventRequestResult_NotAllowed" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_NotAllowed),
            "k_EDevEventRequestResult_InvalidEvent" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_InvalidEvent),
            "k_EDevEventRequestResult_SqlFailure" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_SqlFailure),
            "k_EDevEventRequestResult_Timeout" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_Timeout),
            "k_EDevEventRequestResult_LockFailure" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_LockFailure),
            "k_EDevEventRequestResult_SDOLoadFailure" => ::std::option::Option::Some(EDevEventRequestResult::k_EDevEventRequestResult_SDOLoadFailure),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDevEventRequestResult] = &[
        EDevEventRequestResult::k_EDevEventRequestResult_Success,
        EDevEventRequestResult::k_EDevEventRequestResult_NotAllowed,
        EDevEventRequestResult::k_EDevEventRequestResult_InvalidEvent,
        EDevEventRequestResult::k_EDevEventRequestResult_SqlFailure,
        EDevEventRequestResult::k_EDevEventRequestResult_Timeout,
        EDevEventRequestResult::k_EDevEventRequestResult_LockFailure,
        EDevEventRequestResult::k_EDevEventRequestResult_SDOLoadFailure,
    ];
}

impl ::std::default::Default for EDevEventRequestResult {
    fn default() -> Self {
        EDevEventRequestResult::k_EDevEventRequestResult_Success
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ESupportEventRequestResult)
pub enum ESupportEventRequestResult {
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_Success)
    k_ESupportEventRequestResult_Success = 0,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_Timeout)
    k_ESupportEventRequestResult_Timeout = 1,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_CantLockSOCache)
    k_ESupportEventRequestResult_CantLockSOCache = 2,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_ItemNotInInventory)
    k_ESupportEventRequestResult_ItemNotInInventory = 3,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidItemDef)
    k_ESupportEventRequestResult_InvalidItemDef = 4,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEvent)
    k_ESupportEventRequestResult_InvalidEvent = 5,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_EventExpired)
    k_ESupportEventRequestResult_EventExpired = 6,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportAccount)
    k_ESupportEventRequestResult_InvalidSupportAccount = 7,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidSupportMessage)
    k_ESupportEventRequestResult_InvalidSupportMessage = 8,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidEventPoints)
    k_ESupportEventRequestResult_InvalidEventPoints = 9,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidPremiumPoints)
    k_ESupportEventRequestResult_InvalidPremiumPoints = 10,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionID)
    k_ESupportEventRequestResult_InvalidActionID = 11,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_InvalidActionScore)
    k_ESupportEventRequestResult_InvalidActionScore = 12,
    // @@protoc_insertion_point(enum_value:ESupportEventRequestResult.k_ESupportEventRequestResult_TransactionFailed)
    k_ESupportEventRequestResult_TransactionFailed = 13,
}

impl ::steam_vent_proto_common::protobuf::Enum for ESupportEventRequestResult {
    const NAME: &'static str = "ESupportEventRequestResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ESupportEventRequestResult> {
        match value {
            0 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_Success),
            1 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_Timeout),
            2 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_CantLockSOCache),
            3 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_ItemNotInInventory),
            4 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidItemDef),
            5 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEvent),
            6 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_EventExpired),
            7 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportAccount),
            8 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportMessage),
            9 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEventPoints),
            10 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidPremiumPoints),
            11 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionID),
            12 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionScore),
            13 => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_TransactionFailed),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ESupportEventRequestResult> {
        match str {
            "k_ESupportEventRequestResult_Success" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_Success),
            "k_ESupportEventRequestResult_Timeout" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_Timeout),
            "k_ESupportEventRequestResult_CantLockSOCache" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_CantLockSOCache),
            "k_ESupportEventRequestResult_ItemNotInInventory" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_ItemNotInInventory),
            "k_ESupportEventRequestResult_InvalidItemDef" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidItemDef),
            "k_ESupportEventRequestResult_InvalidEvent" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEvent),
            "k_ESupportEventRequestResult_EventExpired" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_EventExpired),
            "k_ESupportEventRequestResult_InvalidSupportAccount" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportAccount),
            "k_ESupportEventRequestResult_InvalidSupportMessage" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportMessage),
            "k_ESupportEventRequestResult_InvalidEventPoints" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEventPoints),
            "k_ESupportEventRequestResult_InvalidPremiumPoints" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidPremiumPoints),
            "k_ESupportEventRequestResult_InvalidActionID" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionID),
            "k_ESupportEventRequestResult_InvalidActionScore" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionScore),
            "k_ESupportEventRequestResult_TransactionFailed" => ::std::option::Option::Some(ESupportEventRequestResult::k_ESupportEventRequestResult_TransactionFailed),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ESupportEventRequestResult] = &[
        ESupportEventRequestResult::k_ESupportEventRequestResult_Success,
        ESupportEventRequestResult::k_ESupportEventRequestResult_Timeout,
        ESupportEventRequestResult::k_ESupportEventRequestResult_CantLockSOCache,
        ESupportEventRequestResult::k_ESupportEventRequestResult_ItemNotInInventory,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidItemDef,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEvent,
        ESupportEventRequestResult::k_ESupportEventRequestResult_EventExpired,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportAccount,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidSupportMessage,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidEventPoints,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidPremiumPoints,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionID,
        ESupportEventRequestResult::k_ESupportEventRequestResult_InvalidActionScore,
        ESupportEventRequestResult::k_ESupportEventRequestResult_TransactionFailed,
    ];
}

impl ::std::default::Default for ESupportEventRequestResult {
    fn default() -> Self {
        ESupportEventRequestResult::k_ESupportEventRequestResult_Success
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EUnderDraftResponse)
pub enum EUnderDraftResponse {
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eInternalError)
    k_eInternalError = 0,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eSuccess)
    k_eSuccess = 1,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eNoGold)
    k_eNoGold = 2,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eInvalidSlot)
    k_eInvalidSlot = 3,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eNoBenchSpace)
    k_eNoBenchSpace = 4,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eNoTickets)
    k_eNoTickets = 5,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eEventNotOwned)
    k_eEventNotOwned = 6,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eInvalidReward)
    k_eInvalidReward = 7,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eHasBigReward)
    k_eHasBigReward = 8,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eNoGCConnection)
    k_eNoGCConnection = 9,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eTooBusy)
    k_eTooBusy = 10,
    // @@protoc_insertion_point(enum_value:EUnderDraftResponse.k_eCantRollBack)
    k_eCantRollBack = 11,
}

impl ::steam_vent_proto_common::protobuf::Enum for EUnderDraftResponse {
    const NAME: &'static str = "EUnderDraftResponse";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EUnderDraftResponse> {
        match value {
            0 => ::std::option::Option::Some(EUnderDraftResponse::k_eInternalError),
            1 => ::std::option::Option::Some(EUnderDraftResponse::k_eSuccess),
            2 => ::std::option::Option::Some(EUnderDraftResponse::k_eNoGold),
            3 => ::std::option::Option::Some(EUnderDraftResponse::k_eInvalidSlot),
            4 => ::std::option::Option::Some(EUnderDraftResponse::k_eNoBenchSpace),
            5 => ::std::option::Option::Some(EUnderDraftResponse::k_eNoTickets),
            6 => ::std::option::Option::Some(EUnderDraftResponse::k_eEventNotOwned),
            7 => ::std::option::Option::Some(EUnderDraftResponse::k_eInvalidReward),
            8 => ::std::option::Option::Some(EUnderDraftResponse::k_eHasBigReward),
            9 => ::std::option::Option::Some(EUnderDraftResponse::k_eNoGCConnection),
            10 => ::std::option::Option::Some(EUnderDraftResponse::k_eTooBusy),
            11 => ::std::option::Option::Some(EUnderDraftResponse::k_eCantRollBack),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EUnderDraftResponse> {
        match str {
            "k_eInternalError" => ::std::option::Option::Some(EUnderDraftResponse::k_eInternalError),
            "k_eSuccess" => ::std::option::Option::Some(EUnderDraftResponse::k_eSuccess),
            "k_eNoGold" => ::std::option::Option::Some(EUnderDraftResponse::k_eNoGold),
            "k_eInvalidSlot" => ::std::option::Option::Some(EUnderDraftResponse::k_eInvalidSlot),
            "k_eNoBenchSpace" => ::std::option::Option::Some(EUnderDraftResponse::k_eNoBenchSpace),
            "k_eNoTickets" => ::std::option::Option::Some(EUnderDraftResponse::k_eNoTickets),
            "k_eEventNotOwned" => ::std::option::Option::Some(EUnderDraftResponse::k_eEventNotOwned),
            "k_eInvalidReward" => ::std::option::Option::Some(EUnderDraftResponse::k_eInvalidReward),
            "k_eHasBigReward" => ::std::option::Option::Some(EUnderDraftResponse::k_eHasBigReward),
            "k_eNoGCConnection" => ::std::option::Option::Some(EUnderDraftResponse::k_eNoGCConnection),
            "k_eTooBusy" => ::std::option::Option::Some(EUnderDraftResponse::k_eTooBusy),
            "k_eCantRollBack" => ::std::option::Option::Some(EUnderDraftResponse::k_eCantRollBack),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EUnderDraftResponse] = &[
        EUnderDraftResponse::k_eInternalError,
        EUnderDraftResponse::k_eSuccess,
        EUnderDraftResponse::k_eNoGold,
        EUnderDraftResponse::k_eInvalidSlot,
        EUnderDraftResponse::k_eNoBenchSpace,
        EUnderDraftResponse::k_eNoTickets,
        EUnderDraftResponse::k_eEventNotOwned,
        EUnderDraftResponse::k_eInvalidReward,
        EUnderDraftResponse::k_eHasBigReward,
        EUnderDraftResponse::k_eNoGCConnection,
        EUnderDraftResponse::k_eTooBusy,
        EUnderDraftResponse::k_eCantRollBack,
    ];
}

impl ::std::default::Default for EUnderDraftResponse {
    fn default() -> Self {
        EUnderDraftResponse::k_eInternalError
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EDOTADraftTriviaAnswerResult)
pub enum EDOTADraftTriviaAnswerResult {
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_Success)
    k_EDOTADraftTriviaAnswerResult_Success = 0,
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InvalidMatchID)
    k_EDOTADraftTriviaAnswerResult_InvalidMatchID = 1,
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_AlreadyAnswered)
    k_EDOTADraftTriviaAnswerResult_AlreadyAnswered = 2,
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_InternalError)
    k_EDOTADraftTriviaAnswerResult_InternalError = 3,
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_TriviaDisabled)
    k_EDOTADraftTriviaAnswerResult_TriviaDisabled = 4,
    // @@protoc_insertion_point(enum_value:EDOTADraftTriviaAnswerResult.k_EDOTADraftTriviaAnswerResult_GCDown)
    k_EDOTADraftTriviaAnswerResult_GCDown = 5,
}

impl ::steam_vent_proto_common::protobuf::Enum for EDOTADraftTriviaAnswerResult {
    const NAME: &'static str = "EDOTADraftTriviaAnswerResult";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EDOTADraftTriviaAnswerResult> {
        match value {
            0 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success),
            1 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InvalidMatchID),
            2 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_AlreadyAnswered),
            3 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InternalError),
            4 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_TriviaDisabled),
            5 => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_GCDown),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EDOTADraftTriviaAnswerResult> {
        match str {
            "k_EDOTADraftTriviaAnswerResult_Success" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success),
            "k_EDOTADraftTriviaAnswerResult_InvalidMatchID" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InvalidMatchID),
            "k_EDOTADraftTriviaAnswerResult_AlreadyAnswered" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_AlreadyAnswered),
            "k_EDOTADraftTriviaAnswerResult_InternalError" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InternalError),
            "k_EDOTADraftTriviaAnswerResult_TriviaDisabled" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_TriviaDisabled),
            "k_EDOTADraftTriviaAnswerResult_GCDown" => ::std::option::Option::Some(EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_GCDown),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EDOTADraftTriviaAnswerResult] = &[
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success,
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InvalidMatchID,
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_AlreadyAnswered,
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_InternalError,
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_TriviaDisabled,
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_GCDown,
    ];
}

impl ::std::default::Default for EDOTADraftTriviaAnswerResult {
    fn default() -> Self {
        EDOTADraftTriviaAnswerResult::k_EDOTADraftTriviaAnswerResult_Success
    }
}


#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CMsgClientToGCUpdateComicBookStat_Type)
pub enum CMsgClientToGCUpdateComicBookStat_Type {
    // @@protoc_insertion_point(enum_value:CMsgClientToGCUpdateComicBookStat_Type.CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead)
    CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead = 1,
    // @@protoc_insertion_point(enum_value:CMsgClientToGCUpdateComicBookStat_Type.CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading)
    CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading = 2,
    // @@protoc_insertion_point(enum_value:CMsgClientToGCUpdateComicBookStat_Type.CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead)
    CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead = 3,
}

impl ::steam_vent_proto_common::protobuf::Enum for CMsgClientToGCUpdateComicBookStat_Type {
    const NAME: &'static str = "CMsgClientToGCUpdateComicBookStat_Type";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CMsgClientToGCUpdateComicBookStat_Type> {
        match value {
            1 => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead),
            2 => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading),
            3 => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CMsgClientToGCUpdateComicBookStat_Type> {
        match str {
            "CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead" => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead),
            "CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading" => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading),
            "CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead" => ::std::option::Option::Some(CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CMsgClientToGCUpdateComicBookStat_Type] = &[
        CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead,
        CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_SecondsSpentReading,
        CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPercentRead,
    ];
}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for CMsgClientToGCUpdateComicBookStat_Type {
    fn default() -> Self {
        CMsgClientToGCUpdateComicBookStat_Type::CMsgClientToGCUpdateComicBookStat_Type_HighestPageRead
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::steammessages::*;
#[allow(unused_imports)]
use crate::dota_shared_enums::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_webapi::*;
#[allow(unused_imports)]
use crate::gcsdk_gcmessages::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_lobby::*;
#[allow(unused_imports)]
use crate::dota_gcmessages_common_match_management::*;
#[allow(unused_imports)]
use crate::base_gcmessages::*;
#[allow(unused_imports)]
use crate::econ_gcmessages::*;
#[allow(unused_imports)]
use crate::valveextensions::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgClientSuspended {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientSuspended {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCClientSuspended;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgBalancedShuffleLobby {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgBalancedShuffleLobby {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCBalancedShuffleLobby;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgInitialQuestionnaireResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgInitialQuestionnaireResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCInitialQuestionnaireResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTARequestMatchesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPopup {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAReportsRemainingRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAReportsRemainingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerReport {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerReportResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerAvoidRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerAvoidRequestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerReportV2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitPlayerReportResponseV2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitLobbyMVPVote {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitLobbyMVPVoteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALobbyMVPAwarded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAKickedFromMatchmakingQueue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMatchDetailsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCMatchDetailsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCMatchDetailsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCMatchDetailsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCMatchDetailsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCMatchDetailsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAProfileTickets {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetProfileTickets {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetProfileTickets {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetProfileTickets;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPartySearchInvites {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPartySearchInvites {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPartySearchInvites;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAWelcome {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CSODOTAGameHeroFavorites {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMatchVotes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgMatchmakingMatchGroupInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMatchmakingStatsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMatchmakingStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAUpdateMatchmakingStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAUpdateMatchManagementStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetMatchHistoryAccess {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetMatchHistoryAccessResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTANotifyAccountFlagsChange {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetProfilePrivacy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetProfilePrivacyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUpgradeLeagueItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgUpgradeLeagueItem {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgUpgradeLeagueItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgUpgradeLeagueItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgUpgradeLeagueItemResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgUpgradeLeagueItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCWatchDownloadedReplay {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCWatchDownloadedReplay {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCWatchDownloadedReplay;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientsRejoinChatChannels {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientsRejoinChatChannels {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientsRejoinChatChannels;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetHeroStandings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGetHeroStandings {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetHeroStandings;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetHeroStandingsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGetHeroStandingsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetHeroStandingsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerTimedStatAverages {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMatchPlayerTimedStatStdDeviations {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetHeroTimedStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReservationsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCItemEditorReservationsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReservationsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReservation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReservationsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCItemEditorReservationsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReservationsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReserveItemDef {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCItemEditorReserveItemDef {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReserveItemDef;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReserveItemDefResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCItemEditorReserveItemDefResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReserveItemDefResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCItemEditorReleaseReservation {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCItemEditorReleaseReservation {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReleaseReservation;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCItemEditorReleaseReservationResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCItemEditorReleaseReservationResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCItemEditorReleaseReservationResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgFlipLobbyTeams {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgFlipLobbyTeams {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCFlipLobbyTeams;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCLobbyUpdateBroadcastChannelInfo {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCLobbyUpdateBroadcastChannelInfo {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCLobbyUpdateBroadcastChannelInfo;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAClaimEventActionData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAClaimEventAction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAClaimEventAction {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAClaimEventAction;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCClaimEventActionUsingItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCClaimEventActionUsingItem {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCClaimEventActionUsingItem;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCClaimEventActionUsingItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCClaimEventActionUsingItemResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCClaimEventActionUsingItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientClaimEventActionUsingItemCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientClaimEventActionUsingItemCompleted {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientClaimEventActionUsingItemCompleted;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetEventPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAGetEventPoints {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetEventPoints;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetEventPointsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAGetEventPointsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetEventPointsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetPeriodicResource {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAGetPeriodicResource {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetPeriodicResource;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetPeriodicResourceResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgDOTAGetPeriodicResourceResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetPeriodicResourceResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPeriodicResourceUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAPeriodicResourceUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAPeriodicResourceUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACompendiumSelection {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACompendiumSelectionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACompendiumData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACompendiumDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACompendiumDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetPlayerMatchHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTAGetPlayerMatchHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetPlayerMatchHistory;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetPlayerMatchHistoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgDOTAGetPlayerMatchHistoryResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTAGetPlayerMatchHistoryResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotificationsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCNotificationsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCNotificationsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotifications_Notification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotificationsUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotificationsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCNotificationsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCNotificationsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCNotificationsMarkReadRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCNotificationsMarkReadRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCNotificationsMarkReadRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCPlayerInfoSubmit {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCPlayerInfoSubmit {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCPlayerInfoSubmit;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCPlayerInfoSubmitResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCPlayerInfoSubmitResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCPlayerInfoSubmitResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAEmoticonAccessSDO {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCEmoticonDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCEmoticonDataRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCEmoticonDataRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientEmoticonData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientEmoticonData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientEmoticonData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientTournamentItemDrop {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientTournamentItemDrop {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientTournamentItemDrop;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetAllHeroOrder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetAllHeroOrder {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetAllHeroOrder;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetAllHeroOrderResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetAllHeroOrderResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetAllHeroOrderResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetAllHeroProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetAllHeroProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetAllHeroProgress;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetAllHeroProgressResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetAllHeroProgressResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetAllHeroProgressResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetTrophyList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetTrophyList {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetTrophyList;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetTrophyListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetTrophyListResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetTrophyListResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientTrophyAwarded {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientTrophyAwarded {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientTrophyAwarded;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRankRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRankRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRankRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRankResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientRankResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRankResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRankUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientRankUpdate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRankUpdate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetProfileCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetProfileCard {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetProfileCard;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetProfileCardSlots {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetProfileCardSlots {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetProfileCardSlots;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetProfileCardStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetProfileCardStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetProfileCardStats;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateHeroStatue {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCCreateHeroStatue {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateHeroStatue;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientHeroStatueCreateResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientHeroStatueCreateResult {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientHeroStatueCreateResult;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPlayerStatsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCPlayerStatsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlayerStatsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPlayerStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientPlayerStatsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPlayerStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCustomGamesFriendsPlayedRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCustomGamesFriendsPlayedRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCustomGamesFriendsPlayedResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientCustomGamesFriendsPlayedResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSocialFeedPostCommentRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSocialFeedPostCommentRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSocialFeedPostCommentRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientSocialFeedPostCommentResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientSocialFeedPostCommentResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientSocialFeedPostCommentResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSocialFeedPostMessageRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSocialFeedPostMessageRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSocialFeedPostMessageRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientSocialFeedPostMessageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientSocialFeedPostMessageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientSocialFeedPostMessageResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCFriendsPlayedCustomGameRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCFriendsPlayedCustomGameRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCFriendsPlayedCustomGameRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientFriendsPlayedCustomGameResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientFriendsPlayedCustomGameResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientFriendsPlayedCustomGameResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPartyRichPresence {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTALobbyRichPresence {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgDOTACustomGameListenServerStartedLoading {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTACustomGameClientFinishedLoading {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCApplyGemCombiner {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCApplyGemCombiner {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCApplyGemCombiner;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCH264Unsupported {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCH264Unsupported {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCH264Unsupported;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetQuestProgress {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetQuestProgress {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetQuestProgress;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetQuestProgressResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetQuestProgressResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetQuestProgressResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientMatchSignedOut {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientMatchSignedOut {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientMatchSignedOut;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetHeroStatsHistory {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCGetHeroStatsHistory {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetHeroStatsHistory;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCGetHeroStatsHistoryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCGetHeroStatsHistoryResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCGetHeroStatsHistoryResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerConductScorecardRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPlayerConductScorecard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCWageringRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCWageringRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCWageringRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientWageringResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientWageringResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientWageringResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientWageringUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientWageringUpdate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientWageringUpdate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientArcanaVotesUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientArcanaVotesUpdate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientArcanaVotesUpdate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetEventGoals {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEventGoals {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToGCLeaguePredictions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPredictionRankings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPredictionResults {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCHasPlayerVotedForMVP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCHasPlayerVotedForMVP {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCHasPlayerVotedForMVP;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCHasPlayerVotedForMVPResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCHasPlayerVotedForMVPResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCHasPlayerVotedForMVPResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCVoteForMVP {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCVoteForMVP {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCVoteForMVP;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCVoteForMVPResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCVoteForMVPResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCVoteForMVPResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCMVPVoteTimeout {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCMVPVoteTimeout {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCMVPVoteTimeout;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCMVPVoteTimeoutResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCMVPVoteTimeoutResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCMVPVoteTimeoutResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCTeammateStatsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCTeammateStatsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCTeammateStatsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCTeammateStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCTeammateStatsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCTeammateStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCVoteForArcana {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCVoteForArcana {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCVoteForArcana;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCVoteForArcanaResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCVoteForArcanaResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCVoteForArcanaResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestArcanaVotesRemaining {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestArcanaVotesRemaining {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestArcanaVotesRemaining;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestArcanaVotesRemainingResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestArcanaVotesRemainingResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestEventPointLogV2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestEventPointLogV2 {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestEventPointLogV2;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestEventPointLogResponseV2 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestEventPointLogResponseV2 {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestEventPointLogResponseV2;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPublishUserStat {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCPublishUserStat {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPublishUserStat;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestSlarkGameResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestSlarkGameResultResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientQuestProgressUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientQuestProgressUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientQuestProgressUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTARedeemItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTARedeemItem {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTARedeemItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTARedeemItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTARedeemItemResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTARedeemItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSelectCompendiumInGamePrediction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSelectCompendiumInGamePrediction {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSelectCompendiumInGamePrediction;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSelectCompendiumInGamePredictionResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSelectCompendiumInGamePredictionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOpenPlayerCardPack {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCOpenPlayerCardPack {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOpenPlayerCardPack;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOpenPlayerCardPackResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOpenPlayerCardPackResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOpenPlayerCardPackResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRecyclePlayerCard {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRecyclePlayerCard {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRecyclePlayerCard;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRecyclePlayerCardResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRecyclePlayerCardResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRecyclePlayerCardResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreatePlayerCardPack {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreatePlayerCardPack {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreatePlayerCardPack;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCreatePlayerCardPackResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreatePlayerCardPackResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreatePlayerCardPackResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCreateTeamPlayerCardPack {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateTeamPlayerCardPack {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateTeamPlayerCardPack;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCreateTeamPlayerCardPackResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateTeamPlayerCardPackResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateTeamPlayerCardPackResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientBattlePassRollup_International2016 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollup_Fall2016 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientBattlePassRollup_Winter2017 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollup_TI7 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollup_TI8 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollup_TI9 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollup_TI10 {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollupRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientBattlePassRollupRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientBattlePassRollupRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientBattlePassRollupResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientBattlePassRollupResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientBattlePassRollupResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientBattlePassRollupListRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientBattlePassRollupListRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientBattlePassRollupListRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientBattlePassRollupListResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientBattlePassRollupListResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientBattlePassRollupListResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCTransferSeasonalMMRRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCTransferSeasonalMMRRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCTransferSeasonalMMRRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCTransferSeasonalMMRResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCTransferSeasonalMMRResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCTransferSeasonalMMRResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPlaytestStatus {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPlaytestStatus {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPlaytestStatus;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCJoinPlaytest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCJoinPlaytest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCJoinPlaytest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCJoinPlaytestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCJoinPlaytestResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCJoinPlaytestResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASetFavoriteTeam {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDOTASetFavoriteTeam {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDOTASetFavoriteTeam;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTATriviaCurrentQuestions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASubmitTriviaQuestionAnswer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgDOTASubmitTriviaQuestionAnswerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAStartTriviaSession {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAStartTriviaSessionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAAnchorPhoneNumberRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAAnchorPhoneNumberResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAUnanchorPhoneNumberRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgDOTAUnanchorPhoneNumberRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgAnchorPhoneNumberRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAUnanchorPhoneNumberResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgDOTAUnanchorPhoneNumberResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgAnchorPhoneNumberResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientCommendNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCommendNotification {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientCommendNotification;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAClientToGCQuickStatsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAClientToGCQuickStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASelectionPriorityChoiceRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTASelectionPriorityChoiceResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGameAutographReward {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGameAutographRewardResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADestroyLobbyRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTADestroyLobbyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetRecentPlayTimeFriendsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAGetRecentPlayTimeFriendsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPurchaseItemWithEventPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgPurchaseItemWithEventPoints {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPurchaseItemWithEventPoints;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPurchaseItemWithEventPointsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgPurchaseItemWithEventPointsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPurchaseItemWithEventPointsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPurchaseHeroRandomRelic {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgPurchaseHeroRandomRelic {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPurchaseHeroRandomRelic;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPurchaseHeroRandomRelicResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgPurchaseHeroRandomRelicResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPurchaseHeroRandomRelicResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlusWeeklyChallengeResult {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlusWeeklyChallengeResult {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlusWeeklyChallengeResult;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlusWeeklyChallengeResultResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlusWeeklyChallengeResultResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProfileRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgProfileRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgProfileRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProfileResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgProfileResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgProfileResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProfileUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgProfileUpdate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgProfileUpdate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgProfileUpdateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgProfileUpdateResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgProfileUpdateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgTalentWinRates {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGlobalHeroAverages {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroGlobalDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgHeroGlobalDataRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgHeroGlobalDataRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroGlobalDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgHeroGlobalDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgHeroGlobalDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroGlobalDataAllHeroes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgHeroGlobalDataHeroesAlliesAndEnemies {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPrivateMetadataKeyRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgPrivateMetadataKeyRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPrivateMetadataKeyRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPrivateMetadataKeyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgPrivateMetadataKeyResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgPrivateMetadataKeyResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgActivatePlusFreeTrialResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientCavernCrawlMapPathCompleted {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCavernCrawlMapPathCompleted {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientCavernCrawlMapPathCompleted;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientCavernCrawlMapUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCavernCrawlMapUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientCavernCrawlMapUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCavernCrawlClaimRoom {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlClaimRoom {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlClaimRoom;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlClaimRoomResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlClaimRoomResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlClaimRoomResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCavernCrawlUseItemOnRoom {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlUseItemOnRoom {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlUseItemOnRoom;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlUseItemOnRoomResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlUseItemOnRoomResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCavernCrawlUseItemOnPath {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlUseItemOnPath {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlUseItemOnPath;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlUseItemOnPathResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlUseItemOnPathResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCCavernCrawlRequestMapState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlRequestMapState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlRequestMapState;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlRequestMapStateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlRequestMapStateResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlRequestMapStateResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlGetClaimedRoomCount {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlGetClaimedRoomCount;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCavernCrawlGetClaimedRoomCountResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCavernCrawlGetClaimedRoomCountResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAMutationList {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEventTipsSummaryRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgEventTipsSummaryResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSocialFeedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSocialFeedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSocialFeedCommentsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgSocialFeedCommentsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlayerCardSpecificPurchaseRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlayerCardSpecificPurchaseRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlayerCardSpecificPurchaseResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlayerCardSpecificPurchaseResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestContestVotes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestContestVotes {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestContestVotes;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestContestVotesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestContestVotesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestContestVotesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRecordContestVote {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRecordContestVote {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRecordContestVote;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRecordContestVoteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRecordContestVoteResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRecordContestVoteResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevGrantEventPoints {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevGrantEventPoints {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevGrantEventPoints;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevGrantEventPointsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevGrantEventPointsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevGrantEventPointsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevGrantEventAction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevGrantEventAction {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevGrantEventAction;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevGrantEventActionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevGrantEventActionResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevGrantEventActionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevDeleteEventActions {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevDeleteEventActions {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevDeleteEventActions;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevDeleteEventActionsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgDevDeleteEventActionsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevDeleteEventActionsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevResetEventState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevResetEventState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevResetEventState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDevResetEventStateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgDevResetEventStateResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgDevResetEventStateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConsumeEventSupportGrantItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgConsumeEventSupportGrantItem {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgConsumeEventSupportGrantItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgConsumeEventSupportGrantItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgConsumeEventSupportGrantItemResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgConsumeEventSupportGrantItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetFilteredPlayers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetFilteredPlayers {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetFilteredPlayers;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGetFilteredPlayersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientGetFilteredPlayersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGetFilteredPlayersResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRemoveFilteredPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRemoveFilteredPlayer {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRemoveFilteredPlayer;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientRemoveFilteredPlayerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRemoveFilteredPlayerResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRemoveFilteredPlayerResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPurchaseFilteredPlayerSlot {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPurchaseFilteredPlayerSlot {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPurchaseFilteredPlayerSlot;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientPurchaseFilteredPlayerSlotResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPurchaseFilteredPlayerSlotResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUpdateFilteredPlayerNote {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUpdateFilteredPlayerNote {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUpdateFilteredPlayerNote;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientUpdateFilteredPlayerNoteResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientUpdateFilteredPlayerNoteResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgPartySearchPlayer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPlayerBeaconState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPlayerBeaconState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPlayerBeaconState;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPartyBeaconUpdate {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPartyBeaconUpdate {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPartyBeaconUpdate;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUpdatePartyBeacon {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUpdatePartyBeacon {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUpdatePartyBeacon;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestActiveBeaconParties {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestActiveBeaconParties {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestActiveBeaconParties;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientRequestActiveBeaconPartiesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRequestActiveBeaconPartiesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRequestActiveBeaconPartiesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCJoinPartyFromBeacon {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCJoinPartyFromBeacon {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCJoinPartyFromBeacon;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientJoinPartyFromBeaconResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientJoinPartyFromBeaconResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientJoinPartyFromBeaconResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCManageFavorites {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCManageFavorites {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCManageFavorites;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientManageFavoritesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientManageFavoritesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientManageFavoritesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetFavoritePlayers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetFavoritePlayers {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetFavoritePlayers;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGetFavoritePlayersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientGetFavoritePlayersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientGetFavoritePlayersResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientPartySearchInvite {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientPartySearchInvite {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientPartySearchInvite;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCVerifyFavoritePlayers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCVerifyFavoritePlayers {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCVerifyFavoritePlayers;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientVerifyFavoritePlayersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientVerifyFavoritePlayersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientVerifyFavoritePlayersResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlayerRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlayerRecentAccomplishments {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlayerRecentAccomplishments;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlayerRecentAccomplishmentsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlayerRecentAccomplishmentsResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlayerHeroRecentAccomplishments {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlayerHeroRecentAccomplishments;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestPlayerHeroRecentAccomplishmentsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSubmitPlayerMatchSurvey {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSubmitPlayerMatchSurvey {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitPlayerMatchSurvey;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSubmitPlayerMatchSurveyResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitPlayerMatchSurveyResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientVACReminder {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientVACReminder {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientVACReminder;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnderDraftRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnderDraftResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftReroll {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnderDraftReroll {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftReroll;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftRerollResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftRerollResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRerollResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftBuy {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnderDraftBuy {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftBuy;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientGuildUnderDraftGoldUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftBuyResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftBuyResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftBuyResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftRollBackBench {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftRollBackBench {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRollBackBench;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCUnderDraftRollBackBenchResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftRollBackBenchResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRollBackBenchResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftSell {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUnderDraftSell {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftSell;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftSellResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftSellResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftSellResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUnderDraftRedeemReward {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftRedeemReward {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRedeemReward;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCUnderDraftRedeemRewardResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUnderDraftRedeemRewardResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUnderDraftRedeemRewardResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSubmitDraftTriviaMatchAnswer {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitDraftTriviaMatchAnswer;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSubmitDraftTriviaMatchAnswerResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitDraftTriviaMatchAnswerResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDraftTriviaVoteCount {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestReporterUpdates {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestReporterUpdates {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestReporterUpdates;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestReporterUpdatesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestReporterUpdatesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestReporterUpdatesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCAcknowledgeReporterUpdates {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCAcknowledgeReporterUpdates {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCAcknowledgeReporterUpdates;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRecalibrateMMR {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRecalibrateMMR {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRecalibrateMMR;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRecalibrateMMRResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRecalibrateMMRResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRecalibrateMMRResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgDOTAPostGameItemAwardNotification {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetOWMatchDetails {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetOWMatchDetails {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetOWMatchDetails;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetOWMatchDetailsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetOWMatchDetailsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetOWMatchDetailsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSubmitOWConviction {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSubmitOWConviction {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitOWConviction;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSubmitOWConvictionResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSubmitOWConvictionResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSubmitOWConvictionResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCChinaSSAURLRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCChinaSSAURLRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCChinaSSAURLRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCChinaSSAURLResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCChinaSSAURLResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCChinaSSAURLResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCChinaSSAAcceptedRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCChinaSSAAcceptedRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCChinaSSAAcceptedRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCChinaSSAAcceptedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCChinaSSAAcceptedResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCChinaSSAAcceptedResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientOverwatchCasesAvailable {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientOverwatchCasesAvailable {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientOverwatchCasesAvailable;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCStartWatchingOverwatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCStartWatchingOverwatch {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCStartWatchingOverwatch;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCStopWatchingOverwatch {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCStopWatchingOverwatch {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCStopWatchingOverwatch;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCOverwatchReplayError {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOverwatchReplayError {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOverwatchReplayError;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetDPCFavorites {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetDPCFavorites {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetDPCFavorites;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetDPCFavoritesResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetDPCFavoritesResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetDPCFavoritesResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetDPCFavoriteState {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetDPCFavoriteState {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetDPCFavoriteState;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSetDPCFavoriteStateResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetDPCFavoriteStateResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetDPCFavoriteStateResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetEventActiveSeasonID {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetEventActiveSeasonID {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetEventActiveSeasonID;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSetEventActiveSeasonIDResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetEventActiveSeasonIDResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetEventActiveSeasonIDResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPurchaseLabyrinthBlessings {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPurchaseLabyrinthBlessings {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPurchaseLabyrinthBlessings;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPurchaseLabyrinthBlessingsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPurchaseLabyrinthBlessingsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetStickerbookRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetStickerbookRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetStickerbookRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetStickerbookResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetStickerbookResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetStickerbookResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCreateStickerbookPageRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateStickerbookPageRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateStickerbookPageRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCreateStickerbookPageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCreateStickerbookPageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCreateStickerbookPageResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCDeleteStickerbookPageRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCDeleteStickerbookPageRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDeleteStickerbookPageRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCDeleteStickerbookPageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCDeleteStickerbookPageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCDeleteStickerbookPageResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPlaceStickersRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlaceStickersRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlaceStickersRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCPlaceStickersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlaceStickersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlaceStickersResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPlaceCollectionStickersRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlaceCollectionStickersRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlaceCollectionStickersRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCPlaceCollectionStickersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCPlaceCollectionStickersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCPlaceCollectionStickersResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOrderStickerbookTeamPageRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOrderStickerbookTeamPageRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOrderStickerbookTeamPageRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCOrderStickerbookTeamPageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCOrderStickerbookTeamPageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCOrderStickerbookTeamPageResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetHeroSticker {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetHeroSticker {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetHeroSticker;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetHeroStickerResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetHeroStickerResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetHeroStickerResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetHeroStickers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCGetHeroStickers {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetHeroStickers;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCGetHeroStickersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCGetHeroStickersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCGetHeroStickersResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetFavoritePage {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetFavoritePage {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetFavoritePage;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetFavoritePageResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSetFavoritePageResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetFavoritePageResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCClaimSwag {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCClaimSwag {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCClaimSwag;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCClaimSwagResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCCollectorsCacheAvailableDataRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCCollectorsCacheAvailableDataRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCCollectorsCacheAvailableDataRequest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientCollectorsCacheAvailableDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientCollectorsCacheAvailableDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientCollectorsCacheAvailableDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUploadMatchClip {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCUploadMatchClip {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUploadMatchClip;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientUploadMatchClipResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientUploadMatchClipResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientUploadMatchClipResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCMapStatsRequest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCMapStatsRequest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCMapStatsRequest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientMapStatsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgGCToClientMapStatsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientMapStatsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRoadToTIAssignedQuest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgRoadToTIUserData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIGetQuests {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRoadToTIGetQuests {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIGetQuests;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIGetQuestsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRoadToTIGetQuestsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIGetQuestsResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIGetActiveQuest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRoadToTIGetActiveQuest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIGetActiveQuest;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRoadToTIGetActiveQuestResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRoadToTIGetActiveQuestResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIGetActiveQuestResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGCToClientRoadToTIQuestDataUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientRoadToTIQuestDataUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientRoadToTIQuestDataUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIUseItem {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCRoadToTIUseItem {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIUseItem;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIUseItemResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRoadToTIUseItemResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIUseItemResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRoadToTIDevForceQuest {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRoadToTIDevForceQuest {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRoadToTIDevForceQuest;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgLobbyRoadToTIMatchQuestData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgLobbyRoadToTIMatchQuestData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgLobbyRoadToTIMatchQuestData;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCNewBloomGift {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCNewBloomGift {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCNewBloomGift;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCNewBloomGiftResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCNewBloomGiftResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCNewBloomGiftResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSetBannedHeroes {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind for CMsgClientToGCSetBannedHeroes {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSetBannedHeroes;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCUpdateComicBookStats {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCUpdateComicBookStats {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCUpdateComicBookStats;
}
