// This file is generated by rust-protobuf 3.5.1. Do not edit
// .proto file is parsed by pure
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `dota_gcmessages_client_guild_events.proto`
// Generated for lite runtime

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::steam_vent_proto_common::protobuf::VERSION_3_5_1;

// @@protoc_insertion_point(message:CMsgGuildContract)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildContract {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildContract.contract_id)
    pub contract_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgGuildContract.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildContract.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildContract.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildContract.assigned_account_id)
    pub assigned_account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildContract.contract_flags)
    pub contract_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildContract.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildContract {
    fn default() -> &'a CMsgGuildContract {
        <CMsgGuildContract as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildContract {
    pub fn new() -> CMsgGuildContract {
        ::std::default::Default::default()
    }

    // optional uint64 contract_id = 1;

    pub fn contract_id(&self) -> u64 {
        self.contract_id.unwrap_or(0)
    }

    pub fn clear_contract_id(&mut self) {
        self.contract_id = ::std::option::Option::None;
    }

    pub fn has_contract_id(&self) -> bool {
        self.contract_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_id(&mut self, v: u64) {
        self.contract_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_instance_id = 2;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 3;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 4;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 assigned_account_id = 5;

    pub fn assigned_account_id(&self) -> u32 {
        self.assigned_account_id.unwrap_or(0)
    }

    pub fn clear_assigned_account_id(&mut self) {
        self.assigned_account_id = ::std::option::Option::None;
    }

    pub fn has_assigned_account_id(&self) -> bool {
        self.assigned_account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned_account_id(&mut self, v: u32) {
        self.assigned_account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 contract_flags = 6;

    pub fn contract_flags(&self) -> u32 {
        self.contract_flags.unwrap_or(0)
    }

    pub fn clear_contract_flags(&mut self) {
        self.contract_flags = ::std::option::Option::None;
    }

    pub fn has_contract_flags(&self) -> bool {
        self.contract_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_flags(&mut self, v: u32) {
        self.contract_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildContract {
    const NAME: &'static str = "CMsgGuildContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                16 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.assigned_account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.contract_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contract_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(1, v);
        }
        if let Some(v) = self.challenge_instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.assigned_account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.contract_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contract_id {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.assigned_account_id {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.contract_flags {
            os.write_uint32(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildContract {
        CMsgGuildContract::new()
    }

    fn clear(&mut self) {
        self.contract_id = ::std::option::Option::None;
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.assigned_account_id = ::std::option::Option::None;
        self.contract_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildContract {
        static instance: CMsgGuildContract = CMsgGuildContract {
            contract_id: ::std::option::Option::None,
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            assigned_account_id: ::std::option::Option::None,
            contract_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildContractSlot)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildContractSlot {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildContractSlot.contract)
    pub contract: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildContract>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildContractSlot.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildContractSlot {
    fn default() -> &'a CMsgGuildContractSlot {
        <CMsgGuildContractSlot as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildContractSlot {
    pub fn new() -> CMsgGuildContractSlot {
        ::std::default::Default::default()
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildContractSlot {
    const NAME: &'static str = "CMsgGuildContractSlot";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.contract)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contract.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildContractSlot {
        CMsgGuildContractSlot::new()
    }

    fn clear(&mut self) {
        self.contract.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildContractSlot {
        static instance: CMsgGuildContractSlot = CMsgGuildContractSlot {
            contract: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgAccountGuildEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgAccountGuildEventData {
    // message fields
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.guild_points)
    pub guild_points: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.contracts_refreshed_timestamp)
    pub contracts_refreshed_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.contract_slots)
    pub contract_slots: ::std::vec::Vec<CMsgGuildContractSlot>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.completed_challenge_count)
    pub completed_challenge_count: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.challenges_refresh_timestamp)
    pub challenges_refresh_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.guild_weekly_percentile)
    pub guild_weekly_percentile: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.guild_weekly_last_timestamp)
    pub guild_weekly_last_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.last_weekly_claim_time)
    pub last_weekly_claim_time: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgAccountGuildEventData.guild_current_percentile)
    pub guild_current_percentile: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgAccountGuildEventData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgAccountGuildEventData {
    fn default() -> &'a CMsgAccountGuildEventData {
        <CMsgAccountGuildEventData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgAccountGuildEventData {
    pub fn new() -> CMsgAccountGuildEventData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_points = 1;

    pub fn guild_points(&self) -> u32 {
        self.guild_points.unwrap_or(0)
    }

    pub fn clear_guild_points(&mut self) {
        self.guild_points = ::std::option::Option::None;
    }

    pub fn has_guild_points(&self) -> bool {
        self.guild_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points(&mut self, v: u32) {
        self.guild_points = ::std::option::Option::Some(v);
    }

    // optional uint32 contracts_refreshed_timestamp = 2;

    pub fn contracts_refreshed_timestamp(&self) -> u32 {
        self.contracts_refreshed_timestamp.unwrap_or(0)
    }

    pub fn clear_contracts_refreshed_timestamp(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
    }

    pub fn has_contracts_refreshed_timestamp(&self) -> bool {
        self.contracts_refreshed_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_refreshed_timestamp(&mut self, v: u32) {
        self.contracts_refreshed_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 completed_challenge_count = 4;

    pub fn completed_challenge_count(&self) -> u32 {
        self.completed_challenge_count.unwrap_or(0)
    }

    pub fn clear_completed_challenge_count(&mut self) {
        self.completed_challenge_count = ::std::option::Option::None;
    }

    pub fn has_completed_challenge_count(&self) -> bool {
        self.completed_challenge_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_completed_challenge_count(&mut self, v: u32) {
        self.completed_challenge_count = ::std::option::Option::Some(v);
    }

    // optional uint32 challenges_refresh_timestamp = 5;

    pub fn challenges_refresh_timestamp(&self) -> u32 {
        self.challenges_refresh_timestamp.unwrap_or(0)
    }

    pub fn clear_challenges_refresh_timestamp(&mut self) {
        self.challenges_refresh_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenges_refresh_timestamp(&self) -> bool {
        self.challenges_refresh_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenges_refresh_timestamp(&mut self, v: u32) {
        self.challenges_refresh_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_percentile = 6;

    pub fn guild_weekly_percentile(&self) -> u32 {
        self.guild_weekly_percentile.unwrap_or(0)
    }

    pub fn clear_guild_weekly_percentile(&mut self) {
        self.guild_weekly_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_percentile(&self) -> bool {
        self.guild_weekly_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_percentile(&mut self, v: u32) {
        self.guild_weekly_percentile = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_weekly_last_timestamp = 7;

    pub fn guild_weekly_last_timestamp(&self) -> u32 {
        self.guild_weekly_last_timestamp.unwrap_or(0)
    }

    pub fn clear_guild_weekly_last_timestamp(&mut self) {
        self.guild_weekly_last_timestamp = ::std::option::Option::None;
    }

    pub fn has_guild_weekly_last_timestamp(&self) -> bool {
        self.guild_weekly_last_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_weekly_last_timestamp(&mut self, v: u32) {
        self.guild_weekly_last_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 last_weekly_claim_time = 8;

    pub fn last_weekly_claim_time(&self) -> u32 {
        self.last_weekly_claim_time.unwrap_or(0)
    }

    pub fn clear_last_weekly_claim_time(&mut self) {
        self.last_weekly_claim_time = ::std::option::Option::None;
    }

    pub fn has_last_weekly_claim_time(&self) -> bool {
        self.last_weekly_claim_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_weekly_claim_time(&mut self, v: u32) {
        self.last_weekly_claim_time = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_current_percentile = 9;

    pub fn guild_current_percentile(&self) -> u32 {
        self.guild_current_percentile.unwrap_or(0)
    }

    pub fn clear_guild_current_percentile(&mut self) {
        self.guild_current_percentile = ::std::option::Option::None;
    }

    pub fn has_guild_current_percentile(&self) -> bool {
        self.guild_current_percentile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_current_percentile(&mut self, v: u32) {
        self.guild_current_percentile = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgAccountGuildEventData {
    const NAME: &'static str = "CMsgAccountGuildEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.contracts_refreshed_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                26 => {
                    self.contract_slots.push(is.read_message()?);
                },
                32 => {
                    self.completed_challenge_count = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenges_refresh_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                48 => {
                    self.guild_weekly_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                56 => {
                    self.guild_weekly_last_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                64 => {
                    self.last_weekly_claim_time = ::std::option::Option::Some(is.read_uint32()?);
                },
                72 => {
                    self.guild_current_percentile = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.contracts_refreshed_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        for value in &self.contract_slots {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.completed_challenge_count {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenges_refresh_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        if let Some(v) = self.guild_weekly_percentile {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(6, v);
        }
        if let Some(v) = self.guild_weekly_last_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(7, v);
        }
        if let Some(v) = self.last_weekly_claim_time {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(8, v);
        }
        if let Some(v) = self.guild_current_percentile {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(9, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_points {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.contracts_refreshed_timestamp {
            os.write_uint32(2, v)?;
        }
        for v in &self.contract_slots {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.completed_challenge_count {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenges_refresh_timestamp {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.guild_weekly_percentile {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.guild_weekly_last_timestamp {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.last_weekly_claim_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.guild_current_percentile {
            os.write_uint32(9, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgAccountGuildEventData {
        CMsgAccountGuildEventData::new()
    }

    fn clear(&mut self) {
        self.guild_points = ::std::option::Option::None;
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
        self.contract_slots.clear();
        self.completed_challenge_count = ::std::option::Option::None;
        self.challenges_refresh_timestamp = ::std::option::Option::None;
        self.guild_weekly_percentile = ::std::option::Option::None;
        self.guild_weekly_last_timestamp = ::std::option::Option::None;
        self.last_weekly_claim_time = ::std::option::Option::None;
        self.guild_current_percentile = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgAccountGuildEventData {
        static instance: CMsgAccountGuildEventData = CMsgAccountGuildEventData {
            guild_points: ::std::option::Option::None,
            contracts_refreshed_timestamp: ::std::option::Option::None,
            contract_slots: ::std::vec::Vec::new(),
            completed_challenge_count: ::std::option::Option::None,
            challenges_refresh_timestamp: ::std::option::Option::None,
            guild_weekly_percentile: ::std::option::Option::None,
            guild_weekly_last_timestamp: ::std::option::Option::None,
            last_weekly_claim_time: ::std::option::Option::None,
            guild_current_percentile: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildActiveContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildActiveContracts {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildActiveContracts.contracts_refreshed_timestamp)
    pub contracts_refreshed_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildActiveContracts.contracts)
    pub contracts: ::std::vec::Vec<CMsgGuildContract>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildActiveContracts.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildActiveContracts {
    fn default() -> &'a CMsgGuildActiveContracts {
        <CMsgGuildActiveContracts as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildActiveContracts {
    pub fn new() -> CMsgGuildActiveContracts {
        ::std::default::Default::default()
    }

    // optional uint32 contracts_refreshed_timestamp = 1;

    pub fn contracts_refreshed_timestamp(&self) -> u32 {
        self.contracts_refreshed_timestamp.unwrap_or(0)
    }

    pub fn clear_contracts_refreshed_timestamp(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
    }

    pub fn has_contracts_refreshed_timestamp(&self) -> bool {
        self.contracts_refreshed_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_refreshed_timestamp(&mut self, v: u32) {
        self.contracts_refreshed_timestamp = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildActiveContracts {
    const NAME: &'static str = "CMsgGuildActiveContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.contracts_refreshed_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                18 => {
                    self.contracts.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.contracts_refreshed_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        for value in &self.contracts {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.contracts_refreshed_timestamp {
            os.write_uint32(1, v)?;
        }
        for v in &self.contracts {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildActiveContracts {
        CMsgGuildActiveContracts::new()
    }

    fn clear(&mut self) {
        self.contracts_refreshed_timestamp = ::std::option::Option::None;
        self.contracts.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildActiveContracts {
        static instance: CMsgGuildActiveContracts = CMsgGuildActiveContracts {
            contracts_refreshed_timestamp: ::std::option::Option::None,
            contracts: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildChallenge.challenge_instance_id)
    pub challenge_instance_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildChallenge.challenge_parameter)
    pub challenge_parameter: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildChallenge.challenge_timestamp)
    pub challenge_timestamp: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildChallenge.challenge_progress)
    pub challenge_progress: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildChallenge.challenge_flags)
    pub challenge_flags: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildChallenge {
    fn default() -> &'a CMsgGuildChallenge {
        <CMsgGuildChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildChallenge {
    pub fn new() -> CMsgGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 challenge_instance_id = 1;

    pub fn challenge_instance_id(&self) -> u32 {
        self.challenge_instance_id.unwrap_or(0)
    }

    pub fn clear_challenge_instance_id(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
    }

    pub fn has_challenge_instance_id(&self) -> bool {
        self.challenge_instance_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_instance_id(&mut self, v: u32) {
        self.challenge_instance_id = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_parameter = 2;

    pub fn challenge_parameter(&self) -> u32 {
        self.challenge_parameter.unwrap_or(0)
    }

    pub fn clear_challenge_parameter(&mut self) {
        self.challenge_parameter = ::std::option::Option::None;
    }

    pub fn has_challenge_parameter(&self) -> bool {
        self.challenge_parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_parameter(&mut self, v: u32) {
        self.challenge_parameter = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_timestamp = 3;

    pub fn challenge_timestamp(&self) -> u32 {
        self.challenge_timestamp.unwrap_or(0)
    }

    pub fn clear_challenge_timestamp(&mut self) {
        self.challenge_timestamp = ::std::option::Option::None;
    }

    pub fn has_challenge_timestamp(&self) -> bool {
        self.challenge_timestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_timestamp(&mut self, v: u32) {
        self.challenge_timestamp = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_progress = 4;

    pub fn challenge_progress(&self) -> u32 {
        self.challenge_progress.unwrap_or(0)
    }

    pub fn clear_challenge_progress(&mut self) {
        self.challenge_progress = ::std::option::Option::None;
    }

    pub fn has_challenge_progress(&self) -> bool {
        self.challenge_progress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_progress(&mut self, v: u32) {
        self.challenge_progress = ::std::option::Option::Some(v);
    }

    // optional uint32 challenge_flags = 5;

    pub fn challenge_flags(&self) -> u32 {
        self.challenge_flags.unwrap_or(0)
    }

    pub fn clear_challenge_flags(&mut self) {
        self.challenge_flags = ::std::option::Option::None;
    }

    pub fn has_challenge_flags(&self) -> bool {
        self.challenge_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_challenge_flags(&mut self, v: u32) {
        self.challenge_flags = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildChallenge {
    const NAME: &'static str = "CMsgGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.challenge_instance_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.challenge_parameter = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.challenge_timestamp = ::std::option::Option::Some(is.read_uint32()?);
                },
                32 => {
                    self.challenge_progress = ::std::option::Option::Some(is.read_uint32()?);
                },
                40 => {
                    self.challenge_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.challenge_instance_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.challenge_parameter {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.challenge_timestamp {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.challenge_progress {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        if let Some(v) = self.challenge_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(5, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.challenge_instance_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.challenge_parameter {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.challenge_timestamp {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.challenge_progress {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.challenge_flags {
            os.write_uint32(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildChallenge {
        CMsgGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.challenge_instance_id = ::std::option::Option::None;
        self.challenge_parameter = ::std::option::Option::None;
        self.challenge_timestamp = ::std::option::Option::None;
        self.challenge_progress = ::std::option::Option::None;
        self.challenge_flags = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildChallenge {
        static instance: CMsgGuildChallenge = CMsgGuildChallenge {
            challenge_instance_id: ::std::option::Option::None,
            challenge_parameter: ::std::option::Option::None,
            challenge_timestamp: ::std::option::Option::None,
            challenge_progress: ::std::option::Option::None,
            challenge_flags: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgGuildEventMember)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildEventMember {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildEventMember.account_id)
    pub account_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildEventMember.guild_points_earned)
    pub guild_points_earned: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildEventMember.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildEventMember {
    fn default() -> &'a CMsgGuildEventMember {
        <CMsgGuildEventMember as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildEventMember {
    pub fn new() -> CMsgGuildEventMember {
        ::std::default::Default::default()
    }

    // optional uint32 account_id = 1;

    pub fn account_id(&self) -> u32 {
        self.account_id.unwrap_or(0)
    }

    pub fn clear_account_id(&mut self) {
        self.account_id = ::std::option::Option::None;
    }

    pub fn has_account_id(&self) -> bool {
        self.account_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_account_id(&mut self, v: u32) {
        self.account_id = ::std::option::Option::Some(v);
    }

    // optional uint32 guild_points_earned = 2;

    pub fn guild_points_earned(&self) -> u32 {
        self.guild_points_earned.unwrap_or(0)
    }

    pub fn clear_guild_points_earned(&mut self) {
        self.guild_points_earned = ::std::option::Option::None;
    }

    pub fn has_guild_points_earned(&self) -> bool {
        self.guild_points_earned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_points_earned(&mut self, v: u32) {
        self.guild_points_earned = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildEventMember {
    const NAME: &'static str = "CMsgGuildEventMember";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.account_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.guild_points_earned = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.account_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.guild_points_earned {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.account_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.guild_points_earned {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildEventMember {
        CMsgGuildEventMember::new()
    }

    fn clear(&mut self) {
        self.account_id = ::std::option::Option::None;
        self.guild_points_earned = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildEventMember {
        static instance: CMsgGuildEventMember = CMsgGuildEventMember {
            account_id: ::std::option::Option::None,
            guild_points_earned: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildEventData {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildEventData.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildEventData.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildEventData.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildEventData {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildEventData {
        <CMsgClientToGCRequestAccountGuildEventData as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildEventData {
    pub fn new() -> CMsgClientToGCRequestAccountGuildEventData {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildEventData {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildEventData {
        CMsgClientToGCRequestAccountGuildEventData::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildEventData {
        static instance: CMsgClientToGCRequestAccountGuildEventData = CMsgClientToGCRequestAccountGuildEventData {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestAccountGuildEventDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestAccountGuildEventDataResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildEventDataResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildEventDataResponse.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestAccountGuildEventDataResponse.event_data)
    pub event_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgAccountGuildEventData>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestAccountGuildEventDataResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestAccountGuildEventDataResponse {
    fn default() -> &'a CMsgClientToGCRequestAccountGuildEventDataResponse {
        <CMsgClientToGCRequestAccountGuildEventDataResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestAccountGuildEventDataResponse {
    pub fn new() -> CMsgClientToGCRequestAccountGuildEventDataResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_account_guild_event_data_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestAccountGuildEventDataResponse {
    const NAME: &'static str = "CMsgClientToGCRequestAccountGuildEventDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.event_data)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.event_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestAccountGuildEventDataResponse {
        CMsgClientToGCRequestAccountGuildEventDataResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.event_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestAccountGuildEventDataResponse {
        static instance: CMsgClientToGCRequestAccountGuildEventDataResponse = CMsgClientToGCRequestAccountGuildEventDataResponse {
            result: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            event_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestAccountGuildEventDataResponse`
pub mod cmsg_client_to_gcrequest_account_guild_event_data_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestAccountGuildEventDataResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientAccountGuildEventDataUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientAccountGuildEventDataUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientAccountGuildEventDataUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientAccountGuildEventDataUpdated.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgGCToClientAccountGuildEventDataUpdated.update_flags)
    pub update_flags: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientAccountGuildEventDataUpdated.guild_event_data)
    pub guild_event_data: ::steam_vent_proto_common::protobuf::MessageField<CMsgAccountGuildEventData>,
    // @@protoc_insertion_point(field:CMsgGCToClientAccountGuildEventDataUpdated.contracts_updated)
    pub contracts_updated: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientAccountGuildEventDataUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientAccountGuildEventDataUpdated {
    fn default() -> &'a CMsgGCToClientAccountGuildEventDataUpdated {
        <CMsgGCToClientAccountGuildEventDataUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientAccountGuildEventDataUpdated {
    pub fn new() -> CMsgGCToClientAccountGuildEventDataUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 update_flags = 3;

    pub fn update_flags(&self) -> u32 {
        self.update_flags.unwrap_or(0)
    }

    pub fn clear_update_flags(&mut self) {
        self.update_flags = ::std::option::Option::None;
    }

    pub fn has_update_flags(&self) -> bool {
        self.update_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update_flags(&mut self, v: u32) {
        self.update_flags = ::std::option::Option::Some(v);
    }

    // optional bool contracts_updated = 5;

    pub fn contracts_updated(&self) -> bool {
        self.contracts_updated.unwrap_or(false)
    }

    pub fn clear_contracts_updated(&mut self) {
        self.contracts_updated = ::std::option::Option::None;
    }

    pub fn has_contracts_updated(&self) -> bool {
        self.contracts_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contracts_updated(&mut self, v: bool) {
        self.contracts_updated = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientAccountGuildEventDataUpdated {
    const NAME: &'static str = "CMsgGCToClientAccountGuildEventDataUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.update_flags = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.guild_event_data)?;
                },
                40 => {
                    self.contracts_updated = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.update_flags {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        if let Some(v) = self.guild_event_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.contracts_updated {
            my_size += 1 + 1;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.update_flags {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.guild_event_data.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.contracts_updated {
            os.write_bool(5, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientAccountGuildEventDataUpdated {
        CMsgGCToClientAccountGuildEventDataUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.update_flags = ::std::option::Option::None;
        self.guild_event_data.clear();
        self.contracts_updated = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientAccountGuildEventDataUpdated {
        static instance: CMsgGCToClientAccountGuildEventDataUpdated = CMsgGCToClientAccountGuildEventDataUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            update_flags: ::std::option::Option::None,
            guild_event_data: ::steam_vent_proto_common::protobuf::MessageField::none(),
            contracts_updated: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestActiveGuildContracts)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildContracts {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildContracts.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildContracts.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestActiveGuildContracts.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildContracts {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildContracts {
        <CMsgClientToGCRequestActiveGuildContracts as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildContracts {
    pub fn new() -> CMsgClientToGCRequestActiveGuildContracts {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestActiveGuildContracts {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildContracts";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildContracts {
        CMsgClientToGCRequestActiveGuildContracts::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildContracts {
        static instance: CMsgClientToGCRequestActiveGuildContracts = CMsgClientToGCRequestActiveGuildContracts {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestActiveGuildContractsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildContractsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildContractsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildContractsResponse.active_contracts)
    pub active_contracts: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildActiveContracts>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildContractsResponse.active_challenges)
    pub active_challenges: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestActiveGuildContractsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildContractsResponse {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildContractsResponse {
        <CMsgClientToGCRequestActiveGuildContractsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildContractsResponse {
    pub fn new() -> CMsgClientToGCRequestActiveGuildContractsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestActiveGuildContractsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_active_guild_contracts_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestActiveGuildContractsResponse {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildContractsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.active_contracts)?;
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenges)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active_contracts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.active_challenges.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_contracts.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.active_challenges.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildContractsResponse {
        CMsgClientToGCRequestActiveGuildContractsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.active_contracts.clear();
        self.active_challenges.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildContractsResponse {
        static instance: CMsgClientToGCRequestActiveGuildContractsResponse = CMsgClientToGCRequestActiveGuildContractsResponse {
            result: ::std::option::Option::None,
            active_contracts: ::steam_vent_proto_common::protobuf::MessageField::none(),
            active_challenges: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestActiveGuildContractsResponse`
pub mod cmsg_client_to_gcrequest_active_guild_contracts_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildContractsResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientActiveGuildContractsUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientActiveGuildContractsUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientActiveGuildContractsUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientActiveGuildContractsUpdated.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientActiveGuildContractsUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientActiveGuildContractsUpdated {
    fn default() -> &'a CMsgGCToClientActiveGuildContractsUpdated {
        <CMsgGCToClientActiveGuildContractsUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientActiveGuildContractsUpdated {
    pub fn new() -> CMsgGCToClientActiveGuildContractsUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientActiveGuildContractsUpdated {
    const NAME: &'static str = "CMsgGCToClientActiveGuildContractsUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientActiveGuildContractsUpdated {
        CMsgGCToClientActiveGuildContractsUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientActiveGuildContractsUpdated {
        static instance: CMsgGCToClientActiveGuildContractsUpdated = CMsgGCToClientActiveGuildContractsUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSelectGuildContract)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectGuildContract {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSelectGuildContract.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCSelectGuildContract.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgClientToGCSelectGuildContract.contract_id)
    pub contract_id: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:CMsgClientToGCSelectGuildContract.contract_slot)
    pub contract_slot: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSelectGuildContract.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectGuildContract {
    fn default() -> &'a CMsgClientToGCSelectGuildContract {
        <CMsgClientToGCSelectGuildContract as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectGuildContract {
    pub fn new() -> CMsgClientToGCSelectGuildContract {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint64 contract_id = 3;

    pub fn contract_id(&self) -> u64 {
        self.contract_id.unwrap_or(0)
    }

    pub fn clear_contract_id(&mut self) {
        self.contract_id = ::std::option::Option::None;
    }

    pub fn has_contract_id(&self) -> bool {
        self.contract_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_id(&mut self, v: u64) {
        self.contract_id = ::std::option::Option::Some(v);
    }

    // optional uint32 contract_slot = 4;

    pub fn contract_slot(&self) -> u32 {
        self.contract_slot.unwrap_or(0)
    }

    pub fn clear_contract_slot(&mut self) {
        self.contract_slot = ::std::option::Option::None;
    }

    pub fn has_contract_slot(&self) -> bool {
        self.contract_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contract_slot(&mut self, v: u32) {
        self.contract_slot = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSelectGuildContract {
    const NAME: &'static str = "CMsgClientToGCSelectGuildContract";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                24 => {
                    self.contract_id = ::std::option::Option::Some(is.read_uint64()?);
                },
                32 => {
                    self.contract_slot = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.contract_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint64_size(3, v);
        }
        if let Some(v) = self.contract_slot {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(4, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.contract_id {
            os.write_uint64(3, v)?;
        }
        if let Some(v) = self.contract_slot {
            os.write_uint32(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectGuildContract {
        CMsgClientToGCSelectGuildContract::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.contract_id = ::std::option::Option::None;
        self.contract_slot = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectGuildContract {
        static instance: CMsgClientToGCSelectGuildContract = CMsgClientToGCSelectGuildContract {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            contract_id: ::std::option::Option::None,
            contract_slot: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCSelectGuildContractResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCSelectGuildContractResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCSelectGuildContractResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcselect_guild_contract_response::EResponse>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCSelectGuildContractResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCSelectGuildContractResponse {
    fn default() -> &'a CMsgClientToGCSelectGuildContractResponse {
        <CMsgClientToGCSelectGuildContractResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCSelectGuildContractResponse {
    pub fn new() -> CMsgClientToGCSelectGuildContractResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCSelectGuildContractResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcselect_guild_contract_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcselect_guild_contract_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcselect_guild_contract_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcselect_guild_contract_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCSelectGuildContractResponse {
    const NAME: &'static str = "CMsgClientToGCSelectGuildContractResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCSelectGuildContractResponse {
        CMsgClientToGCSelectGuildContractResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCSelectGuildContractResponse {
        static instance: CMsgClientToGCSelectGuildContractResponse = CMsgClientToGCSelectGuildContractResponse {
            result: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCSelectGuildContractResponse`
pub mod cmsg_client_to_gcselect_guild_contract_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCSelectGuildContractResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidContractID)
        k_eInvalidContractID = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eAlreadyAssigned)
        k_eAlreadyAssigned = 10,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eInvalidContractSlot)
        k_eInvalidContractSlot = 11,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotLockedGuild)
        k_eContractSlotLockedGuild = 12,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotCooldown)
        k_eContractSlotCooldown = 13,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractDuplicate)
        k_eContractDuplicate = 14,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotTimeError)
        k_eContractSlotTimeError = 15,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCSelectGuildContractResponse.EResponse.k_eContractSlotLockedDotaPlus)
        k_eContractSlotLockedDotaPlus = 16,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                9 => ::std::option::Option::Some(EResponse::k_eInvalidContractID),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyAssigned),
                11 => ::std::option::Option::Some(EResponse::k_eInvalidContractSlot),
                12 => ::std::option::Option::Some(EResponse::k_eContractSlotLockedGuild),
                13 => ::std::option::Option::Some(EResponse::k_eContractSlotCooldown),
                14 => ::std::option::Option::Some(EResponse::k_eContractDuplicate),
                15 => ::std::option::Option::Some(EResponse::k_eContractSlotTimeError),
                16 => ::std::option::Option::Some(EResponse::k_eContractSlotLockedDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                "k_eInvalidContractID" => ::std::option::Option::Some(EResponse::k_eInvalidContractID),
                "k_eAlreadyAssigned" => ::std::option::Option::Some(EResponse::k_eAlreadyAssigned),
                "k_eInvalidContractSlot" => ::std::option::Option::Some(EResponse::k_eInvalidContractSlot),
                "k_eContractSlotLockedGuild" => ::std::option::Option::Some(EResponse::k_eContractSlotLockedGuild),
                "k_eContractSlotCooldown" => ::std::option::Option::Some(EResponse::k_eContractSlotCooldown),
                "k_eContractDuplicate" => ::std::option::Option::Some(EResponse::k_eContractDuplicate),
                "k_eContractSlotTimeError" => ::std::option::Option::Some(EResponse::k_eContractSlotTimeError),
                "k_eContractSlotLockedDotaPlus" => ::std::option::Option::Some(EResponse::k_eContractSlotLockedDotaPlus),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
            EResponse::k_eInvalidContractID,
            EResponse::k_eAlreadyAssigned,
            EResponse::k_eInvalidContractSlot,
            EResponse::k_eContractSlotLockedGuild,
            EResponse::k_eContractSlotCooldown,
            EResponse::k_eContractDuplicate,
            EResponse::k_eContractSlotTimeError,
            EResponse::k_eContractSlotLockedDotaPlus,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgClientToGCRequestActiveGuildChallenge)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildChallenge {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildChallenge.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildChallenge.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestActiveGuildChallenge.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildChallenge {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildChallenge {
        <CMsgClientToGCRequestActiveGuildChallenge as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildChallenge {
    pub fn new() -> CMsgClientToGCRequestActiveGuildChallenge {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestActiveGuildChallenge {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildChallenge";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildChallenge {
        CMsgClientToGCRequestActiveGuildChallenge::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildChallenge {
        static instance: CMsgClientToGCRequestActiveGuildChallenge = CMsgClientToGCRequestActiveGuildChallenge {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestActiveGuildChallengeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestActiveGuildChallengeResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildChallengeResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestActiveGuildChallengeResponse.active_challenge)
    pub active_challenge: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestActiveGuildChallengeResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestActiveGuildChallengeResponse {
    fn default() -> &'a CMsgClientToGCRequestActiveGuildChallengeResponse {
        <CMsgClientToGCRequestActiveGuildChallengeResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestActiveGuildChallengeResponse {
    pub fn new() -> CMsgClientToGCRequestActiveGuildChallengeResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_active_guild_challenge_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestActiveGuildChallengeResponse {
    const NAME: &'static str = "CMsgClientToGCRequestActiveGuildChallengeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.active_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestActiveGuildChallengeResponse {
        CMsgClientToGCRequestActiveGuildChallengeResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.active_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestActiveGuildChallengeResponse {
        static instance: CMsgClientToGCRequestActiveGuildChallengeResponse = CMsgClientToGCRequestActiveGuildChallengeResponse {
            result: ::std::option::Option::None,
            active_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestActiveGuildChallengeResponse`
pub mod cmsg_client_to_gcrequest_active_guild_challenge_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestActiveGuildChallengeResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGCToClientActiveGuildChallengeUpdated)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGCToClientActiveGuildChallengeUpdated {
    // message fields
    // @@protoc_insertion_point(field:CMsgGCToClientActiveGuildChallengeUpdated.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGCToClientActiveGuildChallengeUpdated.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgGCToClientActiveGuildChallengeUpdated.active_challenge)
    pub active_challenge: ::steam_vent_proto_common::protobuf::MessageField<CMsgGuildChallenge>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGCToClientActiveGuildChallengeUpdated.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGCToClientActiveGuildChallengeUpdated {
    fn default() -> &'a CMsgGCToClientActiveGuildChallengeUpdated {
        <CMsgGCToClientActiveGuildChallengeUpdated as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGCToClientActiveGuildChallengeUpdated {
    pub fn new() -> CMsgGCToClientActiveGuildChallengeUpdated {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGCToClientActiveGuildChallengeUpdated {
    const NAME: &'static str = "CMsgGCToClientActiveGuildChallengeUpdated";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                26 => {
                    ::steam_vent_proto_common::protobuf::rt::read_singular_message_into_field(is, &mut self.active_challenge)?;
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        if let Some(v) = self.active_challenge.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.active_challenge.as_ref() {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGCToClientActiveGuildChallengeUpdated {
        CMsgGCToClientActiveGuildChallengeUpdated::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.active_challenge.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGCToClientActiveGuildChallengeUpdated {
        static instance: CMsgGCToClientActiveGuildChallengeUpdated = CMsgGCToClientActiveGuildChallengeUpdated {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            active_challenge: ::steam_vent_proto_common::protobuf::MessageField::none(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildEventMembers)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildEventMembers {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildEventMembers.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildEventMembers.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildEventMembers.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildEventMembers {
    fn default() -> &'a CMsgClientToGCRequestGuildEventMembers {
        <CMsgClientToGCRequestGuildEventMembers as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildEventMembers {
    pub fn new() -> CMsgClientToGCRequestGuildEventMembers {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildEventMembers {
    const NAME: &'static str = "CMsgClientToGCRequestGuildEventMembers";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildEventMembers {
        CMsgClientToGCRequestGuildEventMembers::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildEventMembers {
        static instance: CMsgClientToGCRequestGuildEventMembers = CMsgClientToGCRequestGuildEventMembers {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCRequestGuildEventMembersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCRequestGuildEventMembersResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildEventMembersResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcrequest_guild_event_members_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCRequestGuildEventMembersResponse.members)
    pub members: ::std::vec::Vec<CMsgGuildEventMember>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCRequestGuildEventMembersResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCRequestGuildEventMembersResponse {
    fn default() -> &'a CMsgClientToGCRequestGuildEventMembersResponse {
        <CMsgClientToGCRequestGuildEventMembersResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCRequestGuildEventMembersResponse {
    pub fn new() -> CMsgClientToGCRequestGuildEventMembersResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCRequestGuildEventMembersResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcrequest_guild_event_members_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcrequest_guild_event_members_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcrequest_guild_event_members_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcrequest_guild_event_members_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCRequestGuildEventMembersResponse {
    const NAME: &'static str = "CMsgClientToGCRequestGuildEventMembersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                18 => {
                    self.members.push(is.read_message()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        for value in &self.members {
            let len = value.compute_size();
            my_size += 1 + ::steam_vent_proto_common::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        for v in &self.members {
            ::steam_vent_proto_common::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCRequestGuildEventMembersResponse {
        CMsgClientToGCRequestGuildEventMembersResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.members.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCRequestGuildEventMembersResponse {
        static instance: CMsgClientToGCRequestGuildEventMembersResponse = CMsgClientToGCRequestGuildEventMembersResponse {
            result: ::std::option::Option::None,
            members: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCRequestGuildEventMembersResponse`
pub mod cmsg_client_to_gcrequest_guild_event_members_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCRequestGuildEventMembersResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCRequestGuildEventMembersResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

// @@protoc_insertion_point(message:CMsgGuildLeaderboardCombinedResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgGuildLeaderboardCombinedResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.region)
    pub region: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.last_updated)
    pub last_updated: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.guild_id)
    pub guild_id: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.rank)
    pub rank: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.current_percentile)
    pub current_percentile: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.weekly_percentile)
    pub weekly_percentile: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:CMsgGuildLeaderboardCombinedResponse.points)
    pub points: ::std::vec::Vec<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgGuildLeaderboardCombinedResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgGuildLeaderboardCombinedResponse {
    fn default() -> &'a CMsgGuildLeaderboardCombinedResponse {
        <CMsgGuildLeaderboardCombinedResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgGuildLeaderboardCombinedResponse {
    pub fn new() -> CMsgGuildLeaderboardCombinedResponse {
        ::std::default::Default::default()
    }

    // optional .EEvent event_id = 1;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 region = 2;

    pub fn region(&self) -> u32 {
        self.region.unwrap_or(0)
    }

    pub fn clear_region(&mut self) {
        self.region = ::std::option::Option::None;
    }

    pub fn has_region(&self) -> bool {
        self.region.is_some()
    }

    // Param is passed by value, moved
    pub fn set_region(&mut self, v: u32) {
        self.region = ::std::option::Option::Some(v);
    }

    // optional uint32 last_updated = 3;

    pub fn last_updated(&self) -> u32 {
        self.last_updated.unwrap_or(0)
    }

    pub fn clear_last_updated(&mut self) {
        self.last_updated = ::std::option::Option::None;
    }

    pub fn has_last_updated(&self) -> bool {
        self.last_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_updated(&mut self, v: u32) {
        self.last_updated = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgGuildLeaderboardCombinedResponse {
    const NAME: &'static str = "CMsgGuildLeaderboardCombinedResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.region = ::std::option::Option::Some(is.read_uint32()?);
                },
                24 => {
                    self.last_updated = ::std::option::Option::Some(is.read_uint32()?);
                },
                34 => {
                    is.read_repeated_packed_uint32_into(&mut self.guild_id)?;
                },
                32 => {
                    self.guild_id.push(is.read_uint32()?);
                },
                42 => {
                    is.read_repeated_packed_uint32_into(&mut self.rank)?;
                },
                40 => {
                    self.rank.push(is.read_uint32()?);
                },
                50 => {
                    is.read_repeated_packed_uint32_into(&mut self.current_percentile)?;
                },
                48 => {
                    self.current_percentile.push(is.read_uint32()?);
                },
                58 => {
                    is.read_repeated_packed_uint32_into(&mut self.weekly_percentile)?;
                },
                56 => {
                    self.weekly_percentile.push(is.read_uint32()?);
                },
                66 => {
                    is.read_repeated_packed_uint32_into(&mut self.points)?;
                },
                64 => {
                    self.points.push(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.region {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        if let Some(v) = self.last_updated {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(3, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(4, &self.guild_id);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(5, &self.rank);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(6, &self.current_percentile);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(7, &self.weekly_percentile);
        my_size += ::steam_vent_proto_common::protobuf::rt::vec_packed_uint32_size(8, &self.points);
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.event_id {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.region {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.last_updated {
            os.write_uint32(3, v)?;
        }
        os.write_repeated_packed_uint32(4, &self.guild_id)?;
        os.write_repeated_packed_uint32(5, &self.rank)?;
        os.write_repeated_packed_uint32(6, &self.current_percentile)?;
        os.write_repeated_packed_uint32(7, &self.weekly_percentile)?;
        os.write_repeated_packed_uint32(8, &self.points)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgGuildLeaderboardCombinedResponse {
        CMsgGuildLeaderboardCombinedResponse::new()
    }

    fn clear(&mut self) {
        self.event_id = ::std::option::Option::None;
        self.region = ::std::option::Option::None;
        self.last_updated = ::std::option::Option::None;
        self.guild_id.clear();
        self.rank.clear();
        self.current_percentile.clear();
        self.weekly_percentile.clear();
        self.points.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgGuildLeaderboardCombinedResponse {
        static instance: CMsgGuildLeaderboardCombinedResponse = CMsgGuildLeaderboardCombinedResponse {
            event_id: ::std::option::Option::None,
            region: ::std::option::Option::None,
            last_updated: ::std::option::Option::None,
            guild_id: ::std::vec::Vec::new(),
            rank: ::std::vec::Vec::new(),
            current_percentile: ::std::vec::Vec::new(),
            weekly_percentile: ::std::vec::Vec::new(),
            points: ::std::vec::Vec::new(),
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCClaimLeaderboardRewards)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimLeaderboardRewards {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimLeaderboardRewards.guild_id)
    pub guild_id: ::std::option::Option<u32>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimLeaderboardRewards.event_id)
    pub event_id: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<super::dota_shared_enums::EEvent>>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimLeaderboardRewards.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimLeaderboardRewards {
    fn default() -> &'a CMsgClientToGCClaimLeaderboardRewards {
        <CMsgClientToGCClaimLeaderboardRewards as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimLeaderboardRewards {
    pub fn new() -> CMsgClientToGCClaimLeaderboardRewards {
        ::std::default::Default::default()
    }

    // optional uint32 guild_id = 1;

    pub fn guild_id(&self) -> u32 {
        self.guild_id.unwrap_or(0)
    }

    pub fn clear_guild_id(&mut self) {
        self.guild_id = ::std::option::Option::None;
    }

    pub fn has_guild_id(&self) -> bool {
        self.guild_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_guild_id(&mut self, v: u32) {
        self.guild_id = ::std::option::Option::Some(v);
    }

    // optional .EEvent event_id = 2;

    pub fn event_id(&self) -> super::dota_shared_enums::EEvent {
        match self.event_id {
            Some(e) => e.enum_value_or(super::dota_shared_enums::EEvent::EVENT_ID_NONE),
            None => super::dota_shared_enums::EEvent::EVENT_ID_NONE,
        }
    }

    pub fn clear_event_id(&mut self) {
        self.event_id = ::std::option::Option::None;
    }

    pub fn has_event_id(&self) -> bool {
        self.event_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_id(&mut self, v: super::dota_shared_enums::EEvent) {
        self.event_id = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimLeaderboardRewards {
    const NAME: &'static str = "CMsgClientToGCClaimLeaderboardRewards";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.guild_id = ::std::option::Option::Some(is.read_uint32()?);
                },
                16 => {
                    self.event_id = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.guild_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(1, v);
        }
        if let Some(v) = self.event_id {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(2, v.value());
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.guild_id {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_id {
            os.write_enum(2, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimLeaderboardRewards {
        CMsgClientToGCClaimLeaderboardRewards::new()
    }

    fn clear(&mut self) {
        self.guild_id = ::std::option::Option::None;
        self.event_id = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimLeaderboardRewards {
        static instance: CMsgClientToGCClaimLeaderboardRewards = CMsgClientToGCClaimLeaderboardRewards {
            guild_id: ::std::option::Option::None,
            event_id: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

// @@protoc_insertion_point(message:CMsgClientToGCClaimLeaderboardRewardsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CMsgClientToGCClaimLeaderboardRewardsResponse {
    // message fields
    // @@protoc_insertion_point(field:CMsgClientToGCClaimLeaderboardRewardsResponse.result)
    pub result: ::std::option::Option<::steam_vent_proto_common::protobuf::EnumOrUnknown<cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse>>,
    // @@protoc_insertion_point(field:CMsgClientToGCClaimLeaderboardRewardsResponse.event_points)
    pub event_points: ::std::option::Option<u32>,
    // special fields
    // @@protoc_insertion_point(special_field:CMsgClientToGCClaimLeaderboardRewardsResponse.special_fields)
    pub special_fields: ::steam_vent_proto_common::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CMsgClientToGCClaimLeaderboardRewardsResponse {
    fn default() -> &'a CMsgClientToGCClaimLeaderboardRewardsResponse {
        <CMsgClientToGCClaimLeaderboardRewardsResponse as ::steam_vent_proto_common::protobuf::Message>::default_instance()
    }
}

impl CMsgClientToGCClaimLeaderboardRewardsResponse {
    pub fn new() -> CMsgClientToGCClaimLeaderboardRewardsResponse {
        ::std::default::Default::default()
    }

    // optional .CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse result = 1;

    pub fn result(&self) -> cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse {
        match self.result {
            Some(e) => e.enum_value_or(cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse::k_eInternalError),
            None => cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse::k_eInternalError,
        }
    }

    pub fn clear_result(&mut self) {
        self.result = ::std::option::Option::None;
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: cmsg_client_to_gcclaim_leaderboard_rewards_response::EResponse) {
        self.result = ::std::option::Option::Some(::steam_vent_proto_common::protobuf::EnumOrUnknown::new(v));
    }

    // optional uint32 event_points = 2;

    pub fn event_points(&self) -> u32 {
        self.event_points.unwrap_or(0)
    }

    pub fn clear_event_points(&mut self) {
        self.event_points = ::std::option::Option::None;
    }

    pub fn has_event_points(&self) -> bool {
        self.event_points.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_points(&mut self, v: u32) {
        self.event_points = ::std::option::Option::Some(v);
    }
}

impl ::steam_vent_proto_common::protobuf::Message for CMsgClientToGCClaimLeaderboardRewardsResponse {
    const NAME: &'static str = "CMsgClientToGCClaimLeaderboardRewardsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::steam_vent_proto_common::protobuf::CodedInputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.result = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.event_points = ::std::option::Option::Some(is.read_uint32()?);
                },
                tag => {
                    ::steam_vent_proto_common::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.result {
            my_size += ::steam_vent_proto_common::protobuf::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.event_points {
            my_size += ::steam_vent_proto_common::protobuf::rt::uint32_size(2, v);
        }
        my_size += ::steam_vent_proto_common::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::steam_vent_proto_common::protobuf::CodedOutputStream<'_>) -> ::steam_vent_proto_common::protobuf::Result<()> {
        if let Some(v) = self.result {
            os.write_enum(1, ::steam_vent_proto_common::protobuf::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.event_points {
            os.write_uint32(2, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::steam_vent_proto_common::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::steam_vent_proto_common::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CMsgClientToGCClaimLeaderboardRewardsResponse {
        CMsgClientToGCClaimLeaderboardRewardsResponse::new()
    }

    fn clear(&mut self) {
        self.result = ::std::option::Option::None;
        self.event_points = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CMsgClientToGCClaimLeaderboardRewardsResponse {
        static instance: CMsgClientToGCClaimLeaderboardRewardsResponse = CMsgClientToGCClaimLeaderboardRewardsResponse {
            result: ::std::option::Option::None,
            event_points: ::std::option::Option::None,
            special_fields: ::steam_vent_proto_common::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

/// Nested message and enums of message `CMsgClientToGCClaimLeaderboardRewardsResponse`
pub mod cmsg_client_to_gcclaim_leaderboard_rewards_response {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse)
    pub enum EResponse {
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInternalError)
        k_eInternalError = 0,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eSuccess)
        k_eSuccess = 1,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eTooBusy)
        k_eTooBusy = 2,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eDisabled)
        k_eDisabled = 3,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eTimeout)
        k_eTimeout = 4,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidEvent)
        k_eInvalidEvent = 5,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidGuild)
        k_eInvalidGuild = 6,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eNotMember)
        k_eNotMember = 7,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eInvalidGuildEvent)
        k_eInvalidGuildEvent = 8,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eDoesNotQualify)
        k_eDoesNotQualify = 9,
        // @@protoc_insertion_point(enum_value:CMsgClientToGCClaimLeaderboardRewardsResponse.EResponse.k_eAlreadyClaimed)
        k_eAlreadyClaimed = 10,
    }

    impl ::steam_vent_proto_common::protobuf::Enum for EResponse {
        const NAME: &'static str = "EResponse";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<EResponse> {
            match value {
                0 => ::std::option::Option::Some(EResponse::k_eInternalError),
                1 => ::std::option::Option::Some(EResponse::k_eSuccess),
                2 => ::std::option::Option::Some(EResponse::k_eTooBusy),
                3 => ::std::option::Option::Some(EResponse::k_eDisabled),
                4 => ::std::option::Option::Some(EResponse::k_eTimeout),
                5 => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                6 => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                7 => ::std::option::Option::Some(EResponse::k_eNotMember),
                8 => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                9 => ::std::option::Option::Some(EResponse::k_eDoesNotQualify),
                10 => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<EResponse> {
            match str {
                "k_eInternalError" => ::std::option::Option::Some(EResponse::k_eInternalError),
                "k_eSuccess" => ::std::option::Option::Some(EResponse::k_eSuccess),
                "k_eTooBusy" => ::std::option::Option::Some(EResponse::k_eTooBusy),
                "k_eDisabled" => ::std::option::Option::Some(EResponse::k_eDisabled),
                "k_eTimeout" => ::std::option::Option::Some(EResponse::k_eTimeout),
                "k_eInvalidEvent" => ::std::option::Option::Some(EResponse::k_eInvalidEvent),
                "k_eInvalidGuild" => ::std::option::Option::Some(EResponse::k_eInvalidGuild),
                "k_eNotMember" => ::std::option::Option::Some(EResponse::k_eNotMember),
                "k_eInvalidGuildEvent" => ::std::option::Option::Some(EResponse::k_eInvalidGuildEvent),
                "k_eDoesNotQualify" => ::std::option::Option::Some(EResponse::k_eDoesNotQualify),
                "k_eAlreadyClaimed" => ::std::option::Option::Some(EResponse::k_eAlreadyClaimed),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [EResponse] = &[
            EResponse::k_eInternalError,
            EResponse::k_eSuccess,
            EResponse::k_eTooBusy,
            EResponse::k_eDisabled,
            EResponse::k_eTimeout,
            EResponse::k_eInvalidEvent,
            EResponse::k_eInvalidGuild,
            EResponse::k_eNotMember,
            EResponse::k_eInvalidGuildEvent,
            EResponse::k_eDoesNotQualify,
            EResponse::k_eAlreadyClaimed,
        ];
    }

    impl ::std::default::Default for EResponse {
        fn default() -> Self {
            EResponse::k_eInternalError
        }
    }

}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EGuildEventAuditAction)
pub enum EGuildEventAuditAction {
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_Invalid)
    k_EGuildEventAuditAction_Invalid = 0,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_DevGrant)
    k_EGuildEventAuditAction_DevGrant = 1,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteContract)
    k_EGuildEventAuditAction_CompleteContract = 2,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteChallenge)
    k_EGuildEventAuditAction_CompleteChallenge = 3,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteMatch_Winner)
    k_EGuildEventAuditAction_CompleteMatch_Winner = 4,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_ChallengeProgress)
    k_EGuildEventAuditAction_ChallengeProgress = 5,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_CompleteMatch_Loser)
    k_EGuildEventAuditAction_CompleteMatch_Loser = 6,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_WeeklyLeaderboard)
    k_EGuildEventAuditAction_WeeklyLeaderboard = 7,
    // @@protoc_insertion_point(enum_value:EGuildEventAuditAction.k_EGuildEventAuditAction_ManualGrant)
    k_EGuildEventAuditAction_ManualGrant = 8,
}

impl ::steam_vent_proto_common::protobuf::Enum for EGuildEventAuditAction {
    const NAME: &'static str = "EGuildEventAuditAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EGuildEventAuditAction> {
        match value {
            0 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid),
            1 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant),
            2 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract),
            3 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge),
            4 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner),
            5 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress),
            6 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser),
            7 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard),
            8 => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EGuildEventAuditAction> {
        match str {
            "k_EGuildEventAuditAction_Invalid" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid),
            "k_EGuildEventAuditAction_DevGrant" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant),
            "k_EGuildEventAuditAction_CompleteContract" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract),
            "k_EGuildEventAuditAction_CompleteChallenge" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge),
            "k_EGuildEventAuditAction_CompleteMatch_Winner" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner),
            "k_EGuildEventAuditAction_ChallengeProgress" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress),
            "k_EGuildEventAuditAction_CompleteMatch_Loser" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser),
            "k_EGuildEventAuditAction_WeeklyLeaderboard" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard),
            "k_EGuildEventAuditAction_ManualGrant" => ::std::option::Option::Some(EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EGuildEventAuditAction] = &[
        EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid,
        EGuildEventAuditAction::k_EGuildEventAuditAction_DevGrant,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteContract,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteChallenge,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Winner,
        EGuildEventAuditAction::k_EGuildEventAuditAction_ChallengeProgress,
        EGuildEventAuditAction::k_EGuildEventAuditAction_CompleteMatch_Loser,
        EGuildEventAuditAction::k_EGuildEventAuditAction_WeeklyLeaderboard,
        EGuildEventAuditAction::k_EGuildEventAuditAction_ManualGrant,
    ];
}

impl ::std::default::Default for EGuildEventAuditAction {
    fn default() -> Self {
        EGuildEventAuditAction::k_EGuildEventAuditAction_Invalid
    }
}



const _VENT_PROTO_VERSION_CHECK: () = ::steam_vent_proto_common::VERSION_0_5_0;

#[allow(unused_imports)]
use crate::dota_shared_enums::*;
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildContract {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildContractSlot {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgAccountGuildEventData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildActiveContracts {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildEventMember {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildEventData {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildEventData {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildEventData;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestAccountGuildEventDataResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestAccountGuildEventDataResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestAccountGuildEventDataResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientAccountGuildEventDataUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientAccountGuildEventDataUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientAccountGuildEventDataUpdated;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestActiveGuildContracts {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestActiveGuildContracts {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestActiveGuildContracts;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestActiveGuildContractsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestActiveGuildContractsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestActiveGuildContractsResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientActiveGuildContractsUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientActiveGuildContractsUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientActiveGuildContractsUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCSelectGuildContract {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSelectGuildContract {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSelectGuildContract;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCSelectGuildContractResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCSelectGuildContractResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCSelectGuildContractResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestActiveGuildChallenge {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestActiveGuildChallenge {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestActiveGuildChallenge;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestActiveGuildChallengeResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestActiveGuildChallengeResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestActiveGuildChallengeResponse;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgGCToClientActiveGuildChallengeUpdated {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgGCToClientActiveGuildChallengeUpdated {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgGCToClientActiveGuildChallengeUpdated;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCRequestGuildEventMembers {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildEventMembers {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildEventMembers;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCRequestGuildEventMembersResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCRequestGuildEventMembersResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCRequestGuildEventMembersResponse;
}
impl ::steam_vent_proto_common::RpcMessage for CMsgGuildLeaderboardCombinedResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessage for CMsgClientToGCClaimLeaderboardRewards {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCClaimLeaderboardRewards {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCClaimLeaderboardRewards;
}
impl ::steam_vent_proto_common::RpcMessage
for CMsgClientToGCClaimLeaderboardRewardsResponse {
    fn parse(reader: &mut dyn std::io::Read) -> ::steam_vent_proto_common::protobuf::Result<Self> {
        <Self as ::steam_vent_proto_common::protobuf::Message>::parse_from_reader(reader)
    }
    fn write(&self, writer: &mut dyn std::io::Write) -> ::steam_vent_proto_common::protobuf::Result<()> {
        use ::steam_vent_proto_common::protobuf::Message;
        self.write_to_writer(writer)
    }
    fn encode_size(&self) -> usize {
        use ::steam_vent_proto_common::protobuf::Message;
        self.compute_size() as usize
    }
}
impl ::steam_vent_proto_common::RpcMessageWithKind
for CMsgClientToGCClaimLeaderboardRewardsResponse {
    type KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg;
    const KIND: Self::KindEnum = crate::dota_gcmessages_msgid::EDOTAGCMsg::k_EMsgClientToGCClaimLeaderboardRewardsResponse;
}
